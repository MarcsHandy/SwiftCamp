[
    {
      "id": "variables",
      "title": "Variables & Constants",
      "description": "Master Swift's fundamental building blocks - from basic declarations to advanced type concepts",
      "difficulty": "beginner",
      "theory": "# Variables & Constants - The Foundation of Swift\n\n## 1. Understanding var vs let (15 min)\n\n**Variables (`var`)** - Mutable values that can change:\n```swift\nvar score = 100\nscore = 150  // This works!\n```\n\n**Constants (`let`)** - Immutable values that cannot change:\n```swift\nlet playerName = \"Alex\"\n// playerName = \"Bob\"  // This would cause an error!\n```\n\n**Best Practice**: Always use `let` by default, and only use `var` when you know the value needs to change.\n\n## 2. Swift's Type System (25 min)\n\n### Basic Data Types:\n- **`String`**: Text data - `\"Hello, World!\"`\n- **`Int`**: Whole numbers - `42`, `-5`, `1_000_000`\n- **`Double`**: Decimal numbers - `3.14`, `-2.5`, `1.0e10`\n- **`Bool`**: True/False - `true`, `false`\n\n### Type Inference:\nSwift automatically infers types:\n```swift\nlet name = \"Maria\"     // Inferred as String\nlet age = 25           // Inferred as Int\nlet temperature = 23.5 // Inferred as Double\nlet isActive = true    // Inferred as Bool\n```\n\n### Type Annotations:\nYou can explicitly declare types:\n```swift\nvar username: String = \"john_doe\"\nvar userAge: Int = 30\nvar averageScore: Double = 95.5\nvar isLoggedIn: Bool = false\n```\n\n## 3. Type Safety & Type Checking (20 min)\n\nSwift is **type-safe** - the compiler checks types at compile time to prevent errors:\n\n```swift\nlet score = 100\n// score = \"high\"  // Error: Cannot assign String to Int\n// let result = score + \" points\"  // Error: Cannot add Int and String\n```\n\n### Type Conversions:\n```swift\nlet stringNumber = \"123\"\nlet actualNumber = Int(stringNumber)  // Converts String to Int?\n\nlet doubleScore = Double(score)       // Converts Int to Double\nlet stringScore = String(score)       // Converts Int to String\n```\n\n## 4. Advanced Variable Concepts (30 min)\n\n### Multiple Declarations:\n```swift\nvar x = 0, y = 0, z = 0\nlet width = 100, height = 200, depth = 50\n```\n\n### Computed Properties:\n```swift\nvar radius: Double = 5.0\nvar diameter: Double {\n    get { return radius * 2 }\n    set { radius = newValue / 2 }\n}\n```\n\n### Property Observers:\n```swift\nvar score = 0 {\n    willSet {\n        print(\"About to set score to \\(newValue)\")\n    }\n    didSet {\n        print(\"Score changed from \\(oldValue) to \\(score)\")\n    }\n}\n```\n\n## 5. Naming Conventions & Best Practices (15 min)\n\n### Swift Naming Rules:\n- Use camelCase: `playerName`, `highScore`\n- Be descriptive: `userEmail` not `ue`\n- Start with lowercase: `firstName` not `FirstName`\n\n### Good vs Bad Examples:\n```swift\n// Good\nvar numberOfStudents = 30\nlet maximumFileSize = 1024\nvar isUserLoggedIn = true\n\n// Avoid\nvar nos = 30\nlet mfs = 1024\nvar log = true\n```\n\n## 6. Scope and Lifetime (15 min)\n\n### Global vs Local Variables:\n```swift\n// Global scope\nlet appVersion = \"1.0.0\"\n\nfunc calculateScore() {\n    // Local scope\n    var currentScore = 0\n    currentScore += 10\n    print(appVersion)  // Can access global constants\n}\n\n// print(currentScore)  // Error: currentScore doesn't exist here\n```\n\n## Practice Exercises\n\nComplete all exercises to master these concepts!",
      "codeExample": "// === BASIC DECLARATIONS ===\n// Variables (can change)\nvar currentHealth = 100\nvar playerName = \"Hero\"\nvar gameActive = true\n\n// Update variables\ncurrentHealth = 75\nplayerName = \"Super Hero\"\ngameActive = false\n\n// Constants (cannot change)\nlet maximumHealth = 100\nlet gameTitle = \"Swift Adventure\"\nlet pi = 3.14159265359\n\n// === TYPE ANNOTATIONS ===\n// Explicit type declarations\nvar goldCoins: Int = 50\nvar playerLevel: Int = 1\nvar experience: Double = 0.0\nvar characterClass: String = \"Warrior\"\nvar hasMagic: Bool = true\n\n// === TYPE CONVERSIONS ===\nlet stringLevel = \"5\"\nif let level = Int(stringLevel) {\n    playerLevel = level\n}\n\nlet doubleCoins = Double(goldCoins)\nlet stringCoins = String(goldCoins)\n\n// === MULTIPLE DECLARATIONS ===\nvar health = 100, mana = 50, stamina = 80\nlet attack = 10, defense = 5, speed = 8\n\n// === COMPUTED PROPERTIES ===\nvar baseDamage = 20\nvar totalDamage: Int {\n    return baseDamage + (playerLevel * 2)\n}\n\n// === PROPERTY OBSERVERS ===\nvar playerScore = 0 {\n    willSet {\n        print(\"Player will have \\(newValue) points\")\n    }\n    didSet {\n        if playerScore > oldValue {\n            print(\"Gained \\(playerScore - oldValue) points!\")\n        }\n    }\n}\n\n// === PRACTICAL EXAMPLE ===\nstruct Player {\n    let id: String\n    var name: String\n    var level: Int\n    var experience: Double\n    var isOnline: Bool\n    \n    var description: String {\n        return \"\\(name) (Level \\(level)) - \\(experience) XP\"\n    }\n}\n\nvar newPlayer = Player(\n    id: \"player_123\",\n    name: \"SwiftLearner\",\n    level: 1,\n    experience: 0.0,\n    isOnline: true\n)",
      "category": "Swift Basics",
      "estimatedTime": 120,
      "dependencies": [],
      "challenge": {
        "instructions": "Create a complete player management system:\n\nPART 1: Basic Properties (20 min)\n1. Create variables for: health (starting at 100), mana (starting at 50), gold (starting at 0)\n2. Create constants for: playerID, maximumHealth (200), maximumMana (100)\n3. Use proper type annotations for all declarations\n\nPART 2: Computed Properties (25 min)\n4. Create a computed property 'healthPercentage' that returns health/maximumHealth as Double\n5. Create a computed property 'isAlive' that returns true if health > 0\n6. Create a computed property 'playerStatus' that returns a string description\n\nPART 3: Property Observers (20 min)\n7. Add property observers to 'health' that prevent it from going below 0 or above maximumHealth\n8. Add a property observer to 'gold' that prints when the player gains or loses gold\n\nPART 4: Type Conversions & Operations (15 min)\n9. Convert gold to String for display purposes\n10. Calculate experience needed for next level (currentLevel * 1000)\n\nPART 5: Advanced Challenge (40 min)\n11. Create a function 'takeDamage' that reduces health and prints combat messages\n12. Create a function 'gainExperience' that increases experience and handles level ups",
        "starterCode": "// === PART 1: Basic Properties ===\n// Create your variables and constants here\n\n\n// === PART 2: Computed Properties ===\n// Add computed properties here\n\n\n// === PART 3: Property Observers ===\n// Add property observers here\n\n\n// === PART 4: Type Conversions ===\n// Add type conversion logic here\n\n\n// === PART 5: Advanced Challenge ===\n// Create functions here\n\n",
        "solution": "// === PART 1: Basic Properties ===\nvar health: Int = 100\nvar mana: Int = 50\nvar gold: Int = 0\nvar currentLevel: Int = 1\nvar experience: Double = 0.0\n\nlet playerID: String = \"player_\" + UUID().uuidString.prefix(8)\nlet maximumHealth: Int = 200\nlet maximumMana: Int = 100\n\n// === PART 2: Computed Properties ===\nvar healthPercentage: Double {\n    return Double(health) / Double(maximumHealth)\n}\n\nvar isAlive: Bool {\n    return health > 0\n}\n\nvar playerStatus: String {\n    return \"Level \\(currentLevel) Player - \\(health)/\\(maximumHealth) HP (\\(Int(healthPercentage * 100))%)\"\n}\n\n// === PART 3: Property Observers ===\nvar observedHealth: Int = 100 {\n    didSet {\n        if observedHealth < 0 {\n            observedHealth = 0\n            print(\"Player has been defeated!\")\n        } else if observedHealth > maximumHealth {\n            observedHealth = maximumHealth\n        }\n        \n        if observedHealth > oldValue {\n            print(\"Healed for \\(observedHealth - oldValue) HP\")\n        } else if observedHealth < oldValue {\n            print(\"Took \\(oldValue - observedHealth) damage\")\n        }\n    }\n}\n\nvar observedGold: Int = 0 {\n    didSet {\n        if observedGold > oldValue {\n            print(\"Gained \\(observedGold - oldValue) gold! Total: \\(observedGold)\")\n        } else if observedGold < oldValue {\n            print(\"Spent \\(oldValue - observedGold) gold. Remaining: \\(observedGold)\")\n        }\n    }\n}\n\n// === PART 4: Type Conversions ===\nvar goldDisplay: String {\n    return \"\\(gold) gold\"\n}\n\nvar experienceNeeded: Double {\n    return Double(currentLevel) * 1000.0\n}\n\n// === PART 5: Advanced Challenge ===\nfunc takeDamage(amount: Int) {\n    let newHealth = health - amount\n    \n    if newHealth <= 0 {\n        health = 0\n        print(\"Critical hit! Player has been defeated.\")\n    } else {\n        health = newHealth\n        print(\"Player took \\(amount) damage. Health: \\(health)/\\(maximumHealth)\")\n    }\n}\n\nfunc gainExperience(amount: Double) {\n    experience += amount\n    print(\"Gained \\(amount) experience. Total: \\(experience)/\\(experienceNeeded)\")\n    \n    if experience >= experienceNeeded {\n        levelUp()\n    }\n}\n\nfunc levelUp() {\n    currentLevel += 1\n    experience = 0.0\n    maximumHealth += 20\n    health = maximumHealth\n    print(\"Level up! Reached level \\(currentLevel). Health restored to full!\")\n}",
        "hints": [
          "PART 1: Use 'var' for changing values (health, mana) and 'let' for constants (playerID, maximums)",
          "PART 2: Computed properties use { } without =, and return a computed value",
          "PART 3: Use willSet/didSet to observe property changes. didSet has 'oldValue', willSet has 'newValue'",
          "PART 4: Use String() to convert numbers to strings, Double() to convert to decimals",
          "PART 5: Functions should update the player's state and provide feedback messages",
          "Remember to use type annotations for clarity: var health: Int = 100",
          "For the playerID, you can use a simple string since we can't import UUID in this context"
        ],
        "testCases": [
          {
            "input": "healthPercentage > 0 && healthPercentage <= 1",
            "expectedOutput": "true",
            "description": "Health percentage should be between 0 and 1"
          },
          {
            "input": "isAlive == (health > 0)",
            "expectedOutput": "true",
            "description": "isAlive should be true when health > 0"
          },
          {
            "input": "playerStatus.contains(\"Level\")",
            "expectedOutput": "true",
            "description": "Player status should include level information"
          }
        ]
      }
    },
    {
      "id": "optionals",
      "title": "Optionals",
      "description": "Master Swift's powerful optional system - safely handling missing values and preventing runtime crashes",
      "difficulty": "beginner",
      "theory": "# Optionals - Safely Handling Missing Values\n\n## 1. Understanding Optionals (20 min)\n\n### What are Optionals?\nOptionals represent values that might be **missing** (nil). They're Swift's way of handling the absence of a value safely.\n\n### Why Use Optionals?\n- **Safety**: Prevents null pointer exceptions\n- **Clarity**: Makes it explicit when a value might be missing\n- **Compile-time checking**: Catches potential nil errors before runtime\n\n### Optional Declaration:\n```swift\nvar regularString: String = \"Hello\"  // Must have a value\nvar optionalString: String? = \"Hello\" // Might have a value or be nil\nvar nilString: String? = nil         // Definitely no value\n```\n\n## 2. Optional Unwrapping Methods (30 min)\n\n### 1. Force Unwrapping (Dangerous!):\n```swift\nlet name: String? = \"John\"\nlet forcedName = name!  // Crash if name is nil\n```\n\n**Only use when you're 100% sure the value exists!**\n\n### 2. Optional Binding (Safe):\n```swift\nif let unwrappedName = name {\n    print(\"Hello, \\(unwrappedName)\")  // unwrappedName is String, not String?\n} else {\n    print(\"No name provided\")\n}\n```\n\n### 3. Guard Statements (Early Exit):\n```swift\nfunc greetUser(name: String?) {\n    guard let unwrappedName = name else {\n        print(\"No name to greet\")\n        return\n    }\n    print(\"Hello, \\(unwrappedName)\")  // unwrappedName available here\n}\n```\n\n### 4. Nil Coalescing (Default Values):\n```swift\nlet userName = name ?? \"Anonymous\"  // Use \"Anonymous\" if name is nil\n```\n\n## 3. Optional Chaining (25 min)\n\nAccess properties and methods on optional values safely:\n\n```swift\nstruct User {\n    var profile: Profile?\n}\n\nstruct Profile {\n    var email: String?\n    func sendMessage() -> String {\n        return \"Message sent\"\n    }\n}\n\nlet user: User? = User(profile: Profile(email: \"test@example.com\"))\n\n// Safe property access\nlet userEmail = user?.profile?.email  // Returns String??\n\n// Safe method calls\nlet message = user?.profile?.sendMessage()  // Returns String?\n\n// Combined with nil coalescing\nlet safeEmail = user?.profile?.email ?? \"No email\"\n```\n\n## 4. Implicitly Unwrapped Optionals (15 min)\n\nUse when a value will be set soon after initialization and won't be nil:\n\n```swift\nvar forcedUserName: String! = nil  // Implicitly unwrapped\n// Later...\nforcedUserName = \"John\"\nprint(forcedUserName)  // No need to unwrap, but crashes if nil\n\n// vs regular optional\nvar regularUserName: String? = nil\nregularUserName = \"John\"\nif let name = regularUserName {\n    print(name)  // Safe but requires unwrapping\n}\n```\n\n## 5. Advanced Optional Patterns (20 min)\n\n### Optional Map and FlatMap:\n```swift\nlet numberString: String? = \"123\"\nlet number = numberString.map { Int($0) }  // Int?? - double optional!\nlet flatNumber = numberString.flatMap { Int($0) }  // Int? - single optional\n\nlet positiveNumber: Int? = 5\nlet squared = positiveNumber.map { $0 * $0 }  // 25\nlet nilNumber: Int? = nil\nlet nilSquared = nilNumber.map { $0 * $0 }  // nil\n```\n\n### Optional with Switch:\n```swift\nswitch userEmail {\ncase .some(let email):\n    print(\"User email: \\(email)\")\ncase .none:\n    print(\"No email provided\")\n}\n```\n\n## 6. Real-World Optional Scenarios (10 min)\n\n### API Responses:\n```swift\nstruct APIResponse {\n    var data: Data?\n    var error: Error?\n    var statusCode: Int?\n}\n\nfunc handleResponse(_ response: APIResponse) {\n    if let data = response.data {\n        // Process data\n    } else if let error = response.error {\n        // Handle error\n    }\n}\n```\n\n### User Input:\n```swift\nfunc validateUserInput(_ input: String?) -> Bool {\n    guard let input = input, !input.isEmpty else {\n        return false\n    }\n    return input.count >= 3\n}\n```\n\n## Best Practices Summary\n- Prefer `if let` and `guard let` over force unwrapping\n- Use nil coalescing for default values\n- Use optional chaining for nested optionals\n- Document when and why values might be nil\n- Consider using non-optional types when values are required",
      "codeExample": "// === BASIC OPTIONAL DECLARATIONS ===\nvar userName: String? = \"SwiftLearner\"\nvar userAge: Int? = nil\nvar userScore: Double? = 95.5\nvar isPremium: Bool? = true\n\n// === OPTIONAL UNWRAPPING EXAMPLES ===\n\n// 1. Force Unwrapping (Use sparingly!)\nlet forcedName = userName!  // Only if sure it's not nil\n\n// 2. Optional Binding with if let\nif let age = userAge {\n    print(\"User age: \\(age)\")\n} else {\n    print(\"Age not provided\")\n}\n\n// 3. Multiple Optional Binding\nif let name = userName, let score = userScore {\n    print(\"\\(name) has score: \\(score)\")\n}\n\n// 4. Guard Statement\nfunc processUser(name: String?, age: Int?) {\n    guard let name = name, let age = age else {\n        print(\"Missing user information\")\n        return\n    }\n    print(\"Processing \\(name), age \\(age)\")\n}\n\n// 5. Nil Coalescing Operator\nlet displayName = userName ?? \"Anonymous\"\nlet displayAge = userAge ?? 0\nlet displayScore = userScore ?? 0.0\n\n// === OPTIONAL CHAINING ===\nstruct Address {\n    var street: String?\n    var city: String?\n    var zipCode: String?\n}\n\nstruct UserProfile {\n    var name: String?\n    var address: Address?\n    var friends: [String]?\n}\n\nvar profile: UserProfile? = UserProfile(\n    name: \"John\",\n    address: Address(street: \"123 Main St\", city: \"Techville\", zipCode: nil),\n    friends: [\"Alice\", \"Bob\"]\n)\n\n// Safe property access through multiple levels\nlet city = profile?.address?.city  // String?\nlet firstFriend = profile?.friends?.first  // String?\nlet friendCount = profile?.friends?.count  // Int?\n\n// Method calls with optional chaining\nlet uppercaseName = profile?.name?.uppercased()  // String?\n\n// === IMPLICITLY UNWrapped OPTIONALS ===\nvar uiLabel: UILabel!  // Will be set in viewDidLoad\nvar apiClient: APIClient!  // Will be injected during setup\n\n// === ADVANCED OPTIONAL PATTERNS ===\n\n// Optional map\nlet numberString: String? = \"42\"\nlet number = numberString.map { Int($0) }  // Int??\nlet flatNumber = numberString.flatMap { Int($0) }  // Int?\n\n// Optional with computed properties\nvar formattedAge: String? {\n    guard let age = userAge else { return nil }\n    return \"Age: \\(age)\"\n}\n\n// === REAL-WORLD EXAMPLE ===\nfunc createUserAccount(username: String?, email: String?, password: String?) -> Bool {\n    // Validate all required fields\n    guard let username = username, !username.isEmpty,\n          let email = email, email.contains(\"@\"),\n          let password = password, password.count >= 8 else {\n        print(\"Invalid account creation data\")\n        return false\n    }\n    \n    print(\"Creating account for \\(username) with email \\(email)\")\n    return true\n}\n\n// === OPTIONAL IN COLLECTIONS ===\nlet optionalNumbers: [Int?] = [1, nil, 3, nil, 5]\nlet validNumbers = optionalNumbers.compactMap { $0 }  // [1, 3, 5]\n\nlet userInputs: [String?] = [\"hello\", nil, \"world\", \"\", nil]\nlet nonEmptyInputs = userInputs.compactMap { $0?.isEmpty == false ? $0 : nil }",
      "category": "Swift Basics",
      "estimatedTime": 120,
      "dependencies": ["variables"],
      "challenge": {
        "instructions": "Build a complete user registration system using optionals to safely handle missing data.\n\nPART 1: Basic Optional Handling (25 min)\n1. Create optional properties for: username, email, age, and phone number\n2. Implement a function that safely prints user information using if-let\n3. Create a function that returns a formatted bio using guard statements\n\nPART 2: Optional Chaining & Collections (30 min)\n4. Create a UserProfile struct with optional address and preferences\n5. Implement safe access to nested optional properties (street, city, etc.)\n6. Create a function that safely accesses array elements from optional arrays\n\nPART 3: Nil Coalescing & Default Values (20 min)\n7. Implement display functions that provide default values for missing data\n8. Create a function that calculates user level with safe default values\n9. Build a user settings system with fallback to default settings\n\nPART 4: Advanced Optional Patterns (25 min)\n10. Use optional map/flatMap to transform optional values safely\n11. Implement a validation system that returns optional error messages\n12. Create a function that chains multiple optional operations\n\nPART 5: Real-World Application (20 min)\n13. Build a complete user registration validator\n14. Implement a safe data processing pipeline\n15. Create error handling with optional error types",
        "starterCode": "// === PART 1: Basic Optional Handling ===\n// Create user properties and basic functions here\n\n\n// === PART 2: Optional Chaining & Collections ===\n// Define UserProfile and implement safe access\n\n\n// === PART 3: Nil Coalescing & Default Values ===\n// Implement display functions with defaults\n\n\n// === PART 4: Advanced Optional Patterns ===\n// Use map/flatMap and advanced patterns\n\n\n// === PART 5: Real-World Application ===\n// Build complete validation system\n\n",
        "solution": "// === PART 1: Basic Optional Handling ===\nvar username: String? = \"SwiftMaster\"\nvar email: String? = \"user@example.com\"\nvar age: Int? = 25\nvar phoneNumber: String? = nil\n\nfunc printUserInfo() {\n    if let name = username {\n        print(\"Username: \\(name)\")\n    } else {\n        print(\"Username: Not set\")\n    }\n    \n    if let userEmail = email {\n        print(\"Email: \\(userEmail)\")\n    } else {\n        print(\"Email: Not provided\")\n    }\n    \n    if let userAge = age {\n        print(\"Age: \\(userAge)\")\n    } else {\n        print(\"Age: Unknown\")\n    }\n}\n\nfunc getUserBio() -> String? {\n    guard let name = username else {\n        return nil\n    }\n    \n    var bio = \"User: \\(name)\"\n    \n    if let userAge = age {\n        bio += \", Age: \\(userAge)\"\n    }\n    \n    if let userEmail = email {\n        bio += \", Email: \\(userEmail)\"\n    }\n    \n    return bio\n}\n\n// === PART 2: Optional Chaining & Collections ===\nstruct Address {\n    var street: String?\n    var city: String?\n    var country: String? = \"USA\"\n}\n\nstruct Preferences {\n    var theme: String?\n    var notifications: Bool? = true\n}\n\nstruct UserProfile {\n    var username: String?\n    var address: Address?\n    var preferences: Preferences?\n    var friends: [String]?\n}\n\nvar userProfile = UserProfile(\n    username: \"JohnDoe\",\n    address: Address(street: \"123 Main St\", city: nil, country: \"USA\"),\n    preferences: Preferences(theme: \"dark\", notifications: true),\n    friends: [\"Alice\", \"Bob\", \"Charlie\"]\n)\n\nfunc getFullAddress() -> String? {\n    guard let address = userProfile.address else {\n        return nil\n    }\n    \n    var addressParts: [String] = []\n    \n    if let street = address.street {\n        addressParts.append(street)\n    }\n    \n    if let city = address.city {\n        addressParts.append(city)\n    }\n    \n    if let country = address.country {\n        addressParts.append(country)\n    }\n    \n    return addressParts.isEmpty ? nil : addressParts.joined(separator: \", \")\n}\n\nfunc getFirstFriend() -> String? {\n    return userProfile.friends?.first\n}\n\n// === PART 3: Nil Coalescing & Default Values ===\nfunc getDisplayName() -> String {\n    return username ?? \"Anonymous User\"\n}\n\nfunc getDisplayAge() -> String {\n    return age.map { \"\\($0) years old\" } ?? \"Age not specified\"\n}\n\nfunc getUserLevel() -> Int {\n    let baseLevel = 1\n    let ageBonus = age.map { $0 / 10 } ?? 0  // 1 level per 10 years\n    return baseLevel + ageBonus\n}\n\nstruct UserSettings {\n    var theme: String?\n    var language: String?\n    var volume: Int?\n    \n    var effectiveTheme: String {\n        return theme ?? \"light\"\n    }\n    \n    var effectiveLanguage: String {\n        return language ?? \"en\"\n    }\n    \n    var effectiveVolume: Int {\n        return volume ?? 50\n    }\n}\n\n// === PART 4: Advanced Optional Patterns ===\nfunc validateEmail() -> Bool {\n    return email?.contains(\"@\") == true\n}\n\nfunc getDomainFromEmail() -> String? {\n    return email?.split(separator: \"@\").last.map(String.init)\n}\n\nfunc createWelcomeMessage() -> String? {\n    return username.map { name in\n        let greeting = \"Welcome, \\(name)!\"\n        let emailPart = email.map { \" We sent a confirmation to \\($0).\" } ?? \"\"\n        return greeting + emailPart\n    }\n}\n\nfunc processUserInput(_ input: String?) -> String? {\n    return input?\n        .trimmingCharacters(in: .whitespaces)\n        .isEmpty == false ? input : nil\n}\n\n// === PART 5: Real-World Application ===\nstruct ValidationError {\n    let message: String\n}\n\nfunc validateRegistration(username: String?, email: String?, password: String?) -> ValidationError? {\n    guard let username = username, !username.isEmpty else {\n        return ValidationError(message: \"Username is required\")\n    }\n    \n    guard let email = email, email.contains(\"@\") else {\n        return ValidationError(message: \"Valid email is required\")\n    }\n    \n    guard let password = password, password.count >= 8 else {\n        return ValidationError(message: \"Password must be at least 8 characters\")\n    }\n    \n    return nil\n}\n\nfunc registerUser(username: String?, email: String?, password: String?) -> Bool {\n    if let error = validateRegistration(username: username, email: email, password: password) {\n        print(\"Registration failed: \\(error.message)\")\n        return false\n    }\n    \n    print(\"User \\(username!) registered successfully with email \\(email!)\")\n    return true\n}\n\nfunc safeDataProcessingPipeline() -> String? {\n    return username?\n        .trimmingCharacters(in: .whitespaces)\n        .uppercased()\n        .appending(\" - VERIFIED\")\n}",
        "hints": [
          "PART 1: Use if-let for safe unwrapping and guard for early returns with required values",
          "PART 2: Optional chaining uses ?. to safely access nested properties: object?.property?.nestedProperty",
          "PART 3: Nil coalescing ?? provides default values when optionals are nil",
          "PART 4: map transforms optional values, flatMap handles nested optionals",
          "PART 5: Use guard statements to validate multiple conditions and return early on failure",
          "Remember: Force unwrapping ! should be avoided - use safe unwrapping instead",
          "Optional chaining returns nil if any part of the chain is nil",
          "Use compactMap with collections of optionals to filter out nil values"
        ],
        "testCases": [
          {
            "input": "getDisplayName() == \"SwiftMaster\"",
            "expectedOutput": "true",
            "description": "Display name should return username when available"
          },
          {
            "input": "validateEmail() == true",
            "expectedOutput": "true",
            "description": "Email validation should pass for valid email"
          },
          {
            "input": "getDomainFromEmail() == \"example.com\"",
            "expectedOutput": "true",
            "description": "Should extract domain from email address"
          }
        ]
      }
    },
    {
      "id": "control_flow",
      "title": "Control Flow",
      "description": "Master decision-making and repetition in Swift with if/else, switch, and loops",
      "difficulty": "beginner",
      "theory": "# Control Flow - Directing Your Code's Execution\n\n## 1. Conditional Statements: Making Decisions (45 min)\n\n### if/else Statements\nControl flow starts with making decisions. Use `if` to execute code only when a condition is true:\n\n```swift\nlet temperature = 25\n\nif temperature > 30 {\n    print(\"It's hot outside!\")\n} else if temperature > 20 {\n    print(\"It's warm outside\")\n} else {\n    print(\"It's cool outside\")\n}\n```\n\n### Boolean Logic\nCombine conditions using logical operators:\n- `&&` (AND) - Both conditions must be true\n- `||` (OR) - At least one condition must be true\n- `!` (NOT) - Inverts a boolean value\n\n```swift\nlet isSunny = true\nlet isWeekend = false\n\nif isSunny && isWeekend {\n    print(\"Perfect day for outdoor activities!\")\n} else if isSunny || isWeekend {\n    print(\"Still a good day\")\n} else {\n    print(\"Maybe stay indoors\")\n}\n```\n\n## 2. Switch Statements: Elegant Multi-Case Handling (45 min)\n\n### Basic Switch Syntax\n`switch` provides a cleaner alternative to multiple `if/else if` statements:\n\n```swift\nlet grade = \"B\"\n\nswitch grade {\ncase \"A\":\n    print(\"Excellent!\")\ncase \"B\":\n    print(\"Good job!\")\ncase \"C\":\n    print(\"You passed\")\ncase \"D\":\n    print(\"You barely passed\")\ncase \"F\":\n    print(\"You failed\")\ndefault:\n    print(\"Invalid grade\")\n}\n```\n\n### Advanced Switch Features\nSwift's `switch` is incredibly powerful:\n\n**Interval Matching:**\n```swift\nlet score = 85\n\nswitch score {\ncase 90...100:\n    print(\"A\")\ncase 80..<90:\n    print(\"B\")\ncase 70..<80:\n    print(\"C\")\ncase 60..<70:\n    print(\"D\")\ncase 0..<60:\n    print(\"F\")\ndefault:\n    print(\"Score out of range\")\n}\n```\n\n**Compound Cases:**\n```swift\nlet character: Character = \"e\"\n\nswitch character {\ncase \"a\", \"e\", \"i\", \"o\", \"u\":\n    print(\"Vowel\")\ncase \"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \n     \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\":\n    print(\"Consonant\")\ndefault:\n    print(\"Not a letter\")\n}\n```\n\n**Value Binding:**\n```swift\nlet point = (2, 0)\n\nswitch point {\ncase (let x, 0):\n    print(\"On the x-axis with x = \\(x)\")\ncase (0, let y):\n    print(\"On the y-axis with y = \\(y)\")\ncase let (x, y):\n    print(\"Somewhere else at (\\(x), \\(y))\")\n}\n```\n\n## 3. Loops: Repeating Code Execution (60 min)\n\n### for-in Loops\nIterate over sequences like arrays, ranges, and strings:\n\n```swift\n// Loop through a range\nfor number in 1...5 {\n    print(\"Number: \\(number)\")\n}\n\n// Loop through an array\nlet fruits = [\"Apple\", \"Banana\", \"Orange\"]\nfor fruit in fruits {\n    print(\"I like \\(fruit)\")\n}\n\n// Loop through a dictionary\nlet scores = [\"Alice\": 85, \"Bob\": 92, \"Charlie\": 78]\nfor (name, score) in scores {\n    print(\"\\(name): \\(score)\")\n}\n```\n\n### while Loops\nExecute code while a condition remains true:\n\n```swift\nvar counter = 5\n\nwhile counter > 0 {\n    print(\"\\(counter)...\")\n    counter -= 1\n}\nprint(\"Go!\")\n```\n\n### repeat-while Loops\nExecute at least once, then check condition:\n\n```swift\nvar number: Int\n\nrepeat {\n    print(\"Enter a positive number: \")\n    // In real app, you'd read user input here\n    number = 5 // Simulated input\n} while number <= 0\n\nprint(\"You entered: \\(number)\")\n```\n\n## 4. Loop Control Statements (30 min)\n\n### break and continue\nControl loop execution flow:\n\n**`break`** - Exit the loop immediately\n```swift\nfor number in 1...10 {\n    if number == 5 {\n        break // Stop the loop when number reaches 5\n    }\n    print(number)\n}\n// Output: 1, 2, 3, 4\n```\n\n**`continue`** - Skip to next iteration\n```swift\nfor number in 1...10 {\n    if number % 2 == 0 {\n        continue // Skip even numbers\n    }\n    print(number)\n}\n// Output: 1, 3, 5, 7, 9\n```\n\n### Labeled Statements\nControl specific loops in nested situations:\n```swift\nouterLoop: for i in 1...3 {\n    innerLoop: for j in 1...3 {\n        if i * j == 6 {\n            break outerLoop // Break the outer loop, not just inner\n        }\n        print(\"i: \\(i), j: \\(j)\")\n    }\n}\n```\n\n## 5. Practical Patterns & Best Practices (30 min)\n\n### Early Returns\nUse `guard` statements for early exit:\n```swift\nfunc processOrder(quantity: Int, price: Double) -> Double? {\n    guard quantity > 0 else {\n        print(\"Quantity must be positive\")\n        return nil\n    }\n    \n    guard price >= 0 else {\n        print(\"Price cannot be negative\")\n        return nil\n    }\n    \n    return Double(quantity) * price\n}\n```\n\n### Pattern Matching with where\nAdd conditions to cases:\n```swift\nlet number = 15\n\nswitch number {\ncase let x where x % 2 == 0:\n    print(\"\\(x) is even\")\ncase let x where x % 2 == 1:\n    print(\"\\(x) is odd\")\ndefault:\n    print(\"Unknown\")\n}\n```\n\n### Loop Performance\n- Use `for-in` for known iteration counts\n- Use `while` for unknown iteration counts\n- Consider algorithm complexity with nested loops\n\n## 6. Real-World Applications (30 min)\n\n### Game Development\n```swift\n// Game loop pattern\nvar gameRunning = true\nvar playerHealth = 100\n\nwhile gameRunning {\n    // Process input\n    // Update game state\n    // Render graphics\n    \n    playerHealth -= 5\n    \n    if playerHealth <= 0 {\n        print(\"Game Over!\")\n        gameRunning = false\n    }\n}\n```\n\n### Data Processing\n```swift\nlet transactions = [125.50, -45.00, 200.00, -30.00, 75.25]\nvar balance = 0.0\n\nfor transaction in transactions {\n    balance += transaction\n    \n    switch transaction {\n    case _ where transaction > 0:\n        print(\"Deposit: $\\(transaction)\")\n    case _ where transaction < 0:\n        print(\"Withdrawal: $\\(abs(transaction))\")\n    default:\n        print(\"No transaction\")\n    }\n}\n\nprint(\"Final balance: $\\(balance)\")\n```\n\nMaster these control flow concepts to write dynamic, responsive Swift code!",
      "codeExample": "// === IF/ELSE STATEMENTS ===\nlet temperature = 25\nlet isRaining = false\n\n// Basic if/else\nif temperature > 30 {\n    print(\"It's hot! Stay hydrated.\")\n} else if temperature > 20 && !isRaining {\n    print(\"Perfect weather for a walk!\")\n} else {\n    print(\"Might want to stay indoors.\")\n}\n\n// Nested conditionals\nlet age = 25\nlet hasLicense = true\n\nif age >= 18 {\n    if hasLicense {\n        print(\"You can drive a car!\")\n    } else {\n        print(\"You're old enough but need a license.\")\n    }\n} else {\n    print(\"You're too young to drive.\")\n}\n\n// === SWITCH STATEMENTS ===\nlet direction = \"north\"\n\n// Basic switch\nswitch direction {\ncase \"north\":\n    print(\"Heading north\")\ncase \"south\":\n    print(\"Heading south\")\ncase \"east\":\n    print(\"Heading east\")\ncase \"west\":\n    print(\"Heading west\")\ndefault:\n    print(\"Unknown direction\")\n}\n\n// Switch with ranges\nlet examScore = 87\n\nswitch examScore {\ncase 90...100:\n    print(\"Grade: A - Excellent!\")\ncase 80..<90:\n    print(\"Grade: B - Good job!\")\ncase 70..<80:\n    print(\"Grade: C - Satisfactory\")\ncase 60..<70:\n    print(\"Grade: D - Needs improvement\")\ncase 0..<60:\n    print(\"Grade: F - Failed\")\ndefault:\n    print(\"Invalid score\")\n}\n\n// Switch with tuples\nlet coordinates = (1, 0)\n\nswitch coordinates {\ncase (0, 0):\n    print(\"At the origin\")\ncase (_, 0):\n    print(\"On the x-axis\")\ncase (0, _):\n    print(\"On the y-axis\")\ncase (-2...2, -2...2):\n    print(\"Inside the 5x5 box\")\ncase let (x, y):\n    print(\"At coordinates (\\(x), \\(y))\")\n}\n\n// === FOR-IN LOOPS ===\n// Loop through range\nprint(\"\\nCounting to 5:\")\nfor number in 1...5 {\n    print(number)\n}\n\n// Loop through array\nlet fruits = [\"Apple\", \"Banana\", \"Cherry\", \"Date\"]\nprint(\"\\nFruits:\")\nfor fruit in fruits {\n    print(\"- \\(fruit)\")\n}\n\n// Loop with index\nprint(\"\\nFruits with index:\")\nfor (index, fruit) in fruits.enumerated() {\n    print(\"\\(index + 1). \\(fruit)\")\n}\n\n// Loop through dictionary\nlet inventory = [\"Sword\": 5, \"Shield\": 3, \"Potion\": 10]\nprint(\"\\nInventory:\")\nfor (item, quantity) in inventory {\n    print(\"\\(item): \\(quantity)\")\n}\n\n// === WHILE LOOPS ===\nvar countdown = 3\nprint(\"\\nCountdown:\")\nwhile countdown > 0 {\n    print(\"\\(countdown)...\")\n    countdown -= 1\n}\nprint(\"Go!\")\n\n// === REPEAT-WHILE LOOPS ===\nvar userInput = \"\"\nprint(\"\\nRepeat-while example:\")\nrepeat {\n    print(\"Type 'exit' to quit: \")\n    // Simulate user input\n    userInput = \"exit\"\n} while userInput != \"exit\"\n\n// === LOOP CONTROL ===\nprint(\"\\nBreak and continue:\")\nfor number in 1...10 {\n    if number == 3 {\n        continue // Skip 3\n    }\n    if number == 8 {\n        break // Stop at 8\n    }\n    print(number)\n}\n\n// === PRACTICAL EXAMPLE: GAME MECHANICS ===\nstruct Player {\n    var health: Int\n    var mana: Int\n    var level: Int\n}\n\nvar player = Player(health: 100, mana: 50, level: 1)\nlet enemies = [\"Goblin\", \"Orc\", \"Dragon\"]\nlet enemyHealth = [\"Goblin\": 30, \"Orc\": 50, \"Dragon\": 100]\n\nprint(\"\\n=== BATTLE SIMULATION ===\")\n\n// Simulate battles with different enemies\nfor enemy in enemies {\n    print(\"\\nA wild \\(enemy) appears!\")\n    \n    var currentEnemyHealth = enemyHealth[enemy] ?? 0\n    \n    while currentEnemyHealth > 0 && player.health > 0 {\n        // Player attacks\n        let damage = Int.random(in: 5...15) * player.level\n        currentEnemyHealth -= damage\n        print(\"You hit the \\(enemy) for \\(damage) damage!\")\n        \n        // Enemy attacks (sometimes)\n        if currentEnemyHealth > 0 && Bool.random() {\n            let enemyDamage = Int.random(in: 3...8)\n            player.health -= enemyDamage\n            print(\"The \\(enemy) hits you for \\(enemyDamage) damage!\")\n        }\n        \n        // Check battle status\n        switch (player.health, currentEnemyHealth) {\n        case (..., 0):\n            print(\"You defeated the \\(enemy)!\")\n            player.level += 1\n        case (0, _):\n            print(\"You were defeated by the \\(enemy)!\")\n        case (1...30, _):\n            print(\"Warning: Low health!\")\n        default:\n            break\n        }\n    }\n    \n    if player.health <= 0 {\n        print(\"Game Over!\")\n        break\n    }\n}",
      "category": "Swift Basics",
      "estimatedTime": 180,
      "dependencies": ["variables"],
      "challenge": {
        "instructions": "Create a complete student grading system using all control flow concepts:\n\nPART 1: Grade Calculator (45 min)\n1. Create a function that takes a score (0-100) and returns a letter grade using switch with ranges\n2. Add plus/minus grading: A (90-100), A- (85-89), B+ (80-84), B (75-79), etc.\n3. Handle invalid scores with default case\n\nPART 2: Student Analysis (45 min)\n4. Create an array of student scores and use for-in loops to:\n   - Calculate class average\n   - Count how many students got each letter grade\n   - Find the highest and lowest scores\n\nPART 3: Grade Distribution (45 min)\n5. Use while/repeat-while loops to simulate grade improvement:\n   - Start with a failing student (score < 60)\n   - Add 5 points each \"study session\" until they pass\n   - Print progress after each session\n\nPART 4: Advanced Reporting (45 min)\n6. Create a comprehensive report using nested control flow:\n   - Categorize students by performance level (Excellent, Good, Needs Improvement)\n   - Use if/else chains with boolean logic\n   - Implement a search function that finds students in a specific grade range\n\nBONUS: Create a menu system with switch that lets users choose different reporting options",
        "starterCode": "// === PART 1: Grade Calculator ===\n// Create your grade calculation function here\n\n\n// === PART 2: Student Analysis ===\n// Analyze the student scores array\nlet studentScores = [85, 92, 78, 45, 67, 95, 88, 72, 60, 81, 53, 98, 75, 64, 89]\n\n\n// === PART 3: Grade Improvement ===\n// Simulate student improvement with loops\n\n\n// === PART 4: Advanced Reporting ===\n// Create comprehensive reporting system\n\n\n// === BONUS: Menu System ===\n// Implement interactive menu\n",
        "solution": "// === PART 1: Grade Calculator ===\nfunc calculateLetterGrade(score: Int) -> String {\n    switch score {\n    case 93...100:\n        return \"A\"\n    case 90...92:\n        return \"A-\"\n    case 87...89:\n        return \"B+\"\n    case 83...86:\n        return \"B\"\n    case 80...82:\n        return \"B-\"\n    case 77...79:\n        return \"C+\"\n    case 73...76:\n        return \"C\"\n    case 70...72:\n        return \"C-\"\n    case 67...69:\n        return \"D+\"\n    case 63...66:\n        return \"D\"\n    case 60...62:\n        return \"D-\"\n    case 0...59:\n        return \"F\"\n    default:\n        return \"Invalid Score\"\n    }\n}\n\n// === PART 2: Student Analysis ===\nlet studentScores = [85, 92, 78, 45, 67, 95, 88, 72, 60, 81, 53, 98, 75, 64, 89]\n\n// Calculate average\nvar totalScore = 0\nfor score in studentScores {\n    totalScore += score\n}\nlet averageScore = totalScore / studentScores.count\nprint(\"Class Average: \\(averageScore)\")\n\n// Count grades\nvar gradeCounts = [\"A\": 0, \"B\": 0, \"C\": 0, \"D\": 0, \"F\": 0]\n\nfor score in studentScores {\n    let grade = calculateLetterGrade(score: score)\n    \n    switch grade.first {\n    case \"A\":\n        gradeCounts[\"A\"]! += 1\n    case \"B\":\n        gradeCounts[\"B\"]! += 1\n    case \"C\":\n        gradeCounts[\"C\"]! += 1\n    case \"D\":\n        gradeCounts[\"D\"]! += 1\n    case \"F\":\n        gradeCounts[\"F\"]! += 1\n    default:\n        break\n    }\n}\n\nprint(\"Grade Distribution: \\(gradeCounts)\")\n\n// Find highest and lowest\nvar highestScore = studentScores[0]\nvar lowestScore = studentScores[0]\n\nfor score in studentScores {\n    if score > highestScore {\n        highestScore = score\n    }\n    if score < lowestScore {\n        lowestScore = score\n    }\n}\n\nprint(\"Highest Score: \\(highestScore), Lowest Score: \\(lowestScore)\")\n\n// === PART 3: Grade Improvement ===\nvar failingStudentScore = 45\nvar studySessions = 0\n\nprint(\"\\n=== STUDENT IMPROVEMENT TRACKER ===\")\n\nwhile failingStudentScore < 60 {\n    studySessions += 1\n    failingStudentScore += 5\n    \n    let currentGrade = calculateLetterGrade(score: failingStudentScore)\n    print(\"After session \\(studySessions): Score = \\(failingStudentScore), Grade = \\(currentGrade)\")\n    \n    if failingStudentScore >= 60 {\n        print(\"ðŸŽ‰ Student passed after \\(studySessions) study sessions!\")\n    }\n}\n\n// === PART 4: Advanced Reporting ===\nfunc categorizePerformance(score: Int) -> String {\n    if score >= 90 {\n        return \"Excellent\"\n    } else if score >= 75 {\n        return \"Good\"\n    } else if score >= 60 {\n        return \"Needs Improvement\"\n    } else {\n        return \"Failing\"\n    }\n}\n\nfunc findStudentsInRange(scores: [Int], minScore: Int, maxScore: Int) -> [Int] {\n    var results: [Int] = []\n    \n    for score in scores {\n        if score >= minScore && score <= maxScore {\n            results.append(score)\n        }\n    }\n    \n    return results\n}\n\nprint(\"\\n=== PERFORMANCE CATEGORIZATION ===\")\nfor score in studentScores {\n    let category = categorizePerformance(score: score)\n    let grade = calculateLetterGrade(score: score)\n    print(\"Score \\(score): \\(grade) - \\(category)\")\n}\n\nlet midRangeScores = findStudentsInRange(scores: studentScores, minScore: 70, maxScore: 85)\nprint(\"\\nScores between 70-85: \\(midRangeScores)\")\n\n// === BONUS: Menu System ===\nfunc displayMenu() {\n    print(\"\"\"\n    \\n=== GRADEBOOK MENU ===\n    1. View All Scores\n    2. Calculate Average\n    3. Grade Distribution\n    4. Find Students in Range\n    5. Exit\n    \"\"\")\n}\n\nvar menuRunning = true\n\nwhile menuRunning {\n    displayMenu()\n    let userChoice = 5 // Simulated user input - would be input in real app\n    \n    switch userChoice {\n    case 1:\n        print(\"All Scores: \\(studentScores)\")\n    case 2:\n        print(\"Class Average: \\(averageScore)\")\n    case 3:\n        print(\"Grade Distribution: \\(gradeCounts)\")\n    case 4:\n        let rangeScores = findStudentsInRange(scores: studentScores, minScore: 70, maxScore: 85)\n        print(\"Scores between 70-85: \\(rangeScores)\")\n    case 5:\n        print(\"Goodbye!\")\n        menuRunning = false\n    default:\n        print(\"Invalid choice. Please try again.\")\n    }\n    \n    if userChoice != 5 {\n        // In real app, you'd have a way to continue\n        menuRunning = false // Simulate exit for this example\n    }\n}",
        "hints": [
          "PART 1: Use switch with range operators (...) for inclusive and (..<) for exclusive ranges",
          "PART 2: Use for-in loops to iterate through arrays. Remember arrays are zero-indexed",
          "PART 3: while loops are perfect for unknown iteration counts - keep going until condition met",
          "PART 4: Combine if/else with boolean logic (&&, ||) for complex conditions",
          "Use print() statements to track your progress and debug",
          "For the bonus menu, think about how real applications handle user interaction loops",
          "Remember to handle edge cases: empty arrays, invalid scores, boundary conditions"
        ],
        "testCases": [
          {
            "input": "calculateLetterGrade(score: 95)",
            "expectedOutput": "A",
            "description": "A score of 95 should return A"
          },
          {
            "input": "calculateLetterGrade(score: 82)",
            "expectedOutput": "B-",
            "description": "A score of 82 should return B-"
          },
          {
            "input": "studentScores.count",
            "expectedOutput": "15",
            "description": "Should have 15 student scores"
          }
        ]
      }
    },
    {
      "id": "functions_closures",
      "title": "Functions & Closures",
      "description": "Master function syntax, parameters, return types, and powerful closure expressions",
      "difficulty": "beginner",
      "theory": "# Functions & Closures - Reusable Code Blocks\n\n## 1. Function Fundamentals (45 min)\n\n### What are Functions?\nFunctions are self-contained chunks of code that perform a specific task. They help you:\n- **Avoid repetition**: Write once, use many times\n- **Organize code**: Break complex problems into smaller pieces\n- **Improve readability**: Give names to operations\n\n### Basic Function Syntax:\n```swift\nfunc functionName(parameters) -> ReturnType {\n    // code\n    return value\n}\n```\n\n## 2. Function Parameters (60 min)\n\n### Parameters vs Arguments:\n- **Parameters**: Variables in function declaration\n- **Arguments**: Actual values passed to function\n\n### Parameter Types:\n\n**Default Parameters:**\n```swift\nfunc greet(name: String, withGreeting: String = \"Hello\") {\n    print(\"\\(withGreeting), \\(name)!\")\n}\ngreet(name: \"Alice\")           // \"Hello, Alice!\"\ngreet(name: \"Bob\", withGreeting: \"Hi\") // \"Hi, Bob!\"\n```\n\n**Variadic Parameters:**\n```swift\nfunc average(_ numbers: Double...) -> Double {\n    let total = numbers.reduce(0, +)\n    return total / Double(numbers.count)\n}\naverage(1, 2, 3, 4, 5)  // 3.0\n```\n\n**In-Out Parameters:**\n```swift\nfunc swapValues(_ a: inout Int, _ b: inout Int) {\n    let temp = a\n    a = b\n    b = temp\n}\nvar x = 5, y = 10\nswapValues(&x, &y)  // x = 10, y = 5\n```\n\n## 3. Return Types & Multiple Returns (45 min)\n\n### Returning Multiple Values:\n```swift\nfunc calculateStatistics(scores: [Int]) -> (min: Int, max: Int, sum: Int) {\n    let min = scores.min() ?? 0\n    let max = scores.max() ?? 0\n    let sum = scores.reduce(0, +)\n    return (min, max, sum)\n}\nlet stats = calculateStatistics(scores: [5, 3, 100, 3, 9])\nprint(stats.min)  // 3\nprint(stats.max)  // 100\nprint(stats.sum)  // 120\n```\n\n### Optional Return Types:\n```swift\nfunc findFirstEven(in numbers: [Int]) -> Int? {\n    return numbers.first { $0 % 2 == 0 }\n}\n```\n\n## 4. Function Types & Higher-Order Functions (45 min)\n\n### Function Types:\nEvery function has a specific type made up of parameter types and return type:\n```swift\nfunc add(_ a: Int, _ b: Int) -> Int { return a + b }\n// Type: (Int, Int) -> Int\n\nfunc printNumber(_ number: Int) { print(number) }\n// Type: (Int) -> Void\n```\n\n### Functions as Parameters:\n```swift\nfunc applyOperation(_ a: Int, _ b: Int, operation: (Int, Int) -> Int) -> Int {\n    return operation(a, b)\n}\n\nlet result = applyOperation(5, 3, operation: add)  // 8\n```\n\n## 5. Closures Introduction (45 min)\n\n### What are Closures?\nClosures are self-contained blocks of functionality that can be passed around and used in your code. They capture and store references to variables and constants from the context in which they're defined.\n\n### Closure Syntax:\n```swift\n{ (parameters) -> ReturnType in\n    statements\n}\n```\n\n### Closure Examples:\n```swift\n// As a variable\nlet multiply: (Int, Int) -> Int = { (a, b) in\n    return a * b\n}\n\n// Inline\nlet numbers = [1, 2, 3, 4, 5]\nlet doubled = numbers.map({ (number: Int) -> Int in\n    return number * 2\n})\n```\n\n## 6. Closure Shorthand Syntax (30 min)\n\nSwift provides several ways to write closures more concisely:\n\n### Implicit Returns:\n```swift\nlet squared = numbers.map { number in\n    number * number  // implicit return\n}\n```\n\n### Shorthand Argument Names:\n```swift\nlet doubled = numbers.map { $0 * 2 }  // $0, $1, $2...\n```\n\n### Trailing Closures:\n```swift\n// When closure is last parameter\nlet evens = numbers.filter { $0 % 2 == 0 }\n\n// Multiple trailing closures (Swift 5.3+)\nanimateView {\n    // animation code\n} completion: {\n    // completion code\n}\n```\n\n## 7. Capturing Values & Escaping Closures (30 min)\n\n### Value Capturing:\n```swift\nfunc makeIncrementer(incrementAmount: Int) -> () -> Int {\n    var total = 0\n    let incrementer: () -> Int = {\n        total += incrementAmount\n        return total\n    }\n    return incrementer\n}\n\nlet incrementByTwo = makeIncrementer(incrementAmount: 2)\nincrementByTwo()  // 2\nincrementByTwo()  // 4\nincrementByTwo()  // 6\n```\n\n### Escaping Closures:\n```swift\nvar completionHandlers: [() -> Void] = []\n\nfunc someFunctionWithEscapingClosure(completionHandler: @escaping () -> Void) {\n    completionHandlers.append(completionHandler)\n}\n```\n\n## 8. Common Closure Patterns (30 min)\n\n### Sorting with Closures:\n```swift\nlet names = [\"Chris\", \"Alex\", \"Ewa\", \"Barry\", \"Daniella\"]\nlet sortedNames = names.sorted { $0 < $1 }\n```\n\n### Network Call Completion:\n```swift\nfunc fetchData(completion: @escaping (Result<String, Error>) -> Void) {\n    DispatchQueue.global().async {\n        // Simulate network call\n        DispatchQueue.main.async {\n            completion(.success(\"Data received\"))\n        }\n    }\n}\n```\n\n## 9. Best Practices & Common Pitfalls (30 min)\n\n### Naming Conventions:\n- Use descriptive names for functions\n- Follow the \"verb-noun\" pattern: `calculateAverage`, `fetchUserData`\n- Be clear about side effects\n\n### Memory Management:\n- Use `[weak self]` or `[unowned self]` in closures to avoid retain cycles\n- Understand when to use escaping vs non-escaping closures\n\n### Error Handling in Closures:\n```swift\nfunc processData(completion: (Result<Data, Error>) -> Void) {\n    do {\n        let data = try loadData()\n        completion(.success(data))\n    } catch {\n        completion(.failure(error))\n    }\n}\n```\n\n## Practice Exercises\n\nComplete all exercises to master functions and closures!",
      "codeExample": "// === FUNCTION FUNDAMENTALS ===\n// Basic function\nfunc greet(person: String) -> String {\n    return \"Hello, \\(person)!\"\n}\n\n// Function without return value\nfunc logMessage(_ message: String) {\n    print(\"LOG: \\(message)\")\n}\n\n// === PARAMETER VARIATIONS ===\n// Default parameters\nfunc createGreeting(for name: String, withEmoji: String = \"ðŸ‘‹\") -> String {\n    return \"\\(withEmoji) Hello, \\(name)!\"\n}\n\n// Variadic parameters\nfunc calculateSum(_ numbers: Int...) -> Int {\n    return numbers.reduce(0, +)\n}\n\n// In-out parameters\nfunc doubleInPlace(_ number: inout Int) {\n    number *= 2\n}\n\n// === RETURN TYPES ===\n// Multiple return values\nfunc analyzeNumbers(_ numbers: [Int]) -> (min: Int, max: Int, average: Double) {\n    let min = numbers.min() ?? 0\n    let max = numbers.max() ?? 0\n    let average = Double(numbers.reduce(0, +)) / Double(numbers.count)\n    return (min, max, average)\n}\n\n// Optional return\nfunc findIndex(of value: Int, in array: [Int]) -> Int? {\n    return array.firstIndex(of: value)\n}\n\n// === FUNCTION TYPES ===\n// Function as type\nlet mathOperation: (Int, Int) -> Int = { $0 + $1 }\n\n// Function accepting function parameter\nfunc processNumbers(_ a: Int, _ b: Int, using operation: (Int, Int) -> Int) -> Int {\n    return operation(a, b)\n}\n\n// === CLOSURES ===\n// Basic closure syntax\nlet addClosure: (Int, Int) -> Int = { (a, b) in\n    return a + b\n}\n\n// Closure with shorthand arguments\nlet multiplyClosure = { (a: Int, b: Int) -> Int in\n    a * b\n}\n\n// === CLOSURE SHORTHAND ===\nlet numbers = [1, 2, 3, 4, 5, 6]\n\n// Using map with closures\nlet squared = numbers.map { $0 * $0 }\n\n// Using filter with closures\nlet evens = numbers.filter { $0 % 2 == 0 }\n\n// Using reduce with closures\nlet sum = numbers.reduce(0) { $0 + $1 }\n\n// Using sorted with closures\nlet descending = numbers.sorted { $0 > $1 }\n\n// === CAPTURING VALUES ===\nfunc makeCounter() -> () -> Int {\n    var count = 0\n    return {\n        count += 1\n        return count\n    }\n}\n\nlet counter = makeCounter()\n\n// === PRACTICAL EXAMPLES ===\n// Network simulation with escaping closure\nfunc simulateNetworkCall(delay: Double, completion: @escaping (Result<String, Error>) -> Void) {\n    DispatchQueue.global().asyncAfter(deadline: .now() + delay) {\n        let success = Bool.random()\n        if success {\n            completion(.success(\"Data fetched successfully\"))\n        } else {\n            completion(.failure(NSError(domain: \"NetworkError\", code: 1)))\n        }\n    }\n}\n\n// Data processing pipeline\nfunc processUserData(names: [String], \n                    filter: (String) -> Bool,\n                    transform: (String) -> String,\n                    completion: ([String]) -> Void) {\n    \n    let filteredNames = names.filter(filter)\n    let transformedNames = filteredNames.map(transform)\n    completion(transformedNames)\n}\n\n// === REAL-WORLD USAGE ===\n// Button tap handler simulation\ntypealias ButtonTapHandler = (UIButton) -> Void\n\nfunc createButton(tapHandler: @escaping ButtonTapHandler) {\n    // In real app, this would create a UIButton\n    print(\"Button created with tap handler\")\n    // Simulate button tap\n    tapHandler(UIButton())  // Using UIButton for demonstration\n}\n\n// Animation completion\nfunc animateView(completion: @escaping () -> Void) {\n    DispatchQueue.main.asyncAfter(deadline: .now() + 1.0) {\n        completion()\n    }\n}",
      "category": "Swift Basics",
      "estimatedTime": 240,
      "dependencies": ["variables", "optionals", "control_flow"],
      "challenge": {
        "instructions": "Create a comprehensive data processing system using functions and closures:\n\nPART 1: Basic Functions (45 min)\n1. Create a function 'calculate' that takes two numbers and an operation closure, returns the result\n2. Create a function 'formatCurrency' that takes a Double and returns a formatted String\n3. Create a function 'validateEmail' that takes a String and returns a Bool\n\nPART 2: Advanced Parameters (45 min)\n4. Create a function 'processNumbers' with variadic Int parameters that returns statistics\n5. Create a function 'updateScore' with inout parameter that modifies a score variable\n6. Create a function 'createGreeting' with default parameters for greeting type\n\nPART 3: Closure Implementation (60 min)\n7. Create a closure that filters an array based on a custom condition\n8. Create a closure that transforms an array of strings to uppercase\n9. Create a closure that sorts an array in a custom order\n\nPART 4: Higher-Order Functions (45 min)\n10. Create a function 'applyToAll' that applies a closure to each element in an array\n11. Create a function 'customFilter' that implements filter functionality using closures\n12. Create a function 'chainOperations' that chains multiple closure operations\n\nPART 5: Real-World Scenario (45 min)\n13. Create a data processing pipeline that filters, transforms, and sorts user data\n14. Implement a retry mechanism with escaping closures for network calls\n15. Create a calculator with operation closures stored in a dictionary",
        "starterCode": "// === PART 1: Basic Functions ===\n// Create your basic functions here\n\n\n// === PART 2: Advanced Parameters ===\n// Create functions with advanced parameters here\n\n\n// === PART 3: Closure Implementation ===\n// Create and use closures here\n\n\n// === PART 4: Higher-Order Functions ===\n// Create higher-order functions here\n\n\n// === PART 5: Real-World Scenario ===\n// Implement real-world scenarios here\n\n",
        "solution": "// === PART 1: Basic Functions ===\nfunc calculate(_ a: Double, _ b: Double, operation: (Double, Double) -> Double) -> Double {\n    return operation(a, b)\n}\n\nfunc formatCurrency(_ amount: Double) -> String {\n    return String(format: \"$%.2f\", amount)\n}\n\nfunc validateEmail(_ email: String) -> Bool {\n    let emailRegex = \"[A-Z0-9a-z._%+-]+@[A-Za-z0-9.-]+\\\\.[A-Za-z]{2,}\"\n    return NSPredicate(format: \"SELF MATCHES %@\", emailRegex).evaluate(with: email)\n}\n\n// === PART 2: Advanced Parameters ===\nfunc processNumbers(_ numbers: Int...) -> (sum: Int, average: Double, count: Int) {\n    let sum = numbers.reduce(0, +)\n    let average = Double(sum) / Double(numbers.count)\n    return (sum, average, numbers.count)\n}\n\nfunc updateScore(_ score: inout Int, by points: Int) {\n    score += points\n    if score < 0 { score = 0 }\n}\n\nfunc createGreeting(for name: String, \n                   greeting: String = \"Hello\", \n                   includeEmoji: Bool = true) -> String {\n    let emoji = includeEmoji ? \"ðŸ‘‹\" : \"\"\n    return \"\\(emoji) \\(greeting), \\(name)!\"\n}\n\n// === PART 3: Closure Implementation ===\nlet isEven: (Int) -> Bool = { $0 % 2 == 0 }\nlet toUpperCase: (String) -> String = { $0.uppercased() }\nlet sortDescending: (Int, Int) -> Bool = { $0 > $1 }\n\nlet numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\nlet evenNumbers = numbers.filter(isEven)\nlet names = [\"alice\", \"bob\", \"charlie\"]\nlet upperNames = names.map(toUpperCase)\nlet sortedNumbers = numbers.sorted(by: sortDescending)\n\n// === PART 4: Higher-Order Functions ===\nfunc applyToAll<T>(_ array: [T], transform: (T) -> T) -> [T] {\n    return array.map(transform)\n}\n\nfunc customFilter<T>(_ array: [T], isIncluded: (T) -> Bool) -> [T] {\n    var result: [T] = []\n    for element in array {\n        if isIncluded(element) {\n            result.append(element)\n        }\n    }\n    return result\n}\n\nfunc chainOperations<T>(_ array: [T], \n                       operations: [( [T]) -> [T]]) -> [T] {\n    var result = array\n    for operation in operations {\n        result = operation(result)\n    }\n    return result\n}\n\n// === PART 5: Real-World Scenario ===\n// Data processing pipeline\ntypealias User = (name: String, age: Int, email: String)\n\nfunc processUsers(_ users: [User], \n                 filter: (User) -> Bool,\n                 transform: (User) -> String,\n                 sort: (String, String) -> Bool,\n                 completion: ([String]) -> Void) {\n    \n    let filteredUsers = users.filter(filter)\n    let transformedUsers = filteredUsers.map(transform)\n    let sortedUsers = transformedUsers.sorted(by: sort)\n    completion(sortedUsers)\n}\n\n// Retry mechanism\nfunc fetchWithRetry(attempts: Int, \n                   operation: @escaping (@escaping (Result<String, Error>) -> Void) -> Void,\n                   completion: @escaping (Result<String, Error>) -> Void) {\n    \n    var currentAttempt = 0\n    \n    func attempt() {\n        currentAttempt += 1\n        operation { result in\n            switch result {\n            case .success(let data):\n                completion(.success(data))\n            case .failure(let error):\n                if currentAttempt < attempts {\n                    print(\"Attempt \\(currentAttempt) failed, retrying...\")\n                    attempt()\n                } else {\n                    completion(.failure(error))\n                }\n            }\n        }\n    }\n    \n    attempt()\n}\n\n// Calculator with operation dictionary\nlet operations: [String: (Double, Double) -> Double] = [\n    \"add\": { $0 + $1 },\n    \"subtract\": { $0 - $1 },\n    \"multiply\": { $0 * $1 },\n    \"divide\": { $0 / $1 }\n]\n\nfunc performOperation(_ operation: String, _ a: Double, _ b: Double) -> Double? {\n    return operations[operation]?(a, b)\n}",
        "hints": [
          "PART 1: Remember function syntax: func name(parameters) -> ReturnType { }",
          "PART 2: Use '...' for variadic parameters, 'inout' for modifiable parameters",
          "PART 3: Closure syntax: { (parameters) -> ReturnType in statements }",
          "PART 4: Higher-order functions take functions/closures as parameters",
          "PART 5: Use @escaping for closures that are called after function returns",
          "For email validation, you can use a simple contains(\"@\") check instead of regex",
          "Use type aliases to make complex closure types more readable",
          "Remember to handle edge cases like division by zero"
        ],
        "testCases": [
          {
            "input": "calculate(10, 5, operation: { $0 + $1 }) == 15",
            "expectedOutput": "true",
            "description": "Calculate function should perform addition correctly"
          },
          {
            "input": "validateEmail(\"test@example.com\")",
            "expectedOutput": "true",
            "description": "Email validation should accept valid emails"
          },
          {
            "input": "evenNumbers.count == 5",
            "expectedOutput": "true",
            "description": "Should filter even numbers correctly"
          }
        ]
      }
    },
    {
      "id": "collections",
      "title": "Collections",
      "description": "Master Arrays, Dictionaries, and Sets - the essential data structures for organizing data in Swift",
      "difficulty": "beginner",
      "theory": "# Collections - Organizing Data in Swift\n\n## 1. Arrays: Ordered Collections (1 hour)\n\n### What are Arrays?\nArrays store ordered collections of values of the same type. They maintain the order of elements and allow duplicate values.\n\n### Array Basics:\n```swift\n// Creating arrays\nvar emptyArray: [Int] = []\nvar numbers = [1, 2, 3, 4, 5]\nvar names = [\"Alice\", \"Bob\", \"Charlie\"]\n\n// Array with repeated values\nvar repeated = Array(repeating: 0, count: 5) // [0, 0, 0, 0, 0]\n```\n\n### Array Operations:\n- **Access**: `array[0]`, `array.first`, `array.last`\n- **Count**: `array.count`, `array.isEmpty`\n- **Modification**: `append()`, `insert()`, `remove()`, `removeAll()`\n\n### Array Properties and Methods:\n```swift\nvar fruits = [\"Apple\", \"Banana\", \"Orange\"]\n\n// Properties\nprint(fruits.count)      // 3\nprint(fruits.isEmpty)    // false\nprint(fruits.first)      // Optional(\"Apple\")\nprint(fruits.last)       // Optional(\"Orange\")\n\n// Adding elements\nfruits.append(\"Grape\")           // [\"Apple\", \"Banana\", \"Orange\", \"Grape\"]\nfruits.insert(\"Mango\", at: 1)   // [\"Apple\", \"Mango\", \"Banana\", \"Orange\", \"Grape\"]\n\n// Removing elements\nfruits.remove(at: 2)     // Removes \"Banana\"\nfruits.removeFirst()     // Removes \"Apple\"\nfruits.removeLast()      // Removes \"Grape\"\n```\n\n## 2. Array Iteration and Transformation (45 minutes)\n\n### Looping Through Arrays:\n```swift\nlet scores = [85, 92, 78, 90, 88]\n\n// For-in loop\nfor score in scores {\n    print(\"Score: \\(score)\")\n}\n\n// Enumerated loop (with index)\nfor (index, score) in scores.enumerated() {\n    print(\"Score at index \\(index): \\(score)\")\n}\n\n// While loop\nvar i = 0\nwhile i < scores.count {\n    print(scores[i])\n    i += 1\n}\n```\n\n### Array Transformation Methods:\n```swift\nlet numbers = [1, 2, 3, 4, 5]\n\n// map - transform each element\nlet squared = numbers.map { $0 * $0 } // [1, 4, 9, 16, 25]\n\n// filter - select elements that meet condition\nlet evenNumbers = numbers.filter { $0 % 2 == 0 } // [2, 4]\n\n// reduce - combine all elements\nlet sum = numbers.reduce(0, +) // 15\n\n// sorted - sort elements\nlet sortedNumbers = numbers.sorted(by: >) // [5, 4, 3, 2, 1]\n```\n\n## 3. Dictionaries: Key-Value Collections (1 hour)\n\n### What are Dictionaries?\nDictionaries store unordered collections of key-value pairs. Each value is associated with a unique key.\n\n### Dictionary Basics:\n```swift\n// Creating dictionaries\nvar emptyDict: [String: Int] = [:]\nvar ages = [\"Alice\": 25, \"Bob\": 30, \"Charlie\": 35]\nvar studentScores = [\"Math\": 95, \"Science\": 88, \"History\": 92]\n\n// Accessing values\nlet aliceAge = ages[\"Alice\"] // Optional(25)\nlet unknownAge = ages[\"David\"] // nil\n\n// Adding and updating\nages[\"David\"] = 28        // Add new entry\nages[\"Alice\"] = 26        // Update existing entry\n```\n\n### Dictionary Operations:\n```swift\nvar inventory = [\"apples\": 10, \"oranges\": 5, \"bananas\": 8]\n\n// Properties\nprint(inventory.count)        // 3\nprint(inventory.isEmpty)      // false\nprint(inventory.keys)         // [\"apples\", \"oranges\", \"bananas\"]\nprint(inventory.values)       // [10, 5, 8]\n\n// Safe access with default values\nlet appleCount = inventory[\"apples\", default: 0]\nlet mangoCount = inventory[\"mangoes\", default: 0]\n\n// Removing values\ninventory[\"oranges\"] = nil   // Remove oranges\ninventory.removeAll()         // Remove all items\n```\n\n## 4. Dictionary Iteration and Methods (45 minutes)\n\n### Looping Through Dictionaries:\n```swift\nlet capitals = [\"France\": \"Paris\", \"Japan\": \"Tokyo\", \"Brazil\": \"BrasÃ­lia\"]\n\n// Loop through key-value pairs\nfor (country, capital) in capitals {\n    print(\"\\(country)'s capital is \\(capital)\")\n}\n\n// Loop through keys only\nfor country in capitals.keys {\n    print(\"Country: \\(country)\")\n}\n\n// Loop through values only\nfor capital in capitals.values {\n    print(\"Capital: \\(capital)\")\n}\n```\n\n### Dictionary Transformation:\n```swift\nlet prices = [\"apple\": 1.99, \"banana\": 0.99, \"orange\": 2.49]\n\n// mapValues - transform values only\nlet salePrices = prices.mapValues { $0 * 0.8 } // 20% off\n\n// filter - keep only certain entries\nlet expensiveItems = prices.filter { $0.value > 2.0 }\n\n// map - transform entire dictionary\nlet priceDescriptions = prices.map { (item, price) in\n    return \"\\(item): $\\(price)\"\n}\n```\n\n## 5. Sets: Unique Collections (30 minutes)\n\n### What are Sets?\nSets store unordered collections of unique values of the same type. They don't allow duplicates.\n\n### Set Basics:\n```swift\n// Creating sets\nvar emptySet: Set<String> = []\nvar favoriteGenres: Set = [\"Rock\", \"Classical\", \"Jazz\"]\nvar primeNumbers: Set = [2, 3, 5, 7, 11]\n\n// Set properties\nprint(favoriteGenres.count)   // 3\nprint(favoriteGenres.isEmpty) // false\n\n// Adding and removing\nfavoriteGenres.insert(\"Hip hop\")  // Add new element\nfavoriteGenres.remove(\"Jazz\")     // Remove element\n```\n\n### Set Operations:\n```swift\nlet oddNumbers: Set = [1, 3, 5, 7, 9]\nlet evenNumbers: Set = [2, 4, 6, 8, 10]\nlet primeNumbers: Set = [2, 3, 5, 7]\n\n// Union - combine sets\nlet allNumbers = oddNumbers.union(evenNumbers) // [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\n// Intersection - common elements\nlet oddPrimes = oddNumbers.intersection(primeNumbers) // [3, 5, 7]\n\n// Subtraction - elements in first but not second\nlet nonPrimeOdds = oddNumbers.subtracting(primeNumbers) // [1, 9]\n\n// Symmetric difference - elements in either but not both\nlet uniqueToEach = oddNumbers.symmetricDifference(primeNumbers) // [1, 2, 9]\n```\n\n## 6. Choosing the Right Collection (30 minutes)\n\n### When to Use Each Collection:\n\n**Use Arrays when:**\n- Order matters\n- You need duplicates\n- You'll access elements by index\n- Example: To-do list, playlist\n\n**Use Dictionaries when:**\n- You need key-value pairs\n- Fast lookup by key is important\n- Order doesn't matter\n- Example: User profiles, settings\n\n**Use Sets when:**\n- Uniqueness is required\n- Order doesn't matter\n- You need set operations (union, intersection)\n- Example: Tags, unique categories\n\n### Performance Characteristics:\n- **Arrays**: Fast index access, slow insertion in middle\n- **Dictionaries**: Fast key lookup, no guaranteed order\n- **Sets**: Fast membership testing, unique values only\n\n## Practice Exercises\n\nComplete all exercises to master collection types and their practical applications!",
      "codeExample": "// === ARRAYS ===\n// Creating and manipulating arrays\nvar shoppingList = [\"Milk\", \"Eggs\", \"Bread\"]\nvar numbers = [1, 2, 3, 4, 5]\n\n// Array operations\nprint(\"First item: \\(shoppingList[0])\")           // Milk\nprint(\"Array count: \\(shoppingList.count)\")       // 3\n\n// Adding elements\nshoppingList.append(\"Butter\")\nshoppingList.insert(\"Cheese\", at: 1)\n\n// Removing elements\nlet removedItem = shoppingList.remove(at: 2)\nshoppingList.removeLast()\n\n// Array transformation\nlet doubledNumbers = numbers.map { $0 * 2 }        // [2, 4, 6, 8, 10]\nlet evenNumbers = numbers.filter { $0 % 2 == 0 }   // [2, 4]\nlet sum = numbers.reduce(0, +)                     // 15\n\n// Sorting\nlet sortedNumbers = numbers.sorted(by: >)          // [5, 4, 3, 2, 1]\n\n// === DICTIONARIES ===\n// Creating dictionaries\nvar studentGrades = [\"Alice\": 95, \"Bob\": 87, \"Charlie\": 92]\nvar countryCapitals = [\"USA\": \"Washington D.C.\", \"UK\": \"London\", \"Japan\": \"Tokyo\"]\n\n// Dictionary operations\nprint(\"Alice's grade: \\(studentGrades[\"Alice\"] ?? 0)\") // 95\nprint(\"Dictionary keys: \\(studentGrades.keys)\")        // [\"Alice\", \"Bob\", \"Charlie\"]\n\n// Adding and updating\nstudentGrades[\"David\"] = 88\nstudentGrades[\"Alice\"] = 96\n\n// Safe access with default\nlet eveGrade = studentGrades[\"Eve\", default: 0]\n\n// Dictionary transformation\nlet gradeDescriptions = studentGrades.map { (name, grade) in\n    return \"\\(name): \\(grade)%\"\n}\n\nlet highAchievers = studentGrades.filter { $0.value >= 90 }\n\n// === SETS ===\n// Creating sets\nvar favoriteColors: Set = [\"Red\", \"Blue\", \"Green\"]\nvar visitedCountries: Set = [\"USA\", \"Canada\", \"Mexico\", \"Japan\"]\n\n// Set operations\nfavoriteColors.insert(\"Purple\")\nfavoriteColors.remove(\"Green\")\n\n// Set operations with multiple sets\nlet warmColors: Set = [\"Red\", \"Orange\", \"Yellow\"]\nlet coolColors: Set = [\"Blue\", \"Green\", \"Purple\"]\n\nlet allColors = warmColors.union(coolColors)\nlet warmAndFavorite = warmColors.intersection(favoriteColors)\nlet onlyWarm = warmColors.subtracting(favoriteColors)\n\n// === PRACTICAL EXAMPLES ===\n// Game inventory system\nstruct GameCharacter {\n    var name: String\n    var level: Int\n    var inventory: [String: Int]  // item: quantity\n    var skills: Set<String>\n}\n\nvar player = GameCharacter(\n    name: \"Hero\",\n    level: 5,\n    inventory: [\"Health Potion\": 3, \"Mana Potion\": 5, \"Gold\": 100],\n    skills: [\"Attack\", \"Defend\", \"Heal\"]\n)\n\n// Array of characters\nvar partyMembers = [\n    GameCharacter(name: \"Warrior\", level: 6, inventory: [\"Sword\": 1, \"Shield\": 1], skills: [\"Attack\", \"Defend\"]),\n    GameCharacter(name: \"Mage\", level: 5, inventory: [\"Staff\": 1, \"Mana Potion\": 10], skills: [\"Fireball\", \"Heal\"]),\n    GameCharacter(name: \"Archer\", level: 4, inventory: [\"Bow\": 1, \"Arrows\": 50], skills: [\"Attack\", \"Stealth\"])\n]\n\n// Working with collections\nlet partyLevels = partyMembers.map { $0.level }\nlet averageLevel = Double(partyLevels.reduce(0, +)) / Double(partyLevels.count)\n\nlet allSkills = partyMembers.reduce(Set<String>()) { result, character in\n    return result.union(character.skills)\n}\n\n// Dictionary of party resources\nvar partyInventory: [String: Int] = [:]\nfor member in partyMembers {\n    for (item, quantity) in member.inventory {\n        partyInventory[item, default: 0] += quantity\n    }\n}",
      "category": "Swift Basics",
      "estimatedTime": 240,
      "dependencies": ["variables"],
      "challenge": {
        "instructions": "Create a complete game inventory management system:\n\nPART 1: Array Operations (45 min)\n1. Create an array of player names: [\"Warrior\", \"Mage\", \"Archer\", \"Healer\"]\n2. Add two new players to the party\n3. Remove the player at index 1\n4. Create an array of player levels and calculate average level\n5. Filter players above level 5\n\nPART 2: Dictionary Operations (45 min)\n6. Create a dictionary mapping player names to their classes\n7. Create an inventory dictionary with items and quantities\n8. Add new items to inventory with safe default values\n9. Create a function to use items from inventory\n10. Calculate total value of inventory (each item has different values)\n\nPART 3: Set Operations (30 min)\n11. Create sets of skills for each character class\n12. Find common skills between Warrior and Mage\n13. Create a set of all unique skills in the party\n14. Find skills that only one class has\n\nPART 4: Combined Operations (1 hour)\n15. Create a Player struct with name, level, inventory, and skills\n16. Create an array of Player objects\n17. Write a function to find players who can use a specific skill\n18. Create a trading system between players\n19. Calculate party statistics (total items, unique skills, average level)\n\nPART 5: Advanced Challenges (1 hour)\n20. Implement item crafting system using multiple ingredients\n21. Create skill tree progression using sets\n22. Build party formation optimizer using collection operations\n23. Implement save/load system using collection transformations",
        "starterCode": "// === PART 1: Array Operations ===\n// Create and manipulate arrays here\n\n\n// === PART 2: Dictionary Operations ===\n// Create and manipulate dictionaries here\n\n\n// === PART 3: Set Operations ===\n// Create and manipulate sets here\n\n\n// === PART 4: Combined Operations ===\n// Create Player struct and combined operations here\n\n\n// === PART 5: Advanced Challenges ===\n// Implement advanced systems here\n\n",
        "solution": "// === PART 1: Array Operations ===\nvar playerNames = [\"Warrior\", \"Mage\", \"Archer\", \"Healer\"]\n\n// Add new players\nplayerNames.append(\"Rogue\")\nplayerNames.append(\"Paladin\")\n\n// Remove player at index 1\nlet removedPlayer = playerNames.remove(at: 1)\n\n// Player levels and average\nlet playerLevels = [6, 8, 5, 7, 4]\nlet totalLevel = playerLevels.reduce(0, +)\nlet averageLevel = Double(totalLevel) / Double(playerLevels.count)\n\n// Filter high-level players\nlet highLevelPlayers = playerLevels.filter { $0 > 5 }\n\n// === PART 2: Dictionary Operations ===\nvar playerClasses = [\n    \"Warrior\": \"Fighter\",\n    \"Mage\": \"Spellcaster\", \n    \"Archer\": \"Ranger\",\n    \"Healer\": \"Support\"\n]\n\n// Add new player classes\nplayerClasses[\"Rogue\"] = \"Stealth\"\nplayerClasses[\"Paladin\"] = \"Holy Warrior\"\n\n// Inventory system\nvar inventory = [\n    \"Health Potion\": 5,\n    \"Mana Potion\": 3,\n    \"Gold\": 250,\n    \"Arrows\": 20\n]\n\n// Safe item access\nlet healthPotionCount = inventory[\"Health Potion\", default: 0]\nlet unknownItemCount = inventory[\"Unknown Item\", default: 0]\n\n// Use item function\nfunc useItem(_ item: String, quantity: Int = 1) -> Bool {\n    guard let currentQuantity = inventory[item], currentQuantity >= quantity else {\n        print(\"Not enough \\(item)\")\n        return false\n    }\n    inventory[item] = currentQuantity - quantity\n    print(\"Used \\(quantity) \\(item)\")\n    return true\n}\n\n// Item values and total worth\nlet itemValues = [\"Health Potion\": 10, \"Mana Potion\": 15, \"Gold\": 1, \"Arrows\": 2]\nlet totalInventoryValue = inventory.reduce(0) { result, item in\n    let value = itemValues[item.key, default: 0] * item.value\n    return result + value\n}\n\n// === PART 3: Set Operations ===\nlet warriorSkills: Set = [\"Attack\", \"Defend\", \"Bash\"]\nlet mageSkills: Set = [\"Fireball\", \"Heal\", \"Teleport\"]\nlet archerSkills: Set = [\"Attack\", \"Stealth\", \"Aim\"]\nlet healerSkills: Set = [\"Heal\", \"Protect\", \"Revive\"]\n\n// Common skills between Warrior and Mage\nlet warriorMageCommon = warriorSkills.intersection(mageSkills)\n\n// All unique skills in party\nlet allSkills = warriorSkills.union(mageSkills).union(archerSkills).union(healerSkills)\n\n// Skills unique to each class\nlet warriorOnlySkills = warriorSkills.subtracting(mageSkills).subtracting(archerSkills).subtracting(healerSkills)\nlet mageOnlySkills = mageSkills.subtracting(warriorSkills).subtracting(archerSkills).subtracting(healerSkills)\n\n// === PART 4: Combined Operations ===\nstruct Player {\n    let name: String\n    var level: Int\n    var inventory: [String: Int]\n    var skills: Set<String>\n    var classType: String\n}\n\nvar players = [\n    Player(name: \"Warrior\", level: 6, inventory: [\"Sword\": 1, \"Shield\": 1, \"Health Potion\": 2], skills: warriorSkills, classType: \"Fighter\"),\n    Player(name: \"Mage\", level: 8, inventory: [\"Staff\": 1, \"Mana Potion\": 5, \"Gold\": 100], skills: mageSkills, classType: \"Spellcaster\"),\n    Player(name: \"Archer\", level: 5, inventory: [\"Bow\": 1, \"Arrows\": 30, \"Health Potion\": 1], skills: archerSkills, classType: \"Ranger\"),\n    Player(name: \"Healer\", level: 7, inventory: [\"Wand\": 1, \"Health Potion\": 4, \"Mana Potion\": 3], skills: healerSkills, classType: \"Support\")\n]\n\n// Find players with specific skill\nfunc playersWithSkill(_ skill: String) -> [Player] {\n    return players.filter { $0.skills.contains(skill) }\n}\n\n// Trading system\nfunc tradeItems(from player1: String, to player2: String, item: String, quantity: Int) -> Bool {\n    guard let fromIndex = players.firstIndex(where: { $0.name == player1 }),\n          let toIndex = players.firstIndex(where: { $0.name == player2 }),\n          let fromQuantity = players[fromIndex].inventory[item],\n          fromQuantity >= quantity else {\n        return false\n    }\n    \n    players[fromIndex].inventory[item] = fromQuantity - quantity\n    players[toIndex].inventory[item, default: 0] += quantity\n    return true\n}\n\n// Party statistics\nlet totalItems = players.reduce(0) { result, player in\n    return result + player.inventory.values.reduce(0, +)\n}\n\nlet uniquePartySkills = players.reduce(Set<String>()) { result, player in\n    return result.union(player.skills)\n}\n\nlet partyAverageLevel = Double(players.reduce(0) { $0 + $1.level }) / Double(players.count)\n\n// === PART 5: Advanced Challenges ===\n// Item crafting system\nlet craftingRecipes: [String: [String: Int]] = [\n    \"Health Potion\": [\"Herb\": 2, \"Vial\": 1],\n    \"Mana Potion\": [\"Mana Herb\": 3, \"Vial\": 1],\n    \"Arrows\": [\"Wood\": 1, \"Metal\": 1]\n]\n\nfunc canCraft(item: String, with inventory: [String: Int]) -> Bool {\n    guard let recipe = craftingRecipes[item] else { return false }\n    \n    for (ingredient, needed) in recipe {\n        guard let available = inventory[ingredient], available >= needed else {\n            return false\n        }\n    }\n    return true\n}\n\n// Skill tree progression\nvar skillTrees: [String: Set<String>] = [\n    \"Basic\": [\"Attack\", \"Defend\"],\n    \"Warrior\": [\"Bash\", \"Charge\"],\n    \"Mage\": [\"Fireball\", \"Ice Bolt\"],\n    \"Advanced\": [\"Ultimate\", \"Combo\"]\n]\n\nfunc availableSkills(for player: Player) -> Set<String> {\n    var available: Set<String> = skillTrees[\"Basic\"] ?? []\n    \n    if let classSkills = skillTrees[player.classType] {\n        available = available.union(classSkills)\n    }\n    \n    if player.level >= 10 {\n        available = available.union(skillTrees[\"Advanced\"] ?? [])\n    }\n    \n    return available.subtracting(player.skills)\n}\n\n// Party formation optimizer\nfunc optimizeParty(for missionType: String) -> [Player] {\n    let requiredSkills: Set<String>\n    \n    switch missionType {\n    case \"Combat\":\n        requiredSkills = [\"Attack\", \"Defend\"]\n    case \"Stealth\":\n        requiredSkills = [\"Stealth\", \"Aim\"]\n    case \"Healing\":\n        requiredSkills = [\"Heal\", \"Protect\"]\n    default:\n        requiredSkills = []\n    }\n    \n    return players.filter { player in\n        !requiredSkills.isDisjoint(with: player.skills)\n    }.sorted { $0.level > $1.level }\n}\n\n// Save/load system simulation\nfunc savePartyData() -> [String: Any] {\n    let playerData = players.map { player in\n        return [\n            \"name\": player.name,\n            \"level\": player.level,\n            \"inventory\": player.inventory,\n            \"skills\": Array(player.skills),\n            \"class\": player.classType\n        ]\n    }\n    \n    return [\n        \"players\": playerData,\n        \"totalPlayers\": players.count,\n        \"averageLevel\": partyAverageLevel,\n        \"uniqueSkills\": uniquePartySkills.count\n    ]\n}",
        "hints": [
          "PART 1: Use append() to add elements, remove(at:) to remove, reduce() for sums, filter() for conditions",
          "PART 2: Use dictionary[key] = value to add/update, dictionary[key, default: 0] for safe access",
          "PART 3: Sets use intersection(), union(), subtracting() for mathematical operations",
          "PART 4: Create a Player struct with properties, then use filter() and reduce() on arrays of players",
          "PART 5: Use nested dictionaries for crafting recipes, sets for skill trees, and complex filtering for optimization",
          "Remember that sets automatically handle uniqueness - no duplicates allowed",
          "Use enumerated() when you need both index and value in loops",
          "mapValues() is great for transforming dictionary values without changing keys",
          "reduce() can start with different initial values (0 for sum, [] for arrays, [:]) for dictionaries"
        ],
        "testCases": [
          {
            "input": "playerNames.count == 5",
            "expectedOutput": "true",
            "description": "Should have 5 players after additions and removals"
          },
          {
            "input": "inventory[\"Health Potion\", default: 0] > 0",
            "expectedOutput": "true",
            "description": "Health potions should be available in inventory"
          },
          {
            "input": "allSkills.contains(\"Heal\")",
            "expectedOutput": "true",
            "description": "Heal skill should be in the complete skill set"
          }
        ]
      }
    },
    {
      "id": "structs_classes",
      "title": "Structs & Classes",
      "description": "Master value types vs reference types - the foundation of Swift's data modeling",
      "difficulty": "beginner",
      "theory": "# Structs & Classes - Value vs Reference Types\n\n## 1. Understanding the Fundamental Difference (45 min)\n\n### Value Types (Structs)\n- **Copied** when assigned or passed\n- Each instance has **independent** data\n- Changes don't affect other instances\n- **Stack-allocated** (usually)\n\n### Reference Types (Classes)\n- **Shared** when assigned or passed  \n- Multiple references point to **same** instance\n- Changes affect all references\n- **Heap-allocated** with reference counting\n\n### Real-world Analogy:\n- **Value Type**: Like a PDF file - each copy is independent\n- **Reference Type**: Like a Google Doc - everyone sees the same document\n\n## 2. Structs in Depth (60 min)\n\n### Basic Struct Syntax:\n```swift\nstruct Point {\n    var x: Double\n    var y: Double\n}\n```\n\n### Memberwise Initializer:\nStructs get a free initializer:\n```swift\nlet point = Point(x: 10.0, y: 20.0)\n```\n\n### Methods in Structs:\n```swift\nstruct Point {\n    var x: Double\n    var y: Double\n    \n    func distance(to other: Point) -> Double {\n        let deltaX = x - other.x\n        let deltaY = y - other.y\n        return sqrt(deltaX * deltaX + deltaY * deltaY)\n    }\n    \n    mutating func moveBy(x deltaX: Double, y deltaY: Double) {\n        x += deltaX\n        y += deltaY\n    }\n}\n```\n\n### Computed Properties:\n```swift\nstruct Rectangle {\n    var width: Double\n    var height: Double\n    \n    var area: Double {\n        return width * height\n    }\n    \n    var perimeter: Double {\n        return 2 * (width + height)\n    }\n}\n```\n\n## 3. Classes in Depth (60 min)\n\n### Basic Class Syntax:\n```swift\nclass Person {\n    var name: String\n    var age: Int\n    \n    init(name: String, age: Int) {\n        self.name = name\n        self.age = age\n    }\n}\n```\n\n### Inheritance:\n```swift\nclass Vehicle {\n    var speed: Double = 0.0\n    \n    func makeSound() {\n        print(\"Some vehicle sound\")\n    }\n}\n\nclass Car: Vehicle {\n    var gear: Int = 1\n    \n    override func makeSound() {\n        print(\"Vroom vroom!\")\n    }\n}\n```\n\n### Reference Semantics Demonstration:\n```swift\nclass Student {\n    var name: String\n    var grade: Int\n    \n    init(name: String, grade: Int) {\n        self.name = name\n        self.grade = grade\n    }\n}\n\nlet student1 = Student(name: \"Alice\", grade: 85)\nlet student2 = student1  // Both reference SAME object\nstudent2.grade = 90\nprint(student1.grade) // 90 - both changed!\n```\n\n## 4. When to Use Each (45 min)\n\n### Use Structs For:\n- Simple data values (Point, Size, Color)\n- Data that should be copied, not shared\n- Immutable data patterns\n- When you want value semantics\n\n### Use Classes For:\n- Objects with identity (User, DatabaseConnection)\n- When you need inheritance\n- When shared mutability is desired\n- Reference semantics needed\n\n### Swift Standard Library Examples:\n- **Structs**: Int, String, Array, Dictionary, Set\n- **Classes**: NSObject subclasses, UIView (UIKit)\n\n## 5. Advanced Concepts (45 min)\n\n### Identity Operators (=== and !==):\n```swift\nclass Animal {\n    var name: String\n    init(name: String) { self.name = name }\n}\n\nlet cat1 = Animal(name: \"Whiskers\")\nlet cat2 = cat1\nlet cat3 = Animal(name: \"Whiskers\")\n\nprint(cat1 === cat2) // true - same instance\nprint(cat1 === cat3) // false - different instances\nprint(cat1.name == cat3.name) // true - same values\n```\n\n### Copy-on-Write Optimization:\nSwift uses copy-on-write for large structs:\n```swift\nvar array1 = [1, 2, 3]\nvar array2 = array1  // No copy yet - shared storage\narray2.append(4)     // Now a copy is made\n```\n\n### Deinitializers (Classes Only):\n```swift\nclass FileHandler {\n    let filename: String\n    \n    init(filename: String) {\n        self.filename = filename\n        print(\"Opening file: \\(filename)\")\n    }\n    \n    deinit {\n        print(\"Closing file: \\(filename)\")\n    }\n}\n```\n\n## 6. Practical Patterns & Best Practices (45 min)\n\n### Model Data with Structs:\n```swift\nstruct User {\n    let id: UUID\n    var username: String\n    var email: String\n    var createdAt: Date\n    \n    var displayName: String {\n        return \"@\\(username)\"\n    }\n}\n```\n\n### Reference Types for Shared Resources:\n```swift\nclass GameManager {\n    static let shared = GameManager()\n    private init() {}\n    \n    var currentScore = 0\n    var highScore = 0\n    \n    func updateScore(_ points: Int) {\n        currentScore += points\n        if currentScore > highScore {\n            highScore = currentScore\n        }\n    }\n}\n```\n\n### Choosing Between Value and Reference:\n- **Ask**: \"If I make a copy, should it be independent?\" â†’ Struct\n- **Ask**: \"Do multiple parts need to share the same instance?\" â†’ Class\n- **Default to structs** unless you need specific class features\n\n## Practice Exercises\n\nComplete all exercises to master value vs reference semantics!",
      "codeExample": "// === STRUCT EXAMPLES ===\n\n// Basic struct with properties\nstruct Book {\n    var title: String\n    var author: String\n    var pageCount: Int\n    var isRead: Bool = false\n    \n    // Computed property\n    var description: String {\n        return \"\\\"\\(title)\\\" by \\(author) (\\(pageCount) pages)\"\n    }\n    \n    // Method\n    func isLongBook() -> Bool {\n        return pageCount > 500\n    }\n    \n    // Mutating method\n    mutating func markAsRead() {\n        isRead = true\n    }\n}\n\n// Using the struct\nvar myBook = Book(title: \"Swift Programming\", author: \"Apple\", pageCount: 350)\nprint(myBook.description) // \"Swift Programming\" by Apple (350 pages)\nmyBook.markAsRead()\n\n// Value semantics demonstration\nvar book1 = Book(title: \"Book A\", author: \"Author A\", pageCount: 100)\nvar book2 = book1  // This creates a COPY\nbook2.title = \"Book B\"\nprint(book1.title) // \"Book A\" - unchanged!\nprint(book2.title) // \"Book B\" - changed copy\n\n// === CLASS EXAMPLES ===\n\n// Basic class with inheritance\nclass Animal {\n    var name: String\n    var age: Int\n    \n    init(name: String, age: Int) {\n        self.name = name\n        self.age = age\n    }\n    \n    func makeSound() {\n        print(\"Some animal sound\")\n    }\n}\n\nclass Dog: Animal {\n    var breed: String\n    \n    init(name: String, age: Int, breed: String) {\n        self.breed = breed\n        super.init(name: name, age: age)\n    }\n    \n    override func makeSound() {\n        print(\"Woof!\")\n    }\n    \n    func bark() {\n        print(\"\\(name) the \\(breed) is barking!\")\n    }\n}\n\n// Using the class\nlet myDog = Dog(name: \"Buddy\", age: 3, breed: \"Golden Retriever\")\nmyDog.makeSound() // \"Woof!\"\nmyDog.bark()      // \"Buddy the Golden Retriever is barking!\"\n\n// Reference semantics demonstration\nlet dog1 = Dog(name: \"Max\", age: 2, breed: \"Labrador\")\nlet dog2 = dog1  // Both reference SAME object\ndog2.name = \"Charlie\"\nprint(dog1.name) // \"Charlie\" - both changed!\n\n// Identity comparison\nprint(dog1 === dog2) // true - same instance\n\n// === PRACTICAL COMPARISON ===\n\n// Struct for value semantics (good for data)\nstruct Coordinate {\n    var latitude: Double\n    var longitude: Double\n    \n    // Computed property\n    var isInNorthernHemisphere: Bool {\n        return latitude > 0\n    }\n}\n\n// Class for reference semantics (good for shared state)\nclass Player {\n    var name: String\n    var score: Int\n    var position: Coordinate\n    \n    init(name: String, score: Int = 0, position: Coordinate) {\n        self.name = name\n        self.score = score\n        self.position = position\n    }\n    \n    func moveTo(newPosition: Coordinate) {\n        position = newPosition\n        print(\"\\(name) moved to (\\(position.latitude), \\(position.longitude))\")\n    }\n}\n\n// Usage example\nlet startPosition = Coordinate(latitude: 37.7749, longitude: -122.4194)\nlet player1 = Player(name: \"Hero\", position: startPosition)\n\n// Copy the coordinate (value type)\nvar newPosition = player1.position\nnewPosition.latitude = 40.7128\n\n// Player's position unchanged (value semantics)\nprint(player1.position.latitude) // 37.7749\n\n// Share player reference\nlet player2 = player1\nplayer2.score = 100\nprint(player1.score) // 100 - both changed (reference semantics)",
      "category": "Swift Basics",
      "estimatedTime": 240,
      "dependencies": ["variables"],
      "challenge": {
        "instructions": "Create a complete system modeling a library with both structs and classes:\n\nPART 1: Value Types with Structs (60 min)\n1. Create a 'Book' struct with: title, author, isbn, pageCount, isCheckedOut\n2. Add computed properties: description, canBeBorrowed\n3. Add methods: checkOut(), returnBook() with proper mutating keywords\n4. Demonstrate value semantics by creating copies and modifying them\n\nPART 2: Reference Types with Classes (60 min)\n5. Create a 'LibraryMember' class with: memberID, name, borrowedBooks array\n6. Add methods: borrowBook(_:), returnBook(_:), listBorrowedBooks()\n7. Demonstrate reference semantics by creating multiple references\n8. Add a 'Library' class that manages all members and books\n\nPART 3: Inheritance & Polymorphism (60 min)\n9. Create a base 'LibraryItem' class with common properties\n10. Create subclasses: 'PrintedBook', 'EBook', 'Audiobook'\n11. Implement different due date calculations for each type\n12. Use polymorphism to handle different item types uniformly\n\nPART 4: Advanced Features (60 min)\n13. Add deinitializers to clean up resources\n14. Implement identity operators to compare instances\n15. Create a singleton 'LibrarySystem' for global access\n16. Add error handling for invalid operations\n\nTest your implementation thoroughly to understand value vs reference behavior!",
        "starterCode": "// === PART 1: Book Struct ===\n// Create your Book struct here\n\n\n// === PART 2: LibraryMember Class ===\n// Create your LibraryMember class here\n\n\n// === PART 3: Inheritance Hierarchy ===\n// Create LibraryItem base class and subclasses here\n\n\n// === PART 4: Advanced Features ===\n// Add deinitializers, singleton, and error handling here\n\n",
        "solution": "// === PART 1: Book Struct ===\nstruct Book {\n    let title: String\n    let author: String\n    let isbn: String\n    let pageCount: Int\n    var isCheckedOut: Bool = false\n    \n    // Computed properties\n    var description: String {\n        return \"\\\"\\(title)\\\" by \\(author) (ISBN: \\(isbn))\"\n    }\n    \n    var canBeBorrowed: Bool {\n        return !isCheckedOut\n    }\n    \n    // Mutating methods\n    mutating func checkOut() {\n        if !isCheckedOut {\n            isCheckedOut = true\n            print(\"Book '\\(title)' has been checked out\")\n        } else {\n            print(\"Book '\\(title)' is already checked out\")\n        }\n    }\n    \n    mutating func returnBook() {\n        if isCheckedOut {\n            isCheckedOut = false\n            print(\"Book '\\(title)' has been returned\")\n        } else {\n            print(\"Book '\\(title)' was not checked out\")\n        }\n    }\n}\n\n// Value semantics demonstration\nvar book1 = Book(title: \"Swift Basics\", author: \"Apple\", isbn: \"123\", pageCount: 300)\nvar book2 = book1  // Copy created\nbook2.checkOut()   // Only affects book2\nprint(book1.isCheckedOut) // false\nprint(book2.isCheckedOut) // true\n\n// === PART 2: LibraryMember Class ===\nclass LibraryMember {\n    let memberID: String\n    var name: String\n    private var borrowedBooks: [Book] = []\n    \n    init(memberID: String, name: String) {\n        self.memberID = memberID\n        self.name = name\n    }\n    \n    func borrowBook(_ book: inout Book) {\n        if book.canBeBorrowed {\n            book.checkOut()\n            borrowedBooks.append(book)\n            print(\"\\(name) borrowed '\\(book.title)'\")\n        } else {\n            print(\"Cannot borrow '\\(book.title)' - already checked out\")\n        }\n    }\n    \n    func returnBook(isbn: String) {\n        if let index = borrowedBooks.firstIndex(where: { $0.isbn == isbn }) {\n            // Note: We can't modify the original book through this reference\n            // In a real app, you'd have a way to update the original\n            borrowedBooks.remove(at: index)\n            print(\"\\(name) returned book with ISBN \\(isbn)\")\n        } else {\n            print(\"No book with ISBN \\(isbn) found in \\(name)'s borrowed list\")\n        }\n    }\n    \n    func listBorrowedBooks() {\n        if borrowedBooks.isEmpty {\n            print(\"\\(name) has no borrowed books\")\n        } else {\n            print(\"\\(name)'s borrowed books:\")\n            for book in borrowedBooks {\n                print(\"  - \\(book.description)\")\n            }\n        }\n    }\n}\n\n// Reference semantics demonstration\nlet member1 = LibraryMember(memberID: \"M001\", name: \"Alice\")\nlet member2 = member1  // Same instance!\nmember2.name = \"Bob\"\nprint(member1.name) // \"Bob\" - both changed\n\n// === PART 3: Inheritance Hierarchy ===\nclass LibraryItem {\n    let id: String\n    let title: String\n    var isAvailable: Bool = true\n    \n    init(id: String, title: String) {\n        self.id = id\n        self.title = title\n    }\n    \n    func calculateDueDate() -> Date {\n        let calendar = Calendar.current\n        return calendar.date(byAdding: .day, value: 14, to: Date()) ?? Date()\n    }\n    \n    func checkOut() {\n        if isAvailable {\n            isAvailable = false\n            let dueDate = calculateDueDate()\n            print(\"'\\(title)' checked out. Due: \\(dueDate)\")\n        } else {\n            print(\"'\\(title)' is not available\")\n        }\n    }\n    \n    func returnItem() {\n        isAvailable = true\n        print(\"'\\(title)' has been returned\")\n    }\n}\n\nclass PrintedBook: LibraryItem {\n    let author: String\n    let pageCount: Int\n    \n    init(id: String, title: String, author: String, pageCount: Int) {\n        self.author = author\n        self.pageCount = pageCount\n        super.init(id: id, title: title)\n    }\n    \n    override func calculateDueDate() -> Date {\n        let calendar = Calendar.current\n        return calendar.date(byAdding: .day, value: 21, to: Date()) ?? Date()\n    }\n}\n\nclass EBook: LibraryItem {\n    let fileSize: Double // in MB\n    \n    init(id: String, title: String, fileSize: Double) {\n        self.fileSize = fileSize\n        super.init(id: id, title: title)\n    }\n    \n    override func calculateDueDate() -> Date {\n        let calendar = Calendar.current\n        return calendar.date(byAdding: .day, value: 7, to: Date()) ?? Date()\n    }\n}\n\n// Polymorphism demonstration\nlet items: [LibraryItem] = [\n    PrintedBook(id: \"B001\", title: \"Swift Guide\", author: \"Apple\", pageCount: 400),\n    EBook(id: \"E001\", title: \"Digital Swift\", fileSize: 5.2)\n]\n\nfor item in items {\n    item.checkOut() // Each calls its own calculateDueDate implementation\n}\n\n// === PART 4: Advanced Features ===\nclass LibrarySystem {\n    static let shared = LibrarySystem()\n    private init() {}\n    \n    private var allItems: [LibraryItem] = []\n    \n    func addItem(_ item: LibraryItem) {\n        allItems.append(item)\n    }\n    \n    func findAvailableItems() -> [LibraryItem] {\n        return allItems.filter { $0.isAvailable }\n    }\n}\n\n// Singleton usage\nLibrarySystem.shared.addItem(PrintedBook(id: \"B002\", title: \"Advanced Swift\", author: \"Apple\", pageCount: 600))\n\n// Identity operators\nlet bookA = PrintedBook(id: \"B003\", title: \"Book A\", author: \"Author A\", pageCount: 100)\nlet bookB = bookA\nlet bookC = PrintedBook(id: \"B003\", title: \"Book A\", author: \"Author A\", pageCount: 100)\n\nprint(bookA === bookB) // true - same instance\nprint(bookA === bookC) // false - different instances\n\n// Deinitializer example\nclass ResourceHandler {\n    let resourceName: String\n    \n    init(resourceName: String) {\n        self.resourceName = resourceName\n        print(\"Acquired resource: \\(resourceName)\")\n    }\n    \n    deinit {\n        print(\"Released resource: \\(resourceName)\")\n    }\n}\n\n// Test deinitializer\nfunc testResource() {\n    let handler = ResourceHandler(resourceName: \"Database Connection\")\n    // handler will be deinitialized when this function ends\n}\n\ntestResource() // Prints: \"Released resource: Database Connection\"",
        "hints": [
          "PART 1: Remember structs are value types - copies are independent. Use 'mutating' for methods that change properties",
          "PART 2: Classes are reference types - assignments create references to the same instance",
          "PART 3: Use 'override' for methods in subclasses. Polymorphism means same method, different behavior",
          "PART 4: === compares instance identity, == compares values (if Equatable is implemented)",
          "Singletons use 'static let shared = ClassName()' and a private init()",
          "Deinitializers only work with classes, not structs",
          "For the Book struct challenge, remember you need 'inout' parameter to modify the original book",
          "Use computed properties for derived values that don't need storage"
        ],
        "testCases": [
          {
            "input": "book1.isCheckedOut == book2.isCheckedOut",
            "expectedOutput": "false",
            "description": "Struct copies should have independent state after modification"
          },
          {
            "input": "member1.name == member2.name",
            "expectedOutput": "true",
            "description": "Class references should share the same data"
          },
          {
            "input": "items.count == 2",
            "expectedOutput": "true",
            "description": "Polymorphic array should contain all items"
          }
        ]
      }
    },
    {
      "id": "enums_protocols",
      "title": "Enums & Protocols",
      "description": "Master Swift's powerful enums with associated values and embrace protocol-oriented programming",
      "difficulty": "beginner",
      "theory": "# Enums & Protocols - Swift's Power Duo\n\n## 1. Enums Fundamentals (45 min)\n\n### Basic Enum Syntax:\n```swift\nenum CompassDirection {\n    case north\n    case south\n    case east\n    case west\n}\n\n// Or in one line:\nenum CompassDirection {\n    case north, south, east, west\n}\n```\n\n### Using Enums:\n```swift\nlet direction = CompassDirection.north\n\n// Type inference with enum cases\nvar currentDirection: CompassDirection = .east\n\n// Switch statements with enums\nswitch direction {\ncase .north:\n    print(\"Heading north\")\ncase .south:\n    print(\"Heading south\")\ncase .east:\n    print(\"Heading east\")\ncase .west:\n    print(\"Heading west\")\n}\n```\n\n### Raw Values:\n```swift\n// Enums with raw values\nenum Planet: Int {\n    case mercury = 1, venus, earth, mars, jupiter, saturn, uranus, neptune\n}\n\nenum ProgrammingLanguage: String {\n    case swift = \"Swift\"\n    case python = \"Python\"\n    case javascript = \"JavaScript\"\n}\n\n// Accessing raw values\nlet earth = Planet.earth\nprint(earth.rawValue) // 3\nprint(ProgrammingLanguage.swift.rawValue) // \"Swift\"\n\n// Creating from raw values\nif let planet = Planet(rawValue: 5) {\n    print(planet) // jupiter\n}\n```\n\n## 2. Associated Values (60 min)\n\n### Enums with Associated Values:\n```swift\n// Enum with associated values\nenum Barcode {\n    case upc(Int, Int, Int, Int)\n    case qrCode(String)\n}\n\n// Creating instances with associated values\nvar productBarcode = Barcode.upc(8, 85909, 51226, 3)\nproductBarcode = .qrCode(\"ABCDEFGHIJKLMNOP\")\n\n// Extracting associated values\nswitch productBarcode {\ncase .upc(let numberSystem, let manufacturer, let product, let check):\n    print(\"UPC: \\(numberSystem), \\(manufacturer), \\(product), \\(check)\")\ncase .qrCode(let productCode):\n    print(\"QR code: \\(productCode)\")\n}\n\n// Shorter syntax when all values are extracted\nswitch productBarcode {\ncase let .upc(numberSystem, manufacturer, product, check):\n    print(\"UPC: \\(numberSystem), \\(manufacturer), \\(product), \\(check)\")\ncase let .qrCode(productCode):\n    print(\"QR code: \\(productCode)\")\n}\n```\n\n### Practical Associated Value Examples:\n```swift\n// Network responses\nenum NetworkResult {\n    case success(data: Data, statusCode: Int)\n    case failure(error: Error, statusCode: Int)\n    case loading(progress: Double)\n}\n\n// Authentication states\nenum AuthState {\n    case authenticated(user: User, token: String)\n    case unauthenticated\n    case expired(token: String)\n}\n\n// Form validation\nenum ValidationResult {\n    case valid\n    case invalid(reason: String, field: String)\n    case warning(message: String)\n}\n```\n\n### Methods in Enums:\n```swift\nenum ArithmeticExpression {\n    case number(Double)\n    case addition(ArithmeticExpression, ArithmeticExpression)\n    case multiplication(ArithmeticExpression, ArithmeticExpression)\n    \n    func evaluate() -> Double {\n        switch self {\n        case .number(let value):\n            return value\n        case .addition(let left, let right):\n            return left.evaluate() + right.evaluate()\n        case .multiplication(let left, let right):\n            return left.evaluate() * right.evaluate()\n        }\n    }\n}\n\n// Usage\nlet expression = ArithmeticExpression.addition(\n    .number(5),\n    .multiplication(.number(2), .number(3))\n)\nprint(expression.evaluate()) // 11.0\n```\n\n## 3. Protocols Fundamentals (45 min)\n\n### Basic Protocol Syntax:\n```swift\n// Protocol definition\nprotocol Vehicle {\n    var numberOfWheels: Int { get }\n    var maxSpeed: Double { get }\n    var currentSpeed: Double { get set }\n    \n    func start()\n    func stop()\n    func description() -> String\n}\n\n// Protocol adoption\nclass Car: Vehicle {\n    let numberOfWheels: Int = 4\n    let maxSpeed: Double = 200.0\n    var currentSpeed: Double = 0.0\n    \n    func start() {\n        print(\"Car started\")\n        currentSpeed = 0\n    }\n    \n    func stop() {\n        print(\"Car stopped\")\n        currentSpeed = 0\n    }\n    \n    func description() -> String {\n        return \"Car with \\(numberOfWheels) wheels, max speed: \\(maxSpeed) km/h\"\n    }\n}\n```\n\n### Protocol Requirements:\n```swift\nprotocol FullyNamed {\n    var fullName: String { get }\n}\n\nprotocol Identifiable {\n    var id: String { get }\n    static var type: String { get }\n}\n\n// Protocol with method requirements\nprotocol Togglable {\n    mutating func toggle()\n}\n\n// Enum adopting a protocol\nenum OnOffSwitch: Togglable {\n    case on, off\n    \n    mutating func toggle() {\n        switch self {\n        case .on:\n            self = .off\n        case .off:\n            self = .on\n        }\n    }\n}\n```\n\n## 4. Protocol-Oriented Programming (60 min)\n\n### Protocol Extensions:\n```swift\n// Protocol with extension\nprotocol Describable {\n    var description: String { get }\n}\n\n// Protocol extension providing default implementation\nextension Describable {\n    var description: String {\n        return \"This is a \\(type(of: self))\"\n    }\n    \n    func detailedDescription() -> String {\n        return \"Detailed: \\(description)\"\n    }\n}\n\n// Adopting the protocol gets the default implementations\nstruct Product: Describable {\n    let name: String\n    // Gets default 'description' from protocol extension\n}\n\nlet product = Product(name: \"iPhone\")\nprint(product.description) // \"This is a Product\"\n```\n\n### Protocol Inheritance:\n```swift\n// Protocol inheritance\nprotocol Drawable {\n    func draw()\n}\n\nprotocol Colorable: Drawable {\n    var color: String { get set }\n    func fillColor()\n}\n\nprotocol Resizable: Drawable {\n    var size: Double { get set }\n    func resize(to scale: Double)\n}\n\n// Multiple protocol inheritance\nprotocol Shape: Colorable, Resizable {\n    var name: String { get }\n}\n\n// Concrete type adopting the protocol\nstruct Circle: Shape {\n    let name = \"Circle\"\n    var color: String = \"black\"\n    var size: Double = 1.0\n    \n    func draw() {\n        print(\"Drawing a \\(color) circle of size \\(size)\")\n    }\n    \n    func fillColor() {\n        print(\"Filling circle with \\(color) color\")\n    }\n    \n    func resize(to scale: Double) {\n        size *= scale\n        print(\"Circle resized to size: \\(size)\")\n    }\n}\n```\n\n### Protocol Composition:\n```swift\n// Protocol composition\nprotocol Named {\n    var name: String { get }\n}\n\nprotocol Aged {\n    var age: Int { get }\n}\n\n// Function accepting types that conform to multiple protocols\nfunc wishHappyBirthday(to celebrant: Named & Aged) {\n    print(\"Happy birthday \\(celebrant.name), you're \\(celebrant.age)!\")\n}\n\nstruct Person: Named, Aged {\n    var name: String\n    var age: Int\n}\n\nlet birthdayPerson = Person(name: \"Alice\", age: 25)\nwishHappyBirthday(to: birthdayPerson)\n```\n\n## 5. Advanced Enum & Protocol Patterns (45 min)\n\n### Recursive Enums:\n```swift\n// Recursive enum with indirect keyword\nindirect enum ArithmeticExpression {\n    case number(Int)\n    case addition(ArithmeticExpression, ArithmeticExpression)\n    case multiplication(ArithmeticExpression, ArithmeticExpression)\n}\n\n// Building complex expressions\nlet five = ArithmeticExpression.number(5)\nlet four = ArithmeticExpression.number(4)\nlet sum = ArithmeticExpression.addition(five, four)\nlet product = ArithmeticExpression.multiplication(sum, ArithmeticExpression.number(2))\n```\n\n### Associated Values with Protocols:\n```swift\nprotocol PaymentMethod {\n    var amount: Double { get }\n    func processPayment() -> Bool\n}\n\nenum Payment {\n    case creditCard(number: String, expiry: String, cvv: String)\n    case paypal(email: String)\n    case applePay\n    case cash\n    \n    func process() -> Bool {\n        switch self {\n        case .creditCard(let number, let expiry, let cvv):\n            return validateCreditCard(number: number, expiry: expiry, cvv: cvv)\n        case .paypal(let email):\n            return processPaypal(email: email)\n        case .applePay:\n            return processApplePay()\n        case .cash:\n            return true\n        }\n    }\n    \n    private func validateCreditCard(number: String, expiry: String, cvv: String) -> Bool {\n        // Validation logic\n        return !number.isEmpty && !expiry.isEmpty && !cvv.isEmpty\n    }\n    \n    private func processPaypal(email: String) -> Bool {\n        return email.contains(\"@\")\n    }\n    \n    private func processApplePay() -> Bool {\n        return true\n    }\n}\n```\n\n### Protocol with Associated Types:\n```swift\n// Protocol with associated type\nprotocol Container {\n    associatedtype Item\n    var count: Int { get }\n    mutating func append(_ item: Item)\n    subscript(i: Int) -> Item { get }\n}\n\n// Generic struct adopting the protocol\nstruct Stack<Element>: Container {\n    private var items: [Element] = []\n    \n    var count: Int {\n        return items.count\n    }\n    \n    mutating func append(_ item: Element) {\n        items.append(item)\n    }\n    \n    subscript(i: Int) -> Element {\n        return items[i]\n    }\n}\n\n// Usage\nvar stringStack = Stack<String>()\nstringStack.append(\"Hello\")\nstringStack.append(\"World\")\nprint(stringStack[0]) // \"Hello\"\n```\n\n## 6. Real-World Applications (45 min)\n\n### State Management with Enums:\n```swift\n// App state management\nenum AppState {\n    case launching\n    case authenticated(user: User)\n    case unauthenticated\n    case loading\n    case error(message: String, retryAction: () -> Void)\n}\n\nclass AppStateManager {\n    var currentState: AppState = .launching {\n        didSet {\n            handleStateChange()\n        }\n    }\n    \n    private func handleStateChange() {\n        switch currentState {\n        case .launching:\n            showLaunchScreen()\n        case .authenticated(let user):\n            showMainInterface(for: user)\n        case .unauthenticated:\n            showLoginScreen()\n        case .loading:\n            showLoadingIndicator()\n        case .error(let message, let retryAction):\n            showError(message: message, retryAction: retryAction)\n        }\n    }\n}\n```\n\n### Protocol-Oriented Networking:\n```swift\n// Networking with protocols\nprotocol APIEndpoint {\n    var baseURL: String { get }\n    var path: String { get }\n    var method: String { get }\n    var parameters: [String: Any]? { get }\n}\n\nprotocol NetworkService {\n    func request<T: Decodable>(_ endpoint: APIEndpoint, completion: @escaping (Result<T, Error>) -> Void)\n}\n\n// Concrete implementation\nclass URLSessionNetworkService: NetworkService {\n    func request<T: Decodable>(_ endpoint: APIEndpoint, completion: @escaping (Result<T, Error>) -> Void) {\n        // Implementation using URLSession\n    }\n}\n```\n\n### Best Practices:\n- Use enums for finite states and choices\n- Prefer protocol composition over inheritance\n- Use protocol extensions for default implementations\n- Leverage associated values for flexible data modeling\n- Use recursive enums for tree-like structures\n\n## Practice Exercises\n\nComplete all exercises to master enums with associated values and protocol-oriented programming!",
      "codeExample": "// === ENUM EXAMPLES ===\n\n// Basic enum with raw values\nenum TrafficLight: String {\n    case red = \"Stop\"\n    case yellow = \"Caution\"\n    case green = \"Go\"\n}\n\nlet light = TrafficLight.red\nprint(light.rawValue) // \"Stop\"\n\n// Enum with associated values\nenum Measurement {\n    case distance(Double)\n    case temperature(celsius: Double)\n    case weight(kilograms: Double)\n    case speed(kilometersPerHour: Double)\n}\n\nlet myMeasurement = Measurement.temperature(celsius: 23.5)\n\nswitch myMeasurement {\ncase .temperature(let celsius):\n    print(\"Temperature is \\(celsius)Â°C\")\n    let fahrenheit = (celsius * 9/5) + 32\n    print(\"That's \\(fahrenheit)Â°F\")\ncase .distance(let meters):\n    print(\"Distance: \\(meters) meters\")\ncase .weight(let kg):\n    print(\"Weight: \\(kg) kg\")\ncase .speed(let kmh):\n    print(\"Speed: \\(kmh) km/h\")\n}\n\n// Enum with methods\nenum MathOperation {\n    case add(Double, Double)\n    case subtract(Double, Double)\n    case multiply(Double, Double)\n    case divide(Double, Double)\n    \n    func calculate() -> Double {\n        switch self {\n        case .add(let a, let b):\n            return a + b\n        case .subtract(let a, let b):\n            return a - b\n        case .multiply(let a, let b):\n            return a * b\n        case .divide(let a, let b):\n            return b != 0 ? a / b : 0\n        }\n    }\n    \n    var symbol: String {\n        switch self {\n        case .add: return \"+\"\n        case .subtract: return \"-\"\n        case .multiply: return \"Ã—\"\n        case .divide: return \"Ã·\"\n        }\n    }\n}\n\nlet operation = MathOperation.add(10, 5)\nprint(\"\\(operation.symbol) operation result: \\(operation.calculate())\") // \"+ operation result: 15.0\"\n\n// === PROTOCOL EXAMPLES ===\n\n// Basic protocol\nprotocol SoundMaker {\n    var volume: Int { get set }\n    func makeSound() -> String\n}\n\n// Protocol extension with default implementation\nextension SoundMaker {\n    func makeSound() -> String {\n        return \"Some generic sound at volume \\(volume)\"\n    }\n}\n\n// Adopting the protocol\nstruct Dog: SoundMaker {\n    var volume: Int = 10\n    \n    func makeSound() -> String {\n        return \"Woof! \\(volume > 5 ? \"LOUD \" : \"\")bark!\"\n    }\n}\n\nstruct Car: SoundMaker {\n    var volume: Int = 7\n    // Uses default makeSound() from protocol extension\n}\n\nlet myDog = Dog(volume: 8)\nlet myCar = Car(volume: 5)\n\nprint(myDog.makeSound()) // \"Woof! LOUD bark!\"\nprint(myCar.makeSound()) // \"Some generic sound at volume 5\"\n\n// Protocol composition\nprotocol Flyable {\n    var maxAltitude: Double { get }\n    func fly()\n}\n\nprotocol Swimmable {\n    var maxDepth: Double { get }\n    func swim()\n}\n\n// Type that conforms to multiple protocols\nstruct Duck: Flyable, Swimmable {\n    let maxAltitude: Double = 1000.0\n    let maxDepth: Double = 5.0\n    \n    func fly() {\n        print(\"Duck flying up to \\(maxAltitude) meters\")\n    }\n    \n    func swim() {\n        print(\"Duck swimming down to \\(maxDepth) meters\")\n    }\n}\n\n// Function that requires protocol composition\nfunc describeAmphibiousCreature(_ creature: Flyable & Swimmable) {\n    print(\"This creature can fly up to \\(creature.maxAltitude)m and swim down to \\(creature.maxDepth)m\")\n    creature.fly()\n    creature.swim()\n}\n\nlet donald = Duck()\ndescribeAmphibiousCreature(donald)\n\n// === ADVANCED PATTERNS ===\n\n// Recursive enum for mathematical expressions\nindirect enum Expression {\n    case number(Double)\n    case add(Expression, Expression)\n    case multiply(Expression, Expression)\n    case power(base: Expression, exponent: Expression)\n    \n    func evaluate() -> Double {\n        switch self {\n        case .number(let value):\n            return value\n        case .add(let left, let right):\n            return left.evaluate() + right.evaluate()\n        case .multiply(let left, let right):\n            return left.evaluate() * right.evaluate()\n        case .power(let base, let exponent):\n            return pow(base.evaluate(), exponent.evaluate())\n        }\n    }\n}\n\n// Build expression: (2 + 3) * 4^2\nlet expr = Expression.multiply(\n    Expression.add(.number(2), .number(3)),\n    Expression.power(base: .number(4), exponent: .number(2))\n)\nprint(\"Expression result: \\(expr.evaluate())\") // (2+3) * 4^2 = 5 * 16 = 80\n\n// Protocol with associated type\nprotocol Queue {\n    associatedtype Element\n    var isEmpty: Bool { get }\n    var count: Int { get }\n    mutating func enqueue(_ element: Element)\n    mutating func dequeue() -> Element?\n    func peek() -> Element?\n}\n\n// Generic queue implementing the protocol\nstruct GenericQueue<T>: Queue {\n    private var elements: [T] = []\n    \n    var isEmpty: Bool {\n        return elements.isEmpty\n    }\n    \n    var count: Int {\n        return elements.count\n    }\n    \n    mutating func enqueue(_ element: T) {\n        elements.append(element)\n    }\n    \n    mutating func dequeue() -> T? {\n        return isEmpty ? nil : elements.removeFirst()\n    }\n    \n    func peek() -> T? {\n        return elements.first\n    }\n}\n\n// Usage\nvar stringQueue = GenericQueue<String>()\nstringQueue.enqueue(\"First\")\nstringQueue.enqueue(\"Second\")\nstringQueue.enqueue(\"Third\")\n\nprint(stringQueue.dequeue() ?? \"None\") // \"First\"\nprint(stringQueue.peek() ?? \"None\")    // \"Second\"",
      "category": "Swift Basics",
      "estimatedTime": 180,
      "dependencies": ["structs_classes", "functions"],
      "challenge": {
        "instructions": "Create a complete authentication system using enums with associated values and protocol-oriented programming:\n\nPART 1: Authentication State Enum (45 min)\n1. Create an 'AuthState' enum with cases: authenticated, unauthenticated, loading, error\n2. Add associated values: user & token for authenticated, Error for error case\n3. Implement methods: isLoggedIn, currentUser, errorMessage\n4. Add a mutating method to handle login/logout transitions\n\nPART 2: Authentication Protocol (45 min)\n5. Create an 'Authenticatable' protocol with requirements: username, email, password\n6. Create a 'User' struct implementing Authenticatable\n7. Add protocol extensions for validation methods\n8. Create a 'Validatable' protocol for input validation\n\nPART 3: Authentication Service (45 min)\n9. Create an 'AuthService' protocol with async methods: login, logout, register\n10. Implement a mock 'MockAuthService' class for testing\n11. Use enums with associated values for service responses\n12. Handle different error types with associated values\n\nPART 4: Advanced Protocol Composition (45 min)\n13. Create protocols for different auth providers: EmailAuth, SocialAuth, BiometricAuth\n14. Implement protocol composition for multi-provider authentication\n15. Use associated types in protocols for flexible return types\n16. Create a protocol extension with default implementations\n\nTest your implementation with various authentication scenarios and error cases!",
        "starterCode": "// === PART 1: AuthState Enum ===\n// Create your AuthState enum with associated values here\n\n\n// === PART 2: Authentication Protocol ===\n// Create Authenticatable protocol and User struct here\n\n\n// === PART 3: Authentication Service ===\n// Create AuthService protocol and MockAuthService here\n\n\n// === PART 4: Advanced Protocol Composition ===\n// Create provider protocols and composition here\n\n",
        "solution": "// === PART 1: AuthState Enum ===\nenum AuthState {\n    case authenticated(user: User, token: String)\n    case unauthenticated\n    case loading(message: String)\n    case error(AuthError)\n    \n    // Computed properties\n    var isLoggedIn: Bool {\n        switch self {\n        case .authenticated:\n            return true\n        default:\n            return false\n        }\n    }\n    \n    var currentUser: User? {\n        switch self {\n        case .authenticated(let user, _):\n            return user\n        default:\n            return nil\n        }\n    }\n    \n    var errorMessage: String? {\n        switch self {\n        case .error(let error):\n            return error.localizedDescription\n        default:\n            return nil\n        }\n    }\n    \n    // Mutating methods for state transitions\n    mutating func login(user: User, token: String) {\n        self = .authenticated(user: user, token: token)\n    }\n    \n    mutating func logout() {\n        self = .unauthenticated\n    }\n    \n    mutating func setLoading(_ message: String) {\n        self = .loading(message: message)\n    }\n    \n    mutating func setError(_ error: AuthError) {\n        self = .error(error)\n    }\n}\n\n// Error enum with associated values\nenum AuthError: Error {\n    case invalidCredentials\n    case networkError(underlyingError: Error)\n    case validationFailed(field: String, reason: String)\n    case accountLocked(until: Date)\n    case unknownError(message: String)\n    \n    var localizedDescription: String {\n        switch self {\n        case .invalidCredentials:\n            return \"Invalid username or password\"\n        case .networkError(let underlyingError):\n            return \"Network error: \\(underlyingError.localizedDescription)\"\n        case .validationFailed(let field, let reason):\n            return \"\\(field) validation failed: \\(reason)\"\n        case .accountLocked(let until):\n            let formatter = DateFormatter()\n            formatter.dateFormat = \"HH:mm\"\n            return \"Account locked until \\(formatter.string(from: until))\"\n        case .unknownError(let message):\n            return \"Unknown error: \\(message)\"\n        }\n    }\n}\n\n// === PART 2: Authentication Protocol ===\nprotocol Authenticatable {\n    var username: String { get }\n    var email: String { get }\n    var password: String { get }\n}\n\nprotocol Validatable {\n    func validate() throws\n}\n\n// Protocol extension with default implementations\nextension Authenticatable {\n    var isValidEmail: Bool {\n        let emailRegex = \"[A-Z0-9a-z._%+-]+@[A-Za-z0-9.-]+\\\\.[A-Za-z]{2,}\"\n        return NSPredicate(format: \"SELF MATCHES %@\", emailRegex).evaluate(with: email)\n    }\n    \n    var isValidUsername: Bool {\n        return username.count >= 3 && username.count <= 20\n    }\n    \n    var isValidPassword: Bool {\n        return password.count >= 8\n    }\n}\n\n// User struct implementing protocols\nstruct User: Authenticatable, Validatable {\n    let username: String\n    let email: String\n    let password: String\n    let id: String\n    let createdAt: Date\n    \n    init(username: String, email: String, password: String) throws {\n        self.username = username\n        self.email = email\n        self.password = password\n        self.id = UUID().uuidString\n        self.createdAt = Date()\n        \n        try validate()\n    }\n    \n    func validate() throws {\n        if !isValidUsername {\n            throw AuthError.validationFailed(field: \"username\", reason: \"Must be 3-20 characters\")\n        }\n        \n        if !isValidEmail {\n            throw AuthError.validationFailed(field: \"email\", reason: \"Invalid email format\")\n        }\n        \n        if !isValidPassword {\n            throw AuthError.validationFailed(field: \"password\", reason: \"Must be at least 8 characters\")\n        }\n    }\n}\n\n// === PART 3: Authentication Service ===\n// Result enum with associated values\nenum AuthResult {\n    case success(user: User, token: String)\n    case failure(AuthError)\n    case loading(progress: Double)\n}\n\nprotocol AuthService {\n    func login(username: String, password: String) async -> AuthResult\n    func logout() async -> Bool\n    func register(user: User) async -> AuthResult\n}\n\nclass MockAuthService: AuthService {\n    private var currentState: AuthState = .unauthenticated\n    \n    func login(username: String, password: String) async -> AuthResult {\n        // Simulate network delay\n        await Task.sleep(1_000_000_000) // 1 second\n        \n        // Mock validation\n        if username == \"admin\" && password == \"password\" {\n            do {\n                let user = try User(username: username, email: \"admin@example.com\", password: password)\n                let token = \"mock-jwt-token-\\(UUID().uuidString)\"\n                return .success(user: user, token: token)\n            } catch {\n                return .failure(error as? AuthError ?? .unknownError(message: error.localizedDescription))\n            }\n        } else {\n            return .failure(.invalidCredentials)\n        }\n    }\n    \n    func logout() async -> Bool {\n        await Task.sleep(500_000_000) // 0.5 second\n        currentState = .unauthenticated\n        return true\n    }\n    \n    func register(user: User) async -> AuthResult {\n        await Task.sleep(1_500_000_000) // 1.5 seconds\n        \n        do {\n            try user.validate()\n            let token = \"mock-jwt-token-\\(UUID().uuidString)\"\n            return .success(user: user, token: token)\n        } catch {\n            return .failure(error as? AuthError ?? .unknownError(message: error.localizedDescription))\n        }\n    }\n}\n\n// === PART 4: Advanced Protocol Composition ===\n// Provider protocols\nprotocol EmailAuth {\n    func loginWithEmail(_ email: String, password: String) async -> AuthResult\n}\n\nprotocol SocialAuth {\n    func loginWithSocialProvider(_ provider: SocialProvider) async -> AuthResult\n}\n\nprotocol BiometricAuth {\n    func loginWithBiometrics() async -> AuthResult\n}\n\n// Social provider enum\nenum SocialProvider {\n    case google\n    case facebook\n    case apple\n    case github\n    \n    var name: String {\n        switch self {\n        case .google: return \"Google\"\n        case .facebook: return \"Facebook\"\n        case .apple: return \"Apple\"\n        case .github: return \"GitHub\"\n        }\n    }\n}\n\n// Protocol composition for multi-provider auth\nprotocol MultiProviderAuth: EmailAuth, SocialAuth, BiometricAuth {\n    var availableProviders: [SocialProvider] { get }\n    func switchProvider(_ provider: SocialProvider)\n}\n\n// Protocol with associated type\nprotocol AuthResponse {\n    associatedtype UserType: Authenticatable\n    func getUser() -> UserType?\n    func getToken() -> String?\n}\n\n// Concrete implementation\nstruct TypedAuthResponse<UserType: Authenticatable>: AuthResponse {\n    let user: UserType?\n    let token: String?\n    \n    func getUser() -> UserType? {\n        return user\n    }\n    \n    func getToken() -> String? {\n        return token\n    }\n}\n\n// Complete auth manager using all patterns\nclass AuthManager: MultiProviderAuth {\n    private var authService: AuthService\n    private(set) var currentState: AuthState = .unauthenticated\n    private(set) var availableProviders: [SocialProvider] = [.google, .apple, .github]\n    \n    init(authService: AuthService = MockAuthService()) {\n        self.authService = authService\n    }\n    \n    // EmailAuth implementation\n    func loginWithEmail(_ email: String, password: String) async -> AuthResult {\n        currentState.setLoading(\"Logging in with email...\")\n        return await authService.login(username: email, password: password)\n    }\n    \n    // SocialAuth implementation\n    func loginWithSocialProvider(_ provider: SocialProvider) async -> AuthResult {\n        currentState.setLoading(\"Logging in with \\(provider.name)...\")\n        \n        await Task.sleep(2_000_000_000) // 2 seconds\n        \n        // Mock social login\n        do {\n            let user = try User(username: \"social_user\", email: \"user@example.com\", password: \"social\")\n            let token = \"social-token-\\(provider.name.lowercased())-\\(UUID().uuidString)\"\n            return .success(user: user, token: token)\n        } catch {\n            return .failure(error as? AuthError ?? .unknownError(message: error.localizedDescription))\n        }\n    }\n    \n    // BiometricAuth implementation\n    func loginWithBiometrics() async -> AuthResult {\n        currentState.setLoading(\"Authenticating with biometrics...\")\n        \n        await Task.sleep(1_000_000_000) // 1 second\n        \n        // Mock biometric auth (80% success rate)\n        if Bool.random() {\n            do {\n                let user = try User(username: \"biometric_user\", email: \"bio@example.com\", password: \"bio\")\n                let token = \"bio-token-\\(UUID().uuidString)\"\n                return .success(user: user, token: token)\n            } catch {\n                return .failure(error as? AuthError ?? .unknownError(message: error.localizedDescription))\n            }\n        } else {\n            return .failure(.unknownError(message: \"Biometric authentication failed\"))\n        }\n    }\n    \n    func switchProvider(_ provider: SocialProvider) {\n        print(\"Switched to \\(provider.name) provider\")\n    }\n    \n    // Update state based on auth result\n    func handleAuthResult(_ result: AuthResult) {\n        switch result {\n        case .success(let user, let token):\n            currentState.login(user: user, token: token)\n            print(\"Login successful for user: \\(user.username)\")\n        case .failure(let error):\n            currentState.setError(error)\n            print(\"Login failed: \\(error.localizedDescription)\")\n        case .loading(let progress):\n            currentState.setLoading(\"Loading... \\(Int(progress * 100))%\")\n        }\n    }\n}\n\n// Usage example\nfunc demonstrateAuthSystem() async {\n    let authManager = AuthManager()\n    \n    // Test email login\n    let emailResult = await authManager.loginWithEmail(\"admin\", password: \"password\")\n    authManager.handleAuthResult(emailResult)\n    \n    // Test social login\n    let socialResult = await authManager.loginWithSocialProvider(.google)\n    authManager.handleAuthResult(socialResult)\n    \n    // Test biometric login\n    let bioResult = await authManager.loginWithBiometrics()\n    authManager.handleAuthResult(bioResult)\n}\n\n// Run the demonstration\n// await demonstrateAuthSystem()",
        "hints": [
          "PART 1: Use associated values in enums to carry additional data. Mutating methods change enum cases",
          "PART 2: Protocol extensions can provide default implementations. Use throws for validation that can fail",
          "PART 3: Async/await works well with auth services. Use Task.sleep for mock delays",
          "PART 4: Protocol composition uses 'ProtocolA & ProtocolB'. Associated types make protocols generic",
          "Remember: enums are great for representing finite states like authentication flow",
          "Use protocol-oriented programming to create flexible, testable authentication systems",
          "Associated values in enums can carry different types of data for different cases",
          "Protocol extensions allow you to add functionality to existing protocols without modifying conforming types"
        ],
        "testCases": [
          {
            "input": "AuthState.authenticated(user: User(), token: \"test\").isLoggedIn",
            "expectedOutput": "true",
            "description": "Authenticated state should return true for isLoggedIn"
          },
          {
            "input": "AuthState.unauthenticated.isLoggedIn",
            "expectedOutput": "false",
            "description": "Unauthenticated state should return false for isLoggedIn"
          },
          {
            "input": "User(username: \"test\", email: \"test@test.com\", password: \"password\").isValidEmail",
            "expectedOutput": "true",
            "description": "Valid email should pass validation"
          }
        ]
      }
    },
    {
      "id": "error_handling",
      "title": "Error Handling",
      "description": "Master do-try-catch and throwing functions to write robust Swift code that handles failures gracefully",
      "difficulty": "beginner",
      "theory": "# Error Handling - Writing Robust Swift Code\n\n## 1. Understanding Errors (30 min)\n\n### What are Errors?\n- **Unexpected events** that occur during program execution\n- **Not the same as bugs** - bugs should be fixed, errors should be handled\n- Examples: Network failure, file not found, invalid input\n\n### Why Handle Errors?\n- **Prevent crashes** and unexpected behavior\n- **Provide better user experience** with helpful messages\n- **Make code more predictable** and maintainable\n\n### Real-world Analogy:\n- **No Error Handling**: Driving without brakes - crash when something goes wrong\n- **With Error Handling**: Driving with brakes and airbags - safe even when problems occur\n\n## 2. Defining Custom Errors (30 min)\n\n### Using Enums with Error Protocol:\n```swift\nenum NetworkError: Error {\n    case invalidURL\n    case noInternetConnection\n    case serverError(statusCode: Int)\n    case timeout\n}\n\nenum ValidationError: Error {\n    case emptyField\n    case invalidEmail\n    case passwordTooShort\n    case ageRestriction\n}\n```\n\n### Error Properties:\n```swift\nenum FileError: Error {\n    case fileNotFound(path: String)\n    case permissionDenied\n    case diskFull\n    \n    var description: String {\n        switch self {\n        case .fileNotFound(let path):\n            return \"File not found at path: \\(path)\"\n        case .permissionDenied:\n            return \"Permission denied to access file\"\n        case .diskFull:\n            return \"Disk is full\"\n        }\n    }\n}\n```\n\n## 3. Throwing Functions (45 min)\n\n### Creating Throwing Functions:\n```swift\nfunc divide(_ numerator: Double, by denominator: Double) throws -> Double {\n    if denominator == 0 {\n        throw DivisionError.divisionByZero\n    }\n    return numerator / denominator\n}\n\nfunc validateEmail(_ email: String) throws {\n    guard !email.isEmpty else {\n        throw ValidationError.emptyField\n    }\n    \n    guard email.contains(\"@\") && email.contains(\".\") else {\n        throw ValidationError.invalidEmail\n    }\n}\n```\n\n### Throwing Initializers:\n```swift\nstruct User {\n    let username: String\n    let email: String\n    \n    init(username: String, email: String) throws {\n        guard !username.isEmpty else {\n            throw ValidationError.emptyField\n        }\n        \n        guard email.contains(\"@\") else {\n            throw ValidationError.invalidEmail\n        }\n        \n        self.username = username\n        self.email = email\n    }\n}\n```\n\n## 4. Handling Errors with do-try-catch (45 min)\n\n### Basic do-try-catch:\n```swift\ndo {\n    let result = try divide(10, by: 2)\n    print(\"Result: \\(result)\")\n} catch {\n    print(\"An error occurred: \\(error)\")\n}\n```\n\n### Catching Specific Errors:\n```swift\ndo {\n    try validateEmail(\"user@example.com\")\n    print(\"Email is valid!\")\n} catch ValidationError.emptyField {\n    print(\"Please enter an email address\")\n} catch ValidationError.invalidEmail {\n    print(\"Please enter a valid email address\")\n} catch {\n    print(\"Unexpected error: \\(error)\")\n}\n```\n\n### Pattern Matching in Catch:\n```swift\ndo {\n    let user = try User(username: \"\", email: \"test@example.com\")\n} catch let error as ValidationError {\n    switch error {\n    case .emptyField:\n        print(\"Field cannot be empty\")\n    case .invalidEmail:\n        print(\"Invalid email format\")\n    case .passwordTooShort, .ageRestriction:\n        print(\"Validation failed\")\n    }\n}\n```\n\n## 5. Alternative Error Handling Methods (30 min)\n\n### try? - Converting to Optional:\n```swift\n// Returns nil if error occurs\nif let result = try? divide(10, by: 2) {\n    print(\"Division successful: \\(result)\")\n} else {\n    print(\"Division failed\")\n}\n```\n\n### try! - Force Try (Use Sparingly):\n```swift\n// Crashes if error occurs - only when 100% sure no error will happen\nlet result = try! divide(10, by: 2)  // Only if denominator is never zero\n```\n\n### Optional Try in Guard Statements:\n```swift\nfunc processUserInput(email: String) {\n    guard let _ = try? validateEmail(email) else {\n        print(\"Invalid email provided\")\n        return\n    }\n    print(\"Email validation passed\")\n}\n```\n\n## 6. Practical Error Handling Patterns (45 min)\n\n### Network Request Example:\n```swift\nenum APIError: Error {\n    case invalidResponse\n    case httpError(code: Int)\n    case decodingError\n    case networkUnavailable\n}\n\nfunc fetchUserData(from urlString: String) throws -> User {\n    guard let url = URL(string: urlString) else {\n        throw APIError.invalidResponse\n    }\n    \n    // Simulate network request\n    let data = Data() // Would come from actual network call\n    \n    guard !data.isEmpty else {\n        throw APIError.networkUnavailable\n    }\n    \n    // Would decode JSON here\n    return User(username: \"test\", email: \"test@example.com\")\n}\n```\n\n### File Operations:\n```swift\nfunc readFile(at path: String) throws -> String {\n    // Simulate file reading\n    let fileExists = Bool.random() // Simulate file existence check\n    \n    if !fileExists {\n        throw FileError.fileNotFound(path: path)\n    }\n    \n    return \"File contents\"\n}\n```\n\n### Chaining Throwing Functions:\n```swift\nfunc processUserRegistration(username: String, email: String, password: String) throws -> User {\n    try validateUsername(username)\n    try validateEmail(email)\n    try validatePassword(password)\n    \n    return try User(username: username, email: email)\n}\n```\n\n## 7. Best Practices & Common Pitfalls (30 min)\n\n### Do's and Don'ts:\n- **DO** provide meaningful error messages\n- **DO** handle errors at the appropriate level\n- **DON'T** use empty catch blocks that ignore errors\n- **DON'T** overuse try! - it can crash your app\n\n### Error Propagation:\n```swift\nfunc uploadUserData(_ user: User) throws {\n    // If any step fails, error propagates up\n    try validateUserData(user)\n    try prepareForUpload(user)\n    try performUpload(user)\n}\n\n// Caller handles all possible errors\nfunc completeRegistration(user: User) {\n    do {\n        try uploadUserData(user)\n        print(\"Registration complete!\")\n    } catch {\n        print(\"Registration failed: \\(error)\")\n    }\n}\n```\n\n### Creating User-friendly Error Messages:\n```swift\nextension ValidationError: LocalizedError {\n    var errorDescription: String? {\n        switch self {\n        case .emptyField:\n            return \"This field cannot be empty\"\n        case .invalidEmail:\n            return \"Please enter a valid email address\"\n        case .passwordTooShort:\n            return \"Password must be at least 8 characters\"\n        case .ageRestriction:\n            return \"You must be 13 years or older to register\"\n        }\n    }\n}\n```\n\n## Practice Exercises\n\nComplete all exercises to master error handling in Swift!",
      "codeExample": "// === DEFINING CUSTOM ERRORS ===\n\n// Network-related errors\nenum NetworkError: Error {\n    case invalidURL\n    case noInternetConnection\n    case requestTimeout\n    case serverError(code: Int)\n    case parsingFailed\n}\n\n// User input validation errors\nenum ValidationError: Error {\n    case emptyField(fieldName: String)\n    case invalidFormat(fieldName: String)\n    case tooShort(fieldName: String, minLength: Int)\n    case valueTooLow(fieldName: String, minValue: Int)\n    case valueTooHigh(fieldName: String, maxValue: Int)\n}\n\n// File operation errors\nenum FileSystemError: Error {\n    case fileNotFound(path: String)\n    case permissionDenied\n    case diskFull\n    case invalidFileFormat\n}\n\n// === THROWING FUNCTIONS ===\n\n// Function that validates user age\nfunc validateAge(_ age: Int) throws {\n    guard age >= 0 else {\n        throw ValidationError.valueTooLow(fieldName: \"age\", minValue: 0)\n    }\n    \n    guard age <= 150 else {\n        throw ValidationError.valueTooHigh(fieldName: \"age\", maxValue: 150)\n    }\n    \n    guard age >= 13 else {\n        throw ValidationError.valueTooLow(fieldName: \"age\", minValue: 13)\n    }\n    \n    print(\"Age validation passed: \\(age)\")\n}\n\n// Function that processes user registration\nfunc registerUser(name: String, email: String, age: Int, password: String) throws -> String {\n    // Validate name\n    guard !name.isEmpty else {\n        throw ValidationError.emptyField(fieldName: \"name\")\n    }\n    \n    guard name.count >= 2 else {\n        throw ValidationError.tooShort(fieldName: \"name\", minLength: 2)\n    }\n    \n    // Validate email\n    guard !email.isEmpty else {\n        throw ValidationError.emptyField(fieldName: \"email\")\n    }\n    \n    guard email.contains(\"@\") && email.contains(\".\") else {\n        throw ValidationError.invalidFormat(fieldName: \"email\")\n    }\n    \n    // Validate age\n    try validateAge(age)\n    \n    // Validate password\n    guard !password.isEmpty else {\n        throw ValidationError.emptyField(fieldName: \"password\")\n    }\n    \n    guard password.count >= 8 else {\n        throw ValidationError.tooShort(fieldName: \"password\", minLength: 8)\n    }\n    \n    return \"User '\\(name)' registered successfully!\"\n}\n\n// Function that simulates network request\nfunc fetchData(from urlString: String) throws -> String {\n    guard let url = URL(string: urlString) else {\n        throw NetworkError.invalidURL\n    }\n    \n    // Simulate network conditions\n    let hasInternet = Bool.random()\n    guard hasInternet else {\n        throw NetworkError.noInternetConnection\n    }\n    \n    // Simulate server response\n    let serverIsWorking = Bool.random()\n    guard serverIsWorking else {\n        throw NetworkError.serverError(code: 500)\n    }\n    \n    return \"Data from \\(urlString)\"\n}\n\n// === ERROR HANDLING EXAMPLES ===\n\n// Example 1: Basic do-try-catch\nprint(\"=== Example 1: Basic Error Handling ===\")\ndo {\n    try validateAge(25)\n    print(\"Age is valid!\")\n} catch {\n    print(\"Error: \\(error)\")\n}\n\n// Example 2: Catching specific errors\nprint(\"\\n=== Example 2: Specific Error Handling ===\")\ndo {\n    try registerUser(name: \"\", email: \"test@example.com\", age: 30, password: \"secure123\")\n} catch ValidationError.emptyField(let fieldName) {\n    print(\"Please fill in the \\(fieldName) field\")\n} catch ValidationError.tooShort(let fieldName, let minLength) {\n    print(\"\\(fieldName) must be at least \\(minLength) characters\")\n} catch {\n    print(\"Registration failed: \\(error)\")\n}\n\n// Example 3: Using try? (optional try)\nprint(\"\\n=== Example 3: Optional Try ===\")\nif let data = try? fetchData(from: \"https://api.example.com/data\") {\n    print(\"Success: \\(data)\")\n} else {\n    print(\"Failed to fetch data\")\n}\n\n// Example 4: Multiple throwing operations\nprint(\"\\n=== Example 4: Multiple Operations ===\")\nfunc completeUserSetup() {\n    do {\n        try validateAge(20)\n        let result = try registerUser(name: \"Alice\", email: \"alice@example.com\", age: 20, password: \"password123\")\n        print(result)\n        \n        let data = try fetchData(from: \"https://api.example.com/user\")\n        print(\"Fetched: \\(data)\")\n        \n    } catch ValidationError.emptyField(let fieldName) {\n        print(\"Error: \\(fieldName) cannot be empty\")\n    } catch ValidationError.invalidFormat(let fieldName) {\n        print(\"Error: \\(fieldName) has invalid format\")\n    } catch let networkError as NetworkError {\n        print(\"Network error: \\(networkError)\")\n    } catch {\n        print(\"Unexpected error: \\(error)\")\n    }\n}\n\ncompleteUserSetup()\n\n// Example 5: Error propagation\nprint(\"\\n=== Example 5: Error Propagation ===\")\nfunc processUserData(name: String, email: String) throws -> String {\n    // Each of these can throw errors\n    try validateAge(25)\n    let registrationMessage = try registerUser(name: name, email: email, age: 25, password: \"test123\")\n    let data = try fetchData(from: \"https://api.example.com/users\")\n    \n    return \"\\(registrationMessage) Data: \\(data)\"\n}\n\n// Handle all propagated errors in one place\ndo {\n    let finalResult = try processUserData(name: \"Bob\", email: \"bob@example.com\")\n    print(\"Final result: \\(finalResult)\")\n} catch {\n    print(\"Process failed: \\(error)\")\n}\n\n// Example 6: Practical file operation simulation\nprint(\"\\n=== Example 6: File Operations ===\")\nfunc readConfigurationFile() throws -> String {\n    let fileExists = Bool.random()\n    \n    if !fileExists {\n        throw FileSystemError.fileNotFound(path: \"/config/app.json\")\n    }\n    \n    let diskHasSpace = Bool.random()\n    if !diskHasSpace {\n        throw FileSystemError.diskFull\n    }\n    \n    return \"Configuration data\"\n}\n\nfunc loadAppConfiguration() {\n    do {\n        let config = try readConfigurationFile()\n        print(\"Configuration loaded: \\(config)\")\n    } catch FileSystemError.fileNotFound(let path) {\n        print(\"Configuration file not found at: \\(path)\")\n    } catch FileSystemError.diskFull {\n        print(\"Disk is full. Please free up some space.\")\n    } catch {\n        print(\"Failed to load configuration: \\(error)\")\n    }\n}\n\nloadAppConfiguration()",
      "category": "Swift Basics",
      "estimatedTime": 120,
      "dependencies": ["functions", "enums"],
      "challenge": {
        "instructions": "Create a complete user registration system with comprehensive error handling:\n\nPART 1: Define Error Types (30 min)\n1. Create 'RegistrationError' enum with cases: invalidUsername, invalidEmail, weakPassword, ageRestriction, duplicateUser\n2. Create 'NetworkError' enum with cases: noConnection, serverDown, timeout, invalidResponse\n3. Add descriptive properties to each error case\n\nPART 2: Validation Functions (45 min)\n4. Create 'validateUsername()' that throws RegistrationError for: empty, too short, invalid characters\n5. Create 'validateEmail()' that throws for: empty, missing @, invalid format\n6. Create 'validatePassword()' that throws for: too short, no numbers, no uppercase\n7. Create 'validateAge()' that throws for: under 13, over 150\n\nPART 3: Registration System (45 min)\n8. Create 'registerUser()' function that calls all validations and throws appropriate errors\n9. Simulate network check with 'checkNetworkAvailability()' that throws NetworkError\n10. Simulate database check with 'checkDuplicateUser()' that throws duplicateUser error\n11. Create a main 'completeRegistration()' function that handles all errors gracefully\n\nPART 4: Advanced Error Handling (60 min)\n12. Add retry mechanism for network errors with maximum 3 attempts\n13. Create user-friendly error messages for each error case\n14. Implement different handling strategies for validation vs network errors\n15. Add logging for all errors while showing user-friendly messages\n\nTest your system with various valid and invalid inputs to ensure robust error handling!",
        "starterCode": "// === PART 1: Define Error Types ===\n// Create your error enums here\n\n\n// === PART 2: Validation Functions ===\n// Create validation functions here\n\n\n// === PART 3: Registration System ===\n// Create registration functions here\n\n\n// === PART 4: Advanced Error Handling ===\n// Add retry mechanism and error messaging here\n\n",
        "solution": "// === PART 1: Define Error Types ===\nenum RegistrationError: Error, CustomStringConvertible {\n    case invalidUsername(reason: String)\n    case invalidEmail\n    case weakPassword(strengthIssue: String)\n    case ageRestriction(minAge: Int)\n    case duplicateUser(username: String)\n    \n    var description: String {\n        switch self {\n        case .invalidUsername(let reason):\n            return \"Invalid username: \\(reason)\"\n        case .invalidEmail:\n            return \"Invalid email format\"\n        case .weakPassword(let issue):\n            return \"Weak password: \\(issue)\"\n        case .ageRestriction(let minAge):\n            return \"Must be at least \\(minAge) years old\"\n        case .duplicateUser(let username):\n            return \"Username '\\(username)' is already taken\"\n        }\n    }\n}\n\nenum NetworkError: Error, CustomStringConvertible {\n    case noConnection\n    case serverDown\n    case timeout\n    case invalidResponse\n    \n    var description: String {\n        switch self {\n        case .noConnection:\n            return \"No internet connection\"\n        case .serverDown:\n            return \"Server is temporarily unavailable\"\n        case .timeout:\n            return \"Request timed out\"\n        case .invalidResponse:\n            return \"Received invalid response from server\"\n        }\n    }\n}\n\n// === PART 2: Validation Functions ===\nfunc validateUsername(_ username: String) throws {\n    guard !username.isEmpty else {\n        throw RegistrationError.invalidUsername(reason: \"Username cannot be empty\")\n    }\n    \n    guard username.count >= 3 else {\n        throw RegistrationError.invalidUsername(reason: \"Username must be at least 3 characters\")\n    }\n    \n    guard username.count <= 20 else {\n        throw RegistrationError.invalidUsername(reason: \"Username cannot exceed 20 characters\")\n    }\n    \n    let invalidCharacters = CharacterSet.alphanumerics.inverted\n    guard username.rangeOfCharacter(from: invalidCharacters) == nil else {\n        throw RegistrationError.invalidUsername(reason: \"Username can only contain letters and numbers\")\n    }\n}\n\nfunc validateEmail(_ email: String) throws {\n    guard !email.isEmpty else {\n        throw RegistrationError.invalidEmail\n    }\n    \n    let emailRegex = \"[A-Z0-9a-z._%+-]+@[A-Za-z0-9.-]+\\\\.[A-Za-z]{2,}\"\n    let emailPredicate = NSPredicate(format: \"SELF MATCHES %@\", emailRegex)\n    \n    guard emailPredicate.evaluate(with: email) else {\n        throw RegistrationError.invalidEmail\n    }\n}\n\nfunc validatePassword(_ password: String) throws {\n    guard !password.isEmpty else {\n        throw RegistrationError.weakPassword(strengthIssue: \"Password cannot be empty\")\n    }\n    \n    guard password.count >= 8 else {\n        throw RegistrationError.weakPassword(strengthIssue: \"Password must be at least 8 characters\")\n    }\n    \n    let numberRegex = \".*[0-9].*\"\n    let numberPredicate = NSPredicate(format: \"SELF MATCHES %@\", numberRegex)\n    guard numberPredicate.evaluate(with: password) else {\n        throw RegistrationError.weakPassword(strengthIssue: \"Password must contain at least one number\")\n    }\n    \n    let uppercaseRegex = \".*[A-Z].*\"\n    let uppercasePredicate = NSPredicate(format: \"SELF MATCHES %@\", uppercaseRegex)\n    guard uppercasePredicate.evaluate(with: password) else {\n        throw RegistrationError.weakPassword(strengthIssue: \"Password must contain at least one uppercase letter\")\n    }\n}\n\nfunc validateAge(_ age: Int) throws {\n    guard age >= 13 else {\n        throw RegistrationError.ageRestriction(minAge: 13)\n    }\n    \n    guard age <= 150 else {\n        throw RegistrationError.invalidUsername(reason: \"Age must be 150 or less\")\n    }\n}\n\n// === PART 3: Registration System ===\nfunc checkNetworkAvailability() throws {\n    // Simulate network check\n    let isOnline = Bool.random()\n    if !isOnline {\n        throw NetworkError.noConnection\n    }\n    \n    let serverIsUp = Bool.random()\n    if !serverIsUp {\n        throw NetworkError.serverDown\n    }\n}\n\nfunc checkDuplicateUser(username: String) throws {\n    // Simulate database check\n    let existingUsers = [\"alice\", \"bob\", \"charlie\"]\n    if existingUsers.contains(username.lowercased()) {\n        throw RegistrationError.duplicateUser(username: username)\n    }\n}\n\nfunc registerUser(username: String, email: String, password: String, age: Int) throws -> String {\n    // Validate all inputs\n    try validateUsername(username)\n    try validateEmail(email)\n    try validatePassword(password)\n    try validateAge(age)\n    \n    // Check network\n    try checkNetworkAvailability()\n    \n    // Check for duplicates\n    try checkDuplicateUser(username: username)\n    \n    // Simulate successful registration\n    return \"User '\\(username)' registered successfully!\"\n}\n\n// === PART 4: Advanced Error Handling ===\nfunc completeRegistration(username: String, email: String, password: String, age: Int) {\n    print(\"Starting registration for: \\(username)\")\n    \n    let maxRetries = 3\n    var attempts = 0\n    \n    while attempts < maxRetries {\n        do {\n            attempts += 1\n            print(\"Attempt \\(attempts) of \\(maxRetries)\")\n            \n            let result = try registerUser(username: username, email: email, password: password, age: age)\n            print(\"âœ… SUCCESS: \\(result)\")\n            return\n            \n        } catch let error as RegistrationError {\n            // Validation errors - no retry needed\n            print(\"âŒ Registration Error: \\(error.description)\")\n            return\n            \n        } catch let error as NetworkError {\n            // Network errors - can retry\n            print(\"ðŸŒ Network Error: \\(error.description)\")\n            \n            if attempts >= maxRetries {\n                print(\"ðŸš« Maximum retry attempts reached. Please try again later.\")\n                return\n            } else {\n                print(\"ðŸ”„ Retrying in 2 seconds...\")\n                // In real app, you'd use proper async delay\n                Thread.sleep(forTimeInterval: 2.0)\n            }\n            \n        } catch {\n            // Unexpected errors\n            print(\"ðŸ’¥ Unexpected error: \\(error)\")\n            return\n        }\n    }\n}\n\n// User-friendly error handler\nfunc handleRegistrationError(_ error: Error) -> String {\n    if let registrationError = error as? RegistrationError {\n        switch registrationError {\n        case .invalidUsername(let reason):\n            return \"Please choose a different username. \\(reason)\"\n        case .invalidEmail:\n            return \"Please enter a valid email address\"\n        case .weakPassword(let issue):\n            return \"Please strengthen your password. \\(issue)\"\n        case .ageRestriction(let minAge):\n            return \"You must be at least \\(minAge) years old to register\"\n        case .duplicateUser(let username):\n            return \"The username '\\(username)' is already taken. Please choose another.\"\n        }\n    } else if let networkError = error as? NetworkError {\n        switch networkError {\n        case .noConnection:\n            return \"Please check your internet connection and try again\"\n        case .serverDown:\n            return \"Our servers are temporarily busy. Please try again in a few minutes\"\n        case .timeout:\n            return \"The request took too long. Please try again\"\n        case .invalidResponse:\n            return \"We encountered an issue. Please try again\"\n        }\n    } else {\n        return \"An unexpected error occurred. Please try again\"\n    }\n}\n\n// Test the system\nprint(\"=== TEST 1: Valid Registration ===\")\ncompleteRegistration(username: \"john_doe\", email: \"john@example.com\", password: \"Secure123\", age: 25)\n\nprint(\"\\n=== TEST 2: Invalid Username ===\")\ncompleteRegistration(username: \"ab\", email: \"test@example.com\", password: \"Secure123\", age: 25)\n\nprint(\"\\n=== TEST 3: Weak Password ===\")\ncompleteRegistration(username: \"jane_doe\", email: \"jane@example.com\", password: \"weak\", age: 30)\n\nprint(\"\\n=== TEST 4: Network Issues ===\")\ncompleteRegistration(username: \"test_user\", email: \"test@example.com\", password: \"Secure123\", age: 20)",
        "hints": [
          "PART 1: Use enums with Error protocol. Add CustomStringConvertible for user-friendly messages",
          "PART 2: Use guard statements to check conditions and throw errors when validation fails",
          "PART 3: Chain multiple throwing functions - if any fails, the entire operation fails",
          "PART 4: Use retry loops for recoverable errors (network), but not for validation errors",
          "Create separate error types for different categories (validation vs network)",
          "Use pattern matching in catch blocks to handle specific error cases",
          "Provide both technical logging and user-friendly error messages",
          "Remember: Validation errors should not be retried - they need user input correction"
        ],
        "testCases": [
          {
            "input": "try validateUsername(\"validUser123\")",
            "expectedOutput": "No error thrown",
            "description": "Valid username should pass validation"
          },
          {
            "input": "try validateUsername(\"ab\")",
            "expectedOutput": "RegistrationError.invalidUsername",
            "description": "Short username should throw error"
          },
          {
            "input": "try validatePassword(\"Weak1\")",
            "expectedOutput": "RegistrationError.weakPassword",
            "description": "Short password should throw error"
          },
          {
            "input": "try validateAge(12)",
            "expectedOutput": "RegistrationError.ageRestriction",
            "description": "Age under 13 should throw restriction error"
          }
        ]
      }
    },
    {
      "id": "swiftui_introduction",
      "title": "SwiftUI Introduction - Views, Modifiers & Previews",
      "description": "Build your first SwiftUI apps with declarative syntax, custom views, and live previews",
      "difficulty": "beginner",
      "theory": "# SwiftUI Introduction - Views, Modifiers & Previews\n\n## 1. What is SwiftUI? (45 min)\n\n### Declarative vs Imperative Programming\n- **Imperative**: Tell HOW to do things (UIKit)\n- **Declarative**: Tell WHAT you want (SwiftUI)\n\n### SwiftUI Benefits:\n- **Less code** - up to 70% reduction\n- **Live Preview** - see changes instantly\n- **Automatic support** for Dark Mode, Dynamic Type\n- **Native performance** across all Apple platforms\n\n### Basic Structure:\n```swift\nimport SwiftUI\n\nstruct ContentView: View {\n    var body: some View {\n        Text(\"Hello, SwiftUI!\")\n    }\n}\n```\n\n## 2. Your First Views (60 min)\n\n### Text Views:\n```swift\nText(\"Hello, World!\")\n    .font(.title)\n    .foregroundColor(.blue)\n```\n\n### Stack Containers:\n```swift\n// Vertical Stack\nVStack {\n    Text(\"First\")\n    Text(\"Second\")\n    Text(\"Third\")\n}\n\n// Horizontal Stack\nHStack {\n    Text(\"Left\")\n    Text(\"Right\")\n}\n\n// Overlapping Stack\nZStack {\n    Circle()\n        .fill(Color.blue)\n    Text(\"Center\")\n}\n```\n\n### Basic Shapes:\n```swift\nCircle()\n    .fill(Color.red)\n    .frame(width: 100, height: 100)\n\nRectangle()\n    .fill(Color.green)\n    .frame(width: 200, height: 100)\n\nRoundedRectangle(cornerRadius: 25)\n    .fill(Color.orange)\n    .frame(width: 150, height: 80)\n```\n\n## 3. Modifiers - Styling Your Views (60 min)\n\n### What are Modifiers?\n- Methods that return NEW views with modifications\n- Order matters!\n- Chain multiple modifiers together\n\n### Common Modifiers:\n```swift\nText(\"Styled Text\")\n    .font(.largeTitle)           // Font size\n    .fontWeight(.bold)           // Font weight\n    .foregroundColor(.white)     // Text color\n    .padding()                   // Add space around\n    .background(Color.blue)      // Background color\n    .cornerRadius(10)            // Rounded corners\n    .shadow(radius: 5)           // Drop shadow\n```\n\n### Order Matters Example:\n```swift\n// Different results based on order\nText(\"Order Matters\")\n    .padding()\n    .background(Color.blue)     // Blue background WITH padding\n\nText(\"Order Matters\")\n    .background(Color.blue)     // Blue background ONLY behind text\n    .padding()                  // Padding around blue background\n```\n\n### Frame Modifier:\n```swift\nText(\"Sized Text\")\n    .frame(width: 200, height: 100)        // Fixed size\n    .frame(maxWidth: .infinity)            // Flexible width\n    .frame(height: 50)                     // Fixed height only\n    .frame(maxWidth: .infinity, maxHeight: .infinity)  // Fill all space\n```\n\n## 4. Layout System (45 min)\n\n### SwiftUI Layout Process:\n1. **Parent proposes size** to child\n2. **Child chooses its size**\n3. **Parent places child** in coordinate space\n\n### Spacers and Alignment:\n```swift\nHStack {\n    Text(\"Left\")\n    Spacer()                    // Pushes views apart\n    Text(\"Right\")\n}\n\nVStack(alignment: .leading) {   // Align all children to leading edge\n    Text(\"First\")\n    Text(\"Second\")\n    Text(\"Third\")\n}\n```\n\n### Padding and Margins:\n```swift\nText(\"Padded Text\")\n    .padding()                          // Default padding (16pt)\n    .padding(20)                        // Custom padding\n    .padding(.horizontal, 10)           // Directional padding\n    .padding([.top, .bottom], 5)        // Multiple edges\n```\n\n## 5. Previews - Your Development Superpower (45 min)\n\n### Basic Preview:\n```swift\nstruct ContentView_Previews: PreviewProvider {\n    static var previews: some View {\n        ContentView()\n    }\n}\n```\n\n### Multiple Previews:\n```swift\nstruct ContentView_Previews: PreviewProvider {\n    static var previews: some View {\n        Group {\n            ContentView()\n                .previewDisplayName(\"Light Mode\")\n            \n            ContentView()\n                .preferredColorScheme(.dark)\n                .previewDisplayName(\"Dark Mode\")\n            \n            ContentView()\n                .previewDevice(\"iPhone SE (2nd generation)\")\n                .previewDisplayName(\"Small Screen\")\n        }\n    }\n}\n```\n\n### Preview Modifiers:\n```swift\nContentView()\n    .previewLayout(.sizeThatFits)    // Shows only content size\n    .previewLayout(.fixed(width: 400, height: 300))  // Fixed size\n    .environment(\\.sizeCategory, .accessibilityLarge)  // Large text\n    .environment(\\.locale, .init(identifier: \"es\"))    // Spanish locale\n```\n\n## 6. Building Custom Views (45 min)\n\n### View Composition:\n```swift\nstruct WelcomeHeader: View {\n    let username: String\n    \n    var body: some View {\n        VStack {\n            Image(systemName: \"person.circle.fill\")\n                .font(.system(size: 60))\n                .foregroundColor(.blue)\n            \n            Text(\"Welcome, \\(username)!\")\n                .font(.title2)\n                .fontWeight(.semibold)\n        }\n    }\n}\n\n// Usage\nWelcomeHeader(username: \"John\")\n```\n\n### Reusable Button Style:\n```swift\nstruct PrimaryButton: View {\n    let title: String\n    let action: () -> Void\n    \n    var body: some View {\n        Button(action: action) {\n            Text(title)\n                .fontWeight(.bold)\n                .foregroundColor(.white)\n                .padding()\n                .frame(maxWidth: .infinity)\n                .background(Color.blue)\n                .cornerRadius(10)\n        }\n    }\n}\n\n// Usage\nPrimaryButton(title: \"Tap Me!\") {\n    print(\"Button tapped!\")\n}\n```\n\n## 7. Working with Images (30 min)\n\n### System Icons (SF Symbols):\n```swift\nImage(systemName: \"heart.fill\")\n    .font(.title)\n    .foregroundColor(.red)\n\nImage(systemName: \"star\")\n    .imageScale(.large)\n    .foregroundColor(.yellow)\n```\n\n### Custom Images:\n```swift\nImage(\"myPhoto\")                    // From asset catalog\n    .resizable()                    // Make resizable\n    .scaledToFit()                  // Maintain aspect ratio\n    .frame(width: 200, height: 200)\n    .clipShape(Circle())            // Circular crop\n```\n\n### Image Modifiers:\n```swift\nImage(\"landscape\")\n    .resizable()\n    .aspectRatio(contentMode: .fill)    // Fill space, may crop\n    .frame(width: 300, height: 200)\n    .clipped()                          // Prevent overflow\n    .overlay(\n        Text(\"Scenic View\")\n            .foregroundColor(.white)\n            .padding(5)\n            .background(Color.black.opacity(0.7))\n            .cornerRadius(5)\n            .padding(10),\n        alignment: .bottomTrailing\n    )\n```\n\n## Practical Patterns & Best Practices (30 min)\n\n### Keep Views Small:\n- Break complex views into smaller components\n- Each view should have single responsibility\n- Use descriptive names for custom views\n\n### Modifier Organization:\n```swift\n// Good: Organized and readable\nText(\"Hello\")\n    .font(.title)\n    .foregroundColor(.primary)\n    .padding()\n    .background(Color.secondary)\n    .cornerRadius(8)\n\n// Group related modifiers\n.background(\n    Color.blue\n        .cornerRadius(10)\n        .shadow(radius: 5)\n)\n```\n\n### Preview Best Practices:\n- Preview multiple states (loading, error, success)\n- Test different screen sizes\n- Verify Dark Mode appearance\n- Check accessibility sizes\n\n## Practice Exercises\n\nComplete all exercises to master SwiftUI fundamentals!",
      "codeExample": "// === BASIC VIEWS EXAMPLE ===\n\nimport SwiftUI\n\nstruct BasicViewsExample: View {\n    var body: some View {\n        VStack(spacing: 20) {\n            // Text with various modifiers\n            Text(\"Welcome to SwiftUI!\")\n                .font(.largeTitle)\n                .fontWeight(.bold)\n                .foregroundColor(.blue)\n            \n            // System icon\n            Image(systemName: \"swift\")\n                .font(.system(size: 60))\n                .foregroundColor(.orange)\n            \n            // Horizontal stack with spacer\n            HStack {\n                Text(\"Left\")\n                Spacer()\n                Text(\"Right\")\n            }\n            .padding(.horizontal)\n            \n            // Custom button\n            Button(action: {\n                print(\"Button tapped!\")\n            }) {\n                HStack {\n                    Image(systemName: \"star.fill\")\n                    Text(\"Favorite\")\n                }\n                .foregroundColor(.white)\n                .padding()\n                .background(Color.purple)\n                .cornerRadius(10)\n            }\n        }\n    }\n}\n\n// === MODIFIERS DEMONSTRATION ===\n\nstruct ModifiersExample: View {\n    var body: some View {\n        VStack(spacing: 30) {\n            // Order matters demonstration\n            VStack {\n                Text(\"Order Example 1\")\n                    .padding()\n                    .background(Color.red)\n                \n                Text(\"Order Example 2\")\n                    .background(Color.red)\n                    .padding()\n            }\n            \n            // Frame and alignment\n            HStack {\n                Text(\"Start\")\n                    .frame(width: 100, height: 50)\n                    .background(Color.green)\n                \n                Spacer()\n                \n                Text(\"End\")\n                    .frame(maxWidth: .infinity, minHeight: 40)\n                    .background(Color.blue)\n                    .foregroundColor(.white)\n            }\n            \n            // Complex modifier chain\n            Text(\"Beautiful Text\")\n                .font(.title2)\n                .fontWeight(.semibold)\n                .foregroundColor(.white)\n                .padding()\n                .background(\n                    LinearGradient(\n                        gradient: Gradient(colors: [.blue, .purple]),\n                        startPoint: .leading,\n                        endPoint: .trailing\n                    )\n                )\n                .cornerRadius(15)\n                .shadow(color: .gray, radius: 5, x: 0, y: 2)\n        }\n        .padding()\n    }\n}\n\n// === CUSTOM VIEW EXAMPLE ===\n\nstruct ProfileCard: View {\n    let name: String\n    let role: String\n    let imageName: String\n    \n    var body: some View {\n        VStack {\n            Image(systemName: imageName)\n                .font(.system(size: 70))\n                .foregroundColor(.blue)\n                .padding()\n                .background(Color.blue.opacity(0.1))\n                .clipShape(Circle())\n            \n            Text(name)\n                .font(.title2)\n                .fontWeight(.bold)\n            \n            Text(role)\n                .font(.body)\n                .foregroundColor(.secondary)\n            \n            HStack {\n                Button(\"Follow\") {\n                    print(\"Follow tapped\")\n                }\n                .buttonStyle(ProfileButtonStyle(backgroundColor: .blue))\n                \n                Button(\"Message\") {\n                    print(\"Message tapped\")\n                }\n                .buttonStyle(ProfileButtonStyle(backgroundColor: .green))\n            }\n        }\n        .padding()\n        .background(Color.white)\n        .cornerRadius(20)\n        .shadow(radius: 5)\n        .padding()\n    }\n}\n\nstruct ProfileButtonStyle: ButtonStyle {\n    let backgroundColor: Color\n    \n    func makeBody(configuration: Configuration) -> some View {\n        configuration.label\n            .foregroundColor(.white)\n            .padding(.horizontal, 20)\n            .padding(.vertical, 10)\n            .background(backgroundColor)\n            .cornerRadius(8)\n            .scaleEffect(configuration.isPressed ? 0.95 : 1.0)\n    }\n}\n\n// === COMPLETE EXAMPLE VIEW ===\n\nstruct SwiftUIIntroductionExample: View {\n    var body: some View {\n        ScrollView {\n            VStack(spacing: 30) {\n                ProfileCard(\n                    name: \"Sarah Johnson\",\n                    role: \"iOS Developer\",\n                    imageName: \"person.crop.circle.fill\"\n                )\n                \n                BasicViewsExample()\n                    .padding()\n                    .background(Color.gray.opacity(0.1))\n                    .cornerRadius(15)\n                \n                ModifiersExample()\n            }\n        }\n    }\n}\n\n// === PREVIEWS WITH MULTIPLE CONFIGURATIONS ===\n\nstruct SwiftUIIntroductionExample_Previews: PreviewProvider {\n    static var previews: some View {\n        Group {\n            SwiftUIIntroductionExample()\n                .previewDisplayName(\"Light Mode\")\n            \n            SwiftUIIntroductionExample()\n                .preferredColorScheme(.dark)\n                .previewDisplayName(\"Dark Mode\")\n            \n            SwiftUIIntroductionExample()\n                .previewDevice(\"iPhone SE (2nd generation)\")\n                .previewDisplayName(\"Small Screen\")\n            \n            SwiftUIIntroductionExample()\n                .previewDevice(\"iPad Pro (12.9-inch) (5th generation)\")\n                .previewDisplayName(\"iPad\")\n        }\n    }\n}\n\n// === USAGE EXAMPLE ===\n\nstruct ContentView: View {\n    var body: some View {\n        NavigationView {\n            SwiftUIIntroductionExample()\n                .navigationTitle(\"SwiftUI Basics\")\n                .navigationBarTitleDisplayMode(.large)\n        }\n    }\n}",
      "category": "SwiftUI Basics",
      "estimatedTime": 180,
      "dependencies": ["variables", "structs_classes"],
      "challenge": {
        "instructions": "Create a complete user profile interface using SwiftUI fundamentals:\n\nPART 1: Basic Layout Structure (60 min)\n1. Create a scrollable profile screen with a VStack as the main container\n2. Add a profile header section with user image, name, and title\n3. Create a stats row showing followers, following, and posts count\n4. Add a bio section with placeholder text\n\nPART 2: Custom Modifiers & Styling (60 min)\n5. Create custom view modifiers for:\n   - Primary buttons (blue background, white text, rounded corners)\n   - Secondary buttons (border only, transparent background)\n   - Card containers (white background, shadow, rounded corners)\n6. Apply consistent spacing, colors, and typography throughout\n7. Use SF Symbols for all icons\n\nPART 3: Interactive Components (60 min)\n8. Add a follow button that toggles between \"Follow\" and \"Following\" states\n9. Create a message button that shows an alert when tapped\n10. Build a tabbed section for Posts, Photos, and Likes\n11. Implement a grid layout for user photos (use placeholder rectangles)\n\nPART 4: Advanced Previews & Responsive Design (60 min)\n12. Create comprehensive previews showing light/dark mode, different devices\n13. Ensure layout works on both iPhone and iPad sizes\n14. Add accessibility modifiers for VoiceOver support\n15. Implement responsive design that adapts to orientation changes\n\nTest your implementation thoroughly in the preview canvas!",
        "starterCode": "import SwiftUI\n\nstruct ProfileView: View {\n    var body: some View {\n        Text(\"Build your profile view here!\")\n    }\n}\n\n// === Custom Modifiers ===\n// Create your custom view modifiers here\n\n// === Preview Section ===\nstruct ProfileView_Previews: PreviewProvider {\n    static var previews: some View {\n        ProfileView()\n    }\n}",
        "solution": "import SwiftUI\n\n// === Custom Modifiers ===\nstruct PrimaryButton: ViewModifier {\n    func body(content: Content) -> some View {\n        content\n            .font(.headline)\n            .foregroundColor(.white)\n            .padding(.horizontal, 24)\n            .padding(.vertical, 12)\n            .background(Color.blue)\n            .cornerRadius(25)\n            .shadow(color: .blue.opacity(0.3), radius: 5, x: 0, y: 2)\n    }\n}\n\nstruct SecondaryButton: ViewModifier {\n    func body(content: Content) -> some View {\n        content\n            .font(.headline)\n            .foregroundColor(.blue)\n            .padding(.horizontal, 24)\n            .padding(.vertical, 12)\n            .overlay(\n                RoundedRectangle(cornerRadius: 25)\n                    .stroke(Color.blue, lineWidth: 2)\n            )\n    }\n}\n\nstruct CardModifier: ViewModifier {\n    func body(content: Content) -> some View {\n        content\n            .padding()\n            .background(Color.white)\n            .cornerRadius(12)\n            .shadow(color: .gray.opacity(0.2), radius: 8, x: 0, y: 2)\n    }\n}\n\nextension View {\n    func primaryButton() -> some View {\n        modifier(PrimaryButton())\n    }\n    \n    func secondaryButton() -> some View {\n        modifier(SecondaryButton())\n    }\n    \n    func cardStyle() -> some View {\n        modifier(CardModifier())\n    }\n}\n\n// === Main Profile View ===\nstruct ProfileView: View {\n    @State private var isFollowing = false\n    @State private var selectedTab = 0\n    @State private var showMessageAlert = false\n    \n    let userStats = [\n        (\"12K\", \"Followers\"),\n        (\"563\", \"Following\"), \n        (\"128\", \"Posts\")\n    ]\n    \n    let tabs = [\"Posts\", \"Photos\", \"Likes\"]\n    \n    var body: some View {\n        ScrollView {\n            VStack(spacing: 20) {\n                // Profile Header\n                VStack(spacing: 16) {\n                    Image(systemName: \"person.circle.fill\")\n                        .font(.system(size: 100))\n                        .foregroundColor(.blue)\n                    \n                    VStack(spacing: 8) {\n                        Text(\"Sarah Johnson\")\n                            .font(.title)\n                            .fontWeight(.bold)\n                        \n                        Text(\"iOS Developer @ Apple\")\n                            .font(.body)\n                            .foregroundColor(.secondary)\n                    }\n                    \n                    HStack(spacing: 16) {\n                        Button(action: {\n                            isFollowing.toggle()\n                        }) {\n                            HStack {\n                                Image(systemName: isFollowing ? \"checkmark\" : \"person.badge.plus\")\n                                Text(isFollowing ? \"Following\" : \"Follow\")\n                            }\n                            .primaryButton()\n                        }\n                        \n                        Button(action: {\n                            showMessageAlert = true\n                        }) {\n                            HStack {\n                                Image(systemName: \"message\")\n                                Text(\"Message\")\n                            }\n                            .secondaryButton()\n                        }\n                    }\n                }\n                .padding()\n                .cardStyle()\n                \n                // Stats Row\n                HStack {\n                    ForEach(userStats, id: \\.1) { stat in\n                        VStack {\n                            Text(stat.0)\n                                .font(.title2)\n                                .fontWeight(.bold)\n                                .foregroundColor(.primary)\n                            \n                            Text(stat.1)\n                                .font(.caption)\n                                .foregroundColor(.secondary)\n                        }\n                        .frame(maxWidth: .infinity)\n                    }\n                }\n                .padding()\n                .cardStyle()\n                \n                // Bio Section\n                VStack(alignment: .leading, spacing: 12) {\n                    Text(\"About\")\n                        .font(.headline)\n                        .fontWeight(.semibold)\n                    \n                    Text(\"Passionate iOS developer with 5+ years of experience building beautiful, user-friendly applications. Love working with SwiftUI and exploring new technologies.\")\n                        .font(.body)\n                        .foregroundColor(.secondary)\n                        .lineSpacing(4)\n                }\n                .frame(maxWidth: .infinity, alignment: .leading)\n                .padding()\n                .cardStyle()\n                \n                // Tabbed Content\n                VStack(spacing: 16) {\n                    // Tab Selector\n                    HStack {\n                        ForEach(0..<tabs.count, id: \\.self) { index in\n                            Button(action: {\n                                selectedTab = index\n                            }) {\n                                Text(tabs[index])\n                                    .font(.headline)\n                                    .foregroundColor(selectedTab == index ? .blue : .secondary)\n                                    .padding(.vertical, 8)\n                                    .frame(maxWidth: .infinity)\n                                    .overlay(\n                                        Rectangle()\n                                            .fill(selectedTab == index ? Color.blue : Color.clear)\n                                            .frame(height: 2)\n                                            .offset(y: 16),\n                                        alignment: .bottom\n                                    )\n                            }\n                        }\n                    }\n                    \n                    // Tab Content\n                    Group {\n                        switch selectedTab {\n                        case 0:\n                            PostsTabView()\n                        case 1:\n                            PhotosTabView()\n                        case 2:\n                            LikesTabView()\n                        default:\n                            EmptyView()\n                        }\n                    }\n                    .animation(.easeInOut, value: selectedTab)\n                }\n                .padding()\n                .cardStyle()\n            }\n            .padding()\n        }\n        .background(Color(.systemGroupedBackground))\n        .alert(\"Message Sent!\", isPresented: $showMessageAlert) {\n            Button(\"OK\", role: .cancel) { }\n        } message: {\n            Text(\"Your message has been sent to Sarah.\")\n        }\n    }\n}\n\n// === Tab Views ===\nstruct PostsTabView: View {\n    var body: some View {\n        VStack(spacing: 16) {\n            ForEach(0..<3, id: \\.self) { _ in\n                HStack(alignment: .top, spacing: 12) {\n                    Image(systemName: \"text.alignleft\")\n                        .font(.title2)\n                        .foregroundColor(.blue)\n                        .frame(width: 40)\n                    \n                    VStack(alignment: .leading, spacing: 8) {\n                        Text(\"Latest Project Update\")\n                            .font(.headline)\n                        \n                        Text(\"Just shipped a new feature using SwiftUI! The declarative syntax makes building UIs so much faster and more enjoyable.\")\n                            .font(.body)\n                            .foregroundColor(.secondary)\n                            .lineSpacing(4)\n                        \n                        Text(\"2 hours ago\")\n                            .font(.caption)\n                            .foregroundColor(.secondary)\n                    }\n                    \n                    Spacer()\n                }\n                .padding()\n                .background(Color.gray.opacity(0.1))\n                .cornerRadius(8)\n            }\n        }\n    }\n}\n\nstruct PhotosTabView: View {\n    let columns = [\n        GridItem(.flexible()),\n        GridItem(.flexible()),\n        GridItem(.flexible())\n    ]\n    \n    var body: some View {\n        LazyVGrid(columns: columns, spacing: 8) {\n            ForEach(0..<9, id: \\.self) { index in\n                Rectangle()\n                    .fill(Color.blue.opacity(0.3))\n                    .aspectRatio(1, contentMode: .fit)\n                    .overlay(\n                        Image(systemName: [\"photo\", \"camera\", \"person\"][index % 3])\n                            .font(.title2)\n                            .foregroundColor(.blue)\n                    )\n                    .cornerRadius(8)\n            }\n        }\n    }\n}\n\nstruct LikesTabView: View {\n    var body: some View {\n        VStack(spacing: 20) {\n            Image(systemName: \"heart.fill\")\n                .font(.system(size: 60))\n                .foregroundColor(.red)\n            \n            Text(\"Recent Likes\")\n                .font(.title2)\n                .fontWeight(.semibold)\n            \n            Text(\"Your liked content will appear here\")\n                .font(.body)\n                .foregroundColor(.secondary)\n                .multilineTextAlignment(.center)\n        }\n        .frame(maxWidth: .infinity)\n        .padding(.vertical, 40)\n    }\n}\n\n// === Comprehensive Previews ===\nstruct ProfileView_Previews: PreviewProvider {\n    static var previews: some View {\n        Group {\n            ProfileView()\n                .previewDisplayName(\"iPhone Light\")\n            \n            ProfileView()\n                .preferredColorScheme(.dark)\n                .previewDisplayName(\"iPhone Dark\")\n            \n            ProfileView()\n                .previewDevice(\"iPhone SE (2nd generation)\")\n                .previewDisplayName(\"iPhone SE\")\n            \n            ProfileView()\n                .previewDevice(\"iPad Pro (12.9-inch) (5th generation)\")\n                .previewDisplayName(\"iPad Pro\")\n            \n            // Accessibility preview\n            ProfileView()\n                .environment(\\.sizeCategory, .accessibilityLarge)\n                .previewDisplayName(\"Large Text\")\n        }\n    }\n}",
        "hints": [
          "PART 1: Use VStack as your main container and ScrollView for scrollable content",
          "PART 2: Create ViewModifier protocols for reusable styling. Order matters in modifier chains!",
          "PART 3: Use @State for properties that change and trigger view updates. Toggle boolean values for state changes",
          "PART 4: PreviewProvider can show multiple device configurations. Use Group to organize them",
          "Use .frame(maxWidth: .infinity) to make views fill available space",
          "SF Symbols are Apple's icon system - use Image(systemName:) to access them",
          "LazyVGrid is perfect for creating photo grid layouts",
          "Add accessibility labels with .accessibilityLabel() for VoiceOver support",
          "Use .preferredColorScheme(.dark) to preview dark mode appearance",
          "Chain animations with .animation() modifier for smooth transitions"
        ],
        "testCases": [
          {
            "input": "isFollowing state changes correctly",
            "expectedOutput": "Button text toggles between 'Follow' and 'Following'",
            "description": "Follow button should update its appearance when tapped"
          },
          {
            "input": "Tab selection",
            "expectedOutput": "Content changes based on selected tab",
            "description": "Tabbed interface should display correct content for each tab"
          },
          {
            "input": "Alert presentation",
            "expectedOutput": "Message alert appears when message button tapped",
            "description": "Alert should be shown when message button is pressed"
          }
        ]
      }
    },
    {
      "id": "swiftui_layout_stacks",
      "title": "Layout & Stacks",
      "description": "Master SwiftUI's fundamental layout containers - VStack, HStack, and ZStack to create beautiful UI arrangements",
      "difficulty": "beginner",
      "theory": "# SwiftUI Layout & Stacks - Building UI Foundations\n\n## 1. Understanding SwiftUI Layout System (45 min)\n\n### Declarative UI Principles:\n- **What you see is what you describe**\n- No storyboards or interface builders\n- **Automatic layout** based on content\n- **Responsive by default**\n\n### Stack Containers Overview:\n- **VStack**: Vertical arrangement (top to bottom)\n- **HStack**: Horizontal arrangement (leading to trailing)\n- **ZStack**: Overlapping arrangement (back to front)\n\n### Basic Structure:\n```swift\nimport SwiftUI\n\nstruct ContentView: View {\n    var body: some View {\n        VStack {\n            Text(\"Hello\")\n            Text(\"SwiftUI!\")\n        }\n    }\n}\n```\n\n## 2. VStack - Vertical Stacks (60 min)\n\n### Basic VStack:\n```swift\nVStack {\n    Text(\"First Item\")\n    Text(\"Second Item\")\n    Text(\"Third Item\")\n}\n```\n\n### VStack with Alignment:\n```swift\n// Different alignments\nVStack(alignment: .leading) {\n    Text(\"Left aligned\")\n    Text(\"Also left\")\n}\n\nVStack(alignment: .trailing) {\n    Text(\"Right aligned\")\n    Text(\"Also right\")\n}\n\nVStack(alignment: .center) {\n    Text(\"Centered\")\n    Text(\"Also centered\")\n}\n```\n\n### VStack with Spacing:\n```swift\n// Custom spacing between elements\nVStack(spacing: 20) {\n    Text(\"Item 1\")\n    Text(\"Item 2\")\n    Text(\"Item 3\")\n}\n\n// No spacing\nVStack(spacing: 0) {\n    Text(\"Tight\")\n    Text(\"Layout\")\n}\n```\n\n## 3. HStack - Horizontal Stacks (60 min)\n\n### Basic HStack:\n```swift\nHStack {\n    Text(\"Left\")\n    Text(\"Middle\")\n    Text(\"Right\")\n}\n```\n\n### HStack with Alignment:\n```swift\n// Vertical alignment within horizontal stack\nHStack(alignment: .top) {\n    Text(\"Top\")\n    Rectangle()\n        .fill(Color.blue)\n        .frame(width: 50, height: 100)\n}\n\nHStack(alignment: .center) {\n    Text(\"Center\")\n    Rectangle()\n        .fill(Color.red)\n        .frame(width: 50, height: 100)\n}\n\nHStack(alignment: .bottom) {\n    Text(\"Bottom\")\n    Rectangle()\n        .fill(Color.green)\n        .frame(width: 50, height: 100)\n}\n```\n\n### HStack with Spacing:\n```swift\nHStack(spacing: 30) {\n    Image(systemName: \"star.fill\")\n    Image(systemName: \"heart.fill\")\n    Image(systemName: \"flag.fill\")\n}\n.foregroundColor(.orange)\n.font(.title)\n```\n\n## 4. ZStack - Overlapping Stacks (45 min)\n\n### Basic ZStack:\n```swift\nZStack {\n    Circle()\n        .fill(Color.blue)\n        .frame(width: 200, height: 200)\n    \n    Text(\"Overlay Text\")\n        .foregroundColor(.white)\n        .font(.title)\n}\n```\n\n### ZStack with Alignment:\n```swift\n// Position elements within ZStack\nZStack(alignment: .topLeading) {\n    Rectangle()\n        .fill(Color.red)\n        .frame(width: 300, height: 200)\n    \n    Text(\"Top Left\")\n        .padding()\n        .background(Color.white)\n}\n\nZStack(alignment: .bottomTrailing) {\n    Rectangle()\n        .fill(Color.green)\n        .frame(width: 300, height: 200)\n    \n    Text(\"Bottom Right\")\n        .padding()\n        .background(Color.white)\n}\n```\n\n### Practical ZStack Examples:\n```swift\n// Badge with notification count\nZStack(alignment: .topTrailing) {\n    Image(systemName: \"bell.fill\")\n        .font(.title)\n    \n    Text(\"5\")\n        .font(.caption)\n        .foregroundColor(.white)\n        .padding(5)\n        .background(Circle().fill(Color.red))\n        .offset(x: 10, y: -10)\n}\n```\n\n## 5. Combining Stacks (60 min)\n\n### Nested Stacks:\n```swift\nVStack {\n    HStack {\n        Text(\"Left Column\")\n        Spacer()\n        Text(\"Right Column\")\n    }\n    \n    HStack {\n        VStack {\n            Text(\"Top\")\n            Text(\"Bottom\")\n        }\n        \n        Spacer()\n        \n        VStack {\n            Text(\"Top\")\n            Text(\"Bottom\")\n        }\n    }\n}\n.padding()\n```\n\n### Complex Layout Example:\n```swift\nVStack(spacing: 20) {\n    // Header\n    HStack {\n        Text(\"My App\")\n            .font(.largeTitle)\n            .fontWeight(.bold)\n        Spacer()\n        Image(systemName: \"person.circle\")\n            .font(.title)\n    }\n    \n    // Content\n    HStack(spacing: 15) {\n        VStack {\n            Image(systemName: \"photo\")\n                .font(.largeTitle)\n            Text(\"Gallery\")\n        }\n        \n        VStack {\n            Image(systemName: \"music.note\")\n                .font(.largeTitle)\n            Text(\"Music\")\n        }\n        \n        VStack {\n            Image(systemName: \"map\")\n                .font(.largeTitle)\n            Text(\"Maps\")\n        }\n    }\n    \n    // Footer\n    HStack {\n        Text(\"Status: Online\")\n        Spacer()\n        Text(\"Version 1.0\")\n    }\n    .font(.caption)\n    .foregroundColor(.gray)\n}\n.padding()\n```\n\n## 6. Spacing & Layout Controls (45 min)\n\n### Using Spacer:\n```swift\nHStack {\n    Text(\"Left\")\n    Spacer() // Pushes elements apart\n    Text(\"Right\")\n}\n\nVStack {\n    Text(\"Top\")\n    Spacer() // Takes all available space\n    Text(\"Bottom\")\n}\n```\n\n### Fixed vs Flexible Spacing:\n```swift\n// Fixed spacing\nHStack(spacing: 20) {\n    Text(\"Fixed\")\n    Text(\"Space\")\n}\n\n// Flexible spacing with Spacer\nHStack {\n    Text(\"Left\")\n    Spacer()\n    Text(\"Middle\")\n    Spacer()\n    Text(\"Right\")\n}\n```\n\n### Padding and Margins:\n```swift\nVStack {\n    Text(\"No Padding\")\n    \n    Text(\"With Padding\")\n        .padding() // All sides\n    \n    Text(\"Custom Padding\")\n        .padding(.horizontal, 20) // Horizontal only\n    \n    Text(\"Multiple Padding\")\n        .padding(.top, 10)\n        .padding(.bottom, 5)\n}\n```\n\n## 7. Real-World Layout Patterns (45 min)\n\n### Card Layout:\n```swift\nVStack(alignment: .leading, spacing: 12) {\n    HStack {\n        Text(\"Featured Article\")\n            .font(.headline)\n        Spacer()\n        Image(systemName: \"bookmark\")\n    }\n    \n    Text(\"This is a sample card layout with proper spacing and alignment.\")\n        .font(.body)\n        .foregroundColor(.secondary)\n    \n    HStack {\n        Image(systemName: \"clock\")\n        Text(\"5 min read\")\n        Spacer()\n        Text(\"SwiftUI\")\n            .padding(.horizontal, 8)\n            .padding(.vertical, 4)\n            .background(Color.blue)\n            .foregroundColor(.white)\n            .cornerRadius(4)\n    }\n    .font(.caption)\n}\n.padding()\n.background(Color(.systemBackground))\n.cornerRadius(12)\n.shadow(radius: 2)\n```\n\n### Form Layout:\n```swift\nVStack(spacing: 0) {\n    ForEach(0..<5) { index in\n        HStack {\n            Image(systemName: \"\\(index).circle\")\n            Text(\"Item \\(index + 1)\")\n            Spacer()\n            Image(systemName: \"chevron.right\")\n                .foregroundColor(.gray)\n        }\n        .padding()\n        \n        if index < 4 {\n            Divider()\n                .padding(.leading)\n        }\n    }\n}\n.background(Color(.systemBackground))\n.cornerRadius(10)\n```\n\n## Best Practices & Common Patterns\n\n### Layout Tips:\n- **Start simple** and build complexity gradually\n- **Use spacing** for visual separation\n- **Combine stacks** for complex layouts\n- **Test on different screen sizes**\n- **Use padding** for comfortable margins\n\n### Performance Considerations:\n- **Avoid deep nesting** when possible\n- **Use LazyVStack/LazyHStack** for long lists\n- **Prefer simple layouts** for better performance\n\n## Practice Exercises\n\nComplete all exercises to master SwiftUI layout fundamentals!",
      "codeExample": "// === VSTACK EXAMPLES ===\n\n// Basic vertical stack\nVStack {\n    Text(\"Welcome to\")\n    Text(\"SwiftUI\")\n        .font(.title)\n        .fontWeight(.bold)\n    Text(\"Layout Basics\")\n}\n\n// VStack with alignment and spacing\nVStack(alignment: .leading, spacing: 15) {\n    Text(\"Left Aligned Title\")\n        .font(.headline)\n    \n    Text(\"This text is left aligned within the VStack with custom spacing between elements.\")\n        .font(.body)\n        .foregroundColor(.secondary)\n    \n    HStack {\n        Image(systemName: \"calendar\")\n        Text(\"January 1, 2024\")\n    }\n    .font(.caption)\n}\n.padding()\n\n// === HSTACK EXAMPLES ===\n\n// Basic horizontal stack\nHStack {\n    Image(systemName: \"person.circle.fill\")\n        .font(.largeTitle)\n    \n    VStack(alignment: .leading) {\n        Text(\"John Appleseed\")\n            .font(.headline)\n        Text(\"iOS Developer\")\n            .font(.subheadline)\n            .foregroundColor(.secondary)\n    }\n    \n    Spacer()\n    \n    Image(systemName: \"chevron.right\")\n        .foregroundColor(.gray)\n}\n.padding()\n\n// HStack with different alignments\nHStack(alignment: .top, spacing: 20) {\n    VStack {\n        Text(\"Short\")\n        Rectangle()\n            .fill(Color.blue)\n            .frame(width: 60, height: 40)\n    }\n    \n    VStack {\n        Text(\"Medium Height\")\n        Rectangle()\n            .fill(Color.green)\n            .frame(width: 60, height: 80)\n    }\n    \n    VStack {\n        Text(\"Tall Element\")\n        Rectangle()\n            .fill(Color.orange)\n            .frame(width: 60, height: 120)\n    }\n}\n\n// === ZSTACK EXAMPLES ===\n\n// Overlapping elements\nZStack {\n    // Background\n    RoundedRectangle(cornerRadius: 15)\n        .fill(\n            LinearGradient(\n                gradient: Gradient(colors: [.blue, .purple]),\n                startPoint: .topLeading,\n                endPoint: .bottomTrailing\n            )\n        )\n        .frame(height: 200)\n    \n    // Content\n    VStack(spacing: 10) {\n        Image(systemName: \"star.fill\")\n            .font(.largeTitle)\n            .foregroundColor(.yellow)\n        \n        Text(\"Premium Feature\")\n            .font(.title2)\n            .fontWeight(.semibold)\n            .foregroundColor(.white)\n        \n        Text(\"Unlock amazing capabilities\")\n            .font(.body)\n            .foregroundColor(.white.opacity(0.8))\n    }\n}\n.padding()\n\n// Badge overlay\nZStack(alignment: .topTrailing) {\n    // Main content\n    VStack {\n        Image(systemName: \"envelope.fill\")\n            .font(.system(size: 50))\n        Text(\"Messages\")\n            .font(.headline)\n    }\n    .foregroundColor(.blue)\n    \n    // Badge\n    Text(\"3\")\n        .font(.caption)\n        .fontWeight(.bold)\n        .foregroundColor(.white)\n        .padding(6)\n        .background(Circle().fill(Color.red))\n        .offset(x: 10, y: -10)\n}\n\n// === COMBINED STACKS EXAMPLE ===\n\n// Profile card using all three stacks\nVStack(spacing: 0) {\n    // Header with background\n    ZStack(alignment: .bottom) {\n        Rectangle()\n            .fill(Color.blue)\n            .frame(height: 120)\n        \n        // Profile image overlapping the header\n        Image(systemName: \"person.circle.fill\")\n            .font(.system(size: 80))\n            .foregroundColor(.white)\n            .offset(y: 40)\n    }\n    \n    // Spacer to push content down for profile image\n    Spacer()\n        .frame(height: 40)\n    \n    // Content area\n    VStack(spacing: 15) {\n        Text(\"Alex Johnson\")\n            .font(.title2)\n            .fontWeight(.bold)\n        \n        Text(\"iOS Developer at TechCo\")\n            .font(.body)\n            .foregroundColor(.secondary)\n        \n        HStack(spacing: 30) {\n            VStack {\n                Text(\"125\")\n                    .font(.headline)\n                    .fontWeight(.bold)\n                Text(\"Posts\")\n                    .font(.caption)\n                    .foregroundColor(.secondary)\n            }\n            \n            VStack {\n                Text(\"1.2K\")\n                    .font(.headline)\n                    .fontWeight(.bold)\n                Text(\"Followers\")\n                    .font(.caption)\n                    .foregroundColor(.secondary)\n            }\n            \n            VStack {\n                Text(\"350\")\n                    .font(.headline)\n                    .fontWeight(.bold)\n                Text(\"Following\")\n                    .font(.caption)\n                    .foregroundColor(.secondary)\n            }\n        }\n        \n        // Action buttons\n        HStack(spacing: 15) {\n            Button(\"Follow\") {\n                // Follow action\n            }\n            .padding(.horizontal, 30)\n            .padding(.vertical, 10)\n            .background(Color.blue)\n            .foregroundColor(.white)\n            .cornerRadius(8)\n            \n            Button(\"Message\") {\n                // Message action\n            }\n            .padding(.horizontal, 30)\n            .padding(.vertical, 10)\n            .background(Color.gray.opacity(0.2))\n            .foregroundColor(.primary)\n            .cornerRadius(8)\n        }\n    }\n    .padding()\n}\n.background(Color(.systemBackground))\n.cornerRadius(15)\n.shadow(radius: 5)\n.padding()",
      "category": "SwiftUI Basics",
      "estimatedTime": 240,
      "dependencies": ["swiftui_intro"],
      "challenge": {
        "instructions": "Create a complete social media post component using VStack, HStack, and ZStack:\n\nPART 1: Basic Post Layout (60 min)\n1. Create a VStack for the main post structure\n2. Add HStack for header with profile picture, name, and timestamp\n3. Add post content (text and optional image)\n4. Add HStack for engagement buttons (like, comment, share)\n5. Use proper spacing and alignment throughout\n\nPART 2: Advanced Features with ZStack (60 min)\n6. Add a verified badge overlay on profile picture using ZStack\n7. Create a like animation with heart overlay\n8. Add a premium content badge for special posts\n9. Implement a read-time indicator overlay on images\n\nPART 3: Interactive Elements (60 min)\n10. Make like button change color when tapped\n11. Add expand/collapse functionality for long text\n12. Create a share sheet overlay using ZStack\n13. Implement profile picture tap with scale animation\n\nPART 4: Complex Layout Composition (60 min)\n14. Build a feed view with multiple posts in a ScrollView\n15. Add different post types (text-only, image, video, link)\n16. Create a sticky header using ZStack\n17. Implement pull-to-refresh indicator\n\nTest your implementation on different device sizes and orientations!",
        "starterCode": "import SwiftUI\n\nstruct SocialMediaPost: View {\n    var body: some View {\n        // TODO: Implement social media post layout\n        Text(\"Implement your social media post here\")\n    }\n}\n\nstruct SocialMediaFeed: View {\n    var body: some View {\n        // TODO: Implement feed with multiple posts\n        Text(\"Implement your social media feed here\")\n    }\n}\n\n// Preview\nstruct ContentView_Previews: PreviewProvider {\n    static var previews: some View {\n        SocialMediaFeed()\n    }\n}",
        "solution": "import SwiftUI\n\nstruct SocialMediaPost: View {\n    let post: Post\n    @State private var isLiked = false\n    @State private var isExpanded = false\n    @State private var showShareSheet = false\n    @State private var profileScale: CGFloat = 1.0\n    \n    var body: some View {\n        VStack(alignment: .leading, spacing: 12) {\n            // Header\n            HStack(alignment: .top, spacing: 12) {\n                // Profile picture with verified badge\n                ZStack(alignment: .bottomTrailing) {\n                    Image(systemName: \"person.circle.fill\")\n                        .font(.system(size: 44))\n                        .foregroundColor(.blue)\n                        .scaleEffect(profileScale)\n                        .onTapGesture {\n                            withAnimation(.spring(response: 0.3, dampingFraction: 0.6)) {\n                                profileScale = 0.8\n                            }\n                            withAnimation(.spring(response: 0.3, dampingFraction: 0.6).delay(0.1)) {\n                                profileScale = 1.0\n                            }\n                        }\n                    \n                    // Verified badge\n                    if post.isVerified {\n                        Image(systemName: \"checkmark.seal.fill\")\n                            .font(.system(size: 12))\n                            .foregroundColor(.blue)\n                            .background(Circle().fill(Color.white))\n                    }\n                }\n                \n                VStack(alignment: .leading, spacing: 2) {\n                    HStack {\n                        Text(post.authorName)\n                            .font(.headline)\n                            .fontWeight(.semibold)\n                        \n                        if post.isPremium {\n                            Image(systemName: \"crown.fill\")\n                                .font(.caption)\n                                .foregroundColor(.yellow)\n                        }\n                    }\n                    \n                    Text(post.timestamp)\n                        .font(.caption)\n                        .foregroundColor(.secondary)\n                }\n                \n                Spacer()\n                \n                Image(systemName: \"ellipsis\")\n                    .foregroundColor(.secondary)\n            }\n            \n            // Post content\n            VStack(alignment: .leading, spacing: 8) {\n                Text(post.content)\n                    .font(.body)\n                    .lineLimit(isExpanded ? nil : 3)\n                \n                if post.content.count > 150 {\n                    Button(isExpanded ? \"Show less\" : \"Show more\") {\n                        withAnimation(.easeInOut(duration: 0.3)) {\n                            isExpanded.toggle()\n                        }\n                    }\n                    .font(.caption)\n                    .fontWeight(.medium)\n                    .foregroundColor(.blue)\n                }\n            }\n            \n            // Post image with overlay\n            if let imageName = post.imageName {\n                ZStack(alignment: .bottomTrailing) {\n                    Rectangle()\n                        .fill(Color.gray.opacity(0.3))\n                        .aspectRatio(1.5, contentMode: .fit)\n                        .overlay(\n                            Image(systemName: imageName)\n                                .font(.system(size: 50))\n                                .foregroundColor(.gray)\n                        )\n                    \n                    // Read time indicator\n                    if post.hasReadTime {\n                        Text(\"5 min read\")\n                            .font(.caption2)\n                            .fontWeight(.medium)\n                            .foregroundColor(.white)\n                            .padding(.horizontal, 8)\n                            .padding(.vertical, 4)\n                            .background(Color.black.opacity(0.7))\n                            .cornerRadius(4)\n                            .padding(8)\n                    }\n                }\n                .cornerRadius(12)\n            }\n            \n            // Engagement stats\n            HStack {\n                HStack(spacing: 4) {\n                    // Like count with animation\n                    ZStack {\n                        Image(systemName: \"heart.fill\")\n                            .font(.caption)\n                            .foregroundColor(isLiked ? .red : .clear)\n                        \n                        Image(systemName: \"heart\")\n                            .font(.caption)\n                            .foregroundColor(.secondary)\n                    }\n                    \n                    Text(\"\\(post.likeCount + (isLiked ? 1 : 0))\")\n                        .font(.caption)\n                        .foregroundColor(.secondary)\n                }\n                \n                Text(\"\\(post.commentCount) comments\")\n                    .font(.caption)\n                    .foregroundColor(.secondary)\n                \n                Spacer()\n                \n                Text(\"\\(post.shareCount) shares\")\n                    .font(.caption)\n                    .foregroundColor(.secondary)\n            }\n            \n            // Engagement buttons\n            HStack(spacing: 0) {\n                Button(action: {\n                    withAnimation(.spring(response: 0.3, dampingFraction: 0.6)) {\n                        isLiked.toggle()\n                    }\n                }) {\n                    HStack {\n                        Image(systemName: isLiked ? \"heart.fill\" : \"heart\")\n                            .foregroundColor(isLiked ? .red : .secondary)\n                        Text(\"Like\")\n                            .foregroundColor(isLiked ? .red : .secondary)\n                    }\n                    .frame(maxWidth: .infinity)\n                    .padding(.vertical, 8)\n                }\n                \n                Button(action: {\n                    // Comment action\n                }) {\n                    HStack {\n                        Image(systemName: \"bubble.right\")\n                        Text(\"Comment\")\n                    }\n                    .frame(maxWidth: .infinity)\n                    .padding(.vertical, 8)\n                    .foregroundColor(.secondary)\n                }\n                \n                Button(action: {\n                    showShareSheet = true\n                }) {\n                    HStack {\n                        Image(systemName: \"arrowshape.turn.up.right\")\n                        Text(\"Share\")\n                    }\n                    .frame(maxWidth: .infinity)\n                    .padding(.vertical, 8)\n                    .foregroundColor(.secondary)\n                }\n            }\n            .font(.subheadline)\n            .fontWeight(.medium)\n            \n            Divider()\n        }\n        .padding(.horizontal)\n        .sheet(isPresented: $showShareSheet) {\n            Text(\"Share Sheet\")\n                .presentationDetents([.medium])\n        }\n    }\n}\n\nstruct SocialMediaFeed: View {\n    let posts: [Post] = Post.mockPosts\n    @State private var isRefreshing = false\n    \n    var body: some View {\n        ZStack(alignment: .top) {\n            ScrollView {\n                LazyVStack(spacing: 0) {\n                    // Pull to refresh indicator\n                    if isRefreshing {\n                        ProgressView()\n                            .padding()\n                    }\n                    \n                    ForEach(posts) { post in\n                        SocialMediaPost(post: post)\n                    }\n                }\n                .background(\n                    GeometryReader { geometry in\n                        Color.clear\n                            .onChange(of: geometry.frame(in: .global).minY) { value in\n                                // Simple pull-to-refresh logic\n                                if value > 50 && !isRefreshing {\n                                    isRefreshing = true\n                                    // Simulate refresh\n                                    DispatchQueue.main.asyncAfter(deadline: .now() + 2) {\n                                        isRefreshing = false\n                                    }\n                                }\n                            }\n                    }\n                )\n            }\n            \n            // Sticky header\n            VStack(spacing: 0) {\n                HStack {\n                    Text(\"Social Feed\")\n                        .font(.title2)\n                        .fontWeight(.bold)\n                    \n                    Spacer()\n                    \n                    Image(systemName: \"bell\")\n                        .font(.title3)\n                }\n                .padding()\n                .background(\n                    Color(.systemBackground)\n                        .shadow(radius: 2)\n                )\n                \n                Spacer()\n            }\n        }\n    }\n}\n\n// Data models\nstruct Post: Identifiable {\n    let id = UUID()\n    let authorName: String\n    let timestamp: String\n    let content: String\n    let imageName: String?\n    let likeCount: Int\n    let commentCount: Int\n    let shareCount: Int\n    let isVerified: Bool\n    let isPremium: Bool\n    let hasReadTime: Bool\n    \n    static let mockPosts = [\n        Post(authorName: \"Sarah Chen\", timestamp: \"2h ago\", content: \"Just launched my new SwiftUI course! It covers everything from basics to advanced animations. So excited to share this with the iOS community! #SwiftUI #iOSDev\", imageName: \"photo\", likeCount: 124, commentCount: 23, shareCount: 8, isVerified: true, isPremium: true, hasReadTime: true),\n        Post(authorName: \"Mike Johnson\", timestamp: \"5h ago\", content: \"Beautiful sunset from the office today. Sometimes you need to appreciate the small moments. ðŸŒ…\", imageName: nil, likeCount: 56, commentCount: 12, shareCount: 2, isVerified: false, isPremium: false, hasReadTime: false),\n        Post(authorName: \"Tech News\", timestamp: \"1d ago\", content: \"Apple announces new SwiftUI features at WWDC. The new APIs make complex layouts even easier to build. Can't wait to try them out!\", imageName: \"newspaper\", likeCount: 342, commentCount: 45, shareCount: 32, isVerified: true, isPremium: false, hasReadTime: true)\n    ]\n}\n\n// Preview\nstruct ContentView_Previews: PreviewProvider {\n    static var previews: some View {\n        SocialMediaFeed()\n    }\n}",
        "hints": [
          "PART 1: Use VStack as the main container, HStack for horizontal elements like header and buttons",
          "PART 2: ZStack is perfect for overlays like badges and indicators. Use alignment parameters to position them",
          "PART 3: Use @State variables to track interactive states like isLiked, isExpanded",
          "PART 4: Combine ScrollView with LazyVStack for efficient feed rendering",
          "Use Spacer() to push elements to edges in HStack and VStack",
          "Apply padding() for comfortable spacing around content",
          "Use .cornerRadius() and .shadow() to create card-like appearance",
          "Experiment with different spacing values in stacks for visual hierarchy",
          "Use .frame(maxWidth: .infinity) to make buttons fill available space",
          "Apply animations with withAnimation for smooth state transitions"
        ],
        "testCases": [
          {
            "input": "Post header should contain profile image, name, and timestamp",
            "expectedOutput": "HStack with proper alignment and spacing",
            "description": "Header layout uses HStack with profile, text, and spacer"
          },
          {
            "input": "Like button should change color when tapped",
            "expectedOutput": "Heart icon turns red when isLiked is true",
            "description": "Interactive state change with visual feedback"
          },
          {
            "input": "Long text should be expandable",
            "expectedOutput": "Show more/less button appears for long content",
            "description": "Conditional UI based on content length"
          },
          {
            "input": "Verified badge should overlay profile image",
            "expectedOutput": "ZStack with alignment for badge positioning",
            "description": "Overlay elements using ZStack alignment"
          }
        ]
      }
    },
    {
      "id": "swiftui_state_management",
      "title": "SwiftUI State Management",
      "description": "Master data flow in SwiftUI with @State, @Binding, and @ObservedObject - the foundation of reactive UI",
      "difficulty": "beginner",
      "theory": "# SwiftUI State Management - Data Flow in Modern UI\n\n## 1. Understanding State in SwiftUI (60 min)\n\n### What is State?\n- **State**: Data that can change over time and affects the UI\n- **Single Source of Truth**: Each piece of data should have one definitive source\n- **Reactive Updates**: UI automatically updates when state changes\n\n### The Problem State Solves:\n```swift\n// Without State Management - UI won't update!\nvar counter = 0\nButton(\"Tap me\") {\n    counter += 1 // UI doesn't know to update!\n}\nText(\"Count: \\(counter)\") // Stays at 0\n```\n\n### State Property Wrapper:\n```swift\n// With @State - UI updates automatically!\n@State private var counter = 0\nButton(\"Tap me\") {\n    counter += 1 // UI automatically updates!\n}\nText(\"Count: \\(counter)\") // Updates in real-time\n```\n\n## 2. @State Property Wrapper (75 min)\n\n### Basic @State Usage:\n```swift\nstruct CounterView: View {\n    @State private var count = 0\n    \n    var body: some View {\n        VStack {\n            Text(\"Count: \\(count)\")\n                .font(.largeTitle)\n            \n            Button(\"Increment\") {\n                count += 1\n            }\n            .buttonStyle(.borderedProminent)\n        }\n    }\n}\n```\n\n### State with Different Data Types:\n```swift\nstruct UserSettingsView: View {\n    @State private var username = \"\"\n    @State private var isOn = false\n    @State private var selectedColor = Color.red\n    @State private var score = 0.0\n    \n    var body: some View {\n        Form {\n            TextField(\"Username\", text: $username)\n            Toggle(\"Notifications\", isOn: $isOn)\n            ColorPicker(\"Theme Color\", selection: $selectedColor)\n            Slider(value: $score, in: 0...100)\n        }\n    }\n}\n```\n\n### State Best Practices:\n- Use `private` access control for @State properties\n- Initialize with default values\n- Use for local, simple data owned by the view\n- Store value types (String, Int, Bool, structs)\n\n## 3. @Binding Property Wrapper (75 min)\n\n### What is @Binding?\n- **Two-way connection** between parent and child views\n- Creates a **reference** to state owned by a parent\n- Allows child views to **read and write** parent's state\n\n### Creating Custom Bindings:\n```swift\nstruct ToggleView: View {\n    @Binding var isOn: Bool\n    \n    var body: some View {\n        Toggle(\"Switch\", isOn: $isOn)\n            .toggleStyle(.switch)\n    }\n}\n\nstruct ParentView: View {\n    @State private var settingsOn = false\n    \n    var body: some View {\n        VStack {\n            Text(\"Settings are: \\(settingsOn ? \"ON\" : \"OFF\")\")\n            ToggleView(isOn: $settingsOn) // Pass binding\n        }\n    }\n}\n```\n\n### Binding with Custom Controls:\n```swift\nstruct BrightnessSlider: View {\n    @Binding var brightness: Double\n    \n    var body: some View {\n        VStack {\n            Text(\"Brightness: \\(Int(brightness * 100))%\")\n            Slider(value: $brightness)\n        }\n    }\n}\n\nstruct LightControlView: View {\n    @State private var brightness = 0.5\n    \n    var body: some View {\n        BrightnessSlider(brightness: $brightness)\n    }\n}\n```\n\n### Custom Binding Creation:\n```swift\nstruct VolumeControl: View {\n    @State private var volume = 0.5\n    \n    private var isMuted: Binding<Bool> {\n        Binding(\n            get: { volume == 0 },\n            set: { newValue in\n                volume = newValue ? 0 : 0.5\n            }\n        )\n    }\n    \n    var body: some View {\n        VStack {\n            Slider(value: $volume)\n            Toggle(\"Mute\", isOn: isMuted)\n        }\n    }\n}\n```\n\n## 4. @ObservedObject for Complex State (90 min)\n\n### When to Use @ObservedObject:\n- **Complex data** that multiple views need\n- **External data** not owned by the view\n- **Reference types** (classes) instead of value types\n- Data that conforms to **ObservableObject**\n\n### Creating Observable Objects:\n```swift\nclass UserSettings: ObservableObject {\n    @Published var username = \"\"\n    @Published var isLoggedIn = false\n    @Published var themeColor = Color.blue\n}\n\nstruct ProfileView: View {\n    @ObservedObject var settings: UserSettings\n    \n    var body: some View {\n        VStack {\n            TextField(\"Username\", text: $settings.username)\n            Toggle(\"Logged In\", isOn: $settings.isLoggedIn)\n            ColorPicker(\"Theme\", selection: $settings.themeColor)\n        }\n    }\n}\n```\n\n### Multiple Views Sharing ObservedObject:\n```swift\nclass GameState: ObservableObject {\n    @Published var score = 0\n    @Published var level = 1\n    @Published var isGameActive = false\n}\n\nstruct GameView: View {\n    @ObservedObject var gameState: GameState\n    \n    var body: some View {\n        VStack {\n            ScoreView(gameState: gameState)\n            LevelView(gameState: gameState)\n            GameControls(gameState: gameState)\n        }\n    }\n}\n\nstruct ScoreView: View {\n    @ObservedObject var gameState: GameState\n    \n    var body: some View {\n        Text(\"Score: \\(gameState.score)\")\n    }\n}\n```\n\n### Manual ObjectWillChange:\n```swift\nclass Inventory: ObservableObject {\n    var items: [String] = [] {\n        willSet {\n            objectWillChange.send()\n        }\n    }\n    \n    func addItem(_ item: String) {\n        items.append(item)\n    }\n}\n```\n\n## 5. Choosing the Right Tool (60 min)\n\n### @State vs @Binding vs @ObservedObject:\n\n| Property Wrapper | Ownership | Use Case | Data Type |\n|------------------|-----------|----------|-----------|\n| `@State` | View owns it | Simple local state | Value types |\n| `@Binding` | Parent owns it | Child modifies parent state | Value types |\n| `@ObservedObject` | External source | Complex shared state | Reference types |\n\n### Decision Flow:\n1. **Is data simple and local?** â†’ `@State`\n2. **Does child need to modify parent's state?** â†’ `@Binding`\n3. **Is data complex and shared?** â†’ `@ObservedObject`\n\n### Real-world Examples:\n```swift\n// @State - User input in a form\nstruct LoginView: View {\n    @State private var email = \"\"\n    @State private var password = \"\"\n}\n\n// @Binding - Settings that affect multiple components\nstruct ThemeSettings: View {\n    @Binding var isDarkMode: Bool\n}\n\n// @ObservedObject - App-wide user data\nclass UserData: ObservableObject {\n    @Published var user: User?\n    @Published var preferences: Preferences\n}\n```\n\n## 6. Common Patterns & Best Practices (60 min)\n\n### State Management Patterns:\n\n#### Single Source of Truth:\n```swift\nstruct TodoApp: View {\n    @StateObject private var store = TodoStore()\n    \n    var body: some View {\n        NavigationView {\n            List {\n                ForEach(store.todos) { todo in\n                    TodoRow(todo: todo)\n                }\n            }\n            .navigationTitle(\"Todos\")\n        }\n        .environmentObject(store)\n    }\n}\n```\n\n#### Derived State:\n```swift\nstruct TaskListView: View {\n    @State private var tasks: [Task] = []\n    \n    // Computed property - derived from state\n    var completedTasks: [Task] {\n        tasks.filter { $0.isCompleted }\n    }\n    \n    var incompleteTasks: [Task] {\n        tasks.filter { !$0.isCompleted }\n    }\n}\n```\n\n### Performance Considerations:\n- Use @State for simple, local data\n- Use @ObservedObject for shared, complex data\n- Avoid putting large objects in @State\n- Use computed properties for derived data\n\n### Testing State:\n```swift\nstruct CounterView: View {\n    @State private var count = 0\n    \n    func increment() {\n        count += 1\n    }\n    \n    var body: some View {\n        Button(\"Count: \\(count)\") {\n            increment()\n        }\n    }\n}\n\n// Testable because logic is separated\nclass CounterViewModel: ObservableObject {\n    @Published var count = 0\n    \n    func increment() {\n        count += 1\n    }\n}\n```\n\n## Practice Exercises\n\nComplete all exercises to master SwiftUI state management!",
      "codeExample": "// === @STATE EXAMPLES ===\n\n// Basic counter with @State\nstruct CounterView: View {\n    @State private var count = 0\n    \n    var body: some View {\n        VStack(spacing: 20) {\n            Text(\"Count: \\(count)\")\n                .font(.title)\n            \n            HStack {\n                Button(\"Decrement\") {\n                    count -= 1\n                }\n                .buttonStyle(.bordered)\n                \n                Button(\"Reset\") {\n                    count = 0\n                }\n                .buttonStyle(.bordered)\n                \n                Button(\"Increment\") {\n                    count += 1\n                }\n                .buttonStyle(.borderedProminent)\n            }\n        }\n        .padding()\n    }\n}\n\n// Form with multiple @State properties\nstruct UserProfileView: View {\n    @State private var name = \"\"\n    @State private var email = \"\"\n    @State private var age = 18\n    @State private var receiveNewsletter = true\n    @State private var selectedColor = Color.blue\n    \n    var body: some View {\n        Form {\n            Section(\"Personal Information\") {\n                TextField(\"Name\", text: $name)\n                TextField(\"Email\", text: $email)\n                    .keyboardType(.emailAddress)\n                Stepper(\"Age: \\(age)\", value: $age, in: 13...100)\n            }\n            \n            Section(\"Preferences\") {\n                Toggle(\"Newsletter\", isOn: $receiveNewsletter)\n                ColorPicker(\"Theme Color\", selection: $selectedColor)\n            }\n            \n            Section(\"Summary\") {\n                Text(\"Name: \\(name)\")\n                Text(\"Email: \\(email)\")\n                Text(\"Age: \\(age)\")\n                Text(\"Newsletter: \\(receiveNewsletter ? \"Yes\" : \"No\")\")\n            }\n        }\n        .navigationTitle(\"Profile\")\n    }\n}\n\n// === @BINDING EXAMPLES ===\n\n// Custom toggle with @Binding\nstruct CustomToggle: View {\n    let title: String\n    @Binding var isOn: Bool\n    \n    var body: some View {\n        HStack {\n            Text(title)\n            Spacer()\n            RoundedRectangle(cornerRadius: 16)\n                .fill(isOn ? Color.green : Color.gray)\n                .frame(width: 50, height: 30)\n                .overlay(\n                    Circle()\n                        .fill(Color.white)\n                        .padding(3)\n                        .offset(x: isOn ? 10 : -10)\n                )\n                .onTapGesture {\n                    withAnimation(.spring()) {\n                        isOn.toggle()\n                    }\n                }\n        }\n        .padding()\n        .background(Color(.systemBackground))\n        .cornerRadius(10)\n    }\n}\n\n// Parent view using the custom toggle\nstruct SettingsView: View {\n    @State private var darkMode = false\n    @State private var notifications = true\n    @State private var autoSave = true\n    \n    var body: some View {\n        VStack(spacing: 16) {\n            CustomToggle(title: \"Dark Mode\", isOn: $darkMode)\n            CustomToggle(title: \"Notifications\", isOn: $notifications)\n            CustomToggle(title: \"Auto Save\", isOn: $autoSave)\n            \n            Spacer()\n            \n            Text(\"Current Settings:\")\n                .font(.headline)\n            Text(\"Dark Mode: \\(darkMode ? \"ON\" : \"OFF\")\")\n            Text(\"Notifications: \\(notifications ? \"ON\" : \"OFF\")\")\n            Text(\"Auto Save: \\(autoSave ? \"ON\" : \"OFF\")\")\n        }\n        .padding()\n        .background(darkMode ? Color.black : Color.white)\n        .foregroundColor(darkMode ? Color.white : Color.black)\n    }\n}\n\n// === @OBSERVEDOBJECT EXAMPLES ===\n\n// ObservableObject for game state\nclass GameState: ObservableObject {\n    @Published var score = 0\n    @Published var level = 1\n    @Published var lives = 3\n    @Published var isGameOver = false\n    \n    func addPoints(_ points: Int) {\n        score += points\n        if score >= level * 1000 {\n            level += 1\n            lives += 1\n        }\n    }\n    \n    func loseLife() {\n        lives -= 1\n        if lives <= 0 {\n            isGameOver = true\n        }\n    }\n    \n    func reset() {\n        score = 0\n        level = 1\n        lives = 3\n        isGameOver = false\n    }\n}\n\n// Multiple views sharing the same ObservedObject\nstruct GameView: View {\n    @ObservedObject var gameState: GameState\n    \n    var body: some View {\n        VStack(spacing: 30) {\n            GameHeaderView(gameState: gameState)\n            GameContentView(gameState: gameState)\n            GameControlsView(gameState: gameState)\n        }\n    }\n}\n\nstruct GameHeaderView: View {\n    @ObservedObject var gameState: GameState\n    \n    var body: some View {\n        HStack {\n            VStack {\n                Text(\"Score\")\n                    .font(.caption)\n                Text(\"\\(gameState.score)\")\n                    .font(.title2)\n                    .bold()\n            }\n            \n            Spacer()\n            \n            VStack {\n                Text(\"Level\")\n                    .font(.caption)\n                Text(\"\\(gameState.level)\")\n                    .font(.title2)\n                    .bold()\n            }\n            \n            Spacer()\n            \n            VStack {\n                Text(\"Lives\")\n                    .font(.caption)\n                Text(\"\\(gameState.lives)\")\n                    .font(.title2)\n                    .bold()\n            }\n        }\n        .padding()\n        .background(Color.blue.opacity(0.1))\n        .cornerRadius(10)\n    }\n}\n\nstruct GameContentView: View {\n    @ObservedObject var gameState: GameState\n    \n    var body: some View {\n        VStack {\n            if gameState.isGameOver {\n                Text(\"Game Over!\")\n                    .font(.largeTitle)\n                    .foregroundColor(.red)\n                Text(\"Final Score: \\(gameState.score)\")\n                    .font(.title2)\n            } else {\n                Text(\"Playing Level \\(gameState.level)\")\n                    .font(.title)\n                Text(\"Collect points and avoid losing lives!\")\n                    .font(.body)\n                    .foregroundColor(.secondary)\n            }\n        }\n    }\n}\n\nstruct GameControlsView: View {\n    @ObservedObject var gameState: GameState\n    \n    var body: some View {\n        VStack(spacing: 16) {\n            if !gameState.isGameOver {\n                Button(\"Collect Points\") {\n                    gameState.addPoints(100)\n                }\n                .buttonStyle(.borderedProminent)\n                \n                Button(\"Lose Life\") {\n                    gameState.loseLife()\n                }\n                .buttonStyle(.bordered)\n                .tint(.red)\n            }\n            \n            Button(\"Reset Game\") {\n                gameState.reset()\n            }\n            .buttonStyle(.bordered)\n        }\n    }\n}\n\n// === COMPREHENSIVE EXAMPLE ===\n\nstruct StateManagementDemo: View {\n    // @State for local view state\n    @State private var showGame = false\n    \n    // @StateObject for creating observed objects (we'll learn this next!)\n    @State private var gameState = GameState()\n    \n    var body: some View {\n        NavigationView {\n            VStack(spacing: 30) {\n                if showGame {\n                    GameView(gameState: gameState)\n                } else {\n                    WelcomeView(showGame: $showGame)\n                }\n            }\n            .navigationTitle(\"State Management Demo\")\n            .padding()\n        }\n    }\n}\n\nstruct WelcomeView: View {\n    @Binding var showGame: Bool\n    \n    var body: some View {\n        VStack(spacing: 20) {\n            Text(\"Welcome to State Management!\")\n                .font(.title)\n                .multilineTextAlignment(.center)\n            \n            Text(\"This demo shows @State, @Binding, and @ObservedObject in action\")\n                .font(.body)\n                .foregroundColor(.secondary)\n                .multilineTextAlignment(.center)\n            \n            Button(\"Start Game\") {\n                showGame = true\n            }\n            .buttonStyle(.borderedProminent)\n            .controlSize(.large)\n        }\n    }\n}",
      "category": "SwiftUI Basics",
      "estimatedTime": 300,
      "dependencies": ["swiftui_intro", "views_layout"],
      "challenge": {
        "instructions": "Create a complete shopping cart application using all three state management tools:\n\nPART 1: @State for Local UI (60 min)\n1. Create a 'ProductListView' with @State for search query and filter options\n2. Implement search functionality that filters products based on @State\n3. Add sorting options (name, price) managed with @State\n4. Create a cart badge that shows item count using @State\n\nPART 2: @Binding for Component Communication (60 min)\n5. Create a 'ProductRow' component that uses @Binding for quantity\n6. Build a 'FilterView' that uses @Binding for filter criteria\n7. Implement a 'CartSummary' view that binds to cart total\n8. Create a 'QuantityStepper' component with @Binding for value\n\nPART 3: @ObservedObject for Shared Data (60 min)\n9. Create 'ShoppingCart' class conforming to ObservableObject\n10. Implement cart operations: add, remove, update quantity\n11. Create 'InventoryManager' class to manage product stock\n12. Build multiple views that observe the same cart instance\n\nPART 4: Integration & Advanced Features (60 min)\n13. Connect all components to work together\n14. Add persistence to save cart between app launches\n15. Implement error handling for stock limitations\n16. Add animations for cart updates and state changes\n\nTest your implementation thoroughly to understand how data flows between components!",
        "starterCode": "// === PART 1: @State for Local UI ===\n// Create ProductListView with search and filters\n\n\n// === PART 2: @Binding for Components ===\n// Create ProductRow, FilterView, and QuantityStepper\n\n\n// === PART 3: @ObservedObject for Shared Data ===\n// Create ShoppingCart and InventoryManager classes\n\n\n// === PART 4: Integration ===\n// Connect all components and add advanced features\n\n",
        "solution": "// === PART 1: @State for Local UI ===\nstruct ProductListView: View {\n    let products: [Product]\n    \n    // @State for local UI state\n    @State private var searchQuery = \"\"\n    @State private var selectedCategory = \"All\"\n    @State private var sortOption = \"name\"\n    @State private var showFilters = false\n    \n    // Computed properties for filtered and sorted products\n    private var filteredProducts: [Product] {\n        let filtered = products.filter { product in\n            (selectedCategory == \"All\" || product.category == selectedCategory) &&\n            (searchQuery.isEmpty || product.name.localizedCaseInsensitiveContains(searchQuery))\n        }\n        \n        switch sortOption {\n        case \"name\":\n            return filtered.sorted { $0.name < $1.name }\n        case \"priceLow\":\n            return filtered.sorted { $0.price < $1.price }\n        case \"priceHigh\":\n            return filtered.sorted { $0.price > $1.price }\n        default:\n            return filtered\n        }\n    }\n    \n    private var categories: [String] {\n        [\"All\"] + Array(Set(products.map { $0.category })).sorted()\n    }\n    \n    var body: some View {\n        NavigationView {\n            VStack {\n                // Search bar\n                HStack {\n                    Image(systemName: \"magnifyingglass\")\n                        .foregroundColor(.secondary)\n                    TextField(\"Search products...\", text: $searchQuery)\n                    \n                    Button(\"Filters\") {\n                        showFilters.toggle()\n                    }\n                    .buttonStyle(.bordered)\n                }\n                .padding()\n                .background(Color(.systemGray6))\n                .cornerRadius(10)\n                .padding(.horizontal)\n                \n                // Filters sheet\n                .sheet(isPresented: $showFilters) {\n                    FilterView(\n                        selectedCategory: $selectedCategory,\n                        sortOption: $sortOption,\n                        categories: categories\n                    )\n                }\n                \n                // Product list\n                List(filteredProducts) { product in\n                    ProductRow(product: product)\n                }\n                .listStyle(.plain)\n            }\n            .navigationTitle(\"Products\")\n        }\n    }\n}\n\n// === PART 2: @Binding for Components ===\nstruct ProductRow: View {\n    let product: Product\n    @Binding var cart: [CartItem]\n    \n    private var quantity: Int {\n        cart.first { $0.product.id == product.id }?.quantity ?? 0\n    }\n    \n    var body: some View {\n        HStack {\n            // Product info\n            VStack(alignment: .leading) {\n                Text(product.name)\n                    .font(.headline)\n                Text(product.category)\n                    .font(.caption)\n                    .foregroundColor(.secondary)\n                Text(\"$\\(product.price, specifier: \"%.2f\")\")\n                    .font(.subheadline)\n                    .bold()\n            }\n            \n            Spacer()\n            \n            // Quantity controls\n            if quantity > 0 {\n                QuantityStepper(quantity: Binding(\n                    get: { quantity },\n                    set: { newValue in\n                        if let index = cart.firstIndex(where: { $0.product.id == product.id }) {\n                            if newValue > 0 {\n                                cart[index].quantity = newValue\n                            } else {\n                                cart.remove(at: index)\n                            }\n                        } else if newValue > 0 {\n                            cart.append(CartItem(product: product, quantity: newValue))\n                        }\n                    }\n                ))\n            } else {\n                Button(\"Add to Cart\") {\n                    if let index = cart.firstIndex(where: { $0.product.id == product.id }) {\n                        cart[index].quantity += 1\n                    } else {\n                        cart.append(CartItem(product: product, quantity: 1))\n                    }\n                }\n                .buttonStyle(.bordered)\n            }\n        }\n        .padding(.vertical, 8)\n    }\n}\n\nstruct QuantityStepper: View {\n    @Binding var quantity: Int\n    \n    var body: some View {\n        HStack {\n            Button(\"-\") {\n                if quantity > 0 {\n                    quantity -= 1\n                }\n            }\n            .buttonStyle(.bordered)\n            \n            Text(\"\\(quantity)\")\n                .frame(minWidth: 30)\n            \n            Button(\"+\") {\n                quantity += 1\n            }\n            .buttonStyle(.bordered)\n        }\n    }\n}\n\nstruct FilterView: View {\n    @Binding var selectedCategory: String\n    @Binding var sortOption: String\n    let categories: [String]\n    @Environment(\\.dismiss) private var dismiss\n    \n    var body: some View {\n        NavigationView {\n            Form {\n                Section(\"Category\") {\n                    Picker(\"Category\", selection: $selectedCategory) {\n                        ForEach(categories, id: \\.self) { category in\n                            Text(category).tag(category)\n                        }\n                    }\n                    .pickerStyle(.segmented)\n                }\n                \n                Section(\"Sort By\") {\n                    Picker(\"Sort By\", selection: $sortOption) {\n                        Text(\"Name\").tag(\"name\")\n                        Text(\"Price: Low to High\").tag(\"priceLow\")\n                        Text(\"Price: High to Low\").tag(\"priceHigh\")\n                    }\n                    .pickerStyle(.segmented)\n                }\n            }\n            .navigationTitle(\"Filters\")\n            .navigationBarItems(trailing: Button(\"Done\") { dismiss() })\n        }\n    }\n}\n\n// === PART 3: @ObservedObject for Shared Data ===\nclass ShoppingCart: ObservableObject {\n    @Published var items: [CartItem] = []\n    @Published var lastUpdate = Date()\n    \n    var total: Double {\n        items.reduce(0) { $0 + ($1.product.price * Double($1.quantity)) }\n    }\n    \n    var itemCount: Int {\n        items.reduce(0) { $0 + $1.quantity }\n    }\n    \n    func addProduct(_ product: Product, quantity: Int = 1) {\n        if let index = items.firstIndex(where: { $0.product.id == product.id }) {\n            items[index].quantity += quantity\n        } else {\n            items.append(CartItem(product: product, quantity: quantity))\n        }\n        lastUpdate = Date()\n    }\n    \n    func removeProduct(_ product: Product) {\n        items.removeAll { $0.product.id == product.id }\n        lastUpdate = Date()\n    }\n    \n    func updateQuantity(for product: Product, to quantity: Int) {\n        if quantity <= 0 {\n            removeProduct(product)\n        } else if let index = items.firstIndex(where: { $0.product.id == product.id }) {\n            items[index].quantity = quantity\n            lastUpdate = Date()\n        }\n    }\n    \n    func clear() {\n        items.removeAll()\n        lastUpdate = Date()\n    }\n}\n\nclass InventoryManager: ObservableObject {\n    @Published var products: [Product] = [\n        Product(id: 1, name: \"iPhone\", category: \"Electronics\", price: 999.99),\n        Product(id: 2, name: \"MacBook\", category: \"Electronics\", price: 1299.99),\n        Product(id: 3, name: \"Coffee Mug\", category: \"Home\", price: 12.99),\n        Product(id: 4, name: \"Desk Lamp\", category: \"Home\", price: 45.99),\n        Product(id: 5, name: \"T-shirt\", category: \"Clothing\", price: 24.99),\n        Product(id: 6, name: \"Jeans\", category: \"Clothing\", price: 59.99)\n    ]\n}\n\n// === PART 4: Integration ===\nstruct ShoppingApp: View {\n    @StateObject private var inventory = InventoryManager()\n    @StateObject private var cart = ShoppingCart()\n    @State private var selectedTab = 0\n    \n    var body: some View {\n        TabView(selection: $selectedTab) {\n            // Products Tab\n            ProductListView(products: inventory.products)\n                .tabItem {\n                    Image(systemName: \"list.bullet\")\n                    Text(\"Products\")\n                }\n                .tag(0)\n            \n            // Cart Tab\n            CartView()\n                .tabItem {\n                    Image(systemName: \"cart\")\n                    Text(\"Cart\")\n                }\n                .badge(cart.itemCount)\n                .tag(1)\n        }\n        .environmentObject(cart)\n        .environmentObject(inventory)\n    }\n}\n\nstruct CartView: View {\n    @EnvironmentObject var cart: ShoppingCart\n    \n    var body: some View {\n        NavigationView {\n            Group {\n                if cart.items.isEmpty {\n                    VStack {\n                        Image(systemName: \"cart\")\n                            .font(.system(size: 60))\n                            .foregroundColor(.secondary)\n                        Text(\"Your cart is empty\")\n                            .font(.title2)\n                            .foregroundColor(.secondary)\n                    }\n                } else {\n                    List {\n                        ForEach(cart.items) { item in\n                            HStack {\n                                VStack(alignment: .leading) {\n                                    Text(item.product.name)\n                                        .font(.headline)\n                                    Text(\"$\\(item.product.price, specifier: \"%.2f\") each\")\n                                        .font(.caption)\n                                        .foregroundColor(.secondary)\n                                }\n                                \n                                Spacer()\n                                \n                                QuantityStepper(quantity: Binding(\n                                    get: { item.quantity },\n                                    set: { newValue in\n                                        cart.updateQuantity(for: item.product, to: newValue)\n                                    }\n                                ))\n                                \n                                Text(\"$\\(item.total, specifier: \"%.2f\")\")\n                                    .font(.headline)\n                                    .frame(width: 80, alignment: .trailing)\n                            }\n                        }\n                        .onDelete { indexSet in\n                            for index in indexSet {\n                                cart.removeProduct(cart.items[index].product)\n                            }\n                        }\n                        \n                        // Total section\n                        Section {\n                            HStack {\n                                Text(\"Total\")\n                                    .font(.title2)\n                                    .bold()\n                                Spacer()\n                                Text(\"$\\(cart.total, specifier: \"%.2f\")\")\n                                    .font(.title2)\n                                    .bold()\n                            }\n                        }\n                    }\n                    .listStyle(.insetGrouped)\n                }\n            }\n            .navigationTitle(\"Shopping Cart\")\n            .toolbar {\n                if !cart.items.isEmpty {\n                    Button(\"Clear All\") {\n                        cart.clear()\n                    }\n                }\n            }\n        }\n    }\n}\n\n// Data Models\nstruct Product: Identifiable {\n    let id: Int\n    let name: String\n    let category: String\n    let price: Double\n}\n\nstruct CartItem: Identifiable {\n    let id = UUID()\n    let product: Product\n    var quantity: Int\n    \n    var total: Double {\n        product.price * Double(quantity)\n    }\n}",
        "hints": [
          "PART 1: Use @State for UI-only state like search queries and filters. Computed properties are great for derived data",
          "PART 2: @Binding creates two-way connections. Use it when child views need to modify parent state",
          "PART 3: ObservableObject classes should contain your app's business logic and shared state",
          "PART 4: Use @EnvironmentObject to share data across multiple views without passing through each one",
          "Remember: @State for view-owned data, @Binding for shared value types, @ObservedObject for shared reference types",
          "Use computed properties to transform state instead of storing derived values",
          "For complex bindings, you can create custom Binding instances with get/set closures",
          "Always mark @State properties as private to ensure they're only modified by the view that owns them"
        ],
        "testCases": [
          {
            "input": "cart.items.count after adding 2 different products",
            "expectedOutput": "2",
            "description": "Cart should contain unique products with quantities"
          },
          {
            "input": "cart.total after adding 3 items of $10 product",
            "expectedOutput": "30.0",
            "description": "Total should calculate price Ã— quantity correctly"
          },
          {
            "input": "filteredProducts.count when searching for non-existent product",
            "expectedOutput": "0",
            "description": "Search should filter products correctly"
          }
        ]
      }
    },
    {
      "id": "lists_navigation",
      "title": "Lists & Navigation",
      "description": "Master displaying data collections and building navigation flows in SwiftUI apps",
      "difficulty": "beginner",
      "theory": "# Lists & Navigation - Building Data-Driven Interfaces\n\n## 1. Understanding Lists in SwiftUI (60 min)\n\n### What are Lists?\n- **Container views** that display rows of data\n- Similar to UITableView but **much simpler**\n- Automatically handles **scrolling, selection, and styling**\n- Built on top of SwiftUI's declarative syntax\n\n### Basic List Syntax:\n```swift\nList {\n    Text(\"Row 1\")\n    Text(\"Row 2\")\n    Text(\"Row 3\")\n}\n```\n\n### Lists with Arrays:\n```swift\nlet fruits = [\"Apple\", \"Banana\", \"Orange\"]\n\nList(fruits, id: \\.self) { fruit in\n    Text(fruit)\n}\n```\n\n### Why Lists are Powerful:\n- **Automatic recycling** (like UITableView reuse)\n- **Smooth performance** with large datasets\n- **Built-in gestures** and interactions\n- **Consistent styling** across iOS\n\n## 2. Building Basic Lists (60 min)\n\n### Static Lists:\n```swift\nList {\n    Text(\"Settings\")\n    Text(\"Profile\")\n    Text(\"Notifications\")\n    Text(\"Help\")\n}\n```\n\n### Dynamic Lists from Arrays:\n```swift\nstruct TodoItem: Identifiable {\n    let id = UUID()\n    let title: String\n    let isCompleted: Bool\n}\n\nlet todos = [\n    TodoItem(title: \"Buy groceries\", isCompleted: false),\n    TodoItem(title: \"Walk the dog\", isCompleted: true),\n    TodoItem(title: \"Learn SwiftUI\", isCompleted: false)\n]\n\nList(todos) { todo in\n    HStack {\n        Image(systemName: todo.isCompleted ? \"checkmark.circle.fill\" : \"circle\")\n        Text(todo.title)\n    }\n}\n```\n\n### Mixed Static and Dynamic Content:\n```swift\nList {\n    Section(header: Text(\"Favorites\")) {\n        Text(\"Starred Items\")\n        Text(\"Recent\")\n    }\n    \n    Section(header: Text(\"All Items\")) {\n        ForEach(items) { item in\n            Text(item.name)\n        }\n    }\n    \n    Section(footer: Text(\"End of list\")) {\n        Button(\"Load More...\") {\n            // Load more action\n        }\n    }\n}\n```\n\n## 3. Navigation Fundamentals (60 min)\n\n### NavigationView Basics:\n- **Container** for navigable content\n- Provides **navigation bar** and **hierarchy management**\n- Automatically handles **back buttons** and **transitions**\n\n### Basic Navigation Setup:\n```swift\nNavigationView {\n    List {\n        Text(\"Home Screen\")\n        Text(\"Profile Screen\")\n        Text(\"Settings Screen\")\n    }\n    .navigationTitle(\"Main Menu\")\n}\n```\n\n### NavigationLink - The Navigation Trigger:\n```swift\nNavigationView {\n    List {\n        NavigationLink(\"Go to Details\") {\n            Text(\"Detail Screen\")\n        }\n        \n        NavigationLink(destination: Text(\"Another Screen\")) {\n            HStack {\n                Image(systemName: \"star\")\n                Text(\"Favorites\")\n            }\n        }\n    }\n    .navigationTitle(\"Navigation Demo\")\n}\n```\n\n### Navigation Modifiers:\n```swift\n.navigationTitle(\"My App\")          // Large title\n.navigationBarTitleDisplayMode(.large) // .large or .inline\n.navigationBarHidden(false)           // Show/hide bar\n.navigationBarBackButtonHidden(false) // Show/hide back button\n```\n\n## 4. Combining Lists & Navigation (60 min)\n\n### Typical App Pattern:\n```swift\nstruct ContentView: View {\n    let categories = [\"Tech\", \"Sports\", \"Food\", \"Travel\"]\n    \n    var body: some View {\n        NavigationView {\n            List(categories, id: \\.self) { category in\n                NavigationLink(destination: CategoryDetail(category: category)) {\n                    HStack {\n                        Image(systemName: \"folder\")\n                        Text(category)\n                        Spacer()\n                        Text(\"5 items\")\n                            .foregroundColor(.gray)\n                    }\n                }\n            }\n            .navigationTitle(\"Categories\")\n        }\n    }\n}\n\nstruct CategoryDetail: View {\n    let category: String\n    \n    var body: some View {\n        List {\n            Text(\"Item 1 in \\(category)\")\n            Text(\"Item 2 in \\(category)\")\n            Text(\"Item 3 in \\(category)\")\n        }\n        .navigationTitle(category)\n    }\n}\n```\n\n### Passing Data Between Screens:\n```swift\nstruct User: Identifiable {\n    let id = UUID()\n    let name: String\n    let email: String\n}\n\nstruct UserListView: View {\n    let users = [\n        User(name: \"John Doe\", email: \"john@example.com\"),\n        User(name: \"Jane Smith\", email: \"jane@example.com\")\n    ]\n    \n    var body: some View {\n        NavigationView {\n            List(users) { user in\n                NavigationLink(destination: UserDetailView(user: user)) {\n                    VStack(alignment: .leading) {\n                        Text(user.name)\n                            .font(.headline)\n                        Text(user.email)\n                            .font(.subheadline)\n                            .foregroundColor(.gray)\n                    }\n                }\n            }\n            .navigationTitle(\"Users\")\n        }\n    }\n}\n\nstruct UserDetailView: View {\n    let user: User\n    \n    var body: some View {\n        VStack(alignment: .leading, spacing: 16) {\n            Text(user.name)\n                .font(.largeTitle)\n            Text(user.email)\n                .font(.title2)\n                .foregroundColor(.blue)\n            Spacer()\n        }\n        .padding()\n        .navigationTitle(\"User Details\")\n        .navigationBarTitleDisplayMode(.inline)\n    }\n}\n```\n\n## 5. Advanced List Features (60 min)\n\n### List Sections:\n```swift\nList {\n    Section(header: Text(\"Important\")) {\n        Text(\"Urgent Task\")\n        Text(\"Critical Update\")\n    }\n    \n    Section(header: Text(\"Regular\"), footer: Text(\"End of regular tasks\")) {\n        ForEach(regularTasks) { task in\n            Text(task.title)\n        }\n    }\n    \n    Section(header: Text(\"Completed\")) {\n        Toggle(\"Show completed\", isOn: $showCompleted)\n        if showCompleted {\n            ForEach(completedTasks) { task in\n                Text(task.title)\n                    .strikethrough()\n                    .foregroundColor(.gray)\n            }\n        }\n    }\n}\n.listStyle(InsetGroupedListStyle())\n```\n\n### List Styles:\n```swift\n.listStyle(PlainListStyle())           // Basic full-width\n.listStyle(GroupedListStyle())         // iOS 13 grouped\n.listStyle(InsetGroupedListStyle())    // iOS 14+ inset grouped\n.listStyle(SidebarListStyle())         // For sidebar navigation\n```\n\n### Swipe Actions (iOS 15+):\n```swift\nList {\n    ForEach(todos) { todo in\n        Text(todo.title)\n            .swipeActions(edge: .trailing) {\n                Button(\"Delete\", role: .destructive) {\n                    deleteTodo(todo)\n                }\n                \n                Button(\"Edit\") {\n                    editTodo(todo)\n                }\n                .tint(.blue)\n            }\n            .swipeActions(edge: .leading) {\n                Button(\"Complete\") {\n                    completeTodo(todo)\n                }\n                .tint(.green)\n            }\n    }\n}\n```\n\n### Pull to Refresh:\n```swift\nList(items) { item in\n    Text(item.name)\n}\n.refreshable {\n    await loadData()\n}\n```\n\n## 6. Navigation Patterns & Best Practices (60 min)\n\n### Programmatic Navigation:\n```swift\nstruct ContentView: View {\n    @State private var isShowingDetail = false\n    @State private var selectedItem: String? = nil\n    \n    var body: some View {\n        NavigationView {\n            List {\n                Button(\"Show Detail Programmatically\") {\n                    selectedItem = \"Manual Selection\"\n                    isShowingDetail = true\n                }\n                \n                NavigationLink(\n                    \"Go to Detail\", \n                    destination: Text(\"Detail Screen\"),\n                    isActive: $isShowingDetail\n                )\n            }\n            .navigationTitle(\"Programmatic Nav\")\n        }\n    }\n}\n```\n\n### Navigation Stack Management:\n```swift\n.navigationBarItems(\n    leading: Button(\"Cancel\") { /* action */ },\n    trailing: HStack {\n        Button(\"Edit\") { /* action */ }\n        Button(\"Add\") { /* action */ }\n    }\n)\n```\n\n### Tab-Based Navigation with Lists:\n```swift\nTabView {\n    NavigationView {\n        List {\n            // Home content\n        }\n        .navigationTitle(\"Home\")\n    }\n    .tabItem {\n        Image(systemName: \"house\")\n        Text(\"Home\")\n    }\n    \n    NavigationView {\n        List {\n            // Settings content\n        }\n        .navigationTitle(\"Settings\")\n    }\n    .tabItem {\n        Image(systemName: \"gear\")\n        Text(\"Settings\")\n    }\n}\n```\n\n### Common Navigation Patterns:\n- **Master-Detail**: List â†’ Detail screen\n- **Tab-Based**: Multiple main sections\n- **Hierarchical**: Deep navigation trees\n- **Modal**: Temporary screens on top\n\n## Practice Exercises\n\nComplete all exercises to master Lists & Navigation in SwiftUI!",
      "codeExample": "// === COMPLETE LIST & NAVIGATION EXAMPLE ===\n\nimport SwiftUI\n\n// Model\nstruct Book: Identifiable {\n    let id = UUID()\n    let title: String\n    let author: String\n    let year: Int\n    let genre: String\n}\n\n// Sample Data\nlet sampleBooks = [\n    Book(title: \"The Great Gatsby\", author: \"F. Scott Fitzgerald\", year: 1925, genre: \"Fiction\"),\n    Book(title: \"To Kill a Mockingbird\", author: \"Harper Lee\", year: 1960, genre: \"Fiction\"),\n    Book(title: \"1984\", author: \"George Orwell\", year: 1949, genre: \"Dystopian\"),\n    Book(title: \"Pride and Prejudice\", author: \"Jane Austen\", year: 1813, genre: \"Romance\"),\n    Book(title: \"The Hobbit\", author: \"J.R.R. Tolkien\", year: 1937, genre: \"Fantasy\")\n]\n\n// Main List View\nstruct BookListView: View {\n    let books: [Book]\n    @State private var searchText = \"\"\n    \n    var filteredBooks: [Book] {\n        if searchText.isEmpty {\n            return books\n        } else {\n            return books.filter { \n                $0.title.localizedCaseInsensitiveContains(searchText) ||\n                $0.author.localizedCaseInsensitiveContains(searchText)\n            }\n        }\n    }\n    \n    var body: some View {\n        NavigationView {\n            List {\n                // Featured Section\n                Section(header: Text(\"Featured Books\")) {\n                    ForEach(filteredBooks.prefix(2)) { book in\n                        NavigationLink(destination: BookDetailView(book: book)) {\n                            FeaturedBookRow(book: book)\n                        }\n                    }\n                }\n                \n                // All Books Section\n                Section(header: Text(\"All Books\")) {\n                    ForEach(filteredBooks) { book in\n                        NavigationLink(destination: BookDetailView(book: book)) {\n                            BookRow(book: book)\n                        }\n                        .swipeActions(edge: .trailing) {\n                            Button(\"Favorite\") {\n                                print(\"Favorited: \\(book.title)\")\n                            }\n                            .tint(.yellow)\n                        }\n                    }\n                }\n            }\n            .searchable(text: $searchText, prompt: \"Search books or authors\")\n            .navigationTitle(\"Book Library\")\n            .listStyle(InsetGroupedListStyle())\n            .toolbar {\n                ToolbarItem(placement: .navigationBarTrailing) {\n                    Button(\"Add Book\") {\n                        print(\"Add new book tapped\")\n                    }\n                }\n            }\n        }\n    }\n}\n\n// Book Row Component\nstruct BookRow: View {\n    let book: Book\n    \n    var body: some View {\n        HStack {\n            VStack(alignment: .leading, spacing: 4) {\n                Text(book.title)\n                    .font(.headline)\n                Text(book.author)\n                    .font(.subheadline)\n                    .foregroundColor(.secondary)\n            }\n            \n            Spacer()\n            \n            VStack(alignment: .trailing, spacing: 4) {\n                Text(\"\\(book.year)\")\n                    .font(.caption)\n                    .foregroundColor(.secondary)\n                Text(book.genre)\n                    .font(.caption)\n                    .padding(4)\n                    .background(Color.blue.opacity(0.1))\n                    .cornerRadius(4)\n            }\n        }\n        .padding(.vertical, 4)\n    }\n}\n\n// Featured Book Row Component\nstruct FeaturedBookRow: View {\n    let book: Book\n    \n    var body: some View {\n        HStack {\n            RoundedRectangle(cornerRadius: 8)\n                .fill(Color.blue.opacity(0.1))\n                .frame(width: 60, height: 80)\n                .overlay(\n                    Image(systemName: \"book\")\n                        .foregroundColor(.blue)\n                )\n            \n            VStack(alignment: .leading, spacing: 4) {\n                Text(book.title)\n                    .font(.headline)\n                Text(book.author)\n                    .font(.subheadline)\n                    .foregroundColor(.secondary)\n                \n                HStack {\n                    Text(book.genre)\n                        .font(.caption)\n                        .padding(4)\n                        .background(Color.blue.opacity(0.2))\n                        .cornerRadius(4)\n                    \n                    Text(\"\\(book.year)\")\n                        .font(.caption)\n                        .foregroundColor(.secondary)\n                }\n            }\n            \n            Spacer()\n            \n            Image(systemName: \"star.fill\")\n                .foregroundColor(.yellow)\n        }\n        .padding(.vertical, 8)\n    }\n}\n\n// Detail View\nstruct BookDetailView: View {\n    let book: Book\n    @Environment(\\.presentationMode) var presentationMode\n    \n    var body: some View {\n        ScrollView {\n            VStack(alignment: .leading, spacing: 20) {\n                // Header\n                HStack {\n                    RoundedRectangle(cornerRadius: 12)\n                        .fill(Color.blue.opacity(0.1))\n                        .frame(width: 100, height: 140)\n                        .overlay(\n                            VStack {\n                                Image(systemName: \"book\")\n                                    .font(.largeTitle)\n                                    .foregroundColor(.blue)\n                                Text(\"BOOK\")\n                                    .font(.caption)\n                                    .foregroundColor(.blue)\n                            }\n                        )\n                    \n                    VStack(alignment: .leading, spacing: 8) {\n                        Text(book.title)\n                            .font(.title2)\n                            .bold()\n                        Text(\"by \\(book.author)\")\n                            .font(.headline)\n                            .foregroundColor(.secondary)\n                        \n                        HStack {\n                            Text(book.genre)\n                                .padding(6)\n                                .background(Color.blue.opacity(0.2))\n                                .cornerRadius(6)\n                            \n                            Text(\"Published: \\(book.year)\")\n                                .font(.caption)\n                                .foregroundColor(.secondary)\n                        }\n                    }\n                    \n                    Spacer()\n                }\n                \n                Divider()\n                \n                // Actions\n                LazyVGrid(columns: [GridItem(.flexible()), GridItem(.flexible())], spacing: 12) {\n                    ActionButton(title: \"Read Now\", icon: \"book.fill\", color: .blue)\n                    ActionButton(title: \"Add to Library\", icon: \"plus.circle.fill\", color: .green)\n                    ActionButton(title: \"Share\", icon: \"square.and.arrow.up\", color: .orange)\n                    ActionButton(title: \"Write Review\", icon: \"pencil\", color: .purple)\n                }\n                \n                Divider()\n                \n                // Description\n                VStack(alignment: .leading, spacing: 12) {\n                    Text(\"About This Book\")\n                        .font(.headline)\n                    \n                    Text(\"This is a detailed description of the book '\\(book.title)' by \\(book.author). Published in \\(book.year), this \\(book.genre.lowercased()) novel has captivated readers for generations.\")\n                        .font(.body)\n                        .foregroundColor(.secondary)\n                }\n            }\n            .padding()\n        }\n        .navigationTitle(book.title)\n        .navigationBarTitleDisplayMode(.inline)\n        .navigationBarBackButtonHidden(false)\n        .toolbar {\n            ToolbarItem(placement: .navigationBarTrailing) {\n                Button(\"Favorite\") {\n                    print(\"Favorited \\(book.title)\")\n                }\n            }\n        }\n    }\n}\n\n// Reusable Action Button\nstruct ActionButton: View {\n    let title: String\n    let icon: String\n    let color: Color\n    \n    var body: some View {\n        Button(action: {\n            print(\"\\(title) tapped\")\n        }) {\n            VStack {\n                Image(systemName: icon)\n                    .font(.title2)\n                    .foregroundColor(color)\n                Text(title)\n                    .font(.caption)\n                    .foregroundColor(.primary)\n            }\n            .frame(maxWidth: .infinity)\n            .padding()\n            .background(Color.gray.opacity(0.1))\n            .cornerRadius(10)\n        }\n    }\n}\n\n// Main App\nstruct BooksApp: App {\n    var body: some Scene {\n        WindowGroup {\n            BookListView(books: sampleBooks)\n        }\n    }\n}\n\n// Preview\nstruct BookListView_Previews: PreviewProvider {\n    static var previews: some View {\n        BookListView(books: sampleBooks)\n    }\n}",
      "category": "SwiftUI Basics",
      "estimatedTime": 240,
      "dependencies": ["swiftui_intro", "data_models"],
      "challenge": {
        "instructions": "Create a complete restaurant discovery app using Lists and Navigation in SwiftUI:\n\nPART 1: Data Modeling & Basic List (60 min)\n1. Create 'Restaurant' struct with: id, name, cuisine, priceRange, rating, imageName, isFavorite\n2. Create sample restaurant data with at least 8 different restaurants\n3. Build a basic list displaying restaurant names and cuisines\n4. Add sections to group restaurants by cuisine type\n\nPART 2: Enhanced List UI (60 min)\n5. Create a custom 'RestaurantRow' view with: name, cuisine, rating stars, price range indicators\n6. Add swipe actions to toggle favorite status and quick actions\n7. Implement search functionality to filter restaurants by name or cuisine\n8. Add pull-to-refresh simulation\n\nPART 3: Navigation & Detail Views (60 min)\n9. Create 'RestaurantDetailView' showing: large header, full details, action buttons\n10. Implement navigation from list to detail view\n11. Add navigation bar buttons for sharing and favoriting\n12. Create a favorites screen that shows only favorited restaurants\n\nPART 4: Advanced Features (60 min)\n13. Implement programmatic navigation to show specific restaurants\n14. Add a filter screen to filter by cuisine, price range, and minimum rating\n15. Create a tab-based navigation with: Home, Favorites, Search tabs\n16. Add a map view integration (placeholder) in the detail screen\n\nTest your app thoroughly to ensure smooth navigation and list performance!",
        "starterCode": "import SwiftUI\n\n// === PART 1: Data Models ===\n// Define your Restaurant struct and sample data here\n\n\n// === PART 2: Restaurant List ===\n// Create your main list view with search and sections\n\n\n// === PART 3: Detail View ===\n// Build the restaurant detail view with navigation\n\n\n// === PART 4: Advanced Navigation ===\n// Implement tab navigation and filtering\n\n\n// Preview Provider\nstruct ContentView_Previews: PreviewProvider {\n    static var previews: some View {\n        // Add your main view here for preview\n        Text(\"Restaurant App Preview\")\n    }\n}",
        "solution": "import SwiftUI\n\n// === PART 1: Data Models ===\nstruct Restaurant: Identifiable {\n    let id = UUID()\n    let name: String\n    let cuisine: String\n    let priceRange: Int // 1-3 ($, $$, $$$)\n    let rating: Double // 1-5\n    let imageName: String\n    let description: String\n    let address: String\n    var isFavorite: Bool = false\n}\n\n// Sample data\nlet sampleRestaurants = [\n    Restaurant(name: \"Italian Bistro\", cuisine: \"Italian\", priceRange: 2, rating: 4.5, imageName: \"italian\", description: \"Authentic Italian cuisine with fresh ingredients\", address: \"123 Main St\"),\n    Restaurant(name: \"Sushi Heaven\", cuisine: \"Japanese\", priceRange: 3, rating: 4.8, imageName: \"sushi\", description: \"Premium sushi and sashimi\", address: \"456 Oak Ave\"),\n    Restaurant(name: \"Burger Palace\", cuisine: \"American\", priceRange: 1, rating: 4.2, imageName: \"burger\", description: \"Classic American burgers and fries\", address: \"789 Elm St\"),\n    Restaurant(name: \"Taco Fiesta\", cuisine: \"Mexican\", priceRange: 1, rating: 4.0, imageName: \"mexican\", description: \"Fresh Mexican street food\", address: \"321 Pine Rd\"),\n    Restaurant(name: \"French Delight\", cuisine: \"French\", priceRange: 3, rating: 4.7, imageName: \"french\", description: \"Elegant French dining experience\", address: \"654 Maple Dr\"),\n    Restaurant(name: \"Dragon Palace\", cuisine: \"Chinese\", priceRange: 2, rating: 4.3, imageName: \"chinese\", description: \"Traditional Chinese dishes\", address: \"987 Cedar Ln\"),\n    Restaurant(name: \"Spice Garden\", cuisine: \"Indian\", priceRange: 2, rating: 4.6, imageName: \"indian\", description: \"Aromatic Indian curries and breads\", address: \"147 Birch St\"),\n    Restaurant(name: \"Mediterranean Grill\", cuisine: \"Mediterranean\", priceRange: 2, rating: 4.4, imageName: \"mediterranean\", description: \"Healthy Mediterranean flavors\", address: \"258 Willow Ave\")\n]\n\n// === PART 2: Restaurant List ===\nstruct RestaurantListView: View {\n    let restaurants: [Restaurant]\n    @State private var searchText = \"\"\n    @State private var isRefreshing = false\n    \n    var filteredRestaurants: [Restaurant] {\n        if searchText.isEmpty {\n            return restaurants\n        } else {\n            return restaurants.filter {\n                $0.name.localizedCaseInsensitiveContains(searchText) ||\n                $0.cuisine.localizedCaseInsensitiveContains(searchText)\n            }\n        }\n    }\n    \n    var groupedRestaurants: [String: [Restaurant]] {\n        Dictionary(grouping: filteredRestaurants) { $0.cuisine }\n    }\n    \n    var body: some View {\n        NavigationView {\n            List {\n                ForEach(Array(groupedRestaurants.keys.sorted()), id: \\.self) { cuisine in\n                    Section(header: Text(cuisine).font(.headline)) {\n                        ForEach(groupedRestaurants[cuisine]!) { restaurant in\n                            NavigationLink(destination: RestaurantDetailView(restaurant: restaurant)) {\n                                RestaurantRow(restaurant: restaurant)\n                            }\n                            .swipeActions(edge: .trailing) {\n                                Button {\n                                    toggleFavorite(for: restaurant)\n                                } label: {\n                                    Label(\"Favorite\", systemImage: restaurant.isFavorite ? \"heart.slash\" : \"heart\")\n                                }\n                                .tint(restaurant.isFavorite ? .gray : .red)\n                            }\n                        }\n                    }\n                }\n            }\n            .searchable(text: $searchText, prompt: \"Search restaurants or cuisines\")\n            .refreshable {\n                await simulateRefresh()\n            }\n            .navigationTitle(\"Restaurants\")\n            .listStyle(InsetGroupedListStyle())\n        }\n    }\n    \n    private func toggleFavorite(for restaurant: Restaurant) {\n        // In a real app, you'd update this in your data model\n        print(\"Toggled favorite for \\(restaurant.name)\")\n    }\n    \n    private func simulateRefresh() async {\n        isRefreshing = true\n        try? await Task.sleep(nanoseconds: 1_000_000_000) // 1 second\n        isRefreshing = false\n    }\n}\n\nstruct RestaurantRow: View {\n    let restaurant: Restaurant\n    \n    var body: some View {\n        HStack {\n            // Restaurant icon\n            Circle()\n                .fill(Color.blue.opacity(0.2))\n                .frame(width: 50, height: 50)\n                .overlay(\n                    Text(String(restaurant.name.prefix(1)))\n                        .font(.title2)\n                        .foregroundColor(.blue)\n                )\n            \n            VStack(alignment: .leading, spacing: 4) {\n                Text(restaurant.name)\n                    .font(.headline)\n                \n                Text(restaurant.cuisine)\n                    .font(.subheadline)\n                    .foregroundColor(.secondary)\n                \n                HStack {\n                    // Rating stars\n                    HStack(spacing: 2) {\n                        ForEach(1...5, id: \\.self) { star in\n                            Image(systemName: star <= Int(restaurant.rating) ? \"star.fill\" : \"star\")\n                                .foregroundColor(.yellow)\n                                .font(.caption)\n                        }\n                        Text(\"(\\(restaurant.rating, specifier: \"%.1f\"))\")\n                            .font(.caption)\n                            .foregroundColor(.secondary)\n                    }\n                }\n            }\n            \n            Spacer()\n            \n            // Price range\n            VStack(alignment: .trailing) {\n                Text(String(repeating: \"$\", count: restaurant.priceRange))\n                    .font(.subheadline)\n                    .foregroundColor(.green)\n                \n                if restaurant.isFavorite {\n                    Image(systemName: \"heart.fill\")\n                        .foregroundColor(.red)\n                        .font(.caption)\n                }\n            }\n        }\n        .padding(.vertical, 4)\n    }\n}\n\n// === PART 3: Detail View ===\nstruct RestaurantDetailView: View {\n    let restaurant: Restaurant\n    @Environment(\\.presentationMode) var presentationMode\n    @State private var isShowingMap = false\n    \n    var body: some View {\n        ScrollView {\n            VStack(alignment: .leading, spacing: 16) {\n                // Header\n                ZStack(alignment: .bottomLeading) {\n                    Rectangle()\n                        .fill(Color.blue.opacity(0.3))\n                        .frame(height: 200)\n                        .overlay(\n                            Text(restaurant.name)\n                                .font(.largeTitle)\n                                .bold()\n                                .foregroundColor(.white)\n                                .shadow(radius: 5)\n                        )\n                    \n                    VStack(alignment: .leading) {\n                        Text(restaurant.cuisine)\n                            .font(.title3)\n                            .foregroundColor(.white)\n                        \n                        HStack {\n                            ForEach(1...5, id: \\.self) { star in\n                                Image(systemName: star <= Int(restaurant.rating) ? \"star.fill\" : \"star\")\n                                    .foregroundColor(.yellow)\n                            }\n                            Text(\"\\(restaurant.rating, specifier: \"%.1f\")\")\n                                .foregroundColor(.white)\n                        }\n                    }\n                    .padding()\n                    .background(Color.black.opacity(0.5))\n                }\n                \n                // Info Section\n                VStack(alignment: .leading, spacing: 12) {\n                    InfoRow(icon: \"mappin.circle\", text: restaurant.address)\n                    InfoRow(icon: \"dollarsign.circle\", text: \"Price: \\(String(repeating: \"$\", count: restaurant.priceRange))\")\n                }\n                .padding(.horizontal)\n                \n                // Actions\n                LazyVGrid(columns: [GridItem(.flexible()), GridItem(.flexible())], spacing: 12) {\n                    ActionButton(title: \"Call\", icon: \"phone\", color: .green) {\n                        print(\"Call \\(restaurant.name)\")\n                    }\n                    ActionButton(title: \"Directions\", icon: \"map\", color: .blue) {\n                        isShowingMap = true\n                    }\n                    ActionButton(title: \"Website\", icon: \"globe\", color: .orange) {\n                        print(\"Open website\")\n                    }\n                    ActionButton(title: \"Share\", icon: \"square.and.arrow.up\", color: .purple) {\n                        print(\"Share restaurant\")\n                    }\n                }\n                .padding(.horizontal)\n                \n                // Description\n                VStack(alignment: .leading, spacing: 8) {\n                    Text(\"About\")\n                        .font(.headline)\n                    \n                    Text(restaurant.description)\n                        .foregroundColor(.secondary)\n                }\n                .padding(.horizontal)\n                \n                Spacer()\n            }\n        }\n        .navigationTitle(restaurant.name)\n        .navigationBarTitleDisplayMode(.inline)\n        .toolbar {\n            ToolbarItem(placement: .navigationBarTrailing) {\n                Button(action: { toggleFavorite() }) {\n                    Image(systemName: restaurant.isFavorite ? \"heart.fill\" : \"heart\")\n                        .foregroundColor(restaurant.isFavorite ? .red : .primary)\n                }\n            }\n        }\n        .sheet(isPresented: $isShowingMap) {\n            MapView(restaurant: restaurant)\n        }\n    }\n    \n    private func toggleFavorite() {\n        print(\"Toggled favorite for \\(restaurant.name)\")\n    }\n}\n\nstruct InfoRow: View {\n    let icon: String\n    let text: String\n    \n    var body: some View {\n        HStack {\n            Image(systemName: icon)\n                .foregroundColor(.blue)\n                .frame(width: 30)\n            Text(text)\n            Spacer()\n        }\n    }\n}\n\nstruct ActionButton: View {\n    let title: String\n    let icon: String\n    let color: Color\n    let action: () -> Void\n    \n    var body: some View {\n        Button(action: action) {\n            VStack {\n                Image(systemName: icon)\n                    .font(.title2)\n                    .foregroundColor(color)\n                Text(title)\n                    .font(.caption)\n                    .foregroundColor(.primary)\n            }\n            .frame(maxWidth: .infinity)\n            .padding()\n            .background(Color.gray.opacity(0.1))\n            .cornerRadius(10)\n        }\n    }\n}\n\n// Placeholder Map View\nstruct MapView: View {\n    let restaurant: Restaurant\n    @Environment(\\.presentationMode) var presentationMode\n    \n    var body: some View {\n        NavigationView {\n            VStack {\n                Rectangle()\n                    .fill(Color.blue.opacity(0.3))\n                    .overlay(\n                        VStack {\n                            Image(systemName: \"map\")\n                                .font(.system(size: 60))\n                                .foregroundColor(.blue)\n                            Text(\"Map View\")\n                                .font(.title2)\n                            Text(restaurant.address)\n                                .font(.body)\n                                .foregroundColor(.secondary)\n                        }\n                    )\n                    .frame(height: 300)\n                \n                Spacer()\n            }\n            .navigationTitle(\"Location\")\n            .navigationBarTitleDisplayMode(.inline)\n            .toolbar {\n                ToolbarItem(placement: .navigationBarTrailing) {\n                    Button(\"Done\") {\n                        presentationMode.wrappedValue.dismiss()\n                    }\n                }\n            }\n        }\n    }\n}\n\n// === PART 4: Advanced Navigation ===\nstruct RestaurantApp: App {\n    var body: some Scene {\n        WindowGroup {\n            MainTabView()\n        }\n    }\n}\n\nstruct MainTabView: View {\n    var body: some View {\n        TabView {\n            RestaurantListView(restaurants: sampleRestaurants)\n                .tabItem {\n                    Image(systemName: \"house\")\n                    Text(\"Home\")\n                }\n            \n            FavoritesView()\n                .tabItem {\n                    Image(systemName: \"heart\")\n                    Text(\"Favorites\")\n                }\n            \n            SearchView()\n                .tabItem {\n                    Image(systemName: \"magnifyingglass\")\n                    Text(\"Search\")\n                }\n        }\n    }\n}\n\nstruct FavoritesView: View {\n    var body: some View {\n        NavigationView {\n            VStack {\n                Text(\"Your Favorite Restaurants\")\n                    .font(.title2)\n                    .padding()\n                \n                // In a real app, you'd filter restaurants that are favorited\n                List(sampleRestaurants.filter { $0.isFavorite }) { restaurant in\n                    RestaurantRow(restaurant: restaurant)\n                }\n                .overlay(\n                    Group {\n                        if sampleRestaurants.filter({ $0.isFavorite }).isEmpty {\n                            Text(\"No favorites yet\\nTap the heart icon to add some!\")\n                                .multilineTextAlignment(.center)\n                                .foregroundColor(.secondary)\n                        }\n                    }\n                )\n            }\n            .navigationTitle(\"Favorites\")\n        }\n    }\n}\n\nstruct SearchView: View {\n    @State private var searchText = \"\"\n    \n    var body: some View {\n        NavigationView {\n            VStack {\n                Text(\"Advanced Search\")\n                    .font(.title2)\n                    .padding()\n                \n                // Search filters would go here\n                List(sampleRestaurants) { restaurant in\n                    RestaurantRow(restaurant: restaurant)\n                }\n            }\n            .navigationTitle(\"Search\")\n        }\n    }\n}\n\n// Preview\nstruct RestaurantListView_Previews: PreviewProvider {\n    static var previews: some View {\n        RestaurantListView(restaurants: sampleRestaurants)\n    }\n}",
        "hints": [
          "PART 1: Use Dictionary(grouping:by:) to create sections by cuisine. Make sure your struct conforms to Identifiable",
          "PART 2: Implement swipeActions with different colors for different actions. Use .searchable modifier for search functionality",
          "PART 3: Use @Environment(\\.presentationMode) to handle custom back button actions. Create reusable components for buttons and info rows",
          "PART 4: TabView with NavigationView in each tab creates proper navigation hierarchies. Use @State for filter selections",
          "For rating stars, use ForEach with range and conditional SF Symbols",
          "Use .overlay modifier to show empty state messages when lists are empty",
          "Implement refreshable with async/await for pull-to-refresh",
          "Create reusable ActionButton component for consistent button styling"
        ],
        "testCases": [
          {
            "input": "groupedRestaurants.keys.count",
            "expectedOutput": "7",
            "description": "Should group restaurants by 7 different cuisines"
          },
          {
            "input": "filteredRestaurants.count when searching 'Italian'",
            "expectedOutput": "1",
            "description": "Search should filter restaurants by name or cuisine"
          },
          {
            "input": "sampleRestaurants.filter { $0.priceRange == 1 }.count",
            "expectedOutput": "2",
            "description": "Should correctly filter by price range"
          }
        ]
      }
    },
    {
      "id": "swiftui_user_input",
      "title": "User Input in SwiftUI",
      "description": "Master interactive controls - buttons, text fields, pickers and forms to create engaging user interfaces",
      "difficulty": "beginner",
      "theory": "# User Input in SwiftUI - Interactive Controls\\n\\n## 1. Understanding State & Binding (60 min)\\n\\n### The Foundation of SwiftUI Interaction\\n- **@State**: For local view state that changes over time\\n- **@Binding**: Creates two-way connection between parent and child views\\n- **@StateObject**: For reference types that conform to ObservableObject\\n- **@Published**: Marks properties that should trigger view updates\\n\\n### State Management Basics:\\n```swift\\nstruct ContentView: View {\\n    @State private var username = \\\"\\\"\\n    @State private var isOn = false\\n    \\n    var body: some View {\\n        VStack {\\n            Text(\\\"Hello, \\\\(username)!\\\")\\n            Toggle(\\\"Active\\\", isOn: $isOn)\\n        }\\n    }\\n}\\n```\\n\\n### Real-world Analogy:\\n- **@State**: Like your personal notebook - you control what's written\\n- **@Binding**: Like a shared whiteboard - multiple people can read and write\\n- **ObservableObject**: Like a company announcement board - everyone gets updates\\n\\n## 2. Buttons & Actions (45 min)\\n\\n### Basic Button Syntax:\\n```swift\\nButton(\\\"Tap Me!\\\") {\\n    print(\\\"Button was tapped!\\\")\\n}\\n\\n// With custom styling\\nButton(action: {\\n    // Action code here\\n}) {\\n    Text(\\\"Custom Button\\\")\\n        .padding()\\n        .background(Color.blue)\\n        .foregroundColor(.white)\\n        .cornerRadius(8)\\n}\\n```\\n\\n### Button Styles & Variations:\\n```swift\\n// Different button styles\\nVStack {\\n    Button(\\\"Plain Style\\\") { }\\n        .buttonStyle(PlainButtonStyle())\\n    \\n    Button(\\\"Bordered\\\") { }\\n        .buttonStyle(.bordered)\\n    \\n    Button(\\\"Bordered Prominent\\\") { }\\n        .buttonStyle(.borderedProminent)\\n    \\n    Button(\\\"Destructive\\\") { }\\n        .buttonStyle(.borderedProminent)\\n        .tint(.red)\\n}\\n```\\n\\n### Advanced Button Features:\\n```swift\\n// Button with role\\nButton(\\\"Delete\\\", role: .destructive) {\\n    deleteItem()\\n}\\n\\n// Disabled state\\nButton(\\\"Submit\\\") {\\n    submitForm()\\n}\\n.disabled(username.isEmpty)\\n\\n// Button with system icon\\nButton {\\n    shareContent()\\n} label: {\\n    Label(\\\"Share\\\", systemImage: \\\"square.and.arrow.up\\\")\\n}\\n```\\n\\n## 3. Text Fields & Text Editors (60 min)\\n\\n### Basic Text Input:\\n```swift\\nstruct LoginView: View {\\n    @State private var email = \\\"\\\"\\n    @State private var password = \\\"\\\"\\n    \\n    var body: some View {\\n        Form {\\n            TextField(\\\"Email address\\\", text: $email)\\n                .textContentType(.emailAddress)\\n                .keyboardType(.emailAddress)\\n                .autocapitalization(.none)\\n            \\n            SecureField(\\\"Password\\\", text: $password)\\n                .textContentType(.password)\\n        }\\n    }\\n}\\n```\\n\\n### Text Field Modifiers & Validation:\\n```swift\\nTextField(\\\"Username\\\", text: $username)\\n    .textFieldStyle(.roundedBorder)\\n    .disableAutocorrection(true)\\n    .textInputAutocapitalization(.never)\\n    .onSubmit {\\n        validateUsername()\\n    }\\n    .onChange(of: username) { newValue in\\n        // React to text changes\\n        if newValue.count > 20 {\\n            username = String(newValue.prefix(20))\\n        }\\n    }\\n```\\n\\n### Text Editor for Multi-line Input:\\n```swift\\nstruct NoteView: View {\\n    @State private var noteText = \\\"Enter your notes here...\\\"\\n    \\n    var body: some View {\\n        TextEditor(text: $noteText)\\n            .font(.body)\\n            .lineSpacing(5)\\n            .border(Color.gray, width: 1)\\n            .frame(height: 200)\\n    }\\n}\\n```\\n\\n### Input Formatting & Masks:\\n```swift\\nTextField(\\\"Phone Number\\\", text: $phoneNumber)\\n    .keyboardType(.phonePad)\\n    .onChange(of: phoneNumber) { newValue in\\n        // Simple phone number formatting\\n        let filtered = newValue.filter { $0.isNumber }\\n        if filtered.count <= 10 {\\n            phoneNumber = formatPhoneNumber(filtered)\\n        }\\n    }\\n```\\n\\n## 4. Pickers & Selection Controls (60 min)\\n\\n### Segmented Picker:\\n```swift\\nstruct ThemePicker: View {\\n    @State private var selectedTheme = 0\\n    let themes = [\\\"Light\\\", \\\"Dark\\\", \\\"Auto\\\"]\\n    \\n    var body: some View {\\n        Picker(\\\"Theme\\\", selection: $selectedTheme) {\\n            ForEach(0..<themes.count, id: \\\\.self) { index in\\n                Text(themes[index]).tag(index)\\n            }\\n        }\\n        .pickerStyle(.segmented)\\n    }\\n}\\n```\\n\\n### Wheel & Menu Pickers:\\n```swift\\n// Wheel picker\\nPicker(\\\"Select Age\\\", selection: $selectedAge) {\\n    ForEach(0..<100, id: \\\\.self) { age in\\n        Text(\\\"\\\\(age) years\\\").tag(age)\\n    }\\n}\\n.pickerStyle(.wheel)\\n\\n// Menu picker (dropdown)\\nPicker(\\\"Color Theme\\\", selection: $selectedColor) {\\n    Text(\\\"Red\\\").tag(Color.red)\\n    Text(\\\"Green\\\").tag(Color.green)\\n    Text(\\\"Blue\\\").tag(Color.blue)\\n}\\n.pickerStyle(.menu)\\n```\\n\\n### Toggle Switches:\\n```swift\\nstruct SettingsView: View {\\n    @State private var notificationsEnabled = true\\n    @State private var darkMode = false\\n    @State private var autoPlay = false\\n    \\n    var body: some View {\\n        Form {\\n            Toggle(\\\"Enable Notifications\\\", isOn: $notificationsEnabled)\\n            Toggle(\\\"Dark Mode\\\", isOn: $darkMode)\\n            Toggle(\\\"Auto-play Videos\\\", isOn: $autoPlay)\\n        }\\n    }\\n}\\n```\\n\\n### Stepper & Slider Controls:\\n```swift\\nVStack {\\n    Stepper(\\\"Age: \\\\(age)\\\", value: $age, in: 0...120)\\n    \\n    Slider(value: $volume, in: 0...1) {\\n        Text(\\\"Volume\\\")\\n    } minimumValueLabel: {\\n        Image(systemName: \\\"speaker.fill\\\")\\n    } maximumValueLabel: {\\n        Image(systemName: \\\"speaker.wave.3.fill\\\")\\n    }\\n    \\n    Text(\\\"Volume: \\\\(Int(volume * 100))%\\\")\\n}\\n```\\n\\n## 5. Forms & Data Validation (45 min)\\n\\n### Building Forms:\\n```swift\\nstruct RegistrationView: View {\\n    @State private var firstName = \\\"\\\"\\n    @State private var lastName = \\\"\\\"\\n    @State private var email = \\\"\\\"\\n    @State private var birthDate = Date()\\n    @State private var receiveNewsletter = true\\n    \\n    var body: some View {\\n        NavigationView {\\n            Form {\\n                Section(header: Text(\\\"Personal Information\\\")) {\\n                    TextField(\\\"First Name\\\", text: $firstName)\\n                    TextField(\\\"Last Name\\\", text: $lastName)\\n                    DatePicker(\\\"Birth Date\\\", selection: $birthDate, displayedComponents: .date)\\n                }\\n                \\n                Section(header: Text(\\\"Contact\\\")) {\\n                    TextField(\\\"Email\\\", text: $email)\\n                        .keyboardType(.emailAddress)\\n                    Toggle(\\\"Receive Newsletter\\\", isOn: $receiveNewsletter)\\n                }\\n                \\n                Section {\\n                    Button(\\\"Create Account\\\") {\\n                        registerUser()\\n                    }\\n                    .disabled(!isFormValid)\\n                }\\n            }\\n            .navigationTitle(\\\"Registration\\\")\\n        }\\n    }\\n    \\n    var isFormValid: Bool {\\n        !firstName.isEmpty && !lastName.isEmpty && !email.isEmpty\\n    }\\n}\\n```\\n\\n### Input Validation & Feedback:\\n```swift\\nTextField(\\\"Email\\\", text: $email)\\n    .onChange(of: email) { _ in\\n        validateEmail()\\n    }\\n    .overlay(\\n        Group {\\n            if showEmailError {\\n                Image(systemName: \\\"exclamationmark.triangle.fill\\\")\\n                    .foregroundColor(.red)\\n                    .offset(x: -10)\\n            }\\n        },\\n        alignment: .trailing\\n    )\\n```\\n\\n### Custom Input Styles:\\n```swift\\n// Custom text field style\\nstruct RoundedTextFieldStyle: TextFieldStyle {\\n    func _body(configuration: TextField<Self._Label>) -> some View {\\n        configuration\\n            .padding(10)\\n            .background(Color(.systemGray6))\\n            .cornerRadius(8)\\n            .overlay(\\n                RoundedRectangle(cornerRadius: 8)\\n                    .stroke(Color.blue, lineWidth: 1)\\n            )\\n    }\\n}\\n\\n// Usage\\nTextField(\\\"Search...\\\", text: $searchText)\\n    .textFieldStyle(RoundedTextFieldStyle())\\n```\\n\\n## 6. Advanced Input Patterns (30 min)\\n\\n### Custom Bindings:\\n```swift\\n// Custom binding with validation\\nvar validatedEmail: Binding<String> {\\n    Binding(\\n        get: { self.email },\\n        set: { newValue in\\n            // Only allow valid email characters\\n            let filtered = newValue.filter { $0.isLetter || $0.isNumber || \\\"@.-_\\\".contains($0) }\\n            self.email = String(filtered.prefix(50))\\n        }\\n    )\\n}\\n\\nTextField(\\\"Email\\\", text: validatedEmail)\\n```\\n\\n### Focus Management:\\n```swift\\nstruct LoginForm: View {\\n    @State private var username = \\\"\\\"\\n    @State private var password = \\\"\\\"\\n    @FocusState private var focusedField: Field?\\n    \\n    enum Field {\\n        case username, password\\n    }\\n    \\n    var body: some View {\\n        Form {\\n            TextField(\\\"Username\\\", text: $username)\\n                .focused($focusedField, equals: .username)\\n                .submitLabel(.next)\\n                .onSubmit {\\n                    focusedField = .password\\n                }\\n            \\n            SecureField(\\\"Password\\\", text: $password)\\n                .focused($focusedField, equals: .password)\\n                .submitLabel(.done)\\n        }\\n        .onAppear {\\n            focusedField = .username\\n        }\\n    }\\n}\\n```\\n\\n### Input Accessibility:\\n```swift\\nTextField(\\\"Name\\\", text: $name)\\n    .accessibilityLabel(\\\"Full name\\\")\\n    .accessibilityHint(\\\"Enter your first and last name\\\")\\n    .accessibilityValue(name.isEmpty ? \\\"Empty\\\" : name)\\n\\nButton(\\\"Submit\\\") { submit() }\\n    .accessibilityLabel(\\\"Submit form\\\")\\n    .accessibilityHint(\\\"Double tap to complete registration\\\")\\n```\\n\\n## Best Practices & Common Patterns\\n\\n### Do's and Don'ts:\\n- **DO** use appropriate keyboard types for different input types\\n- **DO** validate input as users type with `.onChange`\\n- **DO** provide clear feedback for invalid input\\n- **DON'T** store sensitive data in @State without encryption\\n- **DON'T** forget to handle different screen sizes and orientations\\n- **DO** use `.focused` and `@FocusState` for form navigation\\n\\n### Performance Tips:\\n- Use `.onChange` sparingly with expensive operations\\n- Consider debouncing rapid input changes\\n- Use `@StateObject` for complex validation logic\\n- Implement custom bindings for input formatting\\n\\nComplete all practice exercises to master SwiftUI user input controls!\\\"",
      "codeExample": "// === COMPREHENSIVE USER INPUT DEMO ===\\n\\nimport SwiftUI\\n\\nstruct UserInputDemo: View {\\n    // Form State\\n    @State private var username = \\\"\\\"\\n    @State private var email = \\\"\\\"\\n    @State private var password = \\\"\\\"\\n    @State private var age = 18\\n    @State private var rating = 3.0\\n    @State private var isNotificationsOn = true\\n    @State private var selectedColor = \\\"Red\\\"\\n    @State private var birthDate = Date()\\n    @State private var bio = \\\"Tell us about yourself...\\\"\\n    \\n    // UI State\\n    @State private var isSubmitted = false\\n    @State private var showAlert = false\\n    \\n    let colors = [\\\"Red\\\", \\\"Green\\\", \\\"Blue\\\", \\\"Yellow\\\", \\\"Purple\\\"]\\n    \\n    var body: some View {\\n        NavigationView {\\n            Form {\\n                // Section 1: Basic Info\\n                Section(header: Text(\\\"Basic Information\\\")) {\\n                    TextField(\\\"Username\\\", text: $username)\\n                        .textContentType(.username)\\n                        .autocapitalization(.none)\\n                    \\n                    TextField(\\\"Email\\\", text: $email)\\n                        .keyboardType(.emailAddress)\\n                        .textContentType(.emailAddress)\\n                        .autocapitalization(.none)\\n                    \\n                    SecureField(\\\"Password\\\", text: $password)\\n                        .textContentType(.newPassword)\\n                }\\n                \\n                // Section 2: Preferences\\n                Section(header: Text(\\\"Preferences\\\")) {\\n                    Picker(\\\"Favorite Color\\\", selection: $selectedColor) {\\n                        ForEach(colors, id: \\\\.self) { color in\\n                            Text(color)\\n                        }\\n                    }\\n                    .pickerStyle(.menu)\\n                    \\n                    Stepper(\\\"Age: \\\\(age)\\\", value: $age, in: 13...100)\\n                    \\n                    VStack {\\n                        HStack {\\n                            Text(\\\"Satisfaction Rating\\\")\\n                            Spacer()\\n                            Text(\\\"\\\\(rating, specifier: \\\"%.1f\\\")\\\")\\n                        }\\n                        Slider(value: $rating, in: 1...5, step: 0.5)\\n                    }\\n                    \\n                    Toggle(\\\"Enable Notifications\\\", isOn: $isNotificationsOn)\\n                }\\n                \\n                // Section 3: Additional Info\\n                Section(header: Text(\\\"Additional Information\\\")) {\\n                    DatePicker(\\\"Birth Date\\\", selection: $birthDate, displayedComponents: .date)\\n                    \\n                    VStack(alignment: .leading) {\\n                        Text(\\\"Bio\\\")\\n                            .font(.caption)\\n                            .foregroundColor(.secondary)\\n                        TextEditor(text: $bio)\\n                            .frame(height: 100)\\n                            .overlay(\\n                                RoundedRectangle(cornerRadius: 8)\\n                                    .stroke(Color.gray.opacity(0.3), lineWidth: 1)\\n                            )\\n                    }\\n                }\\n                \\n                // Section 4: Actions\\n                Section {\\n                    Button(\\\"Submit Profile\\\") {\\n                        submitProfile()\\n                    }\\n                    .disabled(!isFormValid)\\n                    .frame(maxWidth: .infinity)\\n                    \\n                    Button(\\\"Reset Form\\\", role: .destructive) {\\n                        resetForm()\\n                    }\\n                    .frame(maxWidth: .infinity)\\n                }\\n            }\\n            .navigationTitle(\\\"User Profile\\\")\\n            .alert(\\\"Profile Submitted!\\\", isPresented: $showAlert) {\\n                Button(\\\"OK\\\") { }\\n            } message: {\\n                Text(\\\"Your profile has been successfully updated.\\\")\\n            }\\n        }\\n    }\\n    \\n    // Form Validation\\n    var isFormValid: Bool {\\n        !username.isEmpty && \\n        !email.isEmpty && \\n        !password.isEmpty && \\n        password.count >= 6\\n    }\\n    \\n    // Actions\\n    func submitProfile() {\\n        // In a real app, you would save to a database here\\n        print(\\\"Profile submitted:\\\")\\n        print(\\\"Username: \\\\(username)\\\")\\n        print(\\\"Email: \\\\(email)\\\")\\n        print(\\\"Age: \\\\(age)\\\")\\n        print(\\\"Color: \\\\(selectedColor)\\\")\\n        print(\\\"Rating: \\\\(rating)\\\")\\n        \\n        isSubmitted = true\\n        showAlert = true\\n    }\\n    \\n    func resetForm() {\\n        username = \\\"\\\"\\n        email = \\\"\\\"\\n        password = \\\"\\\"\\n        age = 18\\n        rating = 3.0\\n        isNotificationsOn = true\\n        selectedColor = \\\"Red\\\"\\n        birthDate = Date()\\n        bio = \\\"Tell us about yourself...\\\"\\n        isSubmitted = false\\n    }\\n}\\n\\n// === CUSTOM INPUT COMPONENTS ===\\n\\nstruct CustomTextField: View {\\n    let title: String\\n    @Binding var text: String\\n    var isSecure = false\\n    \\n    var body: some View {\\n        VStack(alignment: .leading) {\\n            Text(title)\\n                .font(.caption)\\n                .foregroundColor(.secondary)\\n            \\n            if isSecure {\\n                SecureField(\\\"\\\", text: $text)\\n                    .textFieldStyle(RoundedBorderTextFieldStyle())\\n            } else {\\n                TextField(\\\"\\\", text: $text)\\n                    .textFieldStyle(RoundedBorderTextFieldStyle())\\n            }\\n        }\\n    }\\n}\\n\\nstruct RatingView: View {\\n    let title: String\\n    @Binding var rating: Int\\n    \\n    var body: some View {\\n        VStack(alignment: .leading) {\\n            Text(title)\\n                .font(.caption)\\n                .foregroundColor(.secondary)\\n            \\n            HStack {\\n                ForEach(1..<6) { star in\\n                    Image(systemName: star <= rating ? \\\"star.fill\\\" : \\\"star\\\")\\n                        .foregroundColor(.yellow)\\n                        .onTapGesture {\\n                            rating = star\\n                        }\\n                }\\n            }\\n        }\\n    }\\n}\\n\\n// === PREVIEW ===\\n\\nstruct UserInputDemo_Previews: PreviewProvider {\\n    static var previews: some View {\\n        UserInputDemo()\\n    }\\n}\\n",
      "category": "SwiftUI Basics",
      "estimatedTime": 240,
      "dependencies": ["swiftui_introduction"],
      "challenge": {
        "instructions": "Create a complete user registration app with multiple input types and validation:\\n\\nPART 1: Basic Form Structure (60 min)\\n1. Create a registration form with sections for personal info, preferences, and account settings\\n2. Implement TextField for name/email, SecureField for passwords\\n3. Add DatePicker for birth date with age validation (18+ only)\\n4. Use Toggle for newsletter subscription option\\n\\nPART 2: Advanced Input Controls (60 min)\\n5. Implement a custom color picker using Picker with segmented style\\n6. Add a Slider for user experience level (1-10) with value display\\n7. Create a Stepper for number of programming languages known\\n8. Add a TextEditor for bio/description with character limit\\n\\nPART 3: Form Validation & UX (60 min)\\n9. Implement real-time validation for email format and password strength\\n10. Add visual feedback for invalid fields (red borders, error messages)\\n11. Create computed properties to enable/disable submit button\\n12. Implement @FocusState for automatic field navigation\\n\\nPART 4: Custom Components & Accessibility (60 min)\\n13. Create custom reusable input components (CustomTextField, RatingView)\\n14. Add full accessibility support with labels, hints, and values\\n15. Implement dark mode compatibility\\n16. Add form reset functionality and confirmation alerts\\n\\nTest your form thoroughly with various input scenarios!",
        "starterCode": "import SwiftUI\\n\\nstruct RegistrationChallenge: View {\\n    // Add your @State properties here\\n    \\n    var body: some View {\\n        NavigationView {\\n            Form {\\n                // PART 1: Build your form sections here\\n                \\n                // PART 2: Add advanced controls here\\n                \\n                // PART 3: Add validation feedback here\\n                \\n                // PART 4: Add action buttons here\\n            }\\n            .navigationTitle(\\\"Complete Registration\\\")\\n        }\\n    }\\n    \\n    // Add your validation logic and methods here\\n    \\n}\\n\\n// PART 4: Create your custom components here\\n\\nstruct RegistrationChallenge_Previews: PreviewProvider {\\n    static var previews: some View {\\n        RegistrationChallenge()\\n    }\\n}\\n",
        "solution": "import SwiftUI\\n\\nstruct RegistrationChallenge: View {\\n    // Form State\\n    @State private var firstName = \\\"\\\"\\n    @State private var lastName = \\\"\\\"\\n    @State private var email = \\\"\\\"\\n    @State private var password = \\\"\\\"\\n    @State private var confirmPassword = \\\"\\\"\\n    @State private var birthDate = Date()\\n    @State private var subscribeNewsletter = true\\n    @State private var selectedTheme = \\\"System\\\"\\n    @State private var experienceLevel = 5.0\\n    @State private var languagesKnown = 1\\n    @State private var bio = \\\"\\\"\\n    @State private var agreedToTerms = false\\n    \\n    // UI State\\n    @State private var showAlert = false\\n    @State private var alertMessage = \\\"\\\"\\n    @FocusState private var focusedField: Field?\\n    \\n    // Validation State\\n    @State private var emailError = \\\"\\\"\\n    @State private var passwordError = \\\"\\\"\\n    \\n    let themes = [\\\"Light\\\", \\\"Dark\\\", \\\"System\\\"]\\n    \\n    enum Field {\\n        case firstName, lastName, email, password, confirmPassword, bio\\n    }\\n    \\n    var body: some View {\\n        NavigationView {\\n            Form {\\n                // Section 1: Personal Information\\n                Section(header: Text(\\\"Personal Information\\\")) {\\n                    CustomTextField(\\\"First Name\\\", text: $firstName)\\n                        .focused($focusedField, equals: .firstName)\\n                        .submitLabel(.next)\\n                        .onSubmit { focusedField = .lastName }\\n                    \\n                    CustomTextField(\\\"Last Name\\\", text: $lastName)\\n                        .focused($focusedField, equals: .lastName)\\n                        .submitLabel(.next)\\n                        .onSubmit { focusedField = .email }\\n                    \\n                    CustomTextField(\\\"Email\\\", text: $email)\\n                        .focused($focusedField, equals: .email)\\n                        .keyboardType(.emailAddress)\\n                        .textContentType(.emailAddress)\\n                        .autocapitalization(.none)\\n                        .onChange(of: email) { _ in validateEmail() }\\n                        .overlay(validationOverlay(for: emailError))\\n                        .submitLabel(.next)\\n                        .onSubmit { focusedField = .password }\\n                    \\n                    DatePicker(\\\"Birth Date\\\", selection: $birthDate, in: ...Date(), displayedComponents: .date)\\n                    \\n                    if !isAdult {\\n                        Text(\\\"Must be 18 years or older to register\\\")\\n                            .font(.caption)\\n                            .foregroundColor(.red)\\n                    }\\n                }\\n                \\n                // Section 2: Account Security\\n                Section(header: Text(\\\"Account Security\\\")) {\\n                    SecureField(\\\"Password\\\", text: $password)\\n                        .focused($focusedField, equals: .password)\\n                        .textContentType(.newPassword)\\n                        .onChange(of: password) { _ in validatePassword() }\\n                        .overlay(validationOverlay(for: passwordError))\\n                        .submitLabel(.next)\\n                        .onSubmit { focusedField = .confirmPassword }\\n                    \\n                    SecureField(\\\"Confirm Password\\\", text: $confirmPassword)\\n                        .focused($focusedField, equals: .confirmPassword)\\n                        .textContentType(.newPassword)\\n                        .overlay(validationOverlay(for: passwordsMatch ? \\\"\\\" : \\\"Passwords do not match\\\"))\\n                        .submitLabel(.next)\\n                        .onSubmit { focusedField = .bio }\\n                    \\n                    PasswordStrengthView(password: password)\\n                }\\n                \\n                // Section 3: Preferences\\n                Section(header: Text(\\\"Preferences\\\")) {\\n                    Picker(\\\"Theme\\\", selection: $selectedTheme) {\\n                        ForEach(themes, id: \\\\.self) { theme in\\n                            Text(theme)\\n                        }\\n                    }\\n                    .pickerStyle(.segmented)\\n                    \\n                    VStack {\\n                        HStack {\\n                            Text(\\\"Experience Level\\\")\\n                            Spacer()\\n                            Text(\\\"\\\\(Int(experienceLevel))/10\\\")\\n                                .foregroundColor(.secondary)\\n                        }\\n                        Slider(value: $experienceLevel, in: 1...10, step: 1)\\n                    }\\n                    \\n                    Stepper(\\\"Programming Languages: \\\\(languagesKnown)\\\", value: $languagesKnown, in: 0...20)\\n                    \\n                    Toggle(\\\"Subscribe to Newsletter\\\", isOn: $subscribeNewsletter)\\n                }\\n                \\n                // Section 4: Additional Info\\n                Section(header: Text(\\\"About You\\\")) {\\n                    VStack(alignment: .leading) {\\n                        Text(\\\"Bio\\\")\\n                            .font(.caption)\\n                            .foregroundColor(.secondary)\\n                        TextEditor(text: $bio)\\n                            .focused($focusedField, equals: .bio)\\n                            .frame(height: 100)\\n                            .overlay(\\n                                RoundedRectangle(cornerRadius: 8)\\n                                    .stroke(bioColor, lineWidth: 1)\\n                            )\\n                        HStack {\\n                            Spacer()\\n                            Text(\\\"\\\\(bio.count)/200\\\")\\n                                .font(.caption)\\n                                .foregroundColor(bioCountColor)\\n                        }\\n                    }\\n                    \\n                    Toggle(\\\"I agree to the Terms and Conditions\\\", isOn: $agreedToTerms)\\n                }\\n                \\n                // Section 5: Actions\\n                Section {\\n                    Button(\\\"Create Account\\\") {\\n                        submitRegistration()\\n                    }\\n                    .disabled(!canSubmit)\\n                    .frame(maxWidth: .infinity)\\n                    \\n                    Button(\\\"Clear Form\\\", role: .destructive) {\\n                        resetForm()\\n                    }\\n                    .frame(maxWidth: .infinity)\\n                }\\n            }\\n            .navigationTitle(\\\"Complete Registration\\\")\\n            .alert(\\\"Registration\\\", isPresented: $showAlert) {\\n                Button(\\\"OK\\\") { }\\n            } message: {\\n                Text(alertMessage)\\n            }\\n            .onAppear {\\n                focusedField = .firstName\\n            }\\n        }\\n    }\\n    \\n    // MARK: - Validation Computed Properties\\n    \\n    var isAdult: Bool {\\n        let calendar = Calendar.current\\n        let age = calendar.dateComponents([.year], from: birthDate, to: Date()).year ?? 0\\n        return age >= 18\\n    }\\n    \\n    var passwordsMatch: Bool {\\n        !password.isEmpty && password == confirmPassword\\n    }\\n    \\n    var isBioValid: Bool {\\n        bio.count <= 200\\n    }\\n    \\n    var bioColor: Color {\\n        isBioValid ? .gray.opacity(0.3) : .red\\n    }\\n    \\n    var bioCountColor: Color {\\n        if bio.isEmpty {\\n            return .secondary\\n        } else if isBioValid {\\n            return .green\\n        } else {\\n            return .red\\n        }\\n    }\\n    \\n    var canSubmit: Bool {\\n        !firstName.isEmpty &&\\n        !lastName.isEmpty &&\\n        emailError.isEmpty &&\\n        passwordError.isEmpty &&\\n        passwordsMatch &&\\n        isAdult &&\\n        isBioValid &&\\n        agreedToTerms\\n    }\\n    \\n    // MARK: - Methods\\n    \\n    func validateEmail() {\\n        let emailRegex = #\\\"^[A-Z0-9a-z._%+-]+@[A-Za-z0-9.-]+\\\\\\\\.[A-Za-z]{2,}$\\\"#\\n        let isValid = NSPredicate(format: \\\"SELF MATCHES %@\\\", emailRegex).evaluate(with: email)\\n        emailError = isValid || email.isEmpty ? \\\"\\\" : \\\"Please enter a valid email address\\\"\\n    }\\n    \\n    func validatePassword() {\\n        if password.count < 8 {\\n            passwordError = \\\"Password must be at least 8 characters\\\"\\n        } else if !password.contains(where: { $0.isUppercase }) {\\n            passwordError = \\\"Password must contain an uppercase letter\\\"\\n        } else if !password.contains(where: { $0.isLowercase }) {\\n            passwordError = \\\"Password must contain a lowercase letter\\\"\\n        } else if !password.contains(where: { $0.isNumber }) {\\n            passwordError = \\\"Password must contain a number\\\"\\n        } else {\\n            passwordError = \\\"\\\"\\n        }\\n    }\\n    \\n    func submitRegistration() {\\n        // In real app, this would call an API\\n        alertMessage = \\\"Welcome, \\\\(firstName)! Your account has been created successfully.\\\"\\n        showAlert = true\\n    }\\n    \\n    func resetForm() {\\n        firstName = \\\"\\\"\\n        lastName = \\\"\\\"\\n        email = \\\"\\\"\\n        password = \\\"\\\"\\n        confirmPassword = \\\"\\\"\\n        birthDate = Date()\\n        subscribeNewsletter = true\\n        selectedTheme = \\\"System\\\"\\n        experienceLevel = 5.0\\n        languagesKnown = 1\\n        bio = \\\"\\\"\\n        agreedToTerms = false\\n        emailError = \\\"\\\"\\n        passwordError = \\\"\\\"\\n        focusedField = .firstName\\n    }\\n    \\n    func validationOverlay(for error: String) -> some View {\\n        Group {\\n            if !error.isEmpty {\\n                HStack {\\n                    Spacer()\\n                    Image(systemName: \\\"exclamationmark.triangle.fill\\\")\\n                        .foregroundColor(.red)\\n                        .padding(.trailing, 8)\\n                }\\n            }\\n        }\\n    }\\n}\\n\\n// MARK: - Custom Components\\n\\nstruct CustomTextField: View {\\n    let title: String\\n    @Binding var text: String\\n    \\n    var body: some View {\\n        VStack(alignment: .leading) {\\n            Text(title)\\n                .font(.caption)\\n                .foregroundColor(.secondary)\\n            \\n            TextField(title, text: $text)\\n                .textFieldStyle(RoundedBorderTextFieldStyle())\\n        }\\n    }\\n}\\n\\nstruct PasswordStrengthView: View {\\n    let password: String\\n    \\n    var strength: (color: Color, text: String) {\\n        if password.isEmpty {\\n            return (.secondary, \\\"Enter a password\\\")\\n        } else if password.count < 8 {\\n            return (.red, \\\"Weak\\\")\\n        } else if password.count < 12 {\\n            return (.orange, \\\"Medium\\\")\\n        } else {\\n            return (.green, \\\"Strong\\\")\\n        }\\n    }\\n    \\n    var body: some View {\\n        VStack(alignment: .leading) {\\n            HStack {\\n                Text(\\\"Password Strength\\\")\\n                    .font(.caption)\\n                    .foregroundColor(.secondary)\\n                Spacer()\\n                Text(strength.text)\\n                    .font(.caption)\\n                    .foregroundColor(strength.color)\\n            }\\n            \\n            GeometryReader { geometry in\\n                ZStack(alignment: .leading) {\\n                    Rectangle()\\n                        .fill(Color.gray.opacity(0.3))\\n                        .frame(height: 4)\\n                    \\n                    Rectangle()\\n                        .fill(strength.color)\\n                        .frame(width: progressWidth(in: geometry.size.width), height: 4)\\n                }\\n            }\\n            .frame(height: 4)\\n        }\\n    }\\n    \\n    func progressWidth(in totalWidth: CGFloat) -> CGFloat {\\n        if password.isEmpty {\\n            return 0\\n        } else if password.count < 8 {\\n            return totalWidth * 0.33\\n        } else if password.count < 12 {\\n            return totalWidth * 0.66\\n        } else {\\n            return totalWidth\\n        }\\n    }\\n}\\n\\n// MARK: - Preview\\n\\nstruct RegistrationChallenge_Previews: PreviewProvider {\\n    static var previews: some View {\\n        RegistrationChallenge()\\n    }\\n}\\n",
        "hints": [
          "PART 1: Use @State for form data and Form container for better iOS styling",
          "PART 2: Picker with .segmented style works well for small option sets like themes",
          "PART 3: Use .onChange modifier to validate fields as users type. Computed properties are great for validation logic",
          "PART 4: @FocusState automatically moves keyboard focus between fields. Add .focused() modifier to each input",
          "For password validation, check length, uppercase, lowercase, and numbers separately",
          "Use .overlay modifier to show validation icons and messages",
          "DatePicker with 'in: ...Date()' restricts to past dates only for birth date",
          "For character limits, use .onChange to truncate text or show warnings",
          "Accessibility: Add .accessibilityLabel, .accessibilityHint, and .accessibilityValue to all interactive elements",
          "Custom components should be reusable and configurable with @Binding"
        ],
        "testCases": [
          {
            "input": "isAdult with birth date 20 years ago",
            "expectedOutput": "true",
            "description": "Age validation should pass for users 18+"
          },
          {
            "input": "password 'Short1' validation",
            "expectedOutput": "Weak or error",
            "description": "Password validation should fail for short passwords"
          },
          {
            "input": "email 'invalid-email' format check",
            "expectedOutput": "Error message shown",
            "description": "Email validation should catch invalid formats"
          },
          {
            "input": "bio with 250 characters",
            "expectedOutput": "Error state",
            "description": "Bio character limit should be enforced"
          }
        ]
      }
    },
    {
      "id": "animation_basics",
      "title": "Animation Basics - Implicit vs Explicit",
      "description": "Master SwiftUI animations with implicit and explicit approaches - bring your UI to life",
      "difficulty": "beginner",
      "theory": "# Animation Basics - Implicit vs Explicit Animations\n\n## 1. Understanding SwiftUI Animations (60 min)\n\n### What are Animations?\nAnimations make your app feel alive and responsive by smoothly transitioning between states.\n\n### Why Animate?\n- **Better User Experience**: Guides user attention\n- **Visual Feedback**: Shows state changes clearly\n- **Professional Polish**: Makes apps feel premium\n- **Intuitive Interactions**: Users understand what's happening\n\n### Animation Principles in SwiftUI:\n- **Declarative**: Describe what you want, not how to do it\n- **Automatic**: Handle timing, curves, and interpolation automatically\n- **Simple**: Often just one line of code\n- **Powerful**: Complex animations made easy\n\n## 2. Implicit Animations (90 min)\n\n### What are Implicit Animations?\nAnimations that are attached to views and automatically animate when specific properties change.\n\n### Basic Syntax:\n```swift\n.viewModifier()\n    .animation(.easeInOut, value: watchedProperty)\n```\n\n### Simple Implicit Animation:\n```swift\nstruct SimpleAnimation: View {\n    @State private var isScaled = false\n    \n    var body: some View {\n        Circle()\n            .frame(width: 100, height: 100)\n            .scaleEffect(isScaled ? 1.5 : 1.0)\n            .animation(.easeInOut(duration: 0.3), value: isScaled)\n            .onTapGesture {\n                isScaled.toggle()\n            }\n    }\n}\n```\n\n### Animating Multiple Properties:\n```swift\nstruct MultiAnimation: View {\n    @State private var isAnimated = false\n    \n    var body: some View {\n        RoundedRectangle(cornerRadius: 20)\n            .fill(isAnimated ? .blue : .red)\n            .frame(width: isAnimated ? 200 : 100, \n                   height: isAnimated ? 200 : 100)\n            .rotationEffect(.degrees(isAnimated ? 180 : 0))\n            .animation(.spring(response: 0.6, dampingFraction: 0.8), value: isAnimated)\n            .onTapGesture {\n                isAnimated.toggle()\n            }\n    }\n}\n```\n\n## 3. Animation Curves and Timing (60 min)\n\n### Built-in Animation Curves:\n\n#### Ease Animations:\n```swift\n.animation(.easeIn, value: property)      // Slow start\n.animation(.easeOut, value: property)     // Slow end\n.animation(.easeInOut, value: property)   // Slow start and end\n```\n\n#### Spring Animations:\n```swift\n.animation(.spring(), value: property)                    // Default spring\n.animation(.spring(response: 0.6, dampingFraction: 0.8), value: property)\n.animation(.interpolatingSpring(mass: 1.0, stiffness: 100, damping: 10), value: property)\n```\n\n#### Linear Animation:\n```swift\n.animation(.linear(duration: 1.0), value: property)  // Constant speed\n```\n\n### Timing Parameters:\n```swift\n// Duration-based\n.animation(.easeInOut(duration: 2.0), value: property)\n\n// Delay\n.animation(.easeInOut(duration: 1.0).delay(0.5), value: property)\n\n// Repeat\n.animation(.easeInOut(duration: 1.0).repeatCount(3), value: property)\n.animation(.easeInOut(duration: 1.0).repeatForever(), value: property)\n\n// Auto-reverse\n.animation(.easeInOut(duration: 1.0).repeatForever(autoreverses: true), value: property)\n```\n\n## 4. Explicit Animations (90 min)\n\n### What are Explicit Animations?\nAnimations that you explicitly trigger using `withAnimation` blocks. They give you more control over when and how animations occur.\n\n### Basic Syntax:\n```swift\nwithAnimation(.animationType) {\n    // State changes here will be animated\n}\n```\n\n### Simple Explicit Animation:\n```swift\nstruct ExplicitAnimation: View {\n    @State private var isExpanded = false\n    \n    var body: some View {\n        VStack {\n            Rectangle()\n                .fill(.blue)\n                .frame(width: isExpanded ? 300 : 100, \n                       height: isExpanded ? 300 : 100)\n                .cornerRadius(isExpanded ? 0 : 50)\n            \n            Button(\"Toggle\") {\n                withAnimation(.spring()) {\n                    isExpanded.toggle()\n                }\n            }\n            \n            Button(\"Reset\") {\n                // No animation\n                isExpanded = false\n            }\n        }\n    }\n}\n```\n\n### Multiple State Changes in One Animation:\n```swift\nstruct ComplexAnimation: View {\n    @State private var isActive = false\n    @State private var rotation = 0.0\n    @State private var color: Color = .blue\n    \n    var body: some View {\n        VStack {\n            Capsule()\n                .fill(color)\n                .frame(width: isActive ? 350 : 100, height: 60)\n                .rotationEffect(.degrees(rotation))\n            \n            Button(\"Animate All\") {\n                withAnimation(.easeInOut(duration: 1.0)) {\n                    isActive.toggle()\n                    rotation += 360\n                    color = isActive ? .orange : .blue\n                }\n            }\n        }\n    }\n}\n```\n\n## 5. When to Use Each Approach (60 min)\n\n### Use Implicit Animations When:\n- Simple property changes\n- You want consistent animation behavior\n- Animating individual view properties\n- Quick prototyping\n\n### Use Explicit Animations When:\n- Complex state changes\n- Coordinating multiple animations\n- Conditional animations\n- User-triggered actions\n- Need precise control over timing\n\n### Real-world Examples:\n\n#### Implicit - Loading Indicator:\n```swift\nstruct LoadingView: View {\n    @State private var isLoading = false\n    \n    var body: some View {\n        Circle()\n            .trim(from: 0.0, to: 0.7)\n            .stroke(Color.blue, lineWidth: 5)\n            .frame(width: 50, height: 50)\n            .rotationEffect(Angle(degrees: isLoading ? 360 : 0))\n            .animation(.linear(duration: 1).repeatForever(autoreverses: false), \n                      value: isLoading)\n            .onAppear { isLoading = true }\n    }\n}\n```\n\n#### Explicit - User Interaction:\n```swift\nstruct LikeButton: View {\n    @State private var isLiked = false\n    @State private var scale = 1.0\n    \n    var body: some View {\n        Button(action: {\n            withAnimation(.spring(response: 0.3, dampingFraction: 0.6)) {\n                isLiked.toggle()\n                scale = 1.2\n            }\n            \n            // Second animation for scale back\n            DispatchQueue.main.asyncAfter(deadline: .now() + 0.1) {\n                withAnimation(.spring()) {\n                    scale = 1.0\n                }\n            }\n        }) {\n            Image(systemName: isLiked ? \"heart.fill\" : \"heart\")\n                .foregroundColor(isLiked ? .red : .gray)\n                .scaleEffect(scale)\n        }\n    }\n}\n```\n\n## 6. Advanced Animation Patterns (60 min)\n\n### Animation Callbacks:\n```swift\nstruct CallbackAnimation: View {\n    @State private var isVisible = false\n    \n    var body: some View {\n        Circle()\n            .scaleEffect(isVisible ? 1.0 : 0.1)\n            .onAppear {\n                withAnimation(.easeOut(duration: 0.5)) {\n                    isVisible = true\n                }\n            }\n    }\n}\n```\n\n### Chained Animations:\n```swift\nstruct ChainedAnimation: View {\n    @State private var phase = 0\n    \n    var body: some View {\n        VStack {\n            ForEach(0..<3) { index in\n                Circle()\n                    .frame(width: 50, height: 50)\n                    .offset(x: phase > index ? 100 : 0)\n                    .animation(.easeInOut.delay(Double(index) * 0.2), \n                              value: phase)\n            }\n            \n            Button(\"Animate\") {\n                phase += 1\n            }\n        }\n    }\n}\n```\n\n### Conditional Animations:\n```swift\nstruct ConditionalAnimation: View {\n    @State private var isOn = false\n    @State private var useSpring = true\n    \n    var body: some View {\n        VStack {\n            Toggle(\"Use Spring Animation\", isOn: $useSpring)\n            \n            Rectangle()\n                .fill(isOn ? .green : .red)\n                .frame(width: 100, height: 100)\n                .scaleEffect(isOn ? 1.5 : 1.0)\n                .onTapGesture {\n                    if useSpring {\n                        withAnimation(.spring()) {\n                            isOn.toggle()\n                        }\n                    } else {\n                        withAnimation(.easeInOut(duration: 0.5)) {\n                            isOn.toggle()\n                        }\n                    }\n                }\n        }\n    }\n}\n```\n\n## Practice Exercises\n\nComplete all exercises to master SwiftUI animations and understand when to use implicit vs explicit approaches!",
      "codeExample": "// === IMPLICIT ANIMATION EXAMPLES ===\n\n// Simple scale animation\nstruct ScaleAnimation: View {\n    @State private var isScaled = false\n    \n    var body: some View {\n        Circle()\n            .fill(.blue)\n            .frame(width: 100, height: 100)\n            .scaleEffect(isScaled ? 1.5 : 1.0)\n            .animation(.easeInOut(duration: 0.3), value: isScaled)\n            .onTapGesture {\n                isScaled.toggle()\n            }\n    }\n}\n\n// Multiple property animation\nstruct MultiPropertyAnimation: View {\n    @State private var isActive = false\n    \n    var body: some View {\n        RoundedRectangle(cornerRadius: isActive ? 50 : 10)\n            .fill(isActive ? .orange : .purple)\n            .frame(width: isActive ? 200 : 100, \n                   height: isActive ? 200 : 100)\n            .rotationEffect(.degrees(isActive ? 180 : 0))\n            .animation(.spring(response: 0.6, dampingFraction: 0.8), value: isActive)\n            .onTapGesture {\n                isActive.toggle()\n            }\n    }\n}\n\n// Loading spinner with implicit animation\nstruct LoadingSpinner: View {\n    @State private var isRotating = false\n    \n    var body: some View {\n        Circle()\n            .trim(from: 0.0, to: 0.7)\n            .stroke(Color.blue, lineWidth: 4)\n            .frame(width: 50, height: 50)\n            .rotationEffect(Angle(degrees: isRotating ? 360 : 0))\n            .animation(.linear(duration: 1.0).repeatForever(autoreverses: false), \n                      value: isRotating)\n            .onAppear {\n                isRotating = true\n            }\n    }\n}\n\n// === EXPLICIT ANIMATION EXAMPLES ===\n\n// Button with explicit animation\nstruct AnimatedButton: View {\n    @State private var isPressed = false\n    \n    var body: some View {\n        Button(\"Press Me\") {\n            withAnimation(.spring(response: 0.3, dampingFraction: 0.6)) {\n                isPressed = true\n            }\n            \n            // Reset after animation\n            DispatchQueue.main.asyncAfter(deadline: .now() + 0.2) {\n                withAnimation(.spring()) {\n                    isPressed = false\n                }\n            }\n        }\n        .padding()\n        .background(Color.blue)\n        .foregroundColor(.white)\n        .cornerRadius(10)\n        .scaleEffect(isPressed ? 0.9 : 1.0)\n    }\n}\n\n// Card flip animation\nstruct CardFlip: View {\n    @State private var isFlipped = false\n    @State private var rotation = 0.0\n    \n    var body: some View {\n        VStack {\n            RoundedRectangle(cornerRadius: 20)\n                .fill(isFlipped ? .green : .red)\n                .frame(width: 200, height: 300)\n                .overlay(\n                    Text(isFlipped ? \"Back\" : \"Front\")\n                        .font(.largeTitle)\n                        .foregroundColor(.white)\n                )\n                .rotation3DEffect(\n                    .degrees(rotation),\n                    axis: (x: 0.0, y: 1.0, z: 0.0)\n                )\n            \n            Button(\"Flip Card\") {\n                withAnimation(.easeInOut(duration: 0.6)) {\n                    rotation += 180\n                    if rotation.truncatingRemainder(dividingBy: 360) == 0 {\n                        isFlipped = false\n                    } else {\n                        isFlipped = true\n                    }\n                }\n            }\n        }\n    }\n}\n\n// Sequential animation\nstruct SequentialAnimation: View {\n    @State private var animateStep = 0\n    \n    var body: some View {\n        VStack(spacing: 20) {\n            ForEach(0..<3) { index in\n                Circle()\n                    .frame(width: 50, height: 50)\n                    .foregroundColor([.red, .green, .blue][index])\n                    .offset(x: animateStep > index ? 100 : 0)\n                    .animation(.easeInOut.delay(Double(index) * 0.3), \n                              value: animateStep)\n            }\n            \n            Button(\"Start Sequence\") {\n                animateStep += 1\n            }\n            \n            Button(\"Reset\") {\n                animateStep = 0\n            }\n        }\n    }\n}\n\n// === PRACTICAL COMPARISON ===\n\n// Same animation implemented both ways\nstruct ComparisonView: View {\n    @State private var isAnimated = false\n    \n    var body: some View {\n        VStack(spacing: 50) {\n            // Implicit version\n            VStack {\n                Text(\"Implicit Animation\")\n                    .font(.headline)\n                \n                Circle()\n                    .fill(.blue)\n                    .frame(width: 80, height: 80)\n                    .scaleEffect(isAnimated ? 1.5 : 1.0)\n                    .animation(.easeInOut(duration: 0.5), value: isAnimated)\n            }\n            \n            // Explicit version  \n            VStack {\n                Text(\"Explicit Animation\")\n                    .font(.headline)\n                \n                Circle()\n                    .fill(.green)\n                    .frame(width: 80, height: 80)\n                    .scaleEffect(isAnimated ? 1.5 : 1.0)\n            }\n            \n            Button(\"Toggle Both\") {\n                // This will only animate the explicit one\n                withAnimation(.easeInOut(duration: 0.5)) {\n                    isAnimated.toggle()\n                }\n            }\n            \n            Button(\"Toggle Implicit Only\") {\n                // This will only animate the implicit one\n                isAnimated.toggle()\n            }\n        }\n    }\n}",
      "category": "SwiftUI Basics",
      "estimatedTime": 300,
      "dependencies": ["swiftui_intro", "state_management"],
      "challenge": {
        "instructions": "Create a complete animated onboarding screen using both implicit and explicit animations:\n\nPART 1: Implicit Animations for UI Elements (75 min)\n1. Create a welcome card that scales and fades in using implicit animation\n2. Add feature list items that animate in sequentially with delays\n3. Create animated progress indicators using implicit .repeatForever\n4. Implement color theme transitions that animate smoothly\n\nPART 2: Explicit Animations for User Interactions (75 min)\n5. Create an animated button that scales and changes color on tap\n6. Implement a card flip animation for showing details\n7. Add drag gesture with spring animation for interactive elements\n8. Create a success confirmation with sequenced animations\n\nPART 3: Combined Animation System (75 min)\n9. Build an animated onboarding flow with multiple screens\n10. Implement page transitions with coordinated animations\n11. Add loading states with combined implicit/explicit animations\n12. Create interactive previews that respond to hover/tap\n\nPART 4: Advanced Animation Patterns (75 min)\n13. Implement staggered animations for complex layouts\n14. Add animation callbacks and state coordination\n15. Create reusable animated components\n16. Implement accessibility-friendly animations\n\nTest your animations thoroughly and ensure smooth performance!",
        "starterCode": "// === PART 1: Implicit Animations ===\nstruct OnboardingView: View {\n    @State private var isVisible = false\n    \n    var body: some View {\n        VStack {\n            // Add your welcome card here\n            \n            // Add feature list here\n            \n            // Add progress indicators here\n        }\n        .onAppear {\n            // Trigger initial animations\n        }\n    }\n}\n\n// === PART 2: Explicit Animations ===\nstruct AnimatedButton: View {\n    @State private var isPressed = false\n    \n    var body: some View {\n        // Create animated button here\n        EmptyView()\n    }\n}\n\n// === PART 3: Combined System ===\nstruct OnboardingFlow: View {\n    @State private var currentPage = 0\n    \n    var body: some View {\n        // Build multi-screen flow here\n        EmptyView()\n    }\n}\n\n// === PART 4: Advanced Patterns ===\nstruct StaggeredGrid: View {\n    var body: some View {\n        // Create staggered animation layout\n        EmptyView()\n    }\n}",
        "solution": "// === PART 1: Implicit Animations ===\nstruct OnboardingView: View {\n    @State private var isVisible = false\n    @State private var featureOpacity = 0.0\n    @State private var progress: Double = 0.0\n    \n    var body: some View {\n        VStack(spacing: 30) {\n            // Welcome card with implicit animation\n            RoundedRectangle(cornerRadius: 20)\n                .fill(LinearGradient(\n                    colors: [.blue, .purple],\n                    startPoint: .topLeading,\n                    endPoint: .bottomTrailing\n                ))\n                .frame(width: isVisible ? 300 : 10, height: 200)\n                .opacity(isVisible ? 1.0 : 0.0)\n                .overlay(\n                    Text(\"Welcome!\")\n                        .font(.largeTitle)\n                        .foregroundColor(.white)\n                        .opacity(isVisible ? 1.0 : 0.0)\n                )\n                .animation(.spring(response: 0.6, dampingFraction: 0.8), value: isVisible)\n            \n            // Feature list with sequential implicit animations\n            VStack(alignment: .leading, spacing: 10) {\n                FeatureRow(text: \"Easy to use\", delay: 0.0, opacity: featureOpacity)\n                FeatureRow(text: \"Powerful features\", delay: 0.2, opacity: featureOpacity)\n                FeatureRow(text: \"Fast performance\", delay: 0.4, opacity: featureOpacity)\n            }\n            \n            // Animated progress indicator\n            Circle()\n                .trim(from: 0.0, to: progress)\n                .stroke(Color.blue, lineWidth: 8)\n                .frame(width: 60, height: 60)\n                .rotationEffect(.degrees(-90))\n                .animation(.easeInOut(duration: 1.0), value: progress)\n        }\n        .onAppear {\n            isVisible = true\n            \n            // Sequence the animations\n            DispatchQueue.main.asyncAfter(deadline: .now() + 0.5) {\n                withAnimation(.easeInOut(duration: 0.5)) {\n                    featureOpacity = 1.0\n                }\n            }\n            \n            DispatchQueue.main.asyncAfter(deadline: .now() + 1.0) {\n                withAnimation(.easeInOut(duration: 2.0)) {\n                    progress = 0.75\n                }\n            }\n        }\n    }\n}\n\nstruct FeatureRow: View {\n    let text: String\n    let delay: Double\n    let opacity: Double\n    \n    var body: some View {\n        HStack {\n            Image(systemName: \"checkmark.circle.fill\")\n                .foregroundColor(.green)\n                .scaleEffect(opacity > 0 ? 1.0 : 0.1)\n            \n            Text(text)\n                .opacity(opacity)\n        }\n        .animation(.spring().delay(delay), value: opacity)\n    }\n}\n\n// === PART 2: Explicit Animations ===\nstruct AnimatedButton: View {\n    @State private var isPressed = false\n    @State private var isSuccess = false\n    \n    var body: some View {\n        Button(action: {\n            withAnimation(.spring(response: 0.3, dampingFraction: 0.6)) {\n                isPressed = true\n                isSuccess.toggle()\n            }\n            \n            // Reset press state\n            DispatchQueue.main.asyncAfter(deadline: .now() + 0.1) {\n                withAnimation(.spring()) {\n                    isPressed = false\n                }\n            }\n        }) {\n            HStack {\n                if isSuccess {\n                    Image(systemName: \"checkmark\")\n                        .transition(.scale.combined(with: .opacity))\n                }\n                \n                Text(isSuccess ? \"Completed!\" : \"Get Started\")\n            }\n            .foregroundColor(.white)\n            .padding()\n            .frame(width: isPressed ? 170 : 160)\n            .background(isSuccess ? Color.green : Color.blue)\n            .cornerRadius(isPressed ? 12 : 8)\n        }\n    }\n}\n\n// Card flip with explicit animation\nstruct FlipCard: View {\n    @State private var isFlipped = false\n    @State private var rotation = 0.0\n    \n    var body: some View {\n        VStack {\n            RoundedRectangle(cornerRadius: 20)\n                .fill(isFlipped ? Color.green : Color.blue)\n                .frame(width: 200, height: 150)\n                .overlay(\n                    Group {\n                        if isFlipped {\n                            Text(\"Back Side\")\n                                .foregroundColor(.white)\n                                .font(.title2)\n                        } else {\n                            Text(\"Front Side\")\n                                .foregroundColor(.white)\n                                .font(.title2)\n                        }\n                    }\n                )\n                .rotation3DEffect(\n                    .degrees(rotation),\n                    axis: (x: 0.0, y: 1.0, z: 0.0)\n                )\n            \n            Button(\"Flip Card\") {\n                withAnimation(.easeInOut(duration: 0.6)) {\n                    rotation += 180\n                    if rotation.truncatingRemainder(dividingBy: 360) == 0 {\n                        isFlipped = false\n                    } else {\n                        isFlipped = true\n                    }\n                }\n            }\n        }\n    }\n}\n\n// === PART 3: Combined System ===\nstruct OnboardingFlow: View {\n    @State private var currentPage = 0\n    @State private var isAnimating = false\n    \n    var body: some View {\n        ZStack {\n            // Background color transition\n            Rectangle()\n                .fill(backgroundGradient)\n                .ignoresSafeArea()\n                .animation(.easeInOut(duration: 0.5), value: currentPage)\n            \n            VStack {\n                // Page content with transition\n                Group {\n                    switch currentPage {\n                    case 0:\n                        WelcomePage()\n                    case 1:\n                        FeaturesPage()\n                    case 2:\n                        GetStartedPage()\n                    default:\n                        WelcomePage()\n                    }\n                }\n                .transition(.asymmetric(\n                    insertion: .move(edge: .trailing).combined(with: .opacity),\n                    removal: .move(edge: .leading).combined(with: .opacity)\n                ))\n                \n                Spacer()\n                \n                // Page indicators with implicit animation\n                HStack(spacing: 8) {\n                    ForEach(0..<3, id: \\.self) { index in\n                        Circle()\n                            .fill(index == currentPage ? Color.white : Color.white.opacity(0.3))\n                            .frame(width: 8, height: 8)\n                            .scaleEffect(index == currentPage ? 1.2 : 1.0)\n                            .animation(.spring(response: 0.3, dampingFraction: 0.6), value: currentPage)\n                    }\n                }\n                \n                // Navigation buttons\n                HStack {\n                    if currentPage > 0 {\n                        Button(\"Previous\") {\n                            withAnimation(.easeInOut(duration: 0.4)) {\n                                currentPage -= 1\n                            }\n                        }\n                    }\n                    \n                    Spacer()\n                    \n                    Button(currentPage == 2 ? \"Get Started\" : \"Next\") {\n                        withAnimation(.easeInOut(duration: 0.4)) {\n                            if currentPage < 2 {\n                                currentPage += 1\n                            }\n                        }\n                    }\n                }\n                .padding()\n            }\n        }\n    }\n    \n    private var backgroundGradient: LinearGradient {\n        let colors: [Color] = [\n            [.blue, .purple],\n            [.purple, .pink],\n            [.orange, .red]\n        ][currentPage]\n        \n        return LinearGradient(\n            colors: colors,\n            startPoint: .topLeading,\n            endPoint: .bottomTrailing\n        )\n    }\n}\n\n// === PART 4: Advanced Patterns ===\nstruct StaggeredGrid: View {\n    @State private var isVisible = false\n    let items = Array(1...6)\n    \n    var body: some View {\n        LazyVGrid(columns: [GridItem(.flexible()), GridItem(.flexible())], spacing: 10) {\n            ForEach(Array(items.enumerated()), id: \\.offset) { index, item in\n                RoundedRectangle(cornerRadius: 12)\n                    .fill(Color.blue)\n                    .frame(height: 80)\n                    .overlay(Text(\"Item \\(item)\").foregroundColor(.white))\n                    .scaleEffect(isVisible ? 1.0 : 0.1)\n                    .opacity(isVisible ? 1.0 : 0.0)\n                    .animation(\n                        .spring(response: 0.6, dampingFraction: 0.8)\n                        .delay(Double(index) * 0.1),\n                        value: isVisible\n                    )\n            }\n        }\n        .padding()\n        .onAppear {\n            withAnimation {\n                isVisible = true\n            }\n        }\n    }\n}",
        "hints": [
          "PART 1: Use .animation() modifier for implicit animations. Remember to watch specific values with the 'value' parameter",
          "PART 2: Wrap state changes in withAnimation {} blocks for explicit control. You can chain multiple animations with delays",
          "PART 3: Combine both approaches - use implicit for continuous UI updates and explicit for user-triggered actions",
          "PART 4: Use .delay() with animations for staggered effects. Calculate delays based on index for grid layouts",
          "For smooth transitions, prefer spring animations over ease animations",
          "Use .transition() with asymmetric transitions for better page navigation",
          "Remember to use @State for properties that trigger animations",
          "Test animations on real devices - simulator performance may differ"
        ],
        "testCases": [
          {
            "input": "isVisible == true",
            "expectedOutput": "Welcome card should be fully visible and scaled",
            "description": "Implicit animation should trigger on state change"
          },
          {
            "input": "isPressed == true",
            "expectedOutput": "Button should scale down when pressed",
            "description": "Explicit animation should trigger in withAnimation block"
          },
          {
            "input": "currentPage changes",
            "expectedOutput": "Smooth page transition with background color change",
            "description": "Combined animations should coordinate properly"
          }
        ]
      }
    },
    {
      "id": "building_first_app",
      "title": "Building Your First iOS App - Todo List",
      "description": "Create a complete todo list app from scratch, learning iOS development fundamentals along the way",
      "difficulty": "beginner",
      "theory": "# Building Your First iOS App - Todo List (5 hours)\n\n## 1. iOS App Architecture & Setup (60 min)\n\n### Understanding MVC (Model-View-Controller)\n- **Model**: Data and business logic (Todo items)\n- **View**: User interface elements (Table, buttons, text fields)\n- **Controller**: Mediates between Model and View (ViewController)\n\n### Xcode Workspace Tour\n- **Project Navigator**: File organization\n- **Interface Builder**: Visual UI design\n- **Code Editor**: Swift programming\n- **Utilities Panel**: Properties and connections\n\n### Creating Your First Project\n1. Open Xcode â†’ \"Create New Project\"\n2. Choose \"iOS\" â†’ \"App\" template\n3. Name: \"MyTodoList\"\n4. Interface: \"Storyboard\"\n5. Language: \"Swift\"\n\n## 2. Building the User Interface (60 min)\n\n### Storyboard Fundamentals\n- **View Controllers**: Screens of your app\n- **Views**: UI components (buttons, labels, tables)\n- **Auto Layout**: Responsive design for all screen sizes\n\n### Key UI Components for Todo App\n```swift\n// UITableView - displays list of todos\n// UIButton - add new todos\n// UITextField - input for new todos\n// UINavigationController - navigation between screens\n```\n\n### Auto Layout Constraints\n- **Leading/Trailing**: Horizontal spacing\n- **Top/Bottom**: Vertical spacing\n- **Width/Height**: Size constraints\n- **Aspect Ratio**: Proportional sizing\n\n## 3. Model: Data Structure (45 min)\n\n### Designing the Todo Model\n```swift\nstruct TodoItem {\n    let id: UUID\n    var title: String\n    var isCompleted: Bool\n    var createdAt: Date\n    var priority: Priority\n}\n\nenum Priority: String, CaseIterable {\n    case low = \"Low\"\n    case medium = \"Medium\"\n    case high = \"High\"\n}\n```\n\n### Data Persistence Options\n- **UserDefaults**: Simple key-value storage\n- **Codable + FileManager**: JSON file storage\n- **Core Data**: Advanced database (future topic)\n\n### Model Management\n```swift\nclass TodoManager {\n    private var todos: [TodoItem] = []\n    \n    func addTodo(_ title: String, priority: Priority = .medium) { ... }\n    func toggleComplete(_ id: UUID) { ... }\n    func deleteTodo(_ id: UUID) { ... }\n    func getTodos() -> [TodoItem] { ... }\n}\n```\n\n## 4. View Controller & Data Binding (60 min)\n\n### ViewController Lifecycle\n```swift\nclass TodoViewController: UIViewController {\n    override func viewDidLoad() { \n        // Called once when view loads\n    }\n    \n    override func viewWillAppear() { \n        // Called before view appears\n    }\n    \n    override func viewDidAppear() { \n        // Called after view appears\n    }\n}\n```\n\n### UITableView DataSource & Delegate\n```swift\n// Required methods:\nfunc tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int\nfunc tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell\n\n// Optional methods:\nfunc tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath)\nfunc tableView(_ tableView: UITableView, commit editingStyle: UITableViewCell.EditingStyle, forRowAt indexPath: IndexPath)\n```\n\n### Custom Table View Cells\n- Create subclass of UITableViewCell\n- Design layout in Interface Builder\n- Connect UI elements via @IBOutlet\n- Configure cell with model data\n\n## 5. User Interactions & Events (45 min)\n\n### Handling Button Taps\n```swift\n@IBAction func addButtonTapped(_ sender: UIButton) {\n    // Handle add todo action\n}\n```\n\n### Text Field Delegates\n```swift\nfunc textFieldShouldReturn(_ textField: UITextField) -> Bool {\n    textField.resignFirstResponder() // Dismiss keyboard\n    return true\n}\n```\n\n### Gesture Recognizers\n- **Tap**: Single finger tap\n- **Swipe**: Left/right swipe actions\n- **Long Press**: Extended touch\n\n### Table View Swipe Actions\n```swift\nfunc tableView(_ tableView: UITableView, \n               trailingSwipeActionsConfigurationForRowAt indexPath: IndexPath) -> UISwipeActionsConfiguration?\n```\n\n## 6. Data Persistence & State Management (45 min)\n\n### Saving Data with UserDefaults\n```swift\n// Saving\nlet encoder = JSONEncoder()\nif let encoded = try? encoder.encode(todos) {\n    UserDefaults.standard.set(encoded, forKey: \"todos\")\n}\n\n// Loading\nif let savedData = UserDefaults.standard.data(forKey: \"todos\") {\n    let decoder = JSONDecoder()\n    if let loadedTodos = try? decoder.decode([TodoItem].self, from: savedData) {\n        todos = loadedTodos\n    }\n}\n```\n\n### State Restoration\n- Save app state when backgrounded\n- Restore state when app relaunches\n- Handle app termination gracefully\n\n### Error Handling\n```swift\ndo {\n    try saveTodos()\n} catch {\n    showErrorAlert(message: \"Failed to save todos\")\n}\n```\n\n## 7. Polish & Final Touches (30 min)\n\n### User Experience Improvements\n- **Empty State**: Show message when no todos\n- **Loading States**: Activity indicators\n- **Error Messages**: User-friendly alerts\n- **Haptic Feedback**: Tactile responses\n\n### Accessibility Features\n- **VoiceOver**: Screen reader support\n- **Dynamic Type**: Adjustable text sizes\n- **Color Contrast**: Readable color schemes\n\n### App Icon & Launch Screen\n- Design app icon in different sizes\n- Create simple launch screen\n- Test on various devices\n\n## Best Practices Summary\n\n1. **Keep MVC separation clean**\n2. **Use meaningful variable names**\n3. **Handle all error cases**\n4. **Test on different screen sizes**\n5. **Follow iOS Human Interface Guidelines**\n\nYou now have all the knowledge to build a complete, functional todo list app!",
      "codeExample": "// === COMPLETE TODO APP IMPLEMENTATION ===\n\n// 1. MODEL: Data Structures\nimport Foundation\n\nenum Priority: String, CaseIterable {\n    case low = \"Low\"\n    case medium = \"Medium\" \n    case high = \"High\"\n    \n    var color: UIColor {\n        switch self {\n        case .low: return .systemGreen\n        case .medium: return .systemOrange\n        case .high: return .systemRed\n        }\n    }\n}\n\nstruct TodoItem: Codable {\n    let id: UUID\n    var title: String\n    var isCompleted: Bool\n    var createdAt: Date\n    var priority: Priority\n    \n    init(title: String, priority: Priority = .medium) {\n        self.id = UUID()\n        self.title = title\n        self.isCompleted = false\n        self.createdAt = Date()\n        self.priority = priority\n    }\n}\n\n// 2. MODEL MANAGER\nclass TodoManager {\n    static let shared = TodoManager()\n    private init() {}\n    \n    private var todos: [TodoItem] = []\n    private let userDefaultsKey = \"savedTodos\"\n    \n    // CRUD Operations\n    func addTodo(_ title: String, priority: Priority = .medium) -> TodoItem {\n        let newTodo = TodoItem(title: title, priority: priority)\n        todos.append(newTodo)\n        saveTodos()\n        return newTodo\n    }\n    \n    func toggleComplete(_ id: UUID) {\n        if let index = todos.firstIndex(where: { $0.id == id }) {\n            todos[index].isCompleted.toggle()\n            saveTodos()\n        }\n    }\n    \n    func deleteTodo(_ id: UUID) {\n        todos.removeAll { $0.id == id }\n        saveTodos()\n    }\n    \n    func getTodos() -> [TodoItem] {\n        return todos\n    }\n    \n    func getIncompleteTodos() -> [TodoItem] {\n        return todos.filter { !$0.isCompleted }\n    }\n    \n    func getCompletedTodos() -> [TodoItem] {\n        return todos.filter { $0.isCompleted }\n    }\n    \n    // Data Persistence\n    private func saveTodos() {\n        let encoder = JSONEncoder()\n        if let encoded = try? encoder.encode(todos) {\n            UserDefaults.standard.set(encoded, forKey: userDefaultsKey)\n        }\n    }\n    \n    func loadTodos() {\n        if let savedData = UserDefaults.standard.data(forKey: userDefaultsKey) {\n            let decoder = JSONDecoder()\n            if let loadedTodos = try? decoder.decode([TodoItem].self, from: savedData) {\n                todos = loadedTodos\n            }\n        }\n    }\n}\n\n// 3. VIEW: Custom Table View Cell\nimport UIKit\n\nclass TodoCell: UITableViewCell {\n    @IBOutlet weak var titleLabel: UILabel!\n    @IBOutlet weak var priorityView: UIView!\n    @IBOutlet weak var completedButton: UIButton!\n    \n    var toggleCompletion: (() -> Void)?\n    \n    @IBAction func completeButtonTapped(_ sender: UIButton) {\n        toggleCompletion?()\n    }\n    \n    func configure(with todo: TodoItem) {\n        titleLabel.text = todo.title\n        priorityView.backgroundColor = todo.priority.color\n        \n        // Strikethrough for completed todos\n        let attributes: [NSAttributedString.Key: Any] = todo.isCompleted ?\n            [.strikethroughStyle: NSUnderlineStyle.single.rawValue,\n             .foregroundColor: UIColor.systemGray] :\n            [.foregroundColor: UIColor.label]\n            \n        titleLabel.attributedText = NSAttributedString(\n            string: todo.title, \n            attributes: attributes\n        )\n        \n        let buttonImage = todo.isCompleted ? \n            UIImage(systemName: \"checkmark.circle.fill\") : \n            UIImage(systemName: \"circle\")\n        completedButton.setImage(buttonImage, for: .normal)\n    }\n}\n\n// 4. CONTROLLER: Main View Controller\nclass TodoViewController: UIViewController {\n    @IBOutlet weak var tableView: UITableView!\n    @IBOutlet weak var addButton: UIButton!\n    @IBOutlet weak var textField: UITextField!\n    @IBOutlet weak var prioritySegmentedControl: UISegmentedControl!\n    \n    private var todos: [TodoItem] = []\n    \n    override func viewDidLoad() {\n        super.viewDidLoad()\n        setupUI()\n        loadData()\n    }\n    \n    private func setupUI() {\n        tableView.dataSource = self\n        tableView.delegate = self\n        textField.delegate = self\n        \n        // Register custom cell\n        let nib = UINib(nibName: \"TodoCell\", bundle: nil)\n        tableView.register(nib, forCellReuseIdentifier: \"TodoCell\")\n        \n        // Style add button\n        addButton.layer.cornerRadius = 8\n        addButton.backgroundColor = .systemBlue\n        addButton.setTitleColor(.white, for: .normal)\n    }\n    \n    private func loadData() {\n        TodoManager.shared.loadTodos()\n        todos = TodoManager.shared.getTodos()\n        tableView.reloadData()\n    }\n    \n    @IBAction func addButtonTapped(_ sender: UIButton) {\n        addNewTodo()\n    }\n    \n    private func addNewTodo() {\n        guard let title = textField.text, !title.isEmpty else { return }\n        \n        let priorityIndex = prioritySegmentedControl.selectedSegmentIndex\n        let priority = Priority.allCases[priorityIndex]\n        \n        let newTodo = TodoManager.shared.addTodo(title, priority: priority)\n        todos.append(newTodo)\n        \n        // Update UI\n        tableView.reloadData()\n        textField.text = \"\"\n        textField.resignFirstResponder()\n        \n        // Show confirmation haptic\n        let generator = UIImpactFeedbackGenerator(style: .medium)\n        generator.impactOccurred()\n    }\n    \n    private func showEmptyState() {\n        if todos.isEmpty {\n            let emptyLabel = UILabel()\n            emptyLabel.text = \"No todos yet!\\nTap + to add your first todo.\"\n            emptyLabel.textAlignment = .center\n            emptyLabel.numberOfLines = 0\n            emptyLabel.textColor = .systemGray\n            tableView.backgroundView = emptyLabel\n        } else {\n            tableView.backgroundView = nil\n        }\n    }\n}\n\n// MARK: - TableView DataSource\nextension TodoViewController: UITableViewDataSource {\n    func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {\n        showEmptyState()\n        return todos.count\n    }\n    \n    func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {\n        let cell = tableView.dequeueReusableCell(withIdentifier: \"TodoCell\", for: indexPath) as! TodoCell\n        let todo = todos[indexPath.row]\n        cell.configure(with: todo)\n        \n        cell.toggleCompletion = { [weak self] in\n            TodoManager.shared.toggleComplete(todo.id)\n            self?.loadData()\n        }\n        \n        return cell\n    }\n}\n\n// MARK: - TableView Delegate\nextension TodoViewController: UITableViewDelegate {\n    func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) {\n        tableView.deselectRow(at: indexPath, animated: true)\n    }\n    \n    func tableView(_ tableView: UITableView, trailingSwipeActionsConfigurationForRowAt indexPath: IndexPath) -> UISwipeActionsConfiguration? {\n        let deleteAction = UIContextualAction(style: .destructive, title: \"Delete\") { [weak self] _, _, completion in\n            let todo = self?.todos[indexPath.row]\n            if let id = todo?.id {\n                TodoManager.shared.deleteTodo(id)\n                self?.loadData()\n            }\n            completion(true)\n        }\n        \n        deleteAction.backgroundColor = .systemRed\n        deleteAction.image = UIImage(systemName: \"trash\")\n        \n        return UISwipeActionsConfiguration(actions: [deleteAction])\n    }\n}\n\n// MARK: - TextField Delegate\nextension TodoViewController: UITextFieldDelegate {\n    func textFieldShouldReturn(_ textField: UITextField) -> Bool {\n        addNewTodo()\n        return true\n    }\n}",
      "category": "iOS Development",
      "estimatedTime": 300,
      "dependencies": ["structs_classes", "optionals"],
      "challenge": {
        "instructions": "Build a complete Todo List iOS App with the following features:\n\nPART 1: Project Setup & Basic UI (60 min)\n1. Create new Xcode project with Storyboard interface\n2. Design main screen with: UITableView, UITextField, UIButton, UISegmentedControl\n3. Set up Auto Layout constraints for all screen sizes\n4. Create custom UITableViewCell with todo item display\n\nPART 2: Data Model & Management (60 min)\n5. Implement TodoItem struct with properties: id, title, isCompleted, createdAt, priority\n6. Create TodoManager singleton class with CRUD operations\n7. Add data persistence using UserDefaults and Codable\n8. Implement priority system with enum (low, medium, high)\n\nPART 3: View Controller Implementation (60 min)\n9. Connect UI elements via @IBOutlet and @IBAction\n10. Implement UITableViewDataSource and UITableViewDelegate\n11. Handle todo creation, completion toggling, and deletion\n12. Add swipe actions for deleting todos\n\nPART 4: User Experience & Polish (60 min)\n13. Implement empty state when no todos exist\n14. Add haptic feedback for user actions\n15. Style the app with colors and proper typography\n16. Add accessibility features (VoiceOver, Dynamic Type)\n\nPART 5: Advanced Features (60 min)\n17. Add search/filter functionality\n18. Implement categories or tags for todos\n19. Add due dates and notifications\n20. Create settings screen for app preferences\n\nTest your app thoroughly on different devices and scenarios!",
        "starterCode": "// === PROJECT SETUP INSTRUCTIONS ===\n// 1. Create new Xcode project: iOS â†’ App â†’ Name: \"TodoApp\"\n// 2. Use Storyboard interface, Swift language\n// 3. Add the following files to your project:\n\n// === TodoItem.swift ===\n// Define your TodoItem struct here\n\n// === TodoManager.swift ===\n// Implement the TodoManager class here\n\n// === TodoCell.swift ===\n// Create custom UITableViewCell subclass\n\n// === TodoViewController.swift ===\n// Main view controller implementation\n\n// === Main.storyboard ===\n// Design your user interface here",
        "solution": "// === COMPLETE SOLUTION ===\n\n// TodoItem.swift\nimport Foundation\n\nenum Priority: String, CaseIterable, Codable {\n    case low = \"Low\", medium = \"Medium\", high = \"High\"\n    \n    var colorName: String {\n        switch self {\n        case .low: return \"systemGreen\"\n        case .medium: return \"systemOrange\"\n        case .high: return \"systemRed\"\n        }\n    }\n}\n\nstruct TodoItem: Codable {\n    let id: UUID\n    var title: String\n    var isCompleted: Bool\n    let createdAt: Date\n    var priority: Priority\n    \n    init(title: String, priority: Priority = .medium) {\n        self.id = UUID()\n        self.title = title\n        self.isCompleted = false\n        self.createdAt = Date()\n        self.priority = priority\n    }\n}\n\n// TodoManager.swift\nimport Foundation\n\nclass TodoManager {\n    static let shared = TodoManager()\n    private init() { loadTodos() }\n    \n    private var todos: [TodoItem] = []\n    private let saveKey = \"userTodos\"\n    \n    // MARK: - Public API\n    func addTodo(_ title: String, priority: Priority = .medium) -> TodoItem {\n        let newTodo = TodoItem(title: title, priority: priority)\n        todos.append(newTodo)\n        saveTodos()\n        return newTodo\n    }\n    \n    func toggleComplete(_ id: UUID) {\n        if let index = todos.firstIndex(where: { $0.id == id }) {\n            todos[index].isCompleted.toggle()\n            saveTodos()\n        }\n    }\n    \n    func deleteTodo(_ id: UUID) {\n        todos.removeAll { $0.id == id }\n        saveTodos()\n    }\n    \n    func updateTodo(_ id: UUID, newTitle: String? = nil, newPriority: Priority? = nil) {\n        if let index = todos.firstIndex(where: { $0.id == id }) {\n            if let newTitle = newTitle {\n                todos[index].title = newTitle\n            }\n            if let newPriority = newPriority {\n                todos[index].priority = newPriority\n            }\n            saveTodos()\n        }\n    }\n    \n    func getTodos() -> [TodoItem] { return todos }\n    func getIncomplete() -> [TodoItem] { return todos.filter { !$0.isCompleted } }\n    func getCompleted() -> [TodoItem] { return todos.filter { $0.isCompleted } }\n    \n    // MARK: - Persistence\n    private func saveTodos() {\n        if let encoded = try? JSONEncoder().encode(todos) {\n            UserDefaults.standard.set(encoded, forKey: saveKey)\n        }\n    }\n    \n    private func loadTodos() {\n        if let data = UserDefaults.standard.data(forKey: saveKey),\n           let decoded = try? JSONDecoder().decode([TodoItem].self, from: data) {\n            todos = decoded\n        }\n    }\n}\n\n// TodoCell.swift\nimport UIKit\n\nclass TodoCell: UITableViewCell {\n    @IBOutlet weak var titleLabel: UILabel!\n    @IBOutlet weak var priorityIndicator: UIView!\n    @IBOutlet weak var completeButton: UIButton!\n    @IBOutlet weak var dateLabel: UILabel!\n    \n    private var todo: TodoItem?\n    var onToggle: ((UUID) -> Void)?\n    \n    override func awakeFromNib() {\n        super.awakeFromNib()\n        priorityIndicator.layer.cornerRadius = 4\n        completeButton.layer.cornerRadius = 12\n    }\n    \n    @IBAction func completeTapped(_ sender: UIButton) {\n        guard let todo = todo else { return }\n        onToggle?(todo.id)\n    }\n    \n    func configure(with todo: TodoItem) {\n        self.todo = todo\n        \n        // Title with strikethrough if completed\n        let attributes: [NSAttributedString.Key: Any] = todo.isCompleted ?\n            [.strikethroughStyle: NSUnderlineStyle.single.rawValue,\n             .foregroundColor: UIColor.systemGray] :\n            [.foregroundColor: UIColor.label]\n        \n        titleLabel.attributedText = NSAttributedString(string: todo.title, attributes: attributes)\n        \n        // Priority color\n        priorityIndicator.backgroundColor = UIColor(named: todo.priority.colorName)\n        \n        // Date formatting\n        let formatter = DateFormatter()\n        formatter.dateStyle = .short\n        formatter.timeStyle = .none\n        dateLabel.text = formatter.string(from: todo.createdAt)\n        dateLabel.isHidden = !todo.isCompleted\n        \n        // Complete button state\n        let imageName = todo.isCompleted ? \"checkmark.circle.fill\" : \"circle\"\n        let image = UIImage(systemName: imageName)\n        completeButton.setImage(image, for: .normal)\n        completeButton.tintColor = todo.isCompleted ? .systemGreen : .systemGray\n    }\n}\n\n// TodoViewController.swift\nimport UIKit\n\nclass TodoViewController: UIViewController {\n    @IBOutlet weak var tableView: UITableView!\n    @IBOutlet weak var addButton: UIButton!\n    @IBOutlet weak var textField: UITextField!\n    @IBOutlet weak var priorityControl: UISegmentedControl!\n    @IBOutlet weak var emptyStateView: UIView!\n    @IBOutlet weak var emptyStateLabel: UILabel!\n    \n    private var todos: [TodoItem] = []\n    \n    override func viewDidLoad() {\n        super.viewDidLoad()\n        setupUI()\n        loadData()\n    }\n    \n    override func viewWillAppear(_ animated: Bool) {\n        super.viewWillAppear(animated)\n        loadData()\n    }\n    \n    private func setupUI() {\n        title = \"My Todos\"\n        \n        // Table View\n        tableView.dataSource = self\n        tableView.delegate = self\n        tableView.rowHeight = UITableView.automaticDimension\n        tableView.estimatedRowHeight = 60\n        \n        // Text Field\n        textField.delegate = self\n        textField.placeholder = \"Add a new todo...\"\n        \n        // Add Button\n        addButton.layer.cornerRadius = 8\n        addButton.backgroundColor = .systemBlue\n        addButton.setTitleColor(.white, for: .normal)\n        \n        // Priority Control\n        priorityControl.removeAllSegments()\n        for (index, priority) in Priority.allCases.enumerated() {\n            priorityControl.insertSegment(withTitle: priority.rawValue, at: index, animated: false)\n        }\n        priorityControl.selectedSegmentIndex = 1 // Medium\n        \n        // Empty State\n        emptyStateLabel.text = \"No todos yet!\\nTap the + button to add your first todo.\"\n        emptyStateLabel.textAlignment = .center\n        emptyStateLabel.numberOfLines = 0\n        \n        // Register cell\n        let nib = UINib(nibName: \"TodoCell\", bundle: nil)\n        tableView.register(nib, forCellReuseIdentifier: \"TodoCell\")\n    }\n    \n    private func loadData() {\n        todos = TodoManager.shared.getTodos()\n        updateEmptyState()\n        tableView.reloadData()\n    }\n    \n    private func updateEmptyState() {\n        let isEmpty = todos.isEmpty\n        emptyStateView.isHidden = !isEmpty\n        tableView.isHidden = isEmpty\n    }\n    \n    @IBAction func addButtonTapped(_ sender: UIButton) {\n        addNewTodo()\n    }\n    \n    private func addNewTodo() {\n        guard let title = textField.text?.trimmingCharacters(in: .whitespaces), !title.isEmpty else {\n            showAlert(title: \"Oops!\", message: \"Please enter a todo title\")\n            return\n        }\n        \n        let priority = Priority.allCases[priorityControl.selectedSegmentIndex]\n        _ = TodoManager.shared.addTodo(title, priority: priority)\n        \n        // Reset UI\n        textField.text = \"\"\n        textField.resignFirstResponder()\n        \n        // Update data\n        loadData()\n        \n        // Haptic feedback\n        UIImpactFeedbackGenerator(style: .medium).impactOccurred()\n        \n        // Scroll to bottom\n        if !todos.isEmpty {\n            let indexPath = IndexPath(row: todos.count - 1, section: 0)\n            tableView.scrollToRow(at: indexPath, at: .bottom, animated: true)\n        }\n    }\n    \n    private func showAlert(title: String, message: String) {\n        let alert = UIAlertController(title: title, message: message, preferredStyle: .alert)\n        alert.addAction(UIAlertAction(title: \"OK\", style: .default))\n        present(alert, animated: true)\n    }\n}\n\n// MARK: - TableView DataSource & Delegate\nextension TodoViewController: UITableViewDataSource, UITableViewDelegate {\n    func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {\n        return todos.count\n    }\n    \n    func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {\n        let cell = tableView.dequeueReusableCell(withIdentifier: \"TodoCell\", for: indexPath) as! TodoCell\n        let todo = todos[indexPath.row]\n        cell.configure(with: todo)\n        \n        cell.onToggle = { [weak self] id in\n            TodoManager.shared.toggleComplete(id)\n            self?.loadData()\n            UISelectionFeedbackGenerator().selectionChanged()\n        }\n        \n        return cell\n    }\n    \n    func tableView(_ tableView: UITableView, trailingSwipeActionsConfigurationForRowAt indexPath: IndexPath) -> UISwipeActionsConfiguration? {\n        let delete = UIContextualAction(style: .destructive, title: \"Delete\") { [weak self] _, _, completion in\n            let todo = self?.todos[indexPath.row]\n            if let id = todo?.id {\n                TodoManager.shared.deleteTodo(id)\n                self?.loadData()\n                UINotificationFeedbackGenerator().notificationOccurred(.success)\n            }\n            completion(true)\n        }\n        \n        delete.image = UIImage(systemName: \"trash\")\n        return UISwipeActionsConfiguration(actions: [delete])\n    }\n}\n\n// MARK: - TextField Delegate\nextension TodoViewController: UITextFieldDelegate {\n    func textFieldShouldReturn(_ textField: UITextField) -> Bool {\n        addNewTodo()\n        return true\n    }\n}",
        "hints": [
          "Use Auto Layout constraints to make your UI responsive on all device sizes",
          "Remember to call tableView.reloadData() after modifying your data",
          "Use @IBAction for button taps and @IBOutlet for UI element connections",
          "Implement both UITableViewDataSource required methods: numberOfRows and cellForRowAt",
          "UserDefaults + Codable is perfect for simple data persistence",
          "Use UISwipeActionsConfiguration for swipe-to-delete functionality",
          "Don't forget to set the delegate for UITableView and UITextField",
          "Use UIImpactFeedbackGenerator for haptic feedback on user actions",
          "Create a custom UITableViewCell for better todo item display",
          "Handle empty state by showing/hiding a view when todos array is empty"
        ],
        "testCases": [
          {
            "input": "Add todo â†’ Check if appears in table",
            "expectedOutput": "New todo visible in list",
            "description": "Todo creation should update UI immediately"
          },
          {
            "input": "Toggle completion â†’ Check strikethrough",
            "expectedOutput": "Title shows strikethrough when completed",
            "description": "Completion state should visually update"
          },
          {
            "input": "Swipe to delete â†’ Confirm removal",
            "expectedOutput": "Todo removed from list",
            "description": "Swipe deletion should work correctly"
          },
          {
            "input": "Relaunch app â†’ Check data persistence",
            "expectedOutput": "Todos still present after restart",
            "description": "UserDefaults should persist data between launches"
          }
        ]
      }
    },
    {
      "id": "xcode_deep_dive",
      "title": "Xcode Deep Dive",
      "description": "Master Xcode interface, debugging tools, and productivity shortcuts to become a more efficient Swift developer",
      "difficulty": "beginner",
      "theory": "# Xcode Deep Dive - Master Your Development Environment\n\n## 1. Xcode Interface Overview (45 min)\n\n### Main Components:\n- **Navigator Area** (Left sidebar) - File structure, search, warnings\n- **Editor Area** (Center) - Code editing, interface builder\n- **Inspector Area** (Right sidebar) - File info, attributes, connections\n- **Toolbar** (Top) - Run button, scheme selector, status\n- **Debug Area** (Bottom) - Console, variables, breakpoints\n\n### Key Panels Explained:\n\n#### Project Navigator (âŒ˜1):\n- Hierarchical view of all project files\n- Folder references vs. groups\n- Target membership controls\n\n#### Source Control Navigator (âŒ˜2):\n- Git branch management\n- Commit history\n- Conflict resolution\n\n#### Issue Navigator (âŒ˜5):\n- Compiler errors and warnings\n- Static analysis results\n- Quick jump to problematic code\n\n#### Debug Navigator (âŒ˜6):\n- Thread and queue overview\n- Memory usage monitoring\n- Performance metrics\n\n## 2. Essential Editor Features (60 min)\n\n### Code Completion (âŒƒSpace):\n```swift\n// Start typing and use autocomplete\nlet myArray = [\"Apple\", \"Banana\", \"Cherry\"]\nmyArray. // Press âŒƒSpace here\n```\n\n### Quick Help (âŒ¥Click):\n- Option-click any symbol for documentation\n- See declarations, parameters, and discussions\n- Links to related symbols\n\n### Code Folding (âŒ¥âŒ˜â† / âŒ¥âŒ˜â†’):\n- Collapse methods and classes\n- Focus on relevant code sections\n- Use folding ribbons in the gutter\n\n### Multiple Cursors (âŒ¥Drag):\n```swift\n// Select multiple lines with âŒ¥Drag\nlet firstName = \"\"\nlet lastName = \"\"\nlet email = \"\"\n// Edit all three simultaneously\n```\n\n### Jump to Definition (âŒƒâŒ˜J):\n- Quickly navigate to symbol definitions\n- Understand code structure\n- Explore framework APIs\n\n## 3. Powerful Navigation Shortcuts (45 min)\n\n### File Navigation:\n- **Quick Open** (âŒ˜â‡§O) - Jump to any file or symbol\n- **Open Quickly** (âŒ˜â‡§O) - Type partial names\n- **Jump to Line** (âŒ˜L) - Go to specific line number\n\n### Code Navigation:\n- **Go Back** (âŒƒâŒ˜â†) - Return to previous location\n- **Go Forward** (âŒƒâŒ˜â†’) - Move forward in navigation history\n- **Show Callers** (âŒƒâ‡§âŒ˜H) - Find all references\n\n### Editor Navigation:\n- **Move Line Up/Down** (âŒ¥âŒ˜â†‘ / âŒ¥âŒ˜â†“)\n- **Duplicate Line** (âŒ˜D)\n- **Comment/Uncomment** (âŒ˜/)\n\n## 4. Debugging Mastery (60 min)\n\n### Breakpoints:\n```swift\nfunc calculateTotal(items: [Double]) -> Double {\n    var total = 0.0\n    for item in items {        // Set breakpoint here\n        total += item\n    }\n    return total\n}\n```\n\n### Breakpoint Types:\n- **Regular Breakpoints** - Pause execution\n- **Conditional Breakpoints** - Break only when condition met\n- **Exception Breakpoints** - Catch all exceptions\n- **Symbolic Breakpoints** - Break on specific methods\n\n### Debug Area Controls:\n- **Continue** (âŒƒâŒ˜Y) - Resume execution\n- **Step Over** (F6) - Execute next line\n- **Step Into** (F7) - Go into function call\n- **Step Out** (F8) - Complete current function\n\n### LLDB Console Commands:\n```swift\n// In debug console:\npo items          // Print object description\np total           // Print primitive value\nexpr total = 100  // Change value during debugging\nframe variable    // Show all local variables\n```\n\n### View Debugging:\n- **View Hierarchy** (âŒ˜â‡§V) - 3D view of UI layers\n- **View Debugger** - Identify auto layout issues\n- **Color Blended Layers** - Performance optimization\n\n## 5. Interface Builder Essentials (45 min)\n\n### Storyboard Navigation:\n- **Zoom** (âŒ˜Â±) - Fit to screen, zoom in/out\n- **Assistant Editor** (âŒ¥âŒ˜â†©) - Split view with code\n- **Show Document Outline** (âŒ˜â‡§O) - View hierarchy\n\n### Auto Layout Tools:\n- **Add New Constraints** - Pin views precisely\n- **Resolve Auto Layout Issues** - Clear warnings/errors\n- **Update Frames** (âŒ¥âŒ˜=) - Apply constraint changes\n\n### Connections Inspector:\n- **Outlets** - Connect UI to code\n- **Actions** - Link events to methods\n- **Referencing Outlets** - See all connections\n\n### Preview Assistant:\n- Multiple device previews\n- Dark/light mode testing\n- Dynamic type sizes\n- Localization preview\n\n## 6. Build System & Schemes (30 min)\n\n### Build Configurations:\n- **Debug** - Full symbols, no optimization\n- **Release** - Optimized, minimal symbols\n- **Profile** - Instruments-ready\n\n### Scheme Management:\n- **Edit Scheme** (âŒ˜<) - Configure run/test/archive\n- **Environment Variables** - Debug configuration\n- **Launch Arguments** - Custom app behavior\n\n### Build Shortcuts:\n- **Build** (âŒ˜B) - Compile without running\n- **Run** (âŒ˜R) - Build and launch\n- **Test** (âŒ˜U) - Run unit tests\n- **Clean** (âŒ˜â‡§K) - Remove build artifacts\n\n## 7. Productivity Workflows (45 min)\n\n### Code Snippets:\n```swift\n// Create reusable code templates\n// Drag from snippet library to editor\n// Use placeholders for dynamic content\n```\n\n### Behaviors (âŒ˜â‡§B):\n- Customize Xcode actions\n- Show debugger on build failures\n- Play sound on test completion\n- Open specific tabs for tasks\n\n### Source Control Integration:\n- **Commit** (âŒ˜âŒ¥C) - Review and commit changes\n- **Push** (âŒ˜â‡§P) - Send commits to remote\n- **Pull** (âŒ˜â‡§X) - Fetch and merge changes\n\n### Refactoring Tools:\n- **Rename** (âŒƒâŒ˜E) - Update symbol everywhere\n- **Extract Method** - Create function from selection\n- **Generate Missing Code** - Stub implementations\n\n## Best Practices Summary\n\n1. **Learn Keyboard Shortcuts** - Muscle memory beats mouse clicks\n2. **Use Multiple Workspaces** - Organize different project aspects\n3. **Master Breakpoints** - Efficient debugging saves hours\n4. **Customize Your Environment** - Tailor Xcode to your workflow\n5. **Stay Updated** - New Xcode versions bring productivity boosts\n\nComplete all exercises to build Xcode proficiency!",
      "codeExample": "// === XCODE SHORTCUTS PRACTICE ===\n\n// Practice these common workflows:\n\n// 1. Code Completion & Quick Help\nstruct User {\n    let name: String\n    let age: Int\n    let email: String\n}\n\nlet users = [\n    User(name: \"Alice\", age: 25, email: \"alice@example.com\"),\n    User(name: \"Bob\", age: 30, email: \"bob@example.com\")\n]\n\n// Try: Type 'users.' then press âŒƒSpace for autocomplete\n// Try: Option-click on 'User' to see documentation\n\n// 2. Multiple Cursors Practice\nclass DataProcessor {\n    // Select all three properties with âŒ¥Drag\n    var inputData: String = \"\"\n    var processedData: String = \"\"\n    var outputData: String = \"\"\n    \n    func process() {\n        // Set breakpoint on next line\n        let results = inputData.split(separator: \",\")\n        processedData = results.joined(separator: \"-\")\n        outputData = processedData.uppercased()\n        \n        // Use debug console: 'po results'\n        // Use debug console: 'p processedData'\n    }\n}\n\n// 3. Navigation Practice\nprotocol DataSource {\n    func fetchData() -> [String]\n}\n\nclass NetworkDataSource: DataSource {\n    func fetchData() -> [String] {\n        return [\"Item 1\", \"Item 2\", \"Item 3\"]\n    }\n}\n\nclass LocalDataSource: DataSource {\n    func fetchData() -> [String] {\n        return [\"Local 1\", \"Local 2\"]\n    }\n}\n\n// Try: âŒƒâŒ˜J on 'DataSource' to jump to protocol\n// Try: âŒ˜â‡§O and type 'User' to quickly open files\n\n// 4. Debugging Practice\nfunc calculateStatistics(scores: [Int]) -> (min: Int, max: Int, average: Double) {\n    // Set conditional breakpoint: 'scores.count > 5'\n    guard !scores.isEmpty else {\n        return (0, 0, 0.0)\n    }\n    \n    var minScore = scores[0]\n    var maxScore = scores[0]\n    var total = 0\n    \n    for score in scores {\n        if score < minScore { minScore = score }\n        if score > maxScore { maxScore = score }\n        total += score\n    }\n    \n    let average = Double(total) / Double(scores.count)\n    return (minScore, maxScore, average)\n}\n\n// Test function with breakpoints\nlet testScores = [85, 92, 78, 90, 88]\nlet stats = calculateStatistics(scores: testScores)\n\n// === INTERFACE BUILDER CONNECTIONS ===\n\n// Practice connecting UI to code:\n/*\n1. Create a button in storyboard\n2. Open Assistant Editor (âŒ¥âŒ˜â†©)\n3. Control-drag from button to create:\n*/\n\n@IBAction func buttonTapped(_ sender: UIButton) {\n    // Handle button tap\n    sender.setTitle(\"Tapped!\", for: .normal)\n}\n\n@IBOutlet weak var statusLabel: UILabel!\n\n// === SCHEME CONFIGURATION ===\n\n// Practice different configurations:\n#if DEBUG\nlet apiBaseURL = \"https://api-dev.example.com\"\nlet enableLogging = true\n#else\nlet apiBaseURL = \"https://api.example.com\"\nlet enableLogging = false\n#endif",
      "category": "Development Tools",
      "estimatedTime": 180,
      "dependencies": [],
      "challenge": {
        "instructions": "Complete this comprehensive Xcode mastery challenge to become proficient with the development environment:\n\nPART 1: Project Setup & Navigation (45 min)\n1. Create a new iOS project called 'XcodeMastery'\n2. Organize files into logical groups (Models, Views, Controllers, Utilities)\n3. Create 5 different Swift files and practice navigating between them using keyboard shortcuts\n4. Set up a custom code snippet for a common UIView subclass pattern\n\nPART 2: Debugging Skills (45 min)\n5. Create a function with a logical error and use breakpoints to identify it\n6. Set up conditional breakpoints that only trigger under specific conditions\n7. Use LLDB commands to inspect and modify variables during debugging\n8. Add an exception breakpoint and trigger it intentionally\n\nPART 3: Interface Builder Proficiency (45 min)\n9. Design a simple login screen with Auto Layout constraints\n10. Connect UI elements to code using both outlets and actions\n11. Use the View Debugger to identify and fix layout issues\n12. Test your interface across different device sizes using previews\n\nPART 4: Productivity Workflow (45 min)\n13. Configure custom behaviors for testing and debugging\n14. Set up source control and make your first commit\n15. Create a custom scheme for debugging with specific environment variables\n16. Use refactoring tools to rename a class and update all references\n\nTest each skill thoroughly and document any issues you encounter!",
        "starterCode": "// === PART 1: Project Structure ===\n// Create these files and organize in groups:\n// - Models/User.swift\n// - Views/LoginView.swift  \n// - Controllers/ViewController.swift\n// - Utilities/NetworkManager.swift\n\n// User.swift\nstruct User {\n    // Add properties here\n}\n\n// === PART 2: Debugging Practice ===\nclass DataProcessor {\n    func processNumbers(_ numbers: [Int]) -> [Int] {\n        var results: [Int] = []\n        for number in numbers {\n            // Intentional bug: should be number * 2\n            results.append(number * 3)\n        }\n        return results\n    }\n}\n\n// === PART 3: UI Connections ===\n// Connect these to your storyboard elements\nclass LoginViewController: UIViewController {\n    // Add IBOutlets and IBActions here\n    \n    @IBAction func loginButtonTapped(_ sender: UIButton) {\n        // Handle login logic\n    }\n}\n\n// === PART 4: Environment Configuration ===\nclass AppConfig {\n    // Configure different environments\n}",
        "solution": "// === PART 1: Project Structure Solution ===\n\n// Models/User.swift\nstruct User {\n    let id: String\n    let username: String\n    let email: String\n    \n    var displayName: String {\n        return \"@\\(username)\"\n    }\n}\n\n// Views/LoginView.swift\nimport UIKit\n\nclass LoginView: UIView {\n    let emailTextField = UITextField()\n    let passwordTextField = UITextField()\n    let loginButton = UIButton(type: .system)\n    \n    override init(frame: CGRect) {\n        super.init(frame: frame)\n        setupView()\n    }\n    \n    required init?(coder: NSCoder) {\n        super.init(coder: coder)\n        setupView()\n    }\n    \n    private func setupView() {\n        // Configure subviews and constraints\n        emailTextField.placeholder = \"Email\"\n        passwordTextField.placeholder = \"Password\"\n        passwordTextField.isSecureTextEntry = true\n        loginButton.setTitle(\"Login\", for: .normal)\n        \n        // Add to view hierarchy and set constraints\n    }\n}\n\n// Utilities/NetworkManager.swift\nclass NetworkManager {\n    static let shared = NetworkManager()\n    \n    private init() {}\n    \n    func login(username: String, password: String, completion: @escaping (Result<User, Error>) -> Void) {\n        // Simulate network request\n        DispatchQueue.main.asyncAfter(deadline: .now() + 1.0) {\n            let user = User(id: \"1\", username: username, email: \"\\(username)@example.com\")\n            completion(.success(user))\n        }\n    }\n}\n\n// === PART 2: Debugging Solution ===\n\nclass DataProcessor {\n    func processNumbers(_ numbers: [Int]) -> [Int] {\n        var results: [Int] = []\n        \n        // Set breakpoint on next line\n        for number in numbers {\n            // Conditional breakpoint: number > 50\n            if number > 50 {\n                print(\"Processing large number: \\(number)\")\n            }\n            \n            // Fixed bug: now correctly doubles numbers\n            results.append(number * 2)\n        }\n        \n        // LLDB practice: 'po numbers' then 'expr numbers = [1,2,3]'\n        return results\n    }\n    \n    func triggerException() {\n        // This will trigger exception breakpoint\n        let array = [1, 2, 3]\n        let _ = array[5] // Index out of bounds\n    }\n}\n\n// Debugging test\nlet processor = DataProcessor()\nlet input = [10, 25, 60, 45]\nlet output = processor.processNumbers(input)\nprint(\"Input: \\(input), Output: \\(output)\")\n\n// === PART 3: UI Connections Solution ===\n\nimport UIKit\n\nclass LoginViewController: UIViewController {\n    \n    // IBOutlets\n    @IBOutlet weak var emailTextField: UITextField!\n    @IBOutlet weak var passwordTextField: UITextField!\n    @IBOutlet weak var loginButton: UIButton!\n    @IBOutlet weak var statusLabel: UILabel!\n    \n    override func viewDidLoad() {\n        super.viewDidLoad()\n        setupUI()\n    }\n    \n    private func setupUI() {\n        loginButton.layer.cornerRadius = 8\n        statusLabel.isHidden = true\n        \n        // Auto Layout constraints should be set in storyboard\n        // Use View Debugger (âŒ˜â‡§V) to verify hierarchy\n    }\n    \n    // IBActions\n    @IBAction func loginButtonTapped(_ sender: UIButton) {\n        guard let email = emailTextField.text, !email.isEmpty,\n              let password = passwordTextField.text, !password.isEmpty else {\n            showStatus(\"Please fill all fields\", isError: true)\n            return\n        }\n        \n        loginButton.isEnabled = false\n        showStatus(\"Logging in...\", isError: false)\n        \n        NetworkManager.shared.login(username: email, password: password) { [weak self] result in\n            DispatchQueue.main.async {\n                self?.loginButton.isEnabled = true\n                \n                switch result {\n                case .success(let user):\n                    self?.showStatus(\"Welcome \\(user.displayName)!\", isError: false)\n                case .failure:\n                    self?.showStatus(\"Login failed\", isError: true)\n                }\n            }\n        }\n    }\n    \n    @IBAction func textFieldDidChange(_ sender: UITextField) {\n        // Real-time validation\n        statusLabel.isHidden = true\n    }\n    \n    private func showStatus(_ message: String, isError: Bool) {\n        statusLabel.text = message\n        statusLabel.textColor = isError ? .red : .systemGreen\n        statusLabel.isHidden = false\n    }\n}\n\n// === PART 4: Environment Configuration Solution ===\n\nclass AppConfig {\n    \n    #if DEBUG\n    static let environment = \"Development\"\n    static let apiBaseURL = \"https://api-dev.example.com\"\n    static let logLevel = \"debug\"\n    #elseif STAGING\n    static let environment = \"Staging\"\n    static let apiBaseURL = \"https://api-staging.example.com\"\n    static let logLevel = \"info\"\n    #else\n    static let environment = \"Production\"\n    static let apiBaseURL = \"https://api.example.com\"\n    static let logLevel = \"warning\"\n    #endif\n    \n    static var description: String {\n        return \"\\(environment) Environment - \\(apiBaseURL)\"\n    }\n}\n\n// Custom scheme configuration:\n// 1. Edit Scheme (âŒ˜<)\n// 2. Duplicate Debug scheme to create Staging\n// 3. Add STAGING flag in Build Settings\n// 4. Set environment variables if needed\n\n// Code Snippet creation:\n// Create snippet for \"UIView Subclass Template\" with:\n// - Custom initializers\n// - Auto Layout setup method\n// - Common configuration",
        "hints": [
          "PART 1: Use âŒ˜1 to navigate files, âŒ˜N to create new files. Right-click in project navigator to create groups",
          "PART 2: Right-click breakpoints for conditions. Use 'po' for objects, 'p' for primitives in LLDB",
          "PART 3: Hold control and drag from storyboard to code to create connections. Use âŒ˜â‡§V for view debugging",
          "PART 4: Behaviors are in Xcode â†’ Behaviors. Schemes are managed with âŒ˜<",
          "Use âŒ˜â‡§O to quickly open any file. Remember the shortcut saves hunting through folders",
          "For conditional breakpoints, right-click the breakpoint and add a condition like 'someVar == 5'",
          "In Interface Builder, use the 'Resolve Auto Layout Issues' button (right-most toolbar button) to quickly fix constraints",
          "Create code snippets by selecting code and dragging to the snippets library (bottom-right of window)"
        ],
        "testCases": [
          {
            "input": "DataProcessor().processNumbers([1, 2, 3])",
            "expectedOutput": "[2, 4, 6]",
            "description": "Debugging practice should correctly double input numbers"
          },
          {
            "input": "AppConfig.environment",
            "expectedOutput": "Development",
            "description": "Scheme configuration should set correct environment"
          },
          {
            "input": "User(id: \"123\", username: \"test\", email: \"test@example.com\").displayName",
            "expectedOutput": "@test",
            "description": "Project structure should organize models correctly"
          }
        ]
      }
    },
    {
      "id": "app_architecture_mvvm",
      "title": "App Architecture - MVVM Pattern",
      "description": "Learn the Model-View-ViewModel pattern - the standard architecture for SwiftUI apps",
      "difficulty": "beginner",
      "theory": "# MVVM Architecture - Organizing Your SwiftUI Apps\n\n## 1. Understanding MVVM Pattern (45 min)\n\n### What is MVVM?\nMVVM stands for **Model-View-ViewModel** - a design pattern that separates your app into three distinct layers:\n\n### The Three Layers:\n- **Model**: Your data and business logic\n- **View**: UI components that display data\n- **ViewModel**: Bridge between Model and View\n\n### Why Use MVVM?\n- **Separation of Concerns**: Each layer has a single responsibility\n- **Testability**: ViewModels can be tested without UI\n- **Maintainability**: Changes in one layer don't break others\n- **SwiftUI Friendly**: Perfect fit for SwiftUI's declarative syntax\n\n### Real-world Analogy:\n- **Model**: Kitchen ingredients and recipes\n- **View**: Restaurant dining area and menu\n- **ViewModel**: Waiters who take orders and deliver food\n\n## 2. Model Layer (45 min)\n\n### What Goes in the Model?\n- Data structures\n- Business logic\n- Data validation\n- API communication\n- Database operations\n\n### Simple Model Example:\n```swift\nstruct User: Identifiable, Codable {\n    let id: UUID\n    var name: String\n    var email: String\n    var joinDate: Date\n    \n    var isEmailValid: Bool {\n        return email.contains(\"@\") && email.contains(\".\")\n    }\n    \n    var membershipDuration: Int {\n        let calendar = Calendar.current\n        return calendar.dateComponents([.day], from: joinDate, to: Date()).day ?? 0\n    }\n}\n```\n\n### Business Logic in Models:\n```swift\nstruct Product {\n    let id: UUID\n    var name: String\n    var price: Double\n    var stockQuantity: Int\n    \n    var isInStock: Bool {\n        return stockQuantity > 0\n    }\n    \n    func applyDiscount(percentage: Double) -> Double {\n        let discount = price * (percentage / 100)\n        return max(0, price - discount)\n    }\n}\n```\n\n## 3. ViewModel Layer (60 min)\n\n### ViewModel Responsibilities:\n- Preparing data for the View\n- Handling user interactions\n- Managing state and business logic\n- Coordinating with Models\n\n### Basic ViewModel Structure:\n```swift\nimport Foundation\nimport Combine\n\nclass UserViewModel: ObservableObject {\n    // MARK: - Published Properties\n    @Published var users: [User] = []\n    @Published var isLoading = false\n    @Published var errorMessage: String?\n    \n    // MARK: - Business Logic\n    func loadUsers() {\n        isLoading = true\n        errorMessage = nil\n        \n        // Simulate API call\n        DispatchQueue.main.asyncAfter(deadline: .now() + 1.0) {\n            self.users = [\n                User(id: UUID(), name: \"John Doe\", email: \"john@example.com\", joinDate: Date()),\n                User(id: UUID(), name: \"Jane Smith\", email: \"jane@example.com\", joinDate: Date())\n            ]\n            self.isLoading = false\n        }\n    }\n    \n    func addUser(name: String, email: String) {\n        let newUser = User(id: UUID(), name: name, email: email, joinDate: Date())\n        users.append(newUser)\n    }\n    \n    func deleteUser(at offsets: IndexSet) {\n        users.remove(atOffsets: offsets)\n    }\n}\n```\n\n### State Management in ViewModels:\n```swift\nclass ShoppingCartViewModel: ObservableObject {\n    @Published var items: [CartItem] = []\n    @Published var totalPrice: Double = 0.0\n    @Published var isCheckingOut = false\n    \n    var itemCount: Int {\n        return items.count\n    }\n    \n    func addItem(_ product: Product, quantity: Int = 1) {\n        if let index = items.firstIndex(where: { $0.product.id == product.id }) {\n            items[index].quantity += quantity\n        } else {\n            let newItem = CartItem(product: product, quantity: quantity)\n            items.append(newItem)\n        }\n        calculateTotal()\n    }\n    \n    private func calculateTotal() {\n        totalPrice = items.reduce(0) { $0 + ($1.product.price * Double($1.quantity)) }\n    }\n}\n```\n\n## 4. View Layer (60 min)\n\n### Connecting View to ViewModel:\n```swift\nimport SwiftUI\n\nstruct UserListView: View {\n    @StateObject private var viewModel = UserViewModel()\n    \n    var body: some View {\n        NavigationView {\n            VStack {\n                if viewModel.isLoading {\n                    ProgressView(\"Loading users...\")\n                } else if let error = viewModel.errorMessage {\n                    ErrorView(message: error) {\n                        viewModel.loadUsers()\n                    }\n                } else {\n                    List {\n                        ForEach(viewModel.users) { user in\n                            UserRowView(user: user)\n                        }\n                        .onDelete(perform: viewModel.deleteUser)\n                    }\n                }\n            }\n            .navigationTitle(\"Users\")\n            .toolbar {\n                Button(\"Add User\") {\n                    // Add user logic\n                }\n            }\n        }\n        .onAppear {\n            viewModel.loadUsers()\n        }\n    }\n}\n\nstruct UserRowView: View {\n    let user: User\n    \n    var body: some View {\n        VStack(alignment: .leading) {\n            Text(user.name)\n                .font(.headline)\n            Text(user.email)\n                .font(.subheadline)\n                .foregroundColor(.secondary)\n            Text(\"Member for \\(user.membershipDuration) days\")\n                .font(.caption)\n        }\n    }\n}\n```\n\n### Handling User Input:\n```swift\nstruct AddUserView: View {\n    @Environment(\\.dismiss) private var dismiss\n    @ObservedObject var viewModel: UserViewModel\n    @State private var name = \"\"\n    @State private var email = \"\"\n    \n    var body: some View {\n        NavigationView {\n            Form {\n                Section(\"User Details\") {\n                    TextField(\"Name\", text: $name)\n                    TextField(\"Email\", text: $email)\n                        .keyboardType(.emailAddress)\n                        .autocapitalization(.none)\n                }\n                \n                Section {\n                    Button(\"Add User\") {\n                        viewModel.addUser(name: name, email: email)\n                        dismiss()\n                    }\n                    .disabled(name.isEmpty || email.isEmpty)\n                }\n            }\n            .navigationTitle(\"Add User\")\n            .toolbar {\n                ToolbarItem(placement: .cancellationAction) {\n                    Button(\"Cancel\") {\n                        dismiss()\n                    }\n                }\n            }\n        }\n    }\n}\n```\n\n## 5. Data Flow in MVVM (45 min)\n\n### One-Way Data Flow:\n- **View â†’ ViewModel**: User actions (button taps, text input)\n- **ViewModel â†’ View**: Published property updates\n- **ViewModel â†’ Model**: Business logic operations\n- **Model â†’ ViewModel**: Data updates and computations\n\n### @StateObject vs @ObservedObject:\n```swift\n// Use @StateObject for ownership - this view creates and owns the ViewModel\nstruct ParentView: View {\n    @StateObject private var viewModel = UserViewModel()\n    \n    var body: some View {\n        ChildView(viewModel: viewModel)\n    }\n}\n\n// Use @ObservedObject for sharing - this view uses a ViewModel created elsewhere\nstruct ChildView: View {\n    @ObservedObject var viewModel: UserViewModel\n    \n    var body: some View {\n        Text(\"\\(viewModel.users.count) users\")\n    }\n}\n```\n\n### Binding Data Between Views:\n```swift\nclass SettingsViewModel: ObservableObject {\n    @Published var username: String = \"\"\n    @Published var notificationsEnabled: Bool = true\n    @Published var theme: Theme = .light\n}\n\nstruct SettingsView: View {\n    @ObservedObject var viewModel: SettingsViewModel\n    \n    var body: some View {\n        Form {\n            TextField(\"Username\", text: $viewModel.username)\n            Toggle(\"Notifications\", isOn: $viewModel.notificationsEnabled)\n            Picker(\"Theme\", selection: $viewModel.theme) {\n                ForEach(Theme.allCases, id: \\.self) { theme in\n                    Text(theme.rawValue.capitalized)\n                }\n            }\n        }\n    }\n}\n```\n\n## 6. Best Practices & Common Patterns (45 min)\n\n### Dependency Injection:\n```swift\nclass UserViewModel: ObservableObject {\n    private let userService: UserServiceProtocol\n    \n    // Inject dependencies through initializer\n    init(userService: UserServiceProtocol = UserService()) {\n        self.userService = userService\n    }\n    \n    func loadUsers() async {\n        do {\n            let users = try await userService.fetchUsers()\n            await MainActor.run {\n                self.users = users\n            }\n        } catch {\n            await MainActor.run {\n                self.errorMessage = error.localizedDescription\n            }\n        }\n    }\n}\n```\n\n### Error Handling in MVVM:\n```swift\nclass WeatherViewModel: ObservableObject {\n    @Published var weather: Weather?\n    @Published var isLoading = false\n    @Published var error: WeatherError?\n    \n    @MainActor\n    func fetchWeather(for city: String) async {\n        isLoading = true\n        error = nil\n        \n        do {\n            weather = try await WeatherService().fetchWeather(for: city)\n        } catch {\n            self.error = WeatherError(message: error.localizedDescription)\n        }\n        \n        isLoading = false\n    }\n}\n```\n\n### Testing ViewModels:\n```swift\nclass UserViewModelTests: XCTestCase {\n    func testAddUser() {\n        // Given\n        let viewModel = UserViewModel()\n        let initialCount = viewModel.users.count\n        \n        // When\n        viewModel.addUser(name: \"Test User\", email: \"test@example.com\")\n        \n        // Then\n        XCTAssertEqual(viewModel.users.count, initialCount + 1)\n        XCTAssertEqual(viewModel.users.last?.name, \"Test User\")\n    }\n}\n```\n\n## Practice Exercises\n\nComplete all exercises to master the MVVM pattern in SwiftUI!",
      "codeExample": "// === COMPLETE MVVM EXAMPLE ===\n\n// MARK: - Model\nstruct Task: Identifiable, Codable {\n    let id: UUID\n    var title: String\n    var description: String\n    var isCompleted: Bool\n    var dueDate: Date?\n    var priority: Priority\n    \n    enum Priority: String, CaseIterable, Codable {\n        case low, medium, high\n    }\n    \n    init(id: UUID = UUID(), title: String, description: String = \"\", isCompleted: Bool = false, dueDate: Date? = nil, priority: Priority = .medium) {\n        self.id = id\n        self.title = title\n        self.description = description\n        self.isCompleted = isCompleted\n        self.dueDate = dueDate\n        self.priority = priority\n    }\n    \n    var isOverdue: Bool {\n        guard let dueDate = dueDate else { return false }\n        return !isCompleted && dueDate < Date()\n    }\n}\n\n// MARK: - ViewModel\nclass TaskViewModel: ObservableObject {\n    @Published var tasks: [Task] = []\n    @Published var isLoading = false\n    @Published var errorMessage: String?\n    @Published var searchText = \"\"\n    @Published var selectedPriority: Task.Priority?\n    \n    var filteredTasks: [Task] {\n        tasks.filter { task in\n            let matchesSearch = searchText.isEmpty || \n                task.title.localizedCaseInsensitiveContains(searchText) ||\n                task.description.localizedCaseInsensitiveContains(searchText)\n            \n            let matchesPriority = selectedPriority == nil || task.priority == selectedPriority\n            \n            return matchesSearch && matchesPriority\n        }\n    }\n    \n    var completedTasks: [Task] {\n        filteredTasks.filter { $0.isCompleted }\n    }\n    \n    var incompleteTasks: [Task] {\n        filteredTasks.filter { !$0.isCompleted }\n    }\n    \n    var overdueTasks: [Task] {\n        filteredTasks.filter { $0.isOverdue }\n    }\n    \n    // MARK: - Intent Methods\n    \n    @MainActor\n    func loadTasks() async {\n        isLoading = true\n        errorMessage = nil\n        \n        // Simulate network request\n        do {\n            try await Task.sleep(nanoseconds: 1_000_000_000) // 1 second\n            \n            // Sample data\n            tasks = [\n                Task(title: \"Learn SwiftUI\", description: \"Complete MVVM tutorial\", priority: .high),\n                Task(title: \"Build Todo App\", isCompleted: true, priority: .medium),\n                Task(title: \"Study Combine\", description: \"Reactive programming\", dueDate: Date().addingTimeInterval(86400), priority: .high),\n                Task(title: \"Read documentation\", dueDate: Date().addingTimeInterval(-86400), priority: .low)\n            ]\n        } catch {\n            errorMessage = \"Failed to load tasks: \\(error.localizedDescription)\"\n        }\n        \n        isLoading = false\n    }\n    \n    func addTask(title: String, description: String = \"\", dueDate: Date? = nil, priority: Task.Priority = .medium) {\n        let newTask = Task(title: title, description: description, dueDate: dueDate, priority: priority)\n        tasks.append(newTask)\n    }\n    \n    func toggleTaskCompletion(_ task: Task) {\n        if let index = tasks.firstIndex(where: { $0.id == task.id }) {\n            tasks[index].isCompleted.toggle()\n        }\n    }\n    \n    func deleteTask(_ task: Task) {\n        tasks.removeAll { $0.id == task.id }\n    }\n    \n    func deleteTasks(at offsets: IndexSet) {\n        tasks.remove(atOffsets: offsets)\n    }\n    \n    func updateTask(_ task: Task) {\n        if let index = tasks.firstIndex(where: { $0.id == task.id }) {\n            tasks[index] = task\n        }\n    }\n}\n\n// MARK: - View\nstruct TaskListView: View {\n    @StateObject private var viewModel = TaskViewModel()\n    @State private var showingAddTask = false\n    \n    var body: some View {\n        NavigationView {\n            VStack {\n                // Search and Filter\n                VStack {\n                    TextField(\"Search tasks...\", text: $viewModel.searchText)\n                        .textFieldStyle(RoundedBorderTextFieldStyle())\n                        .padding(.horizontal)\n                    \n                    ScrollView(.horizontal, showsIndicators: false) {\n                        HStack {\n                            FilterButton(title: \"All\", isSelected: viewModel.selectedPriority == nil) {\n                                viewModel.selectedPriority = nil\n                            }\n                            \n                            ForEach(Task.Priority.allCases, id: \\.self) { priority in\n                                FilterButton(\n                                    title: priority.rawValue.capitalized,\n                                    isSelected: viewModel.selectedPriority == priority\n                                ) {\n                                    viewModel.selectedPriority = priority\n                                }\n                            }\n                        }\n                        .padding(.horizontal)\n                    }\n                }\n                \n                // Content\n                if viewModel.isLoading {\n                    ProgressView(\"Loading tasks...\")\n                        .frame(maxHeight: .infinity)\n                } else if let error = viewModel.errorMessage {\n                    VStack {\n                        Image(systemName: \"exclamationmark.triangle\")\n                            .font(.largeTitle)\n                            .foregroundColor(.orange)\n                        Text(\"Error loading tasks\")\n                        Text(error)\n                            .font(.caption)\n                            .foregroundColor(.secondary)\n                        Button(\"Try Again\") {\n                            Task {\n                                await viewModel.loadTasks()\n                            }\n                        }\n                        .buttonStyle(.bordered)\n                    }\n                    .frame(maxHeight: .infinity)\n                } else {\n                    List {\n                        // Overdue Section\n                        if !viewModel.overdueTasks.isEmpty {\n                            Section(\"Overdue\") {\n                                ForEach(viewModel.overdueTasks) { task in\n                                    TaskRowView(task: task, viewModel: viewModel)\n                                        .foregroundColor(.red)\n                                }\n                            }\n                        }\n                        \n                        // Incomplete Tasks\n                        Section(\"To Do (\\(viewModel.incompleteTasks.count))\" ) {\n                            ForEach(viewModel.incompleteTasks) { task in\n                                TaskRowView(task: task, viewModel: viewModel)\n                            }\n                            .onDelete { offsets in\n                                let incompleteTasks = viewModel.incompleteTasks\n                                let tasksToDelete = offsets.map { incompleteTasks[$0] }\n                                for task in tasksToDelete {\n                                    viewModel.deleteTask(task)\n                                }\n                            }\n                        }\n                        \n                        // Completed Tasks\n                        Section(\"Completed (\\(viewModel.completedTasks.count))\" ) {\n                            ForEach(viewModel.completedTasks) { task in\n                                TaskRowView(task: task, viewModel: viewModel)\n                                    .foregroundColor(.green)\n                            }\n                        }\n                    }\n                    .listStyle(InsetGroupedListStyle())\n                }\n            }\n            .navigationTitle(\"My Tasks\")\n            .toolbar {\n                ToolbarItem(placement: .navigationBarTrailing) {\n                    Button(action: { showingAddTask = true }) {\n                        Image(systemName: \"plus\")\n                    }\n                }\n            }\n            .sheet(isPresented: $showingAddTask) {\n                AddTaskView(viewModel: viewModel)\n            }\n        }\n        .task {\n            await viewModel.loadTasks()\n        }\n    }\n}\n\n// MARK: - Supporting Views\nstruct TaskRowView: View {\n    let task: Task\n    let viewModel: TaskViewModel\n    \n    var body: some View {\n        HStack {\n            Button(action: {\n                viewModel.toggleTaskCompletion(task)\n            }) {\n                Image(systemName: task.isCompleted ? \"checkmark.circle.fill\" : \"circle\")\n                    .foregroundColor(task.isCompleted ? .green : .gray)\n            }\n            .buttonStyle(PlainButtonStyle())\n            \n            VStack(alignment: .leading) {\n                Text(task.title)\n                    .strikethrough(task.isCompleted)\n                    .font(.headline)\n                \n                if !task.description.isEmpty {\n                    Text(task.description)\n                        .font(.caption)\n                        .foregroundColor(.secondary)\n                        .strikethrough(task.isCompleted)\n                }\n                \n                if let dueDate = task.dueDate {\n                    HStack {\n                        Image(systemName: \"calendar\")\n                            .font(.caption2)\n                        Text(dueDate, style: .date)\n                            .font(.caption2)\n                    }\n                    .foregroundColor(task.isOverdue ? .red : .secondary)\n                }\n            }\n            \n            Spacer()\n            \n            PriorityView(priority: task.priority)\n        }\n        .padding(.vertical, 4)\n    }\n}\n\nstruct PriorityView: View {\n    let priority: Task.Priority\n    \n    var color: Color {\n        switch priority {\n        case .low: return .green\n        case .medium: return .orange\n        case .high: return .red\n        }\n    }\n    \n    var body: some View {\n        Text(priority.rawValue.capitalized)\n            .font(.caption)\n            .padding(.horizontal, 8)\n            .padding(.vertical, 4)\n            .background(color.opacity(0.2))\n            .foregroundColor(color)\n            .cornerRadius(4)\n    }\n}\n\nstruct FilterButton: View {\n    let title: String\n    let isSelected: Bool\n    let action: () -> Void\n    \n    var body: some View {\n        Button(action: action) {\n            Text(title)\n                .font(.caption)\n                .padding(.horizontal, 12)\n                .padding(.vertical, 6)\n                .background(isSelected ? Color.blue : Color.gray.opacity(0.2))\n                .foregroundColor(isSelected ? .white : .primary)\n                .cornerRadius(8)\n        }\n    }\n}\n\nstruct AddTaskView: View {\n    @Environment(\\.dismiss) private var dismiss\n    @ObservedObject var viewModel: TaskViewModel\n    \n    @State private var title = \"\"\n    @State private var description = \"\"\n    @State private var dueDate = Date()\n    @State private var hasDueDate = false\n    @State private var priority: Task.Priority = .medium\n    \n    var body: some View {\n        NavigationView {\n            Form {\n                Section(\"Task Details\") {\n                    TextField(\"Title\", text: $title)\n                    TextField(\"Description (optional)\", text: $description)\n                }\n                \n                Section(\"Priority\") {\n                    Picker(\"Priority\", selection: $priority) {\n                        ForEach(Task.Priority.allCases, id: \\.self) { priority in\n                            Text(priority.rawValue.capitalized).tag(priority)\n                        }\n                    }\n                    .pickerStyle(SegmentedPickerStyle())\n                }\n                \n                Section(\"Due Date\") {\n                    Toggle(\"Add due date\", isOn: $hasDueDate)\n                    \n                    if hasDueDate {\n                        DatePicker(\"Due Date\", selection: $dueDate, in: Date()..., displayedComponents: .date)\n                    }\n                }\n            }\n            .navigationTitle(\"Add Task\")\n            .toolbar {\n                ToolbarItem(placement: .cancellationAction) {\n                    Button(\"Cancel\") {\n                        dismiss()\n                    }\n                }\n                \n                ToolbarItem(placement: .confirmationAction) {\n                    Button(\"Add\") {\n                        viewModel.addTask(\n                            title: title,\n                            description: description,\n                            dueDate: hasDueDate ? dueDate : nil,\n                            priority: priority\n                        )\n                        dismiss()\n                    }\n                    .disabled(title.isEmpty)\n                }\n            }\n        }\n    }\n}\n\n// MARK: - Preview\n#Preview {\n    TaskListView()\n}",
      "category": "App Architecture",
      "estimatedTime": 240,
      "dependencies": ["structs_classes", "swiftui_basics"],
      "challenge": {
        "instructions": "Create a complete Weather App using MVVM architecture with the following requirements:\n\nPART 1: Model Layer (60 min)\n1. Create 'Weather' struct with: location, temperature, condition, humidity, windSpeed\n2. Add computed properties: temperatureString, conditionIcon, feelsLikeTemperature\n3. Create 'WeatherService' protocol and mock implementation for testing\n4. Add error types for network failures and invalid data\n\nPART 2: ViewModel Layer (60 min)\n5. Create 'WeatherViewModel' with @Published properties for weather data, loading state, and errors\n6. Implement methods: fetchWeather(for:), searchLocation(_:), toggleTemperatureUnit()\n7. Add business logic for temperature conversion (Celsius/Fahrenheit)\n8. Implement search functionality with debouncing\n\nPART 3: View Layer (60 min)\n9. Create 'WeatherView' with current weather display and search field\n10. Build 'WeatherDetailView' showing extended forecast\n11. Add loading states, error handling, and empty states\n12. Implement temperature unit toggle with animations\n\nPART 4: Advanced Features (60 min)\n13. Add location services to get user's current location\n14. Implement offline support with cached weather data\n15. Add weather alerts and notifications\n16. Create widget extension showing current weather\n\nTest your MVVM implementation by verifying that business logic is in ViewModel and UI is in Views!",
        "starterCode": "// === PART 1: Model Layer ===\n// Define Weather model and service protocol here\n\n\n// === PART 2: ViewModel Layer ===\n// Create WeatherViewModel with @Published properties\n\n\n// === PART 3: View Layer ===\n// Build SwiftUI views that observe the ViewModel\n\n\n// === PART 4: Advanced Features ===\n// Add location services, caching, and widgets\n\n",
        "solution": "// === PART 1: Model Layer ===\nimport Foundation\n\nstruct Weather: Identifiable, Codable {\n    let id = UUID()\n    let location: String\n    let temperature: Double\n    let condition: WeatherCondition\n    let humidity: Int\n    let windSpeed: Double\n    let feelsLike: Double\n    let sunrise: Date\n    let sunset: Date\n    \n    var temperatureString: String {\n        return \"\\(Int(temperature))Â°\"\n    }\n    \n    var feelsLikeString: String {\n        return \"\\(Int(feelsLike))Â°\"\n    }\n    \n    var conditionIcon: String {\n        switch condition {\n        case .sunny: return \"sun.max.fill\"\n        case .cloudy: return \"cloud.fill\"\n        case .rainy: return \"cloud.rain.fill\"\n        case .snowy: return \"snow\"\n        case .thunderstorm: return \"cloud.bolt.fill\"\n        }\n    }\n    \n    var isDaytime: Bool {\n        let now = Date()\n        return now >= sunrise && now <= sunset\n    }\n}\n\nenum WeatherCondition: String, Codable, CaseIterable {\n    case sunny, cloudy, rainy, snowy, thunderstorm\n}\n\nenum TemperatureUnit: String, CaseIterable {\n    case celsius, fahrenheit\n    \n    var symbol: String {\n        switch self {\n        case .celsius: return \"Â°C\"\n        case .fahrenheit: return \"Â°F\"\n        }\n    }\n}\n\nenum WeatherError: LocalizedError {\n    case networkError\n    case locationNotFound\n    case invalidData\n    \n    var errorDescription: String? {\n        switch self {\n        case .networkError: return \"Unable to fetch weather data\"\n        case .locationNotFound: return \"Location not found\"\n        case .invalidData: return \"Invalid weather data received\"\n        }\n    }\n}\n\n// Service Protocol for dependency injection\nprotocol WeatherServiceProtocol {\n    func fetchWeather(for location: String) async throws -> Weather\n    func fetchWeather(for coordinates: (Double, Double)) async throws -> Weather\n}\n\n// Mock implementation for testing\nclass MockWeatherService: WeatherServiceProtocol {\n    func fetchWeather(for location: String) async throws -> Weather {\n        // Simulate network delay\n        try await Task.sleep(nanoseconds: 1_000_000_000)\n        \n        return Weather(\n            location: location,\n            temperature: 22.0,\n            condition: .sunny,\n            humidity: 65,\n            windSpeed: 5.5,\n            feelsLike: 24.0,\n            sunrise: Date(),\n            sunset: Date().addingTimeInterval(43200)\n        )\n    }\n    \n    func fetchWeather(for coordinates: (Double, Double)) async throws -> Weather {\n        try await fetchWeather(for: \"Current Location\")\n    }\n}\n\n// === PART 2: ViewModel Layer ===\nimport Combine\nimport SwiftUI\n\nclass WeatherViewModel: ObservableObject {\n    @Published var currentWeather: Weather?\n    @Published var isLoading = false\n    @Published var error: WeatherError?\n    @Published var searchText = \"\"\n    @Published var temperatureUnit: TemperatureUnit = .celsius\n    \n    private let weatherService: WeatherServiceProtocol\n    private var cancellables = Set<AnyCancellable>()\n    \n    init(weatherService: WeatherServiceProtocol = MockWeatherService()) {\n        self.weatherService = weatherService\n        \n        // Debounce search\n        $searchText\n            .debounce(for: .seconds(0.5), scheduler: RunLoop.main)\n            .removeDuplicates()\n            .sink { [weak self] query in\n                if !query.isEmpty {\n                    self?.fetchWeather(for: query)\n                }\n            }\n            .store(in: &cancellables)\n    }\n    \n    @MainActor\n    func fetchWeather(for location: String) {\n        guard !location.isEmpty else { return }\n        \n        isLoading = true\n        error = nil\n        \n        Task {\n            do {\n                let weather = try await weatherService.fetchWeather(for: location)\n                currentWeather = weather\n            } catch {\n                self.error = WeatherError.networkError\n            }\n            isLoading = false\n        }\n    }\n    \n    func toggleTemperatureUnit() {\n        temperatureUnit = temperatureUnit == .celsius ? .fahrenheit : .celsius\n    }\n    \n    func convertTemperature(_ celsius: Double) -> Double {\n        switch temperatureUnit {\n        case .celsius:\n            return celsius\n        case .fahrenheit:\n            return (celsius * 9/5) + 32\n        }\n    }\n    \n    func formattedTemperature(_ celsius: Double) -> String {\n        let temp = convertTemperature(celsius)\n        return \"\\(Int(temp))\\(temperatureUnit.symbol)\"\n    }\n}\n\n// === PART 3: View Layer ===\nstruct WeatherView: View {\n    @StateObject private var viewModel = WeatherViewModel()\n    \n    var body: some View {\n        NavigationView {\n            VStack(spacing: 20) {\n                // Search Bar\n                HStack {\n                    Image(systemName: \"magnifyingglass\")\n                        .foregroundColor(.secondary)\n                    TextField(\"Search location...\", text: $viewModel.searchText)\n                }\n                .padding()\n                .background(Color(.systemGray6))\n                .cornerRadius(10)\n                .padding(.horizontal)\n                \n                // Content\n                if viewModel.isLoading {\n                    ProgressView(\"Fetching weather...\")\n                        .frame(maxHeight: .infinity)\n                } else if let error = viewModel.error {\n                    VStack {\n                        Image(systemName: \"exclamationmark.triangle\")\n                            .font(.largeTitle)\n                            .foregroundColor(.orange)\n                        Text(error.localizedDescription)\n                            .multilineTextAlignment(.center)\n                        Button(\"Try Again\") {\n                            if !viewModel.searchText.isEmpty {\n                                viewModel.fetchWeather(for: viewModel.searchText)\n                            }\n                        }\n                        .buttonStyle(.bordered)\n                    }\n                    .frame(maxHeight: .infinity)\n                } else if let weather = viewModel.currentWeather {\n                    ScrollView {\n                        VStack(spacing: 20) {\n                            // Current Weather\n                            VStack(spacing: 10) {\n                                Text(weather.location)\n                                    .font(.title2)\n                                    .fontWeight(.semibold)\n                                \n                                HStack {\n                                    Image(systemName: weather.conditionIcon)\n                                        .font(.system(size: 60))\n                                        .foregroundColor(weather.isDaytime ? .orange : .blue)\n                                    \n                                    Text(viewModel.formattedTemperature(weather.temperature))\n                                        .font(.system(size: 50, weight: .thin))\n                                }\n                                \n                                Text(weather.condition.rawValue.capitalized)\n                                    .font(.title3)\n                                    .foregroundColor(.secondary)\n                                \n                                Text(\"Feels like \\(viewModel.formattedTemperature(weather.feelsLike))\")\n                                    .foregroundColor(.secondary)\n                            }\n                            .padding()\n                            .background(Color(.systemGray6))\n                            .cornerRadius(15)\n                            \n                            // Weather Details\n                            LazyVGrid(columns: [GridItem(.flexible()), GridItem(.flexible())], spacing: 10) {\n                                WeatherDetailCard(title: \"Humidity\", value: \"\\(weather.humidity)%\", icon: \"humidity\")\n                                WeatherDetailCard(title: \"Wind Speed\", value: \"\\(weather.windSpeed) km/h\", icon: \"wind\")\n                            }\n                        }\n                        .padding()\n                    }\n                } else {\n                    VStack {\n                        Image(systemName: \"cloud.sun\")\n                            .font(.system(size: 60))\n                            .foregroundColor(.secondary)\n                        Text(\"Search for a location to see weather\")\n                            .foregroundColor(.secondary)\n                    }\n                    .frame(maxHeight: .infinity)\n                }\n            }\n            .navigationTitle(\"Weather\")\n            .toolbar {\n                ToolbarItem(placement: .navigationBarTrailing) {\n                    Button(action: viewModel.toggleTemperatureUnit) {\n                        Text(viewModel.temperatureUnit.symbol)\n                    }\n                }\n            }\n        }\n    }\n}\n\nstruct WeatherDetailCard: View {\n    let title: String\n    let value: String\n    let icon: String\n    \n    var body: some View {\n        VStack {\n            Image(systemName: icon)\n                .font(.title2)\n                .foregroundColor(.blue)\n            Text(title)\n                .font(.caption)\n                .foregroundColor(.secondary)\n            Text(value)\n                .font(.headline)\n        }\n        .padding()\n        .frame(maxWidth: .infinity)\n        .background(Color(.systemGray6))\n        .cornerRadius(10)\n    }\n}\n\n// === PART 4: Advanced Features ===\n// Location Service (simplified)\nclass LocationService: ObservableObject {\n    @Published var currentLocation: (Double, Double)?\n    \n    func requestLocation() {\n        // In real implementation, this would use CoreLocation\n        // For demo, use mock coordinates\n        currentLocation = (37.7749, -122.4194) // San Francisco\n    }\n}\n\n// Extended WeatherViewModel with location\nextension WeatherViewModel {\n    @MainActor\n    func fetchCurrentLocationWeather() {\n        let locationService = LocationService()\n        locationService.requestLocation()\n        \n        // In real app, you'd observe the location service\n        fetchWeather(for: \"San Francisco\")\n    }\n}\n\n// Caching support\nclass WeatherCache {\n    private let cache = NSCache<NSString, Weather>()\n    \n    func getWeather(for location: String) -> Weather? {\n        return cache.object(forKey: location as NSString)\n    }\n    \n    func setWeather(_ weather: Weather, for location: String) {\n        cache.setObject(weather, forKey: location as NSString)\n    }\n}\n\n#Preview {\n    WeatherView()\n}",
        "hints": [
          "PART 1: Use enums for weather conditions and temperature units. Protocols make testing easier",
          "PART 2: Remember @Published properties automatically update the view. Use debouncing for search to avoid excessive API calls",
          "PART 3: Use @StateObject when creating the ViewModel, @ObservedObject when passing it to child views",
          "PART 4: For location services, you'll need to request user permission and handle coordinates",
          "Use async/await for network calls instead of completion handlers for cleaner code",
          "Implement Equatable for your models to enable diffing and efficient UI updates",
          "Consider using AppStorage for persisting user preferences like temperature unit",
          "For caching, you can use NSCache or write to UserDefaults for simple cases"
        ],
        "testCases": [
          {
            "input": "viewModel.convertTemperature(0)",
            "expectedOutput": "32.0",
            "description": "Celsius to Fahrenheit conversion should work correctly"
          },
          {
            "input": "viewModel.currentWeather?.location == \"Test City\"",
            "expectedOutput": "true",
            "description": "Weather data should be properly set after successful fetch"
          },
          {
            "input": "viewModel.isLoading == false after fetch",
            "expectedOutput": "true",
            "description": "Loading state should be false after data is loaded"
          }
        ]
      }
    },
    {
      "id": "view_lifecycle",
      "title": "View Lifecycle",
      "description": "Master view appearance and disappearance events to manage state, resources, and data loading in SwiftUI",
      "difficulty": "beginner",
      "theory": "# View Lifecycle - onAppear & onDisappear\n\n## 1. Understanding View Lifecycle (45 min)\n\n### What is View Lifecycle?\n- The sequence of events from when a view **appears** to when it **disappears**\n- SwiftUI provides modifiers to hook into these events\n- Essential for **resource management** and **data loading**\n\n### Why View Lifecycle Matters:\n- **Load data** when views become visible\n- **Clean up resources** when views disappear\n- **Start/stop animations** appropriately\n- **Manage subscriptions** and timers\n- **Optimize performance** by loading only when needed\n\n### Real-world Analogy:\n- **onAppear**: Like opening a book - you start reading when it's open\n- **onDisappear**: Like closing a book - you stop reading and bookmark your place\n\n## 2. onAppear Modifier (60 min)\n\n### Basic Syntax:\n```swift\nstruct ContentView: View {\n    var body: some View {\n        Text(\"Hello, World!\")\n            .onAppear {\n                // This runs when the view appears\n                print(\"Text view appeared!\")\n            }\n    }\n}\n```\n\n### Common Use Cases for onAppear:\n\n#### Data Loading:\n```swift\nstruct UserProfileView: View {\n    @State private var user: User?\n    \n    var body: some View {\n        VStack {\n            if let user = user {\n                Text(\"Welcome, \\(user.name)!\")\n            } else {\n                ProgressView(\"Loading...\")\n            }\n        }\n        .onAppear {\n            loadUserData()\n        }\n    }\n    \n    private func loadUserData() {\n        // Simulate network request\n        DispatchQueue.main.asyncAfter(deadline: .now() + 1) {\n            user = User(name: \"John Doe\", email: \"john@example.com\")\n        }\n    }\n}\n```\n\n#### Starting Animations:\n```swift\nstruct AnimatedCircle: View {\n    @State private var scale: CGFloat = 1.0\n    \n    var body: some View {\n        Circle()\n            .frame(width: 100, height: 100)\n            .scaleEffect(scale)\n            .onAppear {\n                withAnimation(.easeInOut(duration: 1).repeatForever()) {\n                    scale = 1.5\n                }\n            }\n    }\n}\n```\n\n#### Setting Up Timers:\n```swift\nstruct TimerView: View {\n    @State private var counter = 0\n    @State private var timer: Timer?\n    \n    var body: some View {\n        Text(\"Counter: \\(counter)\")\n            .onAppear {\n                timer = Timer.scheduledTimer(withTimeInterval: 1, repeats: true) { _ in\n                    counter += 1\n                }\n            }\n    }\n}\n```\n\n## 3. onDisappear Modifier (60 min)\n\n### Basic Syntax:\n```swift\nstruct ContentView: View {\n    var body: some View {\n        Text(\"Hello, World!\")\n            .onDisappear {\n                // This runs when the view disappears\n                print(\"Text view disappeared!\")\n            }\n    }\n}\n```\n\n### Common Use Cases for onDisappear:\n\n#### Cleaning Up Resources:\n```swift\nstruct AudioPlayerView: View {\n    @State private var audioPlayer: AudioPlayer?\n    \n    var body: some View {\n        VStack {\n            Button(\"Play\") {\n                audioPlayer?.play()\n            }\n            Button(\"Stop\") {\n                audioPlayer?.stop()\n            }\n        }\n        .onAppear {\n            audioPlayer = AudioPlayer()\n            audioPlayer?.load(\"song.mp3\")\n        }\n        .onDisappear {\n            audioPlayer?.stop()\n            audioPlayer = nil // Clean up\n        }\n    }\n}\n```\n\n#### Stopping Timers:\n```swift\nstruct StopwatchView: View {\n    @State private var seconds = 0\n    @State private var timer: Timer?\n    \n    var body: some View {\n        Text(\"Time: \\(seconds)s\")\n            .onAppear {\n                timer = Timer.scheduledTimer(withTimeInterval: 1, repeats: true) { _ in\n                    seconds += 1\n                }\n            }\n            .onDisappear {\n                timer?.invalidate()\n                timer = nil\n            }\n    }\n}\n```\n\n#### Saving Data:\n```swift\nstruct NoteEditorView: View {\n    @State private var noteText = \"\"\n    \n    var body: some View {\n        TextEditor(text: $noteText)\n            .onAppear {\n                // Load saved note\n                noteText = UserDefaults.standard.string(forKey: \"savedNote\") ?? \"\"\n            }\n            .onDisappear {\n                // Auto-save when leaving\n                UserDefaults.standard.set(noteText, forKey: \"savedNote\")\n            }\n    }\n}\n```\n\n## 4. Combined Usage Patterns (45 min)\n\n### Navigation Flow Example:\n```swift\nstruct ContentView: View {\n    @State private var isShowingDetail = false\n    \n    var body: some View {\n        NavigationView {\n            VStack {\n                Button(\"Show Detail\") {\n                    isShowingDetail = true\n                }\n            }\n            .sheet(isPresented: $isShowingDetail) {\n                DetailView()\n            }\n        }\n    }\n}\n\nstruct DetailView: View {\n    @State private var data: String = \"\"\n    \n    var body: some View {\n        VStack {\n            Text(\"Detail View\")\n            Text(\"Data: \\(data)\")\n        }\n        .onAppear {\n            print(\"DetailView appeared\")\n            loadData()\n        }\n        .onDisappear {\n            print(\"DetailView disappeared\")\n            saveData()\n        }\n    }\n    \n    private func loadData() {\n        // Simulate data loading\n        data = \"Loaded data\"\n    }\n    \n    private func saveData() {\n        // Save any changes\n        print(\"Saving data: \\(data)\")\n    }\n}\n```\n\n### Tab View Lifecycle:\n```swift\nstruct TabLifecycleView: View {\n    var body: some View {\n        TabView {\n            FirstTab()\n                .tabItem { Label(\"First\", systemImage: \"1.circle\") }\n            \n            SecondTab()\n                .tabItem { Label(\"Second\", systemImage: \"2.circle\") }\n        }\n    }\n}\n\nstruct FirstTab: View {\n    var body: some View {\n        Text(\"First Tab\")\n            .onAppear {\n                print(\"First tab became active\")\n            }\n            .onDisappear {\n                print(\"First tab became inactive\")\n            }\n    }\n}\n```\n\n## 5. Advanced Lifecycle Scenarios (45 min)\n\n### Conditional Appearance:\n```swift\nstruct ConditionalView: View {\n    @State private var showFeature = false\n    \n    var body: some View {\n        VStack {\n            Toggle(\"Show Feature\", isOn: $showFeature)\n            \n            if showFeature {\n                PremiumFeature()\n                    .onAppear {\n                        print(\"Premium feature activated\")\n                        startPremiumService()\n                    }\n                    .onDisappear {\n                        print(\"Premium feature deactivated\")\n                        stopPremiumService()\n                    }\n            }\n        }\n    }\n    \n    private func startPremiumService() {\n        // Start premium features\n    }\n    \n    private func stopPremiumService() {\n        // Clean up premium resources\n    }\n}\n```\n\n### Multiple View Hierarchy:\n```swift\nstruct ParentView: View {\n    var body: some View {\n        VStack {\n            Text(\"Parent View\")\n                .onAppear { print(\"Parent appeared\") }\n                .onDisappear { print(\"Parent disappeared\") }\n            \n            ChildView()\n        }\n    }\n}\n\nstruct ChildView: View {\n    var body: some View {\n        Text(\"Child View\")\n            .onAppear { print(\"Child appeared\") }\n            .onDisappear { print(\"Child disappeared\") }\n    }\n}\n```\n\n### Performance Optimization:\n```swift\nstruct LazyLoadingView: View {\n    var body: some View {\n        ScrollView {\n            LazyVStack {\n                ForEach(1...100, id: \\.self) { index in\n                    RowView(index: index)\n                        .onAppear {\n                            // Only load data when row becomes visible\n                            print(\"Row \\(index) appeared\")\n                        }\n                        .onDisappear {\n                            // Optional: cleanup when row leaves screen\n                            print(\"Row \\(index) disappeared\")\n                        }\n                }\n            }\n        }\n    }\n}\n```\n\n## 6. Best Practices & Common Pitfalls (45 min)\n\n### Do's and Don'ts:\n\n#### âœ… DO:\n- Use `onAppear` for **one-time setup**\n- Use `onDisappear` for **cleanup**\n- Consider **performance** when loading data\n- Handle **async operations** properly\n- Test with **navigation** and **tab changes**\n\n#### âŒ DON'T:\n- Put **heavy computation** directly in modifiers\n- Forget to **clean up resources**\n- Assume `onAppear` runs only once\n- Block the **main thread** with long operations\n\n### Memory Management:\n```swift\nstruct SafeTimerView: View {\n    @State private var counter = 0\n    @State private var timer: Timer?\n    \n    var body: some View {\n        VStack {\n            Text(\"Counter: \\(counter)\")\n            \n            Button(\"Reset\") {\n                counter = 0\n            }\n        }\n        .onAppear {\n            // Safe timer setup\n            timer = Timer.scheduledTimer(withTimeInterval: 1, repeats: true) { _ in\n                counter += 1\n            }\n        }\n        .onDisappear {\n            // Always clean up!\n            timer?.invalidate()\n            timer = nil\n        }\n    }\n}\n```\n\n### Error Handling:\n```swift\nstruct RobustDataLoadingView: View {\n    @State private var data: String? = nil\n    @State private var error: String? = nil\n    @State private var isLoading = false\n    \n    var body: some View {\n        VStack {\n            if isLoading {\n                ProgressView()\n            } else if let error = error {\n                Text(\"Error: \\(error)\")\n                    .foregroundColor(.red)\n            } else if let data = data {\n                Text(\"Data: \\(data)\")\n            }\n        }\n        .onAppear {\n            loadData()\n        }\n    }\n    \n    private func loadData() {\n        isLoading = true\n        error = nil\n        \n        // Simulate async operation\n        DispatchQueue.main.asyncAfter(deadline: .now() + 2) {\n            isLoading = false\n            \n            if Bool.random() {\n                data = \"Successfully loaded data\"\n            } else {\n                error = \"Failed to load data\"\n            }\n        }\n    }\n}\n```\n\n## Practice Exercises\n\nComplete all exercises to master view lifecycle management in SwiftUI!",
      "codeExample": "// === BASIC LIFECYCLE EXAMPLES ===\n\nimport SwiftUI\n\n// Simple onAppear/onDisappear\nstruct LifecycleDemo: View {\n    var body: some View {\n        VStack {\n            Text(\"Hello, SwiftUI!\")\n                .onAppear {\n                    print(\"âœ… Text view appeared on screen\")\n                }\n                .onDisappear {\n                    print(\"âŒ Text view disappeared from screen\")\n                }\n        }\n    }\n}\n\n// Data loading example\nstruct UserDashboard: View {\n    @State private var userName: String = \"\"\n    @State private var isLoading = false\n    @State private var lastUpdated = Date()\n    \n    var body: some View {\n        VStack(spacing: 20) {\n            if isLoading {\n                ProgressView(\"Loading user data...\")\n            } else {\n                Text(\"Welcome, \\(userName)\")\n                    .font(.title)\n                \n                Text(\"Last updated: \\(lastUpdated, style: .time)\")\n                    .font(.caption)\n                    .foregroundColor(.gray)\n            }\n        }\n        .onAppear {\n            print(\"ðŸ“± Dashboard appeared - loading user data\")\n            loadUserData()\n        }\n        .onDisappear {\n            print(\"ðŸ‘‹ Dashboard disappeared - saving session\")\n            saveUserSession()\n        }\n    }\n    \n    private func loadUserData() {\n        isLoading = true\n        \n        // Simulate network request\n        DispatchQueue.main.asyncAfter(deadline: .now() + 1.5) {\n            userName = \"John Appleseed\"\n            lastUpdated = Date()\n            isLoading = false\n            print(\"âœ… User data loaded successfully\")\n        }\n    }\n    \n    private func saveUserSession() {\n        // Simulate saving to UserDefaults\n        UserDefaults.standard.set(userName, forKey: \"lastUserName\")\n        print(\"ðŸ’¾ User session saved\")\n    }\n}\n\n// Timer management example\nstruct StopwatchView: View {\n    @State private var seconds = 0\n    @State private var timer: Timer?\n    @State private var isRunning = false\n    \n    var body: some View {\n        VStack(spacing: 20) {\n            Text(\"\\(seconds) seconds\")\n                .font(.system(size: 40, weight: .bold))\n            \n            HStack {\n                Button(isRunning ? \"Stop\" : \"Start\") {\n                    toggleTimer()\n                }\n                .buttonStyle(.borderedProminent)\n                \n                Button(\"Reset\") {\n                    resetTimer()\n                }\n                .buttonStyle(.bordered)\n            }\n        }\n        .onAppear {\n            print(\"â±ï¸ Stopwatch view appeared\")\n            // Optional: Restore previous state\n            restoreTimerState()\n        }\n        .onDisappear {\n            print(\"ðŸ›‘ Stopwatch view disappeared\")\n            // Critical: Always stop timer when view disappears\n            timer?.invalidate()\n            timer = nil\n            saveTimerState()\n        }\n    }\n    \n    private func toggleTimer() {\n        if isRunning {\n            timer?.invalidate()\n            timer = nil\n        } else {\n            timer = Timer.scheduledTimer(withTimeInterval: 1, repeats: true) { _ in\n                seconds += 1\n            }\n        }\n        isRunning.toggle()\n    }\n    \n    private func resetTimer() {\n        timer?.invalidate()\n        timer = nil\n        seconds = 0\n        isRunning = false\n    }\n    \n    private func saveTimerState() {\n        UserDefaults.standard.set(seconds, forKey: \"stopwatchSeconds\")\n        UserDefaults.standard.set(isRunning, forKey: \"stopwatchRunning\")\n    }\n    \n    private func restoreTimerState() {\n        seconds = UserDefaults.standard.integer(forKey: \"stopwatchSeconds\")\n        isRunning = UserDefaults.standard.bool(forKey: \"stopwatchRunning\")\n        \n        if isRunning {\n            toggleTimer() // Restart timer if it was running\n        }\n    }\n}\n\n// Navigation lifecycle example\nstruct MainAppView: View {\n    @State private var selectedTab = 0\n    \n    var body: some View {\n        TabView(selection: $selectedTab) {\n            HomeView()\n                .tabItem {\n                    Image(systemName: \"house\")\n                    Text(\"Home\")\n                }\n                .tag(0)\n            \n            ProfileView()\n                .tabItem {\n                    Image(systemName: \"person\")\n                    Text(\"Profile\")\n                }\n                .tag(1)\n            \n            SettingsView()\n                .tabItem {\n                    Image(systemName: \"gear\")\n                    Text(\"Settings\")\n                }\n                .tag(2)\n        }\n        .onAppear {\n            print(\"ðŸš€ Main app view appeared\")\n        }\n        .onDisappear {\n            print(\"ðŸ”Œ Main app view disappeared\")\n        }\n    }\n}\n\nstruct HomeView: View {\n    var body: some View {\n        NavigationView {\n            VStack {\n                Text(\"Home Screen\")\n                    .font(.largeTitle)\n                \n                NavigationLink(\"Go to Details\") {\n                    DetailView()\n                }\n                .padding()\n            }\n            .onAppear {\n                print(\"ðŸ  Home tab became active\")\n            }\n            .onDisappear {\n                print(\"ðŸ“´ Home tab became inactive\")\n            }\n        }\n    }\n}\n\nstruct DetailView: View {\n    @State private var data = \"\"\n    \n    var body: some View {\n        VStack {\n            TextField(\"Enter data\", text: $data)\n                .textFieldStyle(.roundedBorder)\n                .padding()\n            \n            Text(\"You entered: \\(data)\")\n        }\n        .navigationTitle(\"Detail\")\n        .onAppear {\n            print(\"ðŸ“– Detail view appeared\")\n            // Simulate loading data\n            data = \"Initial data\"\n        }\n        .onDisappear {\n            print(\"ðŸ“• Detail view disappeared\")\n            // Auto-save when leaving\n            UserDefaults.standard.set(data, forKey: \"detailData\")\n        }\n    }\n}\n\nstruct ProfileView: View {\n    var body: some View {\n        Text(\"Profile Screen\")\n            .onAppear { print(\"ðŸ‘¤ Profile tab became active\") }\n            .onDisappear { print(\"ðŸ“µ Profile tab became inactive\") }\n    }\n}\n\nstruct SettingsView: View {\n    var body: some View {\n        Text(\"Settings Screen\")\n            .onAppear { print(\"âš™ï¸ Settings tab became active\") }\n            .onDisappear { print(\"ðŸ“´ Settings tab became inactive\") }\n    }\n}\n\n// Conditional view lifecycle\nstruct FeatureToggleView: View {\n    @State private var showAdvancedFeatures = false\n    \n    var body: some View {\n        VStack(spacing: 30) {\n            Toggle(\"Show Advanced Features\", isOn: $showAdvancedFeatures)\n                .padding()\n            \n            if showAdvancedFeatures {\n                AdvancedFeaturesPanel()\n                    .transition(.opacity)\n            }\n            \n            Spacer()\n        }\n        .padding()\n    }\n}\n\nstruct AdvancedFeaturesPanel: View {\n    @State private var analyticsData: [String] = []\n    \n    var body: some View {\n        VStack {\n            Text(\"Advanced Features\")\n                .font(.title2)\n            \n            List(analyticsData, id: \\.self) { item in\n                Text(item)\n            }\n        }\n        .padding()\n        .background(Color.blue.opacity(0.1))\n        .cornerRadius(10)\n        .onAppear {\n            print(\"ðŸ”§ Advanced features panel appeared\")\n            startAnalyticsCollection()\n        }\n        .onDisappear {\n            print(\"ðŸ›‘ Advanced features panel disappeared\")\n            stopAnalyticsCollection()\n        }\n    }\n    \n    private func startAnalyticsCollection() {\n        print(\"ðŸ“Š Starting analytics collection...\")\n        // Simulate collecting data\n        analyticsData = [\"Event 1\", \"Event 2\", \"Event 3\"]\n    }\n    \n    private func stopAnalyticsCollection() {\n        print(\"ðŸ“ˆ Stopping analytics collection\")\n        analyticsData.removeAll()\n    }\n}",
      "category": "SwiftUI Basics",
      "estimatedTime": 180,
      "dependencies": ["swiftui_intro", "state_management"],
      "challenge": {
        "instructions": "Create a complete news reading app that demonstrates view lifecycle management:\n\nPART 1: Article List with Lifecycle (45 min)\n1. Create an 'ArticleListView' that loads news articles in onAppear\n2. Implement pull-to-refresh that reloads articles\n3. Add loading states and error handling\n4. Use onDisappear to cancel any ongoing network requests\n\nPART 2: Article Detail Management (45 min)\n5. Create an 'ArticleDetailView' that tracks reading progress\n6. Start a reading timer when article appears, stop when it disappears\n7. Auto-save reading progress when leaving the article\n8. Load saved progress when returning to the article\n\nPART 3: Tab-Based Navigation (45 min)\n9. Create a tab view with: Home, Bookmarks, Settings\n10. Each tab should properly manage its resources\n11. Implement bookmark functionality that persists data\n12. Add analytics tracking for tab changes\n\nPART 4: Advanced Lifecycle Scenarios (45 min)\n13. Create a 'VideoPlayerView' that manages video resources\n14. Implement picture-in-picture lifecycle handling\n15. Add background task management\n16. Create a 'NetworkMonitor' that starts/stops with app lifecycle\n\nTest your implementation by navigating between views and observing console logs!",
        "starterCode": "// === PART 1: Article List ===\n// Create your ArticleListView with lifecycle management here\n\n\n// === PART 2: Article Detail ===\n// Create ArticleDetailView with reading progress tracking\n\n\n// === PART 3: Tab Navigation ===\n// Implement tab-based app with proper resource management\n\n\n// === PART 4: Advanced Scenarios ===\n// Add video player and network monitoring\n\n",
        "solution": "// === PART 1: Article List ===\nstruct ArticleListView: View {\n    @State private var articles: [Article] = []\n    @State private var isLoading = false\n    @State private var error: String?\n    @State private var dataTask: URLSessionDataTask?\n    \n    var body: some View {\n        NavigationView {\n            Group {\n                if isLoading && articles.isEmpty {\n                    ProgressView(\"Loading articles...\")\n                } else if let error = error {\n                    VStack {\n                        Text(\"Error: \\(error)\")\n                            .foregroundColor(.red)\n                        Button(\"Retry\") {\n                            loadArticles()\n                        }\n                    }\n                } else {\n                    List(articles) { article in\n                        NavigationLink(destination: ArticleDetailView(article: article)) {\n                            VStack(alignment: .leading) {\n                                Text(article.title)\n                                    .font(.headline)\n                                Text(article.summary)\n                                    .font(.caption)\n                                    .foregroundColor(.gray)\n                            }\n                        }\n                    }\n                    .refreshable {\n                        await refreshArticles()\n                    }\n                }\n            }\n            .navigationTitle(\"News\")\n        }\n        .onAppear {\n            print(\"ðŸ“° Article list appeared\")\n            if articles.isEmpty {\n                loadArticles()\n            }\n        }\n        .onDisappear {\n            print(\"ðŸ“­ Article list disappeared\")\n            // Cancel any ongoing network requests\n            dataTask?.cancel()\n        }\n    }\n    \n    private func loadArticles() {\n        isLoading = true\n        error = nil\n        \n        // Simulate network request\n        dataTask = URLSession.shared.dataTask(with: URL(string: \"https://api.example.com/articles\")!) { _, _, _ in\n            DispatchQueue.main.asyncAfter(deadline: .now() + 1) {\n                isLoading = false\n                articles = [\n                    Article(id: 1, title: \"SwiftUI Tips\", summary: \"Learn advanced SwiftUI techniques\"),\n                    Article(id: 2, title: \"View Lifecycle\", summary: \"Master onAppear and onDisappear\"),\n                    Article(id: 3, title: \"State Management\", summary: \"Understanding @State and @Binding\")\n                ]\n                print(\"âœ… Articles loaded: \\(articles.count)\")\n            }\n        }\n        dataTask?.resume()\n    }\n    \n    private func refreshArticles() async {\n        print(\"ðŸ”„ Refreshing articles...\")\n        try? await Task.sleep(nanoseconds: 2_000_000_000) // Simulate network\n        await MainActor.run {\n            articles.shuffle() // Simulate new content\n            print(\"âœ… Articles refreshed\")\n        }\n    }\n}\n\n// === PART 2: Article Detail ===\nstruct ArticleDetailView: View {\n    let article: Article\n    @State private var readingProgress: Double = 0.0\n    @State private var readingTimer: Timer?\n    @State private var timeSpent: Int = 0\n    @Environment(\\.dismiss) private var dismiss\n    \n    var body: some View {\n        ScrollView {\n            VStack(alignment: .leading, spacing: 16) {\n                Text(article.title)\n                    .font(.title)\n                \n                Text(article.content)\n                    .font(.body)\n                \n                // Reading progress indicator\n                VStack {\n                    Text(\"Reading Progress: \\(Int(readingProgress * 100))%\")\n                    ProgressView(value: readingProgress)\n                        .progressViewStyle(.linear)\n                    Text(\"Time spent: \\(timeSpent) seconds\")\n                }\n                .padding()\n                .background(Color.gray.opacity(0.1))\n                .cornerRadius(8)\n            }\n            .padding()\n        }\n        .navigationTitle(article.title)\n        .navigationBarTitleDisplayMode(.inline)\n        .onAppear {\n            print(\"ðŸ“– Article detail appeared: \\(article.title)\")\n            startReadingSession()\n            loadReadingProgress()\n        }\n        .onDisappear {\n            print(\"ðŸ“• Article detail disappeared: \\(article.title)\")\n            endReadingSession()\n            saveReadingProgress()\n        }\n    }\n    \n    private func startReadingSession() {\n        // Start tracking reading time\n        readingTimer = Timer.scheduledTimer(withTimeInterval: 1, repeats: true) { _ in\n            timeSpent += 1\n            // Simulate progress based on time (in real app, track scroll position)\n            readingProgress = min(readingProgress + 0.01, 1.0)\n        }\n        print(\"â±ï¸ Started reading session\")\n    }\n    \n    private func endReadingSession() {\n        readingTimer?.invalidate()\n        readingTimer = nil\n        print(\"ðŸ›‘ Ended reading session. Total time: \\(timeSpent)s\")\n    }\n    \n    private func loadReadingProgress() {\n        let savedProgress = UserDefaults.standard.double(forKey: \"progress_\\(article.id)\")\n        let savedTime = UserDefaults.standard.integer(forKey: \"time_\\(article.id)\")\n        \n        if savedProgress > 0 {\n            readingProgress = savedProgress\n            timeSpent = savedTime\n            print(\"ðŸ“Š Loaded saved progress: \\(Int(savedProgress * 100))%\")\n        }\n    }\n    \n    private func saveReadingProgress() {\n        UserDefaults.standard.set(readingProgress, forKey: \"progress_\\(article.id)\")\n        UserDefaults.standard.set(timeSpent, forKey: \"time_\\(article.id)\")\n        print(\"ðŸ’¾ Saved progress: \\(Int(readingProgress * 100))%\")\n    }\n}\n\n// === PART 3: Tab Navigation ===\nstruct NewsApp: View {\n    @State private var selectedTab = 0\n    @State private var bookmarks: [Article] = []\n    \n    var body: some View {\n        TabView(selection: $selectedTab) {\n            ArticleListView()\n                .tabItem {\n                    Image(systemName: \"house\")\n                    Text(\"Home\")\n                }\n                .tag(0)\n                .onAppear { trackAnalytics(\"home_tab\") }\n            \n            BookmarksView(bookmarks: $bookmarks)\n                .tabItem {\n                    Image(systemName: \"bookmark\")\n                    Text(\"Bookmarks\")\n                }\n                .tag(1)\n                .onAppear { trackAnalytics(\"bookmarks_tab\") }\n            \n            SettingsView()\n                .tabItem {\n                    Image(systemName: \"gear\")\n                    Text(\"Settings\")\n                }\n                .tag(2)\n                .onAppear { trackAnalytics(\"settings_tab\") }\n        }\n        .onAppear {\n            print(\"ðŸš€ News app launched\")\n            loadBookmarks()\n        }\n        .onDisappear {\n            print(\"ðŸ”Œ News app backgrounded\")\n            saveBookmarks()\n        }\n    }\n    \n    private func trackAnalytics(_ event: String) {\n        print(\"ðŸ“ˆ Analytics: \\(event)\")\n        // In real app, send to analytics service\n    }\n    \n    private func loadBookmarks() {\n        if let data = UserDefaults.standard.data(forKey: \"bookmarks\"),\n           let saved = try? JSONDecoder().decode([Article].self, from: data) {\n            bookmarks = saved\n            print(\"ðŸ“– Loaded \\(bookmarks.count) bookmarks\")\n        }\n    }\n    \n    private func saveBookmarks() {\n        if let data = try? JSONEncoder().encode(bookmarks) {\n            UserDefaults.standard.set(data, forKey: \"bookmarks\")\n            print(\"ðŸ’¾ Saved \\(bookmarks.count) bookmarks\")\n        }\n    }\n}\n\nstruct BookmarksView: View {\n    @Binding var bookmarks: [Article]\n    \n    var body: some View {\n        NavigationView {\n            if bookmarks.isEmpty {\n                Text(\"No bookmarks yet\")\n                    .foregroundColor(.gray)\n            } else {\n                List(bookmarks) { article in\n                    NavigationLink(destination: ArticleDetailView(article: article)) {\n                        Text(article.title)\n                    }\n                }\n            }\n        }\n        .onAppear {\n            print(\"ðŸ”– Bookmarks view appeared\")\n        }\n        .onDisappear {\n            print(\"ðŸ“´ Bookmarks view disappeared\")\n        }\n    }\n}\n\n// === PART 4: Advanced Scenarios ===\nclass NetworkMonitor: ObservableObject {\n    @Published var isConnected = true\n    private var monitorTimer: Timer?\n    \n    func startMonitoring() {\n        print(\"ðŸŒ Starting network monitoring\")\n        // Simulate network monitoring\n        monitorTimer = Timer.scheduledTimer(withTimeInterval: 5, repeats: true) { _ in\n            self.checkConnection()\n        }\n    }\n    \n    func stopMonitoring() {\n        print(\"ðŸ›‘ Stopping network monitoring\")\n        monitorTimer?.invalidate()\n        monitorTimer = nil\n    }\n    \n    private func checkConnection() {\n        // Simulate connection check\n        isConnected = Bool.random()\n        print(\"ðŸ“¡ Network status: \\(isConnected ? \"Connected\" : \"Disconnected\")\")\n    }\n    \n    deinit {\n        stopMonitoring()\n        print(\"ðŸ§¹ NetworkMonitor deinitialized\")\n    }\n}\n\nstruct NetworkAwareView: View {\n    @StateObject private var monitor = NetworkMonitor()\n    \n    var body: some View {\n        VStack {\n            if monitor.isConnected {\n                Text(\"Online\")\n                    .foregroundColor(.green)\n            } else {\n                Text(\"Offline\")\n                    .foregroundColor(.red)\n            }\n        }\n        .onAppear {\n            monitor.startMonitoring()\n        }\n        .onDisappear {\n            monitor.stopMonitoring()\n        }\n    }\n}\n\n// Supporting models\nstruct Article: Identifiable, Codable {\n    let id: Int\n    let title: String\n    let summary: String\n    let content: String = \"This is the full article content. \" + String(repeating: \"SwiftUI is amazing! \", count: 50)\n}\n\nstruct SettingsView: View {\n    var body: some View {\n        Text(\"Settings\")\n            .onAppear { print(\"âš™ï¸ Settings view appeared\") }\n            .onDisappear { print(\"ðŸ“´ Settings view disappeared\") }\n    }\n}",
        "hints": [
          "PART 1: Use URLSessionDataTask for network requests and cancel it in onDisappear to prevent memory leaks",
          "PART 2: Track reading progress with a Timer and always invalidate it in onDisappear",
          "PART 3: Use UserDefaults to persist bookmarks and load them in onAppear",
          "PART 4: Create ObservableObject classes for shared resources and manage their lifecycle with the view",
          "Remember: onAppear can be called multiple times (when navigating back to a view)",
          "Use @Environment(\\.dismiss) to programmatically navigate back",
          "For async operations in onAppear, consider using Task for modern concurrency",
          "Always test your lifecycle management by backgrounding the app and navigating complex flows"
        ],
        "testCases": [
          {
            "input": "Navigate to ArticleDetailView and back",
            "expectedOutput": "Console shows proper appear/disappear logs",
            "description": "View lifecycle should trigger appropriate events"
          },
          {
            "input": "Background app while in ArticleDetailView",
            "expectedOutput": "Reading timer stops and progress saves",
            "description": "Resources should be managed when app backgrounds"
          },
          {
            "input": "Switch between tabs multiple times",
            "expectedOutput": "Analytics track tab changes without resource leaks",
            "description": "Tab navigation should properly manage state"
          }
        ]
      }
    },
    {
      "id": "modifiers_styling",
      "title": "Modifiers & Styling",
      "description": "Master view customization with custom modifiers and view composition - create reusable, consistent UI components",
      "difficulty": "beginner",
      "theory": "# Modifiers & Styling - Custom View Design\n\n## 1. Understanding Modifiers (60 min)\n\n### What are Modifiers?\n- Methods that **wrap and transform** views\n- Return **new views** with applied changes\n- Can be **chained** together\n- Enable **consistent styling** across your app\n\n### Basic Modifier Examples:\n```swift\nText(\"Hello SwiftUI\")\n    .font(.title)           // Font modifier\n    .foregroundColor(.blue) // Color modifier\n    .padding()              // Layout modifier\n    .background(Color.yellow) // Background modifier\n```\n\n### Modifier Order Matters:\n```swift\n// Different order = different results\nText(\"Example\")\n    .padding()\n    .background(Color.red)  // Background includes padding\n\nText(\"Example\")\n    .background(Color.red)  // Background only on text\n    .padding()\n```\n\n### Common Built-in Modifiers:\n- **Layout**: `.padding()`, `.frame()`, `.position()`\n- **Text**: `.font()`, `.foregroundColor()`, `.lineLimit()`\n- **Visual**: `.background()`, `.cornerRadius()`, `.shadow()`\n- **Interaction**: `.onTapGesture()`, `.gesture()`\n\n## 2. View Composition Patterns (60 min)\n\n### Extracting Subviews:\n```swift\n// BEFORE: Everything in one view\nstruct ContentView: View {\n    var body: some View {\n        VStack {\n            Text(\"Welcome\")\n                .font(.largeTitle)\n                .foregroundColor(.blue)\n            \n            Text(\"Subtitle\")\n                .font(.subheadline)\n                .foregroundColor(.gray)\n        }\n    }\n}\n\n// AFTER: Extracted subview\nstruct HeaderView: View {\n    let title: String\n    let subtitle: String\n    \n    var body: some View {\n        VStack {\n            Text(title)\n                .font(.largeTitle)\n                .foregroundColor(.blue)\n            \n            Text(subtitle)\n                .font(.subheadline)\n                .foregroundColor(.gray)\n        }\n    }\n}\n\nstruct ContentView: View {\n    var body: some View {\n        HeaderView(title: \"Welcome\", subtitle: \"Subtitle\")\n    }\n}\n```\n\n### ViewBuilder for Complex Composition:\n```swift\nstruct CardView<Content: View>: View {\n    let content: Content\n    \n    init(@ViewBuilder content: () -> Content) {\n        self.content = content()\n    }\n    \n    var body: some View {\n        content\n            .padding()\n            .background(Color.white)\n            .cornerRadius(10)\n            .shadow(radius: 5)\n    }\n}\n\n// Usage\nCardView {\n    VStack {\n        Text(\"Title\")\n        Text(\"Description\")\n        Button(\"Action\") { }\n    }\n}\n```\n\n## 3. Creating Custom Modifiers (90 min)\n\n### Basic Custom Modifier:\n```swift\nstruct PrimaryButtonStyle: ViewModifier {\n    func body(content: Content) -> some View {\n        content\n            .foregroundColor(.white)\n            .padding()\n            .background(Color.blue)\n            .cornerRadius(8)\n    }\n}\n\n// Extension for easier usage\nextension View {\n    func primaryButtonStyle() -> some View {\n        self.modifier(PrimaryButtonStyle())\n    }\n}\n\n// Usage\nButton(\"Tap Me\") { }\n    .primaryButtonStyle()\n```\n\n### Parameterized Custom Modifiers:\n```swift\nstruct BorderedModifier: ViewModifier {\n    let color: Color\n    let lineWidth: CGFloat\n    \n    func body(content: Content) -> some View {\n        content\n            .padding(4)\n            .overlay(\n                RoundedRectangle(cornerRadius: 8)\n                    .stroke(color, lineWidth: lineWidth)\n            )\n    }\n}\n\nextension View {\n    func bordered(color: Color = .blue, lineWidth: CGFloat = 1) -> some View {\n        self.modifier(BorderedModifier(color: color, lineWidth: lineWidth))\n    }\n}\n\n// Usage\nText(\"Bordered Text\")\n    .bordered(color: .red, lineWidth: 2)\n```\n\n### Conditional Modifiers:\n```swift\nstruct ConditionalBackground: ViewModifier {\n    let condition: Bool\n    \n    func body(content: Content) -> some View {\n        if condition {\n            content\n                .background(Color.yellow)\n        } else {\n            content\n        }\n    }\n}\n\nextension View {\n    func conditionalBackground(_ condition: Bool) -> some View {\n        self.modifier(ConditionalBackground(condition: condition))\n    }\n}\n```\n\n## 4. Advanced Styling Techniques (60 min)\n\n### Gradient Backgrounds:\n```swift\nstruct GradientBackground: ViewModifier {\n    let colors: [Color]\n    \n    func body(content: Content) -> some View {\n        content\n            .background(\n                LinearGradient(\n                    gradient: Gradient(colors: colors),\n                    startPoint: .topLeading,\n                    endPoint: .bottomTrailing\n                )\n            )\n    }\n}\n```\n\n### Animated Modifiers:\n```swift\nstruct PulseAnimation: ViewModifier {\n    @State private var isPulsing = false\n    \n    func body(content: Content) -> some View {\n        content\n            .scaleEffect(isPulsing ? 1.1 : 1.0)\n            .animation(\n                Animation.easeInOut(duration: 1.0).repeatForever(autoreverses: true),\n                value: isPulsing\n            )\n            .onAppear {\n                isPulsing = true\n            }\n    }\n}\n```\n\n### Shadow and Depth Effects:\n```swift\nstruct DepthShadow: ViewModifier {\n    let intensity: CGFloat\n    \n    func body(content: Content) -> some View {\n        content\n            .shadow(\n                color: .black.opacity(0.2 * Double(intensity)),\n                radius: 5 * intensity,\n                x: 0,\n                y: 2 * intensity\n            )\n    }\n}\n```\n\n## 5. Building Design Systems (60 min)\n\n### Color Theme System:\n```swift\nstruct AppColors {\n    static let primary = Color.blue\n    static let secondary = Color.orange\n    static let background = Color(.systemBackground)\n    static let textPrimary = Color.primary\n    static let textSecondary = Color.secondary\n}\n\nstruct Theme {\n    static let cornerRadius: CGFloat = 8\n    static let padding: CGFloat = 16\n    static let shadowRadius: CGFloat = 4\n}\n```\n\n### Typography System:\n```swift\nstruct AppFonts {\n    static let largeTitle = Font.largeTitle.weight(.bold)\n    static let title = Font.title2.weight(.semibold)\n    static let body = Font.body\n    static let caption = Font.caption\n}\n\n// Usage\nText(\"Heading\")\n    .font(AppFonts.title)\n    .foregroundColor(AppColors.textPrimary)\n```\n\n### Complete Component Library:\n```swift\nstruct PrimaryButton: View {\n    let title: String\n    let action: () -> Void\n    \n    var body: some View {\n        Button(title, action: action)\n            .primaryButtonStyle()\n    }\n}\n\nstruct Card<Content: View>: View {\n    let content: Content\n    \n    init(@ViewBuilder content: () -> Content) {\n        self.content = content()\n    }\n    \n    var body: some View {\n        content\n            .padding(Theme.padding)\n            .background(AppColors.background)\n            .cornerRadius(Theme.cornerRadius)\n            .shadow(radius: Theme.shadowRadius)\n    }\n}\n```\n\n## 6. Performance & Best Practices (30 min)\n\n### Efficient View Updates:\n- Use `.equatable()` for expensive views\n- Extract complex calculations from body\n- Leverage `@ViewBuilder` for conditional content\n\n### Modifier Performance Tips:\n- Chain modifiers logically\n- Avoid unnecessary view recreations\n- Use `@ViewBuilder` for complex conditional views\n\n### Testing Custom Modifiers:\n```swift\nimport XCTest\n@testable import YourApp\n\nclass ModifierTests: XCTestCase {\n    func testPrimaryButtonStyle() {\n        let button = Button(\"Test\") { }\n            .primaryButtonStyle()\n        \n        // Test that modifier is applied correctly\n        // (In practice, you'd use snapshot testing or view inspection)\n    }\n}\n```\n\n## Practice Exercises\n\nComplete all exercises to master view styling and composition!",
      "codeExample": "// === BASIC MODIFIER EXAMPLES ===\n\nimport SwiftUI\n\n// Simple modifier chain\nstruct BasicModifiers: View {\n    var body: some View {\n        Text(\"Hello, SwiftUI!\")\n            .font(.largeTitle)\n            .foregroundColor(.white)\n            .padding()\n            .background(Color.blue)\n            .cornerRadius(10)\n            .shadow(radius: 5)\n    }\n}\n\n// Frame and alignment modifiers\nstruct FrameModifiers: View {\n    var body: some View {\n        Text(\"Centered Text\")\n            .frame(maxWidth: .infinity, maxHeight: .infinity)\n            .background(Color.yellow)\n            .padding()\n    }\n}\n\n// === CUSTOM MODIFIER EXAMPLES ===\n\n// Simple custom modifier\nstruct CardModifier: ViewModifier {\n    func body(content: Content) -> some View {\n        content\n            .padding(20)\n            .background(Color.white)\n            .cornerRadius(15)\n            .shadow(\n                color: Color.black.opacity(0.2),\n                radius: 10,\n                x: 0,\n                y: 5\n            )\n    }\n}\n\nextension View {\n    func cardStyle() -> some View {\n        self.modifier(CardModifier())\n    }\n}\n\n// Parameterized custom modifier\nstruct BorderedCaption: ViewModifier {\n    var color: Color = .gray\n    \n    func body(content: Content) -> some View {\n        content\n            .font(.caption)\n            .padding(4)\n            .foregroundColor(color)\n            .overlay(\n                RoundedRectangle(cornerRadius: 4)\n                    .stroke(color, lineWidth: 1)\n            )\n    }\n}\n\nextension View {\n    func borderedCaption(color: Color = .gray) -> some View {\n        self.modifier(BorderedCaption(color: color))\n    }\n}\n\n// === VIEW COMPOSITION EXAMPLES ===\n\n// Reusable header view\nstruct AppHeader: View {\n    let title: String\n    let subtitle: String?\n    \n    var body: some View {\n        VStack(alignment: .leading, spacing: 8) {\n            Text(title)\n                .font(.title2)\n                .fontWeight(.bold)\n                .foregroundColor(.primary)\n            \n            if let subtitle = subtitle {\n                Text(subtitle)\n                    .font(.subheadline)\n                    .foregroundColor(.secondary)\n            }\n        }\n        .frame(maxWidth: .infinity, alignment: .leading)\n    }\n}\n\n// Configurable button component\nstruct PrimaryButton: View {\n    let title: String\n    let icon: String?\n    let action: () -> Void\n    var isDisabled: Bool = false\n    \n    var body: some View {\n        Button(action: action) {\n            HStack {\n                if let icon = icon {\n                    Image(systemName: icon)\n                }\n                Text(title)\n            }\n            .frame(maxWidth: .infinity)\n            .padding()\n            .foregroundColor(.white)\n            .background(isDisabled ? Color.gray : Color.blue)\n            .cornerRadius(8)\n        }\n        .disabled(isDisabled)\n    }\n}\n\n// === COMPLEX COMPOSITION EXAMPLE ===\n\nstruct ProfileCard: View {\n    let user: String\n    let bio: String\n    let isOnline: Bool\n    \n    var body: some View {\n        VStack(alignment: .leading, spacing: 12) {\n            // Header with status\n            HStack {\n                Circle()\n                    .fill(isOnline ? Color.green : Color.gray)\n                    .frame(width: 12, height: 12)\n                \n                Text(user)\n                    .font(.headline)\n                \n                Spacer()\n                \n                Text(isOnline ? \"Online\" : \"Offline\")\n                    .borderedCaption(color: isOnline ? .green : .gray)\n            }\n            \n            // Bio text\n            Text(bio)\n                .font(.body)\n                .foregroundColor(.secondary)\n                .lineLimit(3)\n            \n            // Action buttons\n            HStack {\n                PrimaryButton(title: \"Message\", icon: \"message\", action: {})\n                PrimaryButton(title: \"Follow\", icon: \"person.badge.plus\", action: {})\n            }\n        }\n        .cardStyle()\n    }\n}\n\n// === MAIN CONTENT VIEW ===\n\nstruct ContentView: View {\n    var body: some View {\n        ScrollView {\n            VStack(spacing: 20) {\n                // App header\n                AppHeader(title: \"User Profiles\", subtitle: \"Manage your connections\")\n                \n                // Profile cards\n                ProfileCard(\n                    user: \"John Appleseed\",\n                    bio: \"iOS developer passionate about SwiftUI and clean code. Love hiking and photography.\",\n                    isOnline: true\n                )\n                \n                ProfileCard(\n                    user: \"Sarah Wilson\", \n                    bio: \"UX designer with 5+ years experience. Creating beautiful and accessible interfaces.\",\n                    isOnline: false\n                )\n                \n                // Demo of individual modifiers\n                VStack(spacing: 10) {\n                    Text(\"Modifier Demo\")\n                        .borderedCaption(color: .blue)\n                    \n                    Text(\"Card Style Demo\")\n                        .padding()\n                        .cardStyle()\n                }\n            }\n            .padding()\n        }\n    }\n}\n\n// === PREVIEW ===\n\nstruct ContentView_Previews: PreviewProvider {\n    static var previews: some View {\n        ContentView()\n    }\n}",
      "category": "SwiftUI Basics",
      "estimatedTime": 300,
      "dependencies": ["swiftui_intro", "views_layout"],
      "challenge": {
        "instructions": "Create a complete design system with custom modifiers and reusable components:\n\nPART 1: Basic Custom Modifiers (60 min)\n1. Create a 'PillBadge' modifier for rounded capsule-style badges\n2. Create a 'GradientBackground' modifier that accepts color arrays\n3. Create a 'BorderGlow' modifier for attention-grabbing effects\n4. Create a 'TextOutline' modifier that adds stroke to text\n\nPART 2: View Composition & Reusable Components (90 min)\n5. Build a 'StatsCard' component showing numbers with labels\n6. Create a 'UserAvatar' component with different sizes and status indicators\n7. Build a 'SettingsRow' component for settings screens\n8. Create a 'LoadingButton' that shows activity during async operations\n\nPART 3: Advanced Modifier System (90 min)\n9. Create a 'Theme' system with colors, fonts, and spacing constants\n10. Build modifier variants (primary, secondary, danger styles)\n11. Create conditional modifiers that change based on state\n12. Implement animated modifiers with spring and ease animations\n\nPART 4: Complete UI Screen (60 min)\n13. Combine all components into a 'ProfileScreen'\n14. Create a 'SettingsScreen' using your design system\n15. Ensure consistency across all components\n16. Add dark mode support to your theme system\n\nTest your design system by creating multiple screens with consistent styling!",
        "starterCode": "// === PART 1: Basic Custom Modifiers ===\n// Create your custom modifiers here\n\n\n// === PART 2: View Composition ===\n// Build reusable components here\n\n\n// === PART 3: Advanced Modifier System ===\n// Create theme system and variant modifiers here\n\n\n// === PART 4: Complete UI Screens ===\n// Build ProfileScreen and SettingsScreen here\n\n",
        "solution": "// === PART 1: Basic Custom Modifiers ===\n\nimport SwiftUI\n\n// 1. PillBadge modifier\nstruct PillBadge: ViewModifier {\n    var backgroundColor: Color = .blue\n    var textColor: Color = .white\n    \n    func body(content: Content) -> some View {\n        content\n            .font(.caption)\n            .fontWeight(.semibold)\n            .foregroundColor(textColor)\n            .padding(.horizontal, 12)\n            .padding(.vertical, 6)\n            .background(backgroundColor)\n            .clipShape(Capsule())\n    }\n}\n\nextension View {\n    func pillBadge(backgroundColor: Color = .blue, textColor: Color = .white) -> some View {\n        self.modifier(PillBadge(backgroundColor: backgroundColor, textColor: textColor))\n    }\n}\n\n// 2. GradientBackground modifier\nstruct GradientBackgroundModifier: ViewModifier {\n    let colors: [Color]\n    let startPoint: UnitPoint\n    let endPoint: UnitPoint\n    \n    func body(content: Content) -> some View {\n        content\n            .background(\n                LinearGradient(\n                    gradient: Gradient(colors: colors),\n                    startPoint: startPoint,\n                    endPoint: endPoint\n                )\n            )\n    }\n}\n\nextension View {\n    func gradientBackground(colors: [Color], startPoint: UnitPoint = .topLeading, endPoint: UnitPoint = .bottomTrailing) -> some View {\n        self.modifier(GradientBackgroundModifier(colors: colors, startPoint: startPoint, endPoint: endPoint))\n    }\n}\n\n// 3. BorderGlow modifier\nstruct BorderGlow: ViewModifier {\n    var color: Color = .blue\n    var radius: CGFloat = 10\n    \n    func body(content: Content) -> some View {\n        content\n            .overlay(\n                RoundedRectangle(cornerRadius: 8)\n                    .stroke(color, lineWidth: 1)\n                    .shadow(color: color, radius: radius)\n                    .shadow(color: color, radius: radius)\n            )\n    }\n}\n\nextension View {\n    func borderGlow(color: Color = .blue, radius: CGFloat = 10) -> some View {\n        self.modifier(BorderGlow(color: color, radius: radius))\n    }\n}\n\n// 4. TextOutline modifier\nstruct TextOutline: ViewModifier {\n    var outlineColor: Color = .black\n    var outlineWidth: CGFloat = 2\n    \n    func body(content: Content) -> some View {\n        content\n            .shadow(color: outlineColor, radius: 0)\n            .shadow(color: outlineColor, radius: 0)\n            .shadow(color: outlineColor, radius: 0)\n            .shadow(color: outlineColor, radius: 0)\n    }\n}\n\nextension View {\n    func textOutline(color: Color = .black, width: CGFloat = 2) -> some View {\n        self.modifier(TextOutline(outlineColor: color, outlineWidth: width))\n    }\n}\n\n// === PART 2: View Composition ===\n\n// 5. StatsCard component\nstruct StatsCard: View {\n    let value: String\n    let label: String\n    let icon: String\n    let color: Color\n    \n    var body: some View {\n        VStack(spacing: 8) {\n            Image(systemName: icon)\n                .font(.title2)\n                .foregroundColor(color)\n            \n            Text(value)\n                .font(.title2)\n                .fontWeight(.bold)\n                .foregroundColor(.primary)\n            \n            Text(label)\n                .font(.caption)\n                .foregroundColor(.secondary)\n        }\n        .frame(maxWidth: .infinity)\n        .padding()\n        .background(Color(.systemBackground))\n        .cornerRadius(12)\n        .shadow(color: .black.opacity(0.1), radius: 5)\n    }\n}\n\n// 6. UserAvatar component\nstruct UserAvatar: View {\n    let name: String\n    let size: CGFloat\n    var isOnline: Bool = false\n    \n    private var initials: String {\n        name.split(separator: \" \")\n            .prefix(2)\n            .map { String($0.prefix(1)) }\n            .joined()\n    }\n    \n    var body: some View {\n        ZStack(alignment: .bottomTrailing) {\n            // Avatar circle\n            Circle()\n                .fill(Color.blue.gradient)\n                .frame(width: size, height: size)\n                .overlay(\n                    Text(initials)\n                        .font(.system(size: size * 0.4, weight: .bold))\n                        .foregroundColor(.white)\n                )\n            \n            // Online indicator\n            if isOnline {\n                Circle()\n                    .fill(Color.green)\n                    .frame(width: size * 0.25, height: size * 0.25)\n                    .overlay(\n                        Circle()\n                            .stroke(Color(.systemBackground), lineWidth: 2)\n                    )\n            }\n        }\n    }\n}\n\n// 7. SettingsRow component\nstruct SettingsRow: View {\n    let icon: String\n    let title: String\n    let subtitle: String?\n    let action: () -> Void\n    \n    var body: some View {\n        Button(action: action) {\n            HStack {\n                // Icon\n                Image(systemName: icon)\n                    .font(.body)\n                    .foregroundColor(.blue)\n                    .frame(width: 32)\n                \n                // Text content\n                VStack(alignment: .leading, spacing: 2) {\n                    Text(title)\n                        .font(.body)\n                        .foregroundColor(.primary)\n                    \n                    if let subtitle = subtitle {\n                        Text(subtitle)\n                            .font(.caption)\n                            .foregroundColor(.secondary)\n                    }\n                }\n                \n                Spacer()\n                \n                // Chevron\n                Image(systemName: \"chevron.right\")\n                    .font(.caption)\n                    .foregroundColor(.secondary)\n            }\n            .padding(.vertical, 8)\n        }\n    }\n}\n\n// 8. LoadingButton\nstruct LoadingButton: View {\n    let title: String\n    let isLoading: Bool\n    let action: () -> Void\n    \n    var body: some View {\n        Button(action: action) {\n            HStack {\n                if isLoading {\n                    ProgressView()\n                        .scaleEffect(0.8)\n                        .tint(.white)\n                }\n                \n                Text(title)\n                    .opacity(isLoading ? 0.5 : 1.0)\n            }\n            .frame(maxWidth: .infinity)\n            .padding()\n            .background(Color.blue)\n            .foregroundColor(.white)\n            .cornerRadius(8)\n        }\n        .disabled(isLoading)\n    }\n}\n\n// === PART 3: Advanced Modifier System ===\n\n// 9. Theme system\nstruct AppTheme {\n    static let cornerRadius: CGFloat = 12\n    static let padding: CGFloat = 16\n    static let smallPadding: CGFloat = 8\n    \n    // Colors\n    static let primary = Color.blue\n    static let secondary = Color.orange\n    static let success = Color.green\n    static let danger = Color.red\n    static let warning = Color.yellow\n    \n    // Gradients\n    static let primaryGradient = [Color.blue, Color.purple]\n    static let successGradient = [Color.green, Color.blue]\n    \n    // Fonts\n    static let title = Font.title2.weight(.bold)\n    static let headline = Font.headline.weight(.semibold)\n    static let body = Font.body\n}\n\n// 10. Modifier variants\nstruct PrimaryButtonModifier: ViewModifier {\n    var isDisabled: Bool = false\n    \n    func body(content: Content) -> some View {\n        content\n            .font(.headline)\n            .foregroundColor(.white)\n            .frame(maxWidth: .infinity)\n            .padding()\n            .background(isDisabled ? Color.gray : AppTheme.primary)\n            .cornerRadius(AppTheme.cornerRadius)\n    }\n}\n\nstruct SecondaryButtonModifier: ViewModifier {\n    func body(content: Content) -> some View {\n        content\n            .font(.headline)\n            .foregroundColor(AppTheme.primary)\n            .frame(maxWidth: .infinity)\n            .padding()\n            .background(Color.clear)\n            .overlay(\n                RoundedRectangle(cornerRadius: AppTheme.cornerRadius)\n                    .stroke(AppTheme.primary, lineWidth: 2)\n            )\n    }\n}\n\nextension View {\n    func primaryButtonStyle(disabled: Bool = false) -> some View {\n        self.modifier(PrimaryButtonModifier(isDisabled: disabled))\n    }\n    \n    func secondaryButtonStyle() -> some View {\n        self.modifier(SecondaryButtonModifier())\n    }\n}\n\n// 11. Conditional modifier\nstruct ConditionalScale: ViewModifier {\n    let condition: Bool\n    \n    func body(content: Content) -> some View {\n        content\n            .scaleEffect(condition ? 1.05 : 1.0)\n            .animation(.spring(response: 0.3), value: condition)\n    }\n}\n\nextension View {\n    func conditionalScale(_ condition: Bool) -> some View {\n        self.modifier(ConditionalScale(condition: condition))\n    }\n}\n\n// 12. Animated modifier\nstruct BounceOnAppear: ViewModifier {\n    @State private var isVisible = false\n    \n    func body(content: Content) -> some View {\n        content\n            .scaleEffect(isVisible ? 1.0 : 0.5)\n            .opacity(isVisible ? 1.0 : 0.0)\n            .onAppear {\n                withAnimation(.spring(response: 0.6, dampingFraction: 0.6)) {\n                    isVisible = true\n                }\n            }\n    }\n}\n\nextension View {\n    func bounceOnAppear() -> some View {\n        self.modifier(BounceOnAppear())\n    }\n}\n\n// === PART 4: Complete UI Screens ===\n\n// 13. ProfileScreen\nstruct ProfileScreen: View {\n    @State private var isLoading = false\n    \n    var body: some View {\n        ScrollView {\n            VStack(spacing: AppTheme.padding) {\n                // Header\n                VStack(spacing: 16) {\n                    UserAvatar(name: \"John Appleseed\", size: 100, isOnline: true)\n                        .bounceOnAppear()\n                    \n                    Text(\"John Appleseed\")\n                        .font(AppTheme.title)\n                    \n                    Text(\"iOS Developer @ Apple\")\n                        .font(AppTheme.body)\n                        .foregroundColor(.secondary)\n                    \n                    HStack {\n                        Text(\"PRO\")\n                            .pillBadge(backgroundColor: .orange)\n                        \n                        Text(\"VERIFIED\")\n                            .pillBadge(backgroundColor: .green)\n                    }\n                }\n                .padding()\n                .gradientBackground(colors: AppTheme.primaryGradient)\n                .foregroundColor(.white)\n                \n                // Stats\n                LazyVGrid(columns: [\n                    GridItem(.flexible()),\n                    GridItem(.flexible()),\n                    GridItem(.flexible())\n                ], spacing: AppTheme.smallPadding) {\n                    StatsCard(value: \"1.2K\", label: \"Followers\", icon: \"person.2\", color: .blue)\n                    StatsCard(value: \"348\", label: \"Following\", icon: \"heart\", color: .red)\n                    StatsCard(value: \"127\", label: \"Posts\", icon: \"square.and.pencil\", color: .green)\n                }\n                .padding(.horizontal)\n                \n                // Actions\n                VStack(spacing: AppTheme.smallPadding) {\n                    LoadingButton(title: \"Follow\", isLoading: isLoading) {\n                        isLoading = true\n                        // Simulate async operation\n                        DispatchQueue.main.asyncAfter(deadline: .now() + 2) {\n                            isLoading = false\n                        }\n                    }\n                    .primaryButtonStyle(disabled: isLoading)\n                    \n                    Button(\"Message\") { }\n                        .secondaryButtonStyle()\n                }\n                .padding()\n                \n                Spacer()\n            }\n        }\n    }\n}\n\n// 14. SettingsScreen\nstruct SettingsScreen: View {\n    var body: some View {\n        NavigationView {\n            List {\n                Section {\n                    SettingsRow(icon: \"person\", title: \"Edit Profile\", subtitle: \"Update your personal information\") {}\n                    SettingsRow(icon: \"bell\", title: \"Notifications\", subtitle: \"Manage your notifications\") {}\n                    SettingsRow(icon: \"lock\", title: \"Privacy\", subtitle: \"Control your privacy settings\") {}\n                }\n                \n                Section {\n                    SettingsRow(icon: \"questionmark.circle\", title: \"Help & Support\", subtitle: nil) {}\n                    SettingsRow(icon: \"info.circle\", title: \"About\", subtitle: \"App version 1.0\") {}\n                }\n            }\n            .navigationTitle(\"Settings\")\n        }\n    }\n}\n\n// Main app view to demonstrate both screens\nstruct DesignSystemDemo: View {\n    var body: some View {\n        TabView {\n            ProfileScreen()\n                .tabItem {\n                    Image(systemName: \"person\")\n                    Text(\"Profile\")\n                }\n            \n            SettingsScreen()\n                .tabItem {\n                    Image(systemName: \"gearshape\")\n                    Text(\"Settings\")\n                }\n        }\n    }\n}",
        "hints": [
          "PART 1: Use ViewModifier protocol and create extensions on View for easy usage",
          "PART 2: Break down complex views into smaller, reusable components",
          "PART 3: Create a central Theme struct to maintain design consistency",
          "PART 4: Use your custom modifiers and components consistently across screens",
          "For gradients, experiment with different color combinations and direction points",
          "Use @State for animated modifiers that need to track internal state",
          "Consider accessibility when choosing colors and contrast ratios",
          "Test your components in both light and dark mode",
          "Use .clipShape() with Capsule() for perfect pill shapes",
          "For loading states, consider using ProgressView with .tint() modifier"
        ],
        "testCases": [
          {
            "input": "Text(\"Test\").pillBadge().background(Color.red)",
            "expectedOutput": "Pill-shaped badge with red background visible around edges",
            "description": "PillBadge should maintain capsule shape and allow background"
          },
          {
            "input": "UserAvatar(name: \"John Doe\", size: 60).isOnline",
            "expectedOutput": "Avatar with green online indicator",
            "description": "UserAvatar should show online status when specified"
          },
          {
            "input": "LoadingButton(title: \"Save\", isLoading: true).disabled",
            "expectedOutput": "Button should be disabled and show loading indicator",
            "description": "LoadingButton should disable interaction during loading"
          }
        ]
      }
    },
    {
      "id": "weather_app_project",
      "title": "Project: Weather App",
      "description": "Build a multi-screen weather application with mock data and beautiful UI",
      "difficulty": "beginner",
      "theory": "# Weather App Project - 10 Hour Comprehensive Guide\n\n## Project Overview (1 hour)\n\n### What You'll Build:\nA fully-featured weather application with:\n- **Home Screen**: Current weather with temperature, conditions, and details\n- **Forecast Screen**: 5-day weather forecast\n- **Location Search**: Find weather by city name\n- **Settings**: Temperature unit preferences\n- **Beautiful Animations**: Weather-condition appropriate visuals\n\n### Learning Objectives:\n- Master multi-screen navigation in SwiftUI\n- Implement complex data models\n- Create reusable UI components\n- Handle user preferences with UserDefaults\n- Build professional-looking animations\n\n## Architecture & Planning (1 hour)\n\n### App Structure:\n```\nWeatherApp/\nâ”œâ”€â”€ Models/\nâ”‚   â”œâ”€â”€ WeatherData.swift\nâ”‚   â”œâ”€â”€ Forecast.swift\nâ”‚   â””â”€â”€ Location.swift\nâ”œâ”€â”€ Views/\nâ”‚   â”œâ”€â”€ HomeView.swift\nâ”‚   â”œâ”€â”€ ForecastView.swift\nâ”‚   â”œâ”€â”€ SearchView.swift\nâ”‚   â”œâ”€â”€ SettingsView.swift\nâ”‚   â””â”€â”€ Components/\nâ”œâ”€â”€ ViewModels/\nâ”‚   â””â”€â”€ WeatherViewModel.swift\nâ””â”€â”€ Services/\n    â””â”€â”€ WeatherService.swift\n```\n\n### Data Flow:\n1. User opens app â†’ Load default location weather\n2. User searches city â†’ Fetch mock data for that location\n3. User changes settings â†’ Update display preferences\n4. App stores preferences â†’ Persist with UserDefaults\n\n## Step 1: Data Models (1.5 hours)\n\n### Core Data Structures:\nWe'll create comprehensive models to represent:\n- Current weather conditions\n- Multi-day forecasts\n- Location information\n- User preferences\n\n### Key Concepts:\n- **Codable Protocol**: For easy JSON parsing (simulated)\n- **Identifiable**: For SwiftUI lists\n- **Equatable**: For comparing weather data\n- **ObservableObject**: For data binding\n\n## Step 2: Building the Home Screen (2 hours)\n\n### Home Screen Components:\n- **Weather Card**: Large temperature display with conditions\n- **Detail Grid**: Humidity, wind, pressure, visibility\n- **Hourly Forecast**: Scrollable horizontal list\n- **Location Header**: Current city and last updated time\n- **Navigation Bar**: Links to other screens\n\n### UI Design Principles:\n- **Hierarchy**: Important information should be most prominent\n- **Consistency**: Use consistent spacing and typography\n- **Accessibility**: Support Dynamic Type and VoiceOver\n- **Dark/Light Mode**: Automatic theme adaptation\n\n## Step 3: Forecast Screen (1.5 hours)\n\n### 5-Day Forecast:\n- Daily high/low temperatures\n- Weather conditions with icons\n- Precipitation probability\n- Wind speed and direction\n- Sunrise/sunset times\n\n### List Implementation:\n- **LazyVStack**: For efficient scrolling\n- **Section Headers**: Group by day\n- **Custom Rows**: Weather information per day\n- **Smooth Animations**: Transition between days\n\n## Step 4: Search & Location (1.5 hours)\n\n### Search Functionality:\n- **Text Input**: City name search\n- **Mock Data**: Pre-defined city database\n- **Search Results**: Filtered list of matching cities\n- **Location Selection**: Tap to set current location\n\n### User Experience:\n- **Debounced Search**: Avoid excessive filtering\n- **Empty States**: Helpful messages when no results\n- **Recent Searches**: Persist user's search history\n- **Error Handling**: Invalid city names\n\n## Step 5: Settings & Preferences (1 hour)\n\n### User Configurable Options:\n- **Temperature Units**: Celsius vs Fahrenheit\n- **Theme Preferences**: Light/Dark/Auto\n- **Notification Settings**: Weather alerts\n- **Data Refresh**: Manual/Auto refresh intervals\n\n### Persistence:\n- **UserDefaults**: Simple key-value storage\n- **@AppStorage**: SwiftUI property wrapper\n- **Settings Bundle**: For system settings integration\n\n## Step 6: Animations & Polish (1.5 hours)\n\n### Weather Animations:\n- **Condition-based**: Different animations for sun, rain, clouds\n- **Smooth Transitions**: Between screen changes\n- **Loading States**: Skeleton screens and progress indicators\n- **Pull-to-Refresh**: Update weather data\n\n### Micro-interactions:\n- **Button Feedback**: Visual response to taps\n- **Swipe Gestures**: Navigate between days\n- **Haptic Feedback**: Tactile responses\n- **Sound Effects**: Optional audio feedback\n\n## Advanced Features & Extensions\n\n### Optional Enhancements:\n- **Weather Maps**: Simple precipitation maps\n- **Weather Widgets**: Home screen widgets\n- **Location Services**: Real GPS location\n- **Weather Alerts**: Severe weather notifications\n- **Data Caching**: Offline weather access\n\n## Testing & Debugging\n\n### Quality Assurance:\n- **Unit Tests**: Data model validation\n- **UI Tests**: Screen navigation flows\n- **Performance**: Memory usage and loading times\n- **Accessibility**: VoiceOver and Dynamic Type testing\n\n## Project Completion\n\nBy the end of this 10-hour project, you'll have:\n- A professional-grade weather application\n- Deep understanding of SwiftUI architecture\n- Experience with complex state management\n- Portfolio-ready project for job applications\n- Foundation for building any data-driven iOS app\n\n## Getting Started\n\nBegin with the data models and build up layer by layer. Test each component as you build it, and don't forget to celebrate small victories along the way!",
      "codeExample": "// === WEATHER DATA MODELS ===\n\nimport Foundation\n\n// Current weather conditions\nstruct CurrentWeather: Codable, Identifiable {\n    let id = UUID()\n    let temperature: Double\n    let feelsLike: Double\n    let condition: WeatherCondition\n    let humidity: Int\n    let windSpeed: Double\n    let windDirection: Int\n    let pressure: Int\n    let visibility: Double\n    let uvIndex: Int\n    let sunrise: Date\n    let sunset: Date\n    \n    var temperatureFahrenheit: Double {\n        return (temperature * 9/5) + 32\n    }\n    \n    var windDirectionText: String {\n        let directions = [\"N\", \"NNE\", \"NE\", \"ENE\", \"E\", \"ESE\", \"SE\", \"SSE\", \n                         \"S\", \"SSW\", \"SW\", \"WSW\", \"W\", \"WNW\", \"NW\", \"NNW\"]\n        let index = Int((Double(windDirection) + 11.25) / 22.5) % 16\n        return directions[index]\n    }\n}\n\n// Weather condition with emoji and description\nenum WeatherCondition: String, CaseIterable, Codable {\n    case clear = \"Clear\"\n    case cloudy = \"Cloudy\"\n    case partlyCloudy = \"Partly Cloudy\"\n    case rainy = \"Rainy\"\n    case stormy = \"Stormy\"\n    case snowy = \"Snowy\"\n    case foggy = \"Foggy\"\n    case windy = \"Windy\"\n    \n    var emoji: String {\n        switch self {\n        case .clear: return \"â˜€ï¸\"\n        case .cloudy: return \"â˜ï¸\"\n        case .partlyCloudy: return \"â›…\"\n        case .rainy: return \"ðŸŒ§ï¸\"\n        case .stormy: return \"â›ˆï¸\"\n        case .snowy: return \"â„ï¸\"\n        case .foggy: return \"ðŸŒ«ï¸\"\n        case .windy: return \"ðŸ’¨\"\n        }\n    }\n    \n    var color: String {\n        switch self {\n        case .clear: return \"FFD700\" // Gold\n        case .cloudy: return \"A9A9A9\" // Dark Gray\n        case .partlyCloudy: return \"87CEEB\" // Sky Blue\n        case .rainy: return \"4682B4\" // Steel Blue\n        case .stormy: return \"2F4F4F\" // Dark Slate Gray\n        case .snowy: return \"F0F8FF\" // Alice Blue\n        case .foggy: return \"D3D3D3\" // Light Gray\n        case .windy: return \"B0C4DE\" // Light Steel Blue\n        }\n    }\n}\n\n// Daily forecast\nstruct DailyForecast: Codable, Identifiable {\n    let id = UUID()\n    let date: Date\n    let highTemperature: Double\n    let lowTemperature: Double\n    let condition: WeatherCondition\n    let precipitationChance: Int\n    let sunrise: Date\n    let sunset: Date\n    let moonPhase: String\n    \n    var dayOfWeek: String {\n        let formatter = DateFormatter()\n        formatter.dateFormat = \"EEEE\"\n        return formatter.string(from: date)\n    }\n}\n\n// Location information\nstruct WeatherLocation: Codable, Identifiable, Hashable {\n    let id = UUID()\n    let name: String\n    let country: String\n    let latitude: Double\n    let longitude: Double\n    let timezone: String\n    \n    var displayName: String {\n        return \"\\(name), \\(country)\"\n    }\n}\n\n// Complete weather data package\nstruct WeatherData: Codable {\n    let location: WeatherLocation\n    let current: CurrentWeather\n    let forecast: [DailyForecast]\n    let hourly: [HourlyWeather]\n    let lastUpdated: Date\n}\n\n// Hourly weather for today\nstruct HourlyWeather: Codable, Identifiable {\n    let id = UUID()\n    let time: Date\n    let temperature: Double\n    let condition: WeatherCondition\n    let precipitationChance: Int\n    \n    var hourString: String {\n        let formatter = DateFormatter()\n        formatter.dateFormat = \"h a\"\n        return formatter.string(from: time)\n    }\n}\n\n// === WEATHER VIEW MODEL ===\n\nimport SwiftUI\nimport Combine\n\nclass WeatherViewModel: ObservableObject {\n    @Published var weatherData: WeatherData?\n    @Published var isLoading = false\n    @Published var errorMessage: String?\n    @Published var selectedLocation: WeatherLocation?\n    \n    @AppStorage(\"temperatureUnit\") var temperatureUnit: String = \"celsius\"\n    @AppStorage(\"selectedLocationId\") var selectedLocationId: String = \"\"\n    \n    private let weatherService = WeatherService()\n    private var cancellables = Set<AnyCancellable>()\n    \n    // Mock locations for the app\n    let mockLocations = [\n        WeatherLocation(name: \"New York\", country: \"US\", latitude: 40.7128, longitude: -74.0060, timezone: \"America/New_York\"),\n        WeatherLocation(name: \"London\", country: \"UK\", latitude: 51.5074, longitude: -0.1278, timezone: \"Europe/London\"),\n        WeatherLocation(name: \"Tokyo\", country: \"Japan\", latitude: 35.6762, longitude: 139.6503, timezone: \"Asia/Tokyo\"),\n        WeatherLocation(name: \"Sydney\", country: \"Australia\", latitude: -33.8688, longitude: 151.2093, timezone: \"Australia/Sydney\"),\n        WeatherLocation(name: \"Paris\", country: \"France\", latitude: 48.8566, longitude: 2.3522, timezone: \"Europe/Paris\")\n    ]\n    \n    init() {\n        loadInitialData()\n    }\n    \n    func loadInitialData() {\n        // Set default location if none selected\n        if selectedLocation == nil {\n            selectedLocation = mockLocations.first\n        }\n        \n        if let location = selectedLocation {\n            loadWeather(for: location)\n        }\n    }\n    \n    func loadWeather(for location: WeatherLocation) {\n        isLoading = true\n        errorMessage = nil\n        \n        weatherService.fetchWeather(for: location)\n            .receive(on: DispatchQueue.main)\n            .sink { [weak self] completion in\n                self?.isLoading = false\n                if case .failure(let error) = completion {\n                    self?.errorMessage = error.localizedDescription\n                }\n            } receiveValue: { [weak self] weatherData in\n                self?.weatherData = weatherData\n                self?.selectedLocation = location\n                self?.selectedLocationId = location.id.uuidString\n            }\n            .store(in: &cancellables)\n    }\n    \n    func searchLocations(query: String) -> [WeatherLocation] {\n        if query.isEmpty {\n            return mockLocations\n        }\n        \n        return mockLocations.filter { location in\n            location.name.localizedCaseInsensitiveContains(query) ||\n            location.country.localizedCaseInsensitiveContains(query)\n        }\n    }\n    \n    // Temperature formatting based on user preference\n    func formattedTemperature(_ temperature: Double) -> String {\n        if temperatureUnit == \"fahrenheit\" {\n            let fahrenheit = (temperature * 9/5) + 32\n            return \"\\(Int(round(fahrenheit)))Â°F\"\n        } else {\n            return \"\\(Int(round(temperature)))Â°C\"\n        }\n    }\n    \n    // Toggle temperature unit\n    func toggleTemperatureUnit() {\n        temperatureUnit = temperatureUnit == \"celsius\" ? \"fahrenheit\" : \"celsius\"\n        objectWillChange.send()\n    }\n}\n\n// === WEATHER SERVICE (MOCK DATA) ===\n\nclass WeatherService {\n    func fetchWeather(for location: WeatherLocation) -> AnyPublisher<WeatherData, Error> {\n        // Generate mock weather data based on location and current time\n        let mockWeatherData = generateMockWeatherData(for: location)\n        \n        return Just(mockWeatherData)\n            .setFailureType(to: Error.self)\n            .delay(for: .seconds(1), scheduler: RunLoop.main) // Simulate network delay\n            .eraseToAnyPublisher()\n    }\n    \n    private func generateMockWeatherData(for location: WeatherLocation) -> WeatherData {\n        let currentDate = Date()\n        let calendar = Calendar.current\n        \n        // Generate current weather\n        let currentWeather = CurrentWeather(\n            temperature: Double.random(in: -5...35), // Realistic temperature range\n            feelsLike: Double.random(in: -8...38),\n            condition: WeatherCondition.allCases.randomElement()!,\n            humidity: Int.random(in: 30...90),\n            windSpeed: Double.random(in: 0...25),\n            windDirection: Int.random(in: 0...359),\n            pressure: Int.random(in: 980...1040),\n            visibility: Double.random(in: 2...20),\n            uvIndex: Int.random(in: 0...11),\n            sunrise: calendar.date(byAdding: .hour, value: -2, to: currentDate)!,\n            sunset: calendar.date(byAdding: .hour, value: 10, to: currentDate)!\n        )\n        \n        // Generate 5-day forecast\n        var forecast: [DailyForecast] = []\n        for day in 0..<5 {\n            let forecastDate = calendar.date(byAdding: .day, value: day, to: currentDate)!\n            let dailyForecast = DailyForecast(\n                date: forecastDate,\n                highTemperature: Double.random(in: currentWeather.temperature - 5...currentWeather.temperature + 8),\n                lowTemperature: Double.random(in: currentWeather.temperature - 15...currentWeather.temperature - 2),\n                condition: WeatherCondition.allCases.randomElement()!,\n                precipitationChance: Int.random(in: 0...100),\n                sunrise: calendar.date(byAdding: .hour, value: -2, to: forecastDate)!,\n                sunset: calendar.date(byAdding: .hour, value: 10, to: forecastDate)!,\n                moonPhase: [\"New Moon\", \"Waxing Crescent\", \"First Quarter\", \"Waxing Gibbous\", \n                           \"Full Moon\", \"Waning Gibbous\", \"Last Quarter\", \"Waning Crescent\"].randomElement()!\n            )\n            forecast.append(dailyForecast)\n        }\n        \n        // Generate 24-hour forecast\n        var hourly: [HourlyWeather] = []\n        for hour in 0..<24 {\n            let hourDate = calendar.date(byAdding: .hour, value: hour, to: currentDate)!\n            let hourlyWeather = HourlyWeather(\n                time: hourDate,\n                temperature: Double.random(in: currentWeather.temperature - 8...currentWeather.temperature + 5),\n                condition: currentWeather.condition, // Same condition for simplicity\n                precipitationChance: Int.random(in: 0...30)\n            )\n            hourly.append(hourlyWeather)\n        }\n        \n        return WeatherData(\n            location: location,\n            current: currentWeather,\n            forecast: forecast,\n            hourly: hourly,\n            lastUpdated: currentDate\n        )\n    }\n}",
      "category": "Projects",
      "estimatedTime": 600,
      "dependencies": ["variables", "optionals", "control_flow", "functions", "collections", "structs_classes"],
      "challenge": {
        "instructions": "Build a complete Weather App with the following features:\n\nPART 1: Project Setup & Data Models (2 hours)\n1. Create all the data models: CurrentWeather, WeatherCondition, DailyForecast, WeatherLocation, WeatherData\n2. Implement the WeatherService with mock data generation\n3. Set up the basic WeatherViewModel with @Published properties\n\nPART 2: Home Screen Implementation (3 hours)\n4. Create a HomeView that displays current weather conditions\n5. Build a weather card showing temperature, condition, and feels-like\n6. Add a detail grid showing humidity, wind, pressure, and visibility\n7. Implement a horizontal scroll view for hourly forecast\n8. Add a location header and last updated time\n\nPART 3: Forecast & Navigation (2 hours)\n9. Create a ForecastView showing 5-day weather forecast\n10. Implement navigation between Home and Forecast screens\n11. Add a tab bar or navigation bar for app structure\n12. Create smooth transitions between screens\n\nPART 4: Search & Location Management (2 hours)\n13. Build a SearchView for finding cities\n14. Implement location switching functionality\n15. Add recent searches persistence\n16. Handle empty states and loading states\n\nPART 5: Settings & Polish (1 hour)\n17. Create a SettingsView for temperature units\n18. Implement @AppStorage for user preferences\n19. Add weather-appropriate animations\n20. Test the complete app flow\n\nBONUS FEATURES (Extra Credit):\n- Add pull-to-refresh functionality\n- Implement weather condition animations\n- Add weather maps or radar\n- Create home screen widgets\n- Add weather alerts system",
        "starterCode": "// === PART 1: Data Models ===\n// Add your data model implementations here\n\n\n// === PART 2: Weather Service ===\n// Implement WeatherService with mock data\n\n\n// === PART 3: Weather ViewModel ===\n// Create WeatherViewModel class\n\n\n// === PART 4: Home View ===\n// Build the main weather display\n\n\n// === PART 5: Forecast View ===\n// Create 5-day forecast screen\n\n\n// === PART 6: Search View ===\n// Implement location search\n\n\n// === PART 7: Settings View ===\n// Add user preferences\n\n\n// === PART 8: App Structure ===\n// Set up navigation and tab views",
        "solution": "// Note: The complete solution would be very extensive (1000+ lines)\n// Here's a simplified version of key components:\n\nimport SwiftUI\n\n// Main App Structure\nstruct WeatherApp: App {\n    var body: some Scene {\n        WindowGroup {\n            ContentView()\n                .environmentObject(WeatherViewModel())\n        }\n    }\n}\n\nstruct ContentView: View {\n    var body: some View {\n        TabView {\n            HomeView()\n                .tabItem {\n                    Image(systemName: \"house.fill\")\n                    Text(\"Home\")\n                }\n            \n            ForecastView()\n                .tabItem {\n                    Image(systemName: \"calendar\")\n                    Text(\"Forecast\")\n                }\n            \n            SearchView()\n                .tabItem {\n                    Image(systemName: \"magnifyingglass\")\n                    Text(\"Search\")\n                }\n            \n            SettingsView()\n                .tabItem {\n                    Image(systemName: \"gear\")\n                    Text(\"Settings\")\n                }\n        }\n    }\n}\n\n// Home View Implementation\nstruct HomeView: View {\n    @EnvironmentObject var viewModel: WeatherViewModel\n    \n    var body: some View {\n        NavigationView {\n            ScrollView {\n                VStack(spacing: 20) {\n                    if let weather = viewModel.weatherData {\n                        // Weather Card\n                        WeatherCard(weather: weather.current, location: weather.location)\n                        \n                        // Hourly Forecast\n                        HourlyForecastView(hourly: weather.hourly)\n                        \n                        // Weather Details\n                        WeatherDetailsView(weather: weather.current)\n                    } else if viewModel.isLoading {\n                        ProgressView(\"Loading weather...\")\n                    } else if let error = viewModel.errorMessage {\n                        ErrorView(message: error)\n                    }\n                }\n                .padding()\n            }\n            .navigationTitle(\"Weather\")\n            .refreshable {\n                if let location = viewModel.selectedLocation {\n                    viewModel.loadWeather(for: location)\n                }\n            }\n        }\n    }\n}\n\n// Weather Card Component\nstruct WeatherCard: View {\n    let weather: CurrentWeather\n    let location: WeatherLocation\n    @EnvironmentObject var viewModel: WeatherViewModel\n    \n    var body: some View {\n        VStack(spacing: 16) {\n            Text(location.displayName)\n                .font(.title2)\n                .fontWeight(.semibold)\n            \n            HStack(alignment: .top) {\n                Text(viewModel.formattedTemperature(weather.temperature))\n                    .font(.system(size: 64, weight: .thin))\n                \n                VStack(alignment: .leading) {\n                    Text(weather.condition.rawValue)\n                        .font(.title3)\n                    Text(weather.condition.emoji)\n                        .font(.largeTitle)\n                }\n            }\n            \n            Text(\"Feels like \\(viewModel.formattedTemperature(weather.feelsLike))\")\n                .foregroundColor(.secondary)\n        }\n        .padding()\n        .background(Color(.systemBackground))\n        .cornerRadius(20)\n        .shadow(color: .black.opacity(0.1), radius: 10)\n    }\n}\n\n// This is a simplified version - the complete app would include:\n// - ForecastView with List of daily forecasts\n// - SearchView with TextField and results list\n// - SettingsView with toggle for temperature units\n// - All the data models and services from the theory section",
        "hints": [
          "PART 1: Start with the data models - they're the foundation of your app",
          "PART 2: Use VStack and HStack to layout the home screen components",
          "PART 3: Implement NavigationView and NavigationLink for screen transitions",
          "PART 4: Use @State for search text and filter locations based on input",
          "PART 5: @AppStorage automatically persists user preferences",
          "Use ScrollView for content that might overflow the screen",
          "Create reusable components for weather cards and detail items",
          "Mock data should be realistic - check real weather ranges for temperatures",
          "Test your app with different weather conditions and locations",
          "Add loading states and error handling for better user experience"
        ],
        "testCases": [
          {
            "input": "weatherData != nil",
            "expectedOutput": "true",
            "description": "Weather data should be loaded successfully"
          },
          {
            "input": "viewModel.mockLocations.count >= 3",
            "expectedOutput": "true",
            "description": "Should have multiple mock locations available"
          },
          {
            "input": "viewModel.formattedTemperature(0).contains(\"Â°\")",
            "expectedOutput": "true",
            "description": "Temperature formatting should include degree symbol"
          }
        ]
      }
    },
    {
      "id": "custom_views",
      "title": "Custom Views",
      "description": "Master creating reusable, maintainable SwiftUI components through custom views",
      "difficulty": "beginner",
      "theory": "# Custom Views - Building Reusable Components\n\n## 1. Why Custom Views? (30 min)\n\n### The Problem with Repetitive Code\n```swift\n// Without custom views - repetitive code\nVStack {\n    HStack {\n        Image(systemName: \"star.fill\")\n            .foregroundColor(.yellow)\n        Text(\"Rating: 4.8\")\n            .font(.subheadline)\n        Spacer()\n    }\n    HStack {\n        Image(systemName: \"clock.fill\")\n            .foregroundColor(.blue)\n        Text(\"30 min\")\n            .font(.subheadline)\n        Spacer()\n    }\n    HStack {\n        Image(systemName: \"dollarsign.circle.fill\")\n            .foregroundColor(.green)\n        Text(\"$$\")\n            .font(.subheadline)\n        Spacer()\n    }\n}\n```\n\n### The Solution: Custom Views\n```swift\n// With custom views - clean and reusable\nVStack {\n    InfoRow(icon: \"star.fill\", color: .yellow, text: \"Rating: 4.8\")\n    InfoRow(icon: \"clock.fill\", color: .blue, text: \"30 min\")\n    InfoRow(icon: \"dollarsign.circle.fill\", color: .green, text: \"$$\")\n}\n```\n\n**Benefits:**\n- **Reusability**: Use the same component across your app\n- **Maintainability**: Change in one place, updates everywhere\n- **Readability**: Clean, semantic code\n- **Testability**: Easier to test individual components\n\n## 2. Basic Custom View Creation (45 min)\n\n### Simple Custom View\n```swift\nstruct WelcomeHeader: View {\n    let username: String\n    \n    var body: some View {\n        VStack(alignment: .leading) {\n            Text(\"Welcome back,\")\n                .font(.headline)\n                .foregroundColor(.secondary)\n            Text(username)\n                .font(.largeTitle)\n                .fontWeight(.bold)\n        }\n    }\n}\n\n// Usage\nWelcomeHeader(username: \"Sarah\")\n```\n\n### View with Multiple Parameters\n```swift\nstruct StatCard: View {\n    let title: String\n    let value: String\n    let icon: String\n    let color: Color\n    \n    var body: some View {\n        VStack {\n            Image(systemName: icon)\n                .font(.title)\n                .foregroundColor(color)\n            Text(value)\n                .font(.title2)\n                .fontWeight(.bold)\n            Text(title)\n                .font(.caption)\n                .foregroundColor(.secondary)\n        }\n        .padding()\n        .background(Color(.systemBackground))\n        .cornerRadius(12)\n        .shadow(color: .gray.opacity(0.2), radius: 5)\n    }\n}\n\n// Usage\nHStack {\n    StatCard(title: \"Steps\", value: \"8,542\", icon: \"figure.walk\", color: .green)\n    StatCard(title: \"Calories\", value: \"420\", icon: \"flame.fill\", color: .orange)\n}\n```\n\n## 3. Advanced Custom View Patterns (60 min)\n\n### View Composition\n```swift\n// Small, focused components\nstruct Avatar: View {\n    let imageName: String\n    let size: CGFloat\n    \n    var body: some View {\n        Image(imageName)\n            .resizable()\n            .aspectRatio(contentMode: .fill)\n            .frame(width: size, height: size)\n            .clipShape(Circle())\n    }\n}\n\nstruct UserBadge: View {\n    let user: String\n    let role: String\n    let isOnline: Bool\n    \n    var body: some View {\n        HStack {\n            Avatar(imageName: user, size: 40)\n            VStack(alignment: .leading) {\n                Text(user)\n                    .fontWeight(.semibold)\n                Text(role)\n                    .font(.caption)\n                    .foregroundColor(.secondary)\n            }\n            Spacer()\n            Circle()\n                .fill(isOnline ? .green : .gray)\n                .frame(width: 8, height: 8)\n        }\n    }\n}\n```\n\n### Generic Custom Views\n```swift\nstruct CardView<Content: View>: View {\n    let content: Content\n    \n    init(@ViewBuilder content: () -> Content) {\n        self.content = content()\n    }\n    \n    var body: some View {\n        content\n            .padding()\n            .background(Color(.systemBackground))\n            .cornerRadius(12)\n            .shadow(color: .gray.opacity(0.2), radius: 5)\n    }\n}\n\n// Usage with any content\nCardView {\n    VStack {\n        Text(\"Custom Content\")\n        Image(systemName: \"heart.fill\")\n    }\n}\n```\n\n## 4. View Modifiers & Styling (45 min)\n\n### Custom View Modifiers\n```swift\nstruct PrimaryButtonStyle: ViewModifier {\n    func body(content: Content) -> some View {\n        content\n            .font(.headline)\n            .foregroundColor(.white)\n            .padding()\n            .frame(maxWidth: .infinity)\n            .background(Color.blue)\n            .cornerRadius(10)\n    }\n}\n\nextension View {\n    func primaryButton() -> some View {\n        modifier(PrimaryButtonStyle())\n    }\n}\n\n// Usage\nButton(\"Save Changes\") { }\n    .primaryButton()\n```\n\n### Conditional Styling\n```swift\nstruct AdaptiveCard: View {\n    let title: String\n    let message: String\n    let type: CardType\n    \n    enum CardType {\n        case info, warning, error, success\n        \n        var color: Color {\n            switch self {\n            case .info: return .blue\n            case .warning: return .orange\n            case .error: return .red\n            case .success: return .green\n            }\n        }\n        \n        var icon: String {\n            switch self {\n            case .info: return \"info.circle.fill\"\n            case .warning: return \"exclamationmark.triangle.fill\"\n            case .error: return \"xmark.circle.fill\"\n            case .success: return \"checkmark.circle.fill\"\n            }\n        }\n    }\n    \n    var body: some View {\n        HStack {\n            Image(systemName: type.icon)\n                .foregroundColor(type.color)\n            VStack(alignment: .leading) {\n                Text(title)\n                    .fontWeight(.semibold)\n                Text(message)\n                    .font(.caption)\n                    .foregroundColor(.secondary)\n            }\n            Spacer()\n        }\n        .padding()\n        .background(type.color.opacity(0.1))\n        .cornerRadius(8)\n        .overlay(\n            RoundedRectangle(cornerRadius: 8)\n                .stroke(type.color.opacity(0.3), lineWidth: 1)\n        )\n    }\n}\n```\n\n## 5. State Management in Custom Views (45 min)\n\n### Interactive Custom Views\n```swift\nstruct ExpandableCard: View {\n    let title: String\n    let content: String\n    \n    @State private var isExpanded = false\n    \n    var body: some View {\n        VStack(alignment: .leading) {\n            HStack {\n                Text(title)\n                    .font(.headline)\n                Spacer()\n                Image(systemName: isExpanded ? \"chevron.up\" : \"chevron.down\")\n                    .foregroundColor(.blue)\n            }\n            .contentShape(Rectangle())\n            .onTapGesture {\n                withAnimation(.spring()) {\n                    isExpanded.toggle()\n                }\n            }\n            \n            if isExpanded {\n                Text(content)\n                    .font(.body)\n                    .padding(.top, 8)\n                    .transition(.opacity.combined(with: .move(edge: .top)))\n            }\n        }\n        .padding()\n        .background(Color(.systemBackground))\n        .cornerRadius(12)\n        .shadow(color: .gray.opacity(0.2), radius: 5)\n    }\n}\n```\n\n### Binding in Custom Views\n```swift\nstruct ToggleSetting: View {\n    let title: String\n    let description: String\n    @Binding var isOn: Bool\n    \n    var body: some View {\n        HStack {\n            VStack(alignment: .leading) {\n                Text(title)\n                    .fontWeight(.semibold)\n                Text(description)\n                    .font(.caption)\n                    .foregroundColor(.secondary)\n            }\n            Spacer()\n            Toggle(\"\", isOn: $isOn)\n                .labelsHidden()\n        }\n        .padding()\n        .background(Color(.systemBackground))\n        .cornerRadius(8)\n    }\n}\n\n// Usage in parent view\nstruct SettingsView: View {\n    @State private var notificationsEnabled = true\n    @State private var darkMode = false\n    \n    var body: some View {\n        VStack {\n            ToggleSetting(\n                title: \"Push Notifications\",\n                description: \"Receive push notifications\",\n                isOn: $notificationsEnabled\n            )\n            ToggleSetting(\n                title: \"Dark Mode\", \n                description: \"Enable dark theme\",\n                isOn: $darkMode\n            )\n        }\n    }\n}\n```\n\n## 6. Advanced Patterns & Best Practices (45 min)\n\n### ViewBuilder for Complex Content\n```swift\nstruct SectionContainer<Header: View, Content: View>: View {\n    let header: Header\n    let content: Content\n    \n    init(@ViewBuilder header: () -> Header, \n         @ViewBuilder content: () -> Content) {\n        self.header = header()\n        self.content = content()\n    }\n    \n    var body: some View {\n        VStack(alignment: .leading, spacing: 12) {\n            header\n                .font(.title2)\n                .fontWeight(.bold)\n            \n            content\n                .padding()\n                .background(Color(.systemBackground))\n                .cornerRadius(12)\n                .shadow(color: .gray.opacity(0.1), radius: 3)\n        }\n    }\n}\n\n// Usage\nSectionContainer {\n    Text(\"Profile Settings\")\n} content: {\n    VStack {\n        Text(\"Name: John Doe\")\n        Text(\"Email: john@example.com\")\n    }\n}\n```\n\n### Environment-Based Custom Views\n```swift\nstruct Theme {\n    let primaryColor: Color\n    let backgroundColor: Color\n    let cornerRadius: CGFloat\n}\n\nstruct ThemedCard<Content: View>: View {\n    @Environment(\\.theme) private var theme\n    let content: Content\n    \n    init(@ViewBuilder content: () -> Content) {\n        self.content = content()\n    }\n    \n    var body: some View {\n        content\n            .padding()\n            .background(theme.backgroundColor)\n            .cornerRadius(theme.cornerRadius)\n            .overlay(\n                RoundedRectangle(cornerRadius: theme.cornerRadius)\n                    .stroke(theme.primaryColor.opacity(0.2), lineWidth: 1)\n            )\n    }\n}\n```\n\n## 7. Testing & Debugging Custom Views (30 min)\n\n### Preview Providers for Custom Views\n```swift\n#Preview(\"Light Mode\") {\n    StatCard(title: \"Steps\", value: \"8,542\", icon: \"figure.walk\", color: .green)\n        .padding()\n        .background(Color.white)\n}\n\n#Preview(\"Dark Mode\") {\n    StatCard(title: \"Steps\", value: \"8,542\", icon: \"figure.walk\", color: .green)\n        .padding()\n        .background(Color.black)\n        .preferredColorScheme(.dark)\n}\n\n#Preview(\"Multiple States\") {\n    VStack {\n        ExpandableCard(title: \"Collapsed\", content: \"Hidden content\")\n        ExpandableCard(title: \"Expanded\", content: \"Visible content\")\n    }\n    .padding()\n}\n```\n\n### Debugging Tips\n- Use `.border(.red)` to visualize view frames\n- Add `#if DEBUG` conditionals for debug views\n- Use previews extensively during development\n- Test with different data states and screen sizes\n\n## Best Practices Summary\n1. **Single Responsibility**: Each custom view should do one thing well\n2. **Configurable**: Use parameters to make views flexible\n3. **Reusable**: Design views to work in multiple contexts\n4. **Testable**: Make views easy to preview and test\n5. **Documented**: Add clear documentation for complex views\n\nComplete the practice exercises to master these concepts!",
      "codeExample": "// === BASIC CUSTOM VIEWS ===\nstruct InfoRow: View {\n    let icon: String\n    let color: Color\n    let text: String\n    \n    var body: some View {\n        HStack {\n            Image(systemName: icon)\n                .foregroundColor(color)\n                .frame(width: 20)\n            Text(text)\n                .font(.subheadline)\n            Spacer()\n        }\n    }\n}\n\n// === ADVANCED CUSTOM VIEWS ===\nstruct UserProfileHeader: View {\n    let user: User\n    let onEdit: () -> Void\n    \n    var body: some View {\n        HStack {\n            Avatar(imageName: user.avatar, size: 60)\n            \n            VStack(alignment: .leading, spacing: 4) {\n                Text(user.name)\n                    .font(.title2)\n                    .fontWeight(.bold)\n                Text(user.title)\n                    .font(.subheadline)\n                    .foregroundColor(.secondary)\n                HStack {\n                    Image(systemName: \"location.fill\")\n                        .font(.caption)\n                    Text(user.location)\n                        .font(.caption)\n                }\n                .foregroundColor(.secondary)\n            }\n            \n            Spacer()\n            \n            Button(action: onEdit) {\n                Image(systemName: \"pencil\")\n                    .foregroundColor(.blue)\n            }\n        }\n        .padding()\n    }\n}\n\n// === GENERIC CONTAINER VIEW ===\nstruct CardContainer<Content: View>: View {\n    let title: String?\n    let content: Content\n    \n    init(title: String? = nil, @ViewBuilder content: () -> Content) {\n        self.title = title\n        self.content = content()\n    }\n    \n    var body: some View {\n        VStack(alignment: .leading, spacing: 12) {\n            if let title = title {\n                Text(title)\n                    .font(.headline)\n                    .padding(.horizontal)\n            }\n            \n            content\n                .padding()\n                .background(Color(.systemBackground))\n                .cornerRadius(12)\n                .shadow(color: .gray.opacity(0.1), radius: 3)\n        }\n    }\n}\n\n// === INTERACTIVE CUSTOM VIEW ===\nstruct RatingView: View {\n    let maxRating: Int\n    @Binding var currentRating: Int\n    let onRatingChanged: (Int) -> Void\n    \n    var body: some View {\n        HStack {\n            ForEach(1...maxRating, id: \\.self) { star in\n                Image(systemName: star <= currentRating ? \"star.fill\" : \"star\")\n                    .foregroundColor(star <= currentRating ? .yellow : .gray)\n                    .onTapGesture {\n                        withAnimation(.spring()) {\n                            currentRating = star\n                            onRatingChanged(star)\n                        }\n                    }\n            }\n        }\n    }\n}\n\n// === COMPLEX COMPOSITE VIEW ===\nstruct ProductCard: View {\n    let product: Product\n    @State private var isFavorite = false\n    \n    var body: some View {\n        CardContainer {\n            VStack(alignment: .leading, spacing: 12) {\n                // Header with image and favorite button\n                ZStack(alignment: .topTrailing) {\n                    AsyncImage(url: URL(string: product.imageUrl)) { image in\n                        image\n                            .resizable()\n                            .aspectRatio(contentMode: .fill)\n                    } placeholder: {\n                        Rectangle()\n                            .fill(Color.gray.opacity(0.3))\n                    }\n                    .frame(height: 150)\n                    .clipped()\n                    .cornerRadius(8)\n                    \n                    Button(action: { isFavorite.toggle() }) {\n                        Image(systemName: isFavorite ? \"heart.fill\" : \"heart\")\n                            .foregroundColor(isFavorite ? .red : .white)\n                            .padding(8)\n                            .background(Color.black.opacity(0.6))\n                            .clipShape(Circle())\n                    }\n                    .padding(8)\n                }\n                \n                // Product info\n                VStack(alignment: .leading, spacing: 8) {\n                    Text(product.name)\n                        .font(.headline)\n                        .lineLimit(2)\n                    \n                    Text(product.description)\n                        .font(.caption)\n                        .foregroundColor(.secondary)\n                        .lineLimit(2)\n                    \n                    HStack {\n                        Text(\"$\\(product.price, specifier: \"%.2f\")\")\n                            .font(.title3)\n                            .fontWeight(.bold)\n                        \n                        Spacer()\n                        \n                        HStack {\n                            Image(systemName: \"star.fill\")\n                                .foregroundColor(.yellow)\n                                .font(.caption)\n                            Text(\"\\(product.rating, specifier: \"%.1f\")\")\n                                .font(.caption)\n                                .fontWeight(.semibold)\n                        }\n                    }\n                }\n                \n                // Action buttons\n                HStack {\n                    Button(\"Add to Cart\") {\n                        // Add to cart action\n                    }\n                    .buttonStyle(.bordered)\n                    \n                    Spacer()\n                    \n                    Button(\"Buy Now\") {\n                        // Buy now action\n                    }\n                    .buttonStyle(.borderedProminent)\n                }\n            }\n        }\n    }\n}\n\n// === SUPPORTING MODELS ===\nstruct User {\n    let id = UUID()\n    let name: String\n    let title: String\n    let location: String\n    let avatar: String\n}\n\nstruct Product {\n    let id = UUID()\n    let name: String\n    let description: String\n    let price: Double\n    let rating: Double\n    let imageUrl: String\n}\n\n// === USAGE EXAMPLE ===\nstruct ContentView: View {\n    @State private var userRating = 3\n    let sampleUser = User(\n        name: \"Sarah Chen\",\n        title: \"Senior iOS Developer\",\n        location: \"San Francisco, CA\",\n        avatar: \"person.circle.fill\"\n    )\n    \n    let sampleProduct = Product(\n        name: \"Wireless Bluetooth Headphones\",\n        description: \"Noise cancelling over-ear headphones with premium sound quality\",\n        price: 199.99,\n        rating: 4.5,\n        imageUrl: \"https://example.com/headphones.jpg\"\n    )\n    \n    var body: some View {\n        ScrollView {\n            VStack(spacing: 20) {\n                UserProfileHeader(user: sampleUser) {\n                    print(\"Edit profile tapped\")\n                }\n                \n                CardContainer(title: \"Product Rating\") {\n                    VStack {\n                        Text(\"How would you rate this product?\")\n                            .font(.headline)\n                        RatingView(\n                            maxRating: 5,\n                            currentRating: $userRating,\n                            onRatingChanged: { newRating in\n                                print(\"Rating changed to: \\(newRating)\")\n                            }\n                        )\n                        .font(.title)\n                    }\n                }\n                \n                ProductCard(product: sampleProduct)\n                \n                // Info rows example\n                CardContainer(title: \"Product Details\") {\n                    VStack(spacing: 12) {\n                        InfoRow(icon: \"shippingbox.fill\", color: .blue, text: \"Free Shipping\")\n                        InfoRow(icon: \"arrow.clockwise\", color: .green, text: \"30-Day Returns\")\n                        InfoRow(icon: \"lock.fill\", color: .orange, text: \"Secure Payment\")\n                    }\n                }\n            }\n            .padding()\n        }\n    }\n}",
      "category": "SwiftUI Advanced",
      "estimatedTime": 240,
      "dependencies": ["variables", "optionals"],
      "challenge": {
        "instructions": "Build a complete Task Management app using custom views:\n\nPART 1: Basic Custom Views (45 min)\n1. Create a `TaskRow` view that displays: title, due date, priority, and completion status\n2. Create a `PriorityBadge` view that shows priority with different colors (low=green, medium=yellow, high=red)\n3. Create a `DueDateView` that shows relative due dates (Today, Tomorrow, Overdue, etc.)\n\nPART 2: Interactive Custom Views (45 min)\n4. Create a `TaskCard` that uses `TaskRow` and can be expanded to show task details\n5. Add swipe actions to `TaskRow` for complete/delete functionality\n6. Create a `AddTaskButton` with a floating action button style\n\nPART 3: Composite Custom Views (45 min)\n7. Build a `TaskSection` that groups tasks by status (Todo, In Progress, Done)\n8. Create a `ProgressHeader` that shows completion statistics\n9. Build a `FilterBar` with multiple filter options (All, Active, Completed)\n\nPART 4: Advanced Custom Views (45 min)\n10. Create a `TaskEditor` modal view for adding/editing tasks\n11. Build a `SortableTaskList` that supports drag-and-drop reordering\n12. Create a `SearchableTaskView` with real-time search functionality\n\nPART 5: Styling & Theming (30 min)\n13. Create custom view modifiers for consistent styling\n14. Add dark mode support to all custom views\n15. Create previews for all custom views with different data states",
        "starterCode": "// === PART 1: Basic Custom Views ===\n// Define your Task model and basic views here\n\n\n// === PART 2: Interactive Custom Views ===\n// Add interactive functionality here\n\n\n// === PART 3: Composite Custom Views ===\n// Build composite views that combine multiple components\n\n\n// === PART 4: Advanced Custom Views ===\n// Implement advanced features like editing and search\n\n\n// === PART 5: Styling & Theming ===\n// Add styling and theming support\n\n",
        "solution": "// === TASK MODEL ===\nstruct TaskItem: Identifiable {\n    let id = UUID()\n    var title: String\n    var description: String\n    var dueDate: Date\n    var priority: Priority\n    var isCompleted: Bool\n    var category: String\n    \n    enum Priority: String, CaseIterable {\n        case low, medium, high\n        \n        var color: Color {\n            switch self {\n            case .low: return .green\n            case .medium: return .yellow\n            case .high: return .red\n            }\n        }\n        \n        var icon: String {\n            switch self {\n            case .low: return \"arrow.down\"\n            case .medium: return \"minus\"\n            case .high: return \"arrow.up\"\n            }\n        }\n    }\n}\n\n// === PART 1: BASIC CUSTOM VIEWS ===\nstruct PriorityBadge: View {\n    let priority: TaskItem.Priority\n    \n    var body: some View {\n        HStack(spacing: 4) {\n            Image(systemName: priority.icon)\n                .font(.caption)\n            Text(priority.rawValue.capitalized)\n                .font(.caption)\n                .fontWeight(.medium)\n        }\n        .padding(.horizontal, 8)\n        .padding(.vertical, 4)\n        .background(priority.color.opacity(0.2))\n        .foregroundColor(priority.color)\n        .cornerRadius(6)\n    }\n}\n\nstruct DueDateView: View {\n    let dueDate: Date\n    \n    private var relativeDate: String {\n        let calendar = Calendar.current\n        if calendar.isDateInToday(dueDate) {\n            return \"Today\"\n        } else if calendar.isDateInTomorrow(dueDate) {\n            return \"Tomorrow\"\n        } else if dueDate < Date() {\n            return \"Overdue\"\n        } else {\n            let formatter = RelativeDateTimeFormatter()\n            return formatter.localizedString(for: dueDate, relativeTo: Date())\n        }\n    }\n    \n    private var textColor: Color {\n        if dueDate < Date() && !Calendar.current.isDateInToday(dueDate) {\n            return .red\n        } else if Calendar.current.isDateInToday(dueDate) {\n            return .blue\n        } else {\n            return .secondary\n        }\n    }\n    \n    var body: some View {\n        HStack(spacing: 4) {\n            Image(systemName: \"calendar\")\n                .font(.caption)\n            Text(relativeDate)\n                .font(.caption)\n                .foregroundColor(textColor)\n        }\n    }\n}\n\nstruct TaskRow: View {\n    let task: TaskItem\n    let onToggleComplete: () -> Void\n    \n    var body: some View {\n        HStack(spacing: 12) {\n            // Completion toggle\n            Button(action: onToggleComplete) {\n                Image(systemName: task.isCompleted ? \"checkmark.circle.fill\" : \"circle\")\n                    .foregroundColor(task.isCompleted ? .green : .gray)\n                    .font(.title2)\n            }\n            \n            // Task info\n            VStack(alignment: .leading, spacing: 4) {\n                Text(task.title)\n                    .font(.headline)\n                    .strikethrough(task.isCompleted)\n                    .foregroundColor(task.isCompleted ? .secondary : .primary)\n                \n                if !task.description.isEmpty {\n                    Text(task.description)\n                        .font(.caption)\n                        .foregroundColor(.secondary)\n                        .lineLimit(1)\n                }\n                \n                HStack {\n                    PriorityBadge(priority: task.priority)\n                    DueDateView(dueDate: task.dueDate)\n                    Spacer()\n                    Text(task.category)\n                        .font(.caption)\n                        .padding(.horizontal, 8)\n                        .padding(.vertical, 2)\n                        .background(Color.blue.opacity(0.1))\n                        .foregroundColor(.blue)\n                        .cornerRadius(4)\n                }\n            }\n            \n            Spacer()\n        }\n        .padding(.vertical, 8)\n        .contentShape(Rectangle())\n    }\n}\n\n// === PART 2: INTERACTIVE CUSTOM VIEWS ===\nstruct TaskCard: View {\n    let task: TaskItem\n    @State private var isExpanded = false\n    \n    var body: some View {\n        VStack(alignment: .leading, spacing: 12) {\n            // Header\n            HStack {\n                VStack(alignment: .leading, spacing: 4) {\n                    Text(task.title)\n                        .font(.headline)\n                    HStack {\n                        PriorityBadge(priority: task.priority)\n                        DueDateView(dueDate: task.dueDate)\n                    }\n                }\n                \n                Spacer()\n                \n                Button(action: { withAnimation { isExpanded.toggle() } }) {\n                    Image(systemName: isExpanded ? \"chevron.up\" : \"chevron.down\")\n                        .foregroundColor(.blue)\n                }\n            }\n            \n            // Expandable content\n            if isExpanded {\n                VStack(alignment: .leading, spacing: 8) {\n                    if !task.description.isEmpty {\n                        Text(task.description)\n                            .font(.body)\n                            .foregroundColor(.secondary)\n                    }\n                    \n                    HStack {\n                        Text(\"Category:\")\n                            .font(.caption)\n                            .fontWeight(.medium)\n                        Text(task.category)\n                            .font(.caption)\n                            .padding(.horizontal, 8)\n                            .padding(.vertical, 2)\n                            .background(Color.blue.opacity(0.1))\n                            .foregroundColor(.blue)\n                            .cornerRadius(4)\n                        Spacer()\n                    }\n                }\n                .padding(.top, 8)\n                .transition(.opacity.combined(with: .move(edge: .top)))\n            }\n        }\n        .padding()\n        .background(Color(.systemBackground))\n        .cornerRadius(12)\n        .shadow(color: .gray.opacity(0.1), radius: 3)\n    }\n}\n\n// === CONTINUED IN NEXT MESSAGE (solution is too long for one response)",
        "hints": [
          "PART 1: Start with simple, focused views that do one thing well",
          "PART 2: Use @State for view-specific state and @Binding for shared state",
          "PART 3: Compose larger views from smaller, reusable components",
          "PART 4: Consider using EnvironmentObject for shared data across views",
          "Use ViewBuilder for flexible content containers",
          "Create custom view modifiers for consistent styling across your app",
          "Test your custom views with different data states in previews",
          "Use enums for type-safe configuration options",
          "Consider accessibility when designing custom views",
          "Use SwiftUI's animation system for smooth interactions"
        ],
        "testCases": [
          {
            "input": "task.isCompleted ? \"completed\" : \"active\"",
            "expectedOutput": "active",
            "description": "Task should start as active (not completed)"
          },
          {
            "input": "priority.color != .clear",
            "expectedOutput": "true",
            "description": "Priority badge should have a valid color"
          },
          {
            "input": "dueDate != nil",
            "expectedOutput": "true",
            "description": "Due date view should handle valid dates"
          }
        ]
      }
    },
    {
      "id": "grids_layout",
      "title": "Grids & Layout",
      "description": "Master SwiftUI's powerful grid systems for creating complex, responsive layouts",
      "difficulty": "beginner",
      "theory": "# Grids & Layout - Creating Responsive UI\n\n## 1. Introduction to Grid Systems (30 min)\n\n**Grids** are fundamental to creating organized, responsive layouts in SwiftUI. Unlike stacks that arrange views in a single direction, grids allow two-dimensional layouts.\n\n### Why Use Grids?\n- **Responsive Design**: Automatically adapt to different screen sizes\n- **Consistent Spacing**: Maintain uniform spacing between elements\n- **Complex Layouts**: Create magazine-style, gallery, or dashboard layouts\n- **Performance**: Lazy grids only create views as needed\n\n## 2. LazyVGrid - Vertical Grids (60 min)\n\n### Basic LazyVGrid Structure:\n```swift\nLazyVGrid(columns: columns, alignment: .center, spacing: 20) {\n    ForEach(items, id: \\.self) { item in\n        ItemView(item: item)\n    }\n}\n```\n\n### GridItem Types:\n- **`.flexible()`**: Shares available space equally\n- **`.adaptive(minimum:)`**: Creates as many columns as fit\n- **`.fixed(CGFloat)`**: Fixed width columns\n\n### Column Configurations:\n```swift\n// Three equal columns\nlet threeColumns = [\n    GridItem(.flexible()),\n    GridItem(.flexible()),\n    GridItem(.flexible())\n]\n\n// Responsive columns (2-4 based on screen size)\nlet responsiveColumns = [\n    GridItem(.adaptive(minimum: 150))\n]\n\n// Mixed column types\nlet mixedColumns = [\n    GridItem(.fixed(100)),    // Fixed sidebar\n    GridItem(.flexible()),    // Flexible content\n    GridItem(.fixed(80))      // Fixed actions\n]\n```\n\n## 3. LazyHGrid - Horizontal Grids (45 min)\n\n### Basic LazyHGrid Structure:\n```swift\nLazyHGrid(rows: rows, alignment: .center, spacing: 15) {\n    ForEach(items, id: \\.self) { item in\n        ItemView(item: item)\n    }\n}\n```\n\n### Row Configurations:\n```swift\n// Two equal rows\nlet twoRows = [\n    GridItem(.flexible()),\n    GridItem(.flexible())\n]\n\n// Fixed height rows\nlet fixedRows = [\n    GridItem(.fixed(80)),\n    GridItem(.fixed(120)),\n    GridItem(.fixed(80))\n]\n```\n\n## 4. Advanced Grid Features (45 min)\n\n### Grid Alignment Options:\n```swift\n// Different alignments for different use cases\nLazyVGrid(columns: columns, alignment: .leading)  // Left-aligned\nLazyVGrid(columns: columns, alignment: .trailing) // Right-aligned\nLazyVGrid(columns: columns, alignment: .center)   // Center-aligned\n```\n\n### Pinned Views (Headers/Footers):\n```swift\nLazyVGrid(columns: columns, pinnedViews: [.sectionHeaders]) {\n    Section(header: HeaderView()) {\n        ForEach(items) { item in\n            ItemView(item: item)\n        }\n    }\n}\n```\n\n## 5. Responsive Design Patterns (60 min)\n\n### Adaptive Layouts:\n```swift\n@State private var gridColumns = [GridItem(.adaptive(minimum: 160))]\n\nvar body: some View {\n    LazyVGrid(columns: gridColumns) {\n        ForEach(items) { item in\n            ItemView(item: item)\n        }\n    }\n    .onAppear {\n        // Adjust based on screen size\n        updateGridLayout()\n    }\n}\n```\n\n### Orientation Changes:\n```swift\n// Detect orientation changes\n@State private var isLandscape = false\n\nprivate var gridLayout: [GridItem] {\n    if isLandscape {\n        return [GridItem(.adaptive(minimum: 200))]\n    } else {\n        return [GridItem(.adaptive(minimum: 160))]\n    }\n}\n```\n\n## 6. Performance Optimization (30 min)\n\n### Why Lazy Grids?\n- **Memory Efficient**: Only create visible views\n- **Fast Scrolling**: Smooth performance with large datasets\n- **Dynamic Loading**: Load data as user scrolls\n\n### Best Practices:\n```swift\n// Good: Lazy loading with identifiable data\nLazyVGrid(columns: columns) {\n    ForEach(items, id: \\.id) { item in\n        ItemView(item: item)\n            .onAppear { loadMoreIfNeeded(item) }\n    }\n}\n\n// Avoid: Complex views in grid cells\nLazyVGrid(columns: columns) {\n    ForEach(items) { item in\n        // Keep grid cells simple!\n        SimpleItemView(item: item)\n    }\n}\n```\n\n## 7. Real-World Examples (30 min)\n\n### Photo Gallery:\n```swift\nstruct PhotoGallery: View {\n    let photos: [Photo]\n    let columns = [GridItem(.adaptive(minimum: 100))]\n    \n    var body: some View {\n        ScrollView {\n            LazyVGrid(columns: columns, spacing: 2) {\n                ForEach(photos) { photo in\n                    AsyncImage(url: photo.url) { image in\n                        image.resizable().scaledToFill()\n                    } placeholder: {\n                        Color.gray\n                    }\n                    .frame(height: 100)\n                    .clipped()\n                }\n            }\n        }\n    }\n}\n```\n\n### Dashboard Layout:\n```swift\nstruct Dashboard: View {\n    let stats: [StatItem]\n    let columns = [\n        GridItem(.flexible()),\n        GridItem(.flexible())\n    ]\n    \n    var body: some View {\n        LazyVGrid(columns: columns, spacing: 16) {\n            ForEach(stats) { stat in\n                StatCard(stat: stat)\n                    .frame(height: 120)\n            }\n        }\n        .padding()\n    }\n}\n```",
      "codeExample": "import SwiftUI\n\n// === BASIC GRID EXAMPLES ===\n\n// 1. Simple 3-column grid\nlet threeColumnGrid = [\n    GridItem(.flexible()),\n    GridItem(.flexible()),\n    GridItem(.flexible())\n]\n\n// 2. Adaptive grid (responsive)\nlet adaptiveGrid = [GridItem(.adaptive(minimum: 100))]\n\n// 3. Mixed grid with fixed and flexible items\nlet mixedGrid = [\n    GridItem(.fixed(120)),\n    GridItem(.flexible()),\n    GridItem(.fixed(80))\n]\n\n// 4. Horizontal grid rows\nlet horizontalGridRows = [\n    GridItem(.fixed(60)),\n    GridItem(.fixed(60)),\n    GridItem(.fixed(60))\n]\n\n// === COMPREHENSIVE EXAMPLE: PRODUCT GRID ===\n\nstruct Product: Identifiable {\n    let id = UUID()\n    let name: String\n    let price: Double\n    let imageName: String\n    let category: String\n}\n\nstruct ProductGridView: View {\n    let products: [Product]\n    \n    // Responsive grid that adapts to screen size\n    @State private var gridColumns = [GridItem(.adaptive(minimum: 160))]\n    \n    var body: some View {\n        ScrollView {\n            LazyVGrid(columns: gridColumns, spacing: 16) {\n                ForEach(products) { product in\n                    ProductCard(product: product)\n                }\n            }\n            .padding()\n        }\n        .navigationTitle(\"Products\")\n    }\n}\n\nstruct ProductCard: View {\n    let product: Product\n    \n    var body: some View {\n        VStack(alignment: .leading, spacing: 8) {\n            // Image placeholder\n            Rectangle()\n                .fill(Color.blue.opacity(0.2))\n                .frame(height: 120)\n                .overlay(\n                    Text(product.imageName)\n                        .foregroundColor(.blue)\n                )\n            \n            VStack(alignment: .leading, spacing: 4) {\n                Text(product.name)\n                    .font(.headline)\n                    .lineLimit(2)\n                \n                Text(product.category)\n                    .font(.caption)\n                    .foregroundColor(.secondary)\n                \n                Text(\"$\\(product.price, specifier: \"%.2f\")\")\n                    .font(.subheadline)\n                    .fontWeight(.semibold)\n                    .foregroundColor(.green)\n            }\n            .padding(.horizontal, 8)\n            .padding(.bottom, 8)\n        }\n        .background(Color(.systemBackground))\n        .cornerRadius(12)\n        .shadow(color: .black.opacity(0.1), radius: 2, x: 0, y: 1)\n    }\n}\n\n// === DASHBOARD LAYOUT EXAMPLE ===\n\nstruct StatItem: Identifiable {\n    let id = UUID()\n    let title: String\n    let value: String\n    let icon: String\n    let color: Color\n}\n\nstruct DashboardView: View {\n    let stats: [StatItem]\n    \n    // 2-column grid for dashboard\n    let dashboardColumns = [\n        GridItem(.flexible()),\n        GridItem(.flexible())\n    ]\n    \n    var body: some View {\n        ScrollView {\n            VStack(spacing: 20) {\n                // Stats grid\n                LazyVGrid(columns: dashboardColumns, spacing: 16) {\n                    ForEach(stats) { stat in\n                        StatCard(stat: stat)\n                    }\n                }\n                .padding(.horizontal)\n                \n                // Recent activity (horizontal scroll)\n                VStack(alignment: .leading) {\n                    Text(\"Recent Activity\")\n                        .font(.headline)\n                        .padding(.horizontal)\n                    \n                    ScrollView(.horizontal, showsIndicators: false) {\n                        LazyHGrid(rows: [GridItem(.fixed(100))], spacing: 12) {\n                            ForEach(1...10, id: \\.self) { index in\n                                ActivityCard(index: index)\n                                    .frame(width: 120)\n                            }\n                        }\n                        .padding(.horizontal)\n                    }\n                }\n            }\n        }\n    }\n}\n\nstruct StatCard: View {\n    let stat: StatItem\n    \n    var body: some View {\n        VStack(spacing: 12) {\n            Image(systemName: stat.icon)\n                .font(.title2)\n                .foregroundColor(stat.color)\n            \n            Text(stat.value)\n                .font(.title2)\n                .fontWeight(.bold)\n            \n            Text(stat.title)\n                .font(.caption)\n                .foregroundColor(.secondary)\n                .multilineTextAlignment(.center)\n        }\n        .frame(maxWidth: .infinity)\n        .padding()\n        .background(Color(.systemBackground))\n        .cornerRadius(12)\n        .shadow(color: .black.opacity(0.05), radius: 3, x: 0, y: 1)\n    }\n}\n\nstruct ActivityCard: View {\n    let index: Int\n    \n    var body: some View {\n        VStack {\n            Circle()\n                .fill(Color.orange.opacity(0.2))\n                .frame(width: 50, height: 50)\n                .overlay(\n                    Text(\"\\(index)\")\n                        .fontWeight(.medium)\n                )\n            \n            Text(\"Activity \\(index)\")\n                .font(.caption)\n                .multilineTextAlignment(.center)\n        }\n        .padding()\n        .background(Color(.systemBackground))\n        .cornerRadius(8)\n    }\n}\n\n// === PREVIEW DATA ===\n\nlet sampleProducts = [\n    Product(name: \"Wireless Headphones\", price: 199.99, imageName: \"headphones\", category: \"Audio\"),\n    Product(name: \"Smart Watch\", price: 299.99, imageName: \"watch\", category: \"Wearables\"),\n    Product(name: \"Laptop Stand\", price: 49.99, imageName: \"stand\", category: \"Accessories\"),\n    Product(name: \"Mechanical Keyboard\", price: 129.99, imageName: \"keyboard\", category: \"Accessories\"),\n    Product(name: \"Gaming Mouse\", price: 79.99, imageName: \"mouse\", category: \"Accessories\"),\n    Product(name: \"USB-C Hub\", price: 39.99, imageName: \"hub\", category: \"Accessories\")\n]\n\nlet sampleStats = [\n    StatItem(title: \"Total Users\", value: \"1,234\", icon: \"person.2.fill\", color: .blue),\n    StatItem(title: \"Revenue\", value: \"$12,345\", icon: \"dollarsign.circle.fill\", color: .green),\n    StatItem(title: \"Orders\", value: \"456\", icon: \"cart.fill\", color: .orange),\n    StatItem(title: \"Growth\", value: \"+12.5%\", icon: \"chart.line.uptrend.xyaxis\", color: .purple)\n]",
      "category": "SwiftUI Layout",
      "estimatedTime": 240,
      "dependencies": ["variables"],
      "challenge": {
        "instructions": "Create a comprehensive photo gallery app with multiple grid layouts:\n\nPART 1: Basic Photo Grid (60 min)\n1. Create a LazyVGrid with adaptive columns (minimum 120 points)\n2. Display 20 sample photos with placeholder colors\n3. Add consistent spacing (8 points) and padding\n4. Make the grid responsive to different screen sizes\n\nPART 2: Grid Layout Selector (45 min)\n5. Create a segmented picker with 3 layout options: 2-column, 3-column, adaptive\n6. Implement state management to switch between grid layouts\n7. Add smooth animations when changing layouts\n\nPART 3: Horizontal Category Grid (45 min)\n8. Create a LazyHGrid for photo categories above the main grid\n9. Each category should be a pill-shaped button\n10. Implement category filtering when a category is tapped\n\nPART 4: Advanced Features (60 min)\n11. Add a search bar that filters photos by name\n12. Implement a grid/list toggle switch\n13. Add pull-to-refresh functionality\n14. Create a detail view that opens when a photo is tapped\n\nPART 5: Performance & Polish (30 min)\n15. Optimize grid performance with identifiable data\n16. Add loading states and empty states\n17. Implement proper error handling\n18. Add accessibility labels to grid items",
        "starterCode": "import SwiftUI\n\nstruct Photo: Identifiable {\n    let id = UUID()\n    let name: String\n    let category: String\n    let color: Color\n}\n\nstruct PhotoGalleryView: View {\n    let samplePhotos = [\n        // Add 20 sample photos here with different colors and categories\n    ]\n    \n    // Add your state variables here\n    \n    var body: some View {\n        // Implement your photo gallery here\n        Text(\"Implement Photo Gallery\")\n    }\n}\n\n// Add supporting views here\n\nstruct PhotoGalleryView_Previews: PreviewProvider {\n    static var previews: some View {\n        PhotoGalleryView()\n    }\n}",
        "solution": "import SwiftUI\n\nstruct Photo: Identifiable {\n    let id = UUID()\n    let name: String\n    let category: String\n    let color: Color\n}\n\nstruct PhotoGalleryView: View {\n    let samplePhotos = [\n        Photo(name: \"Sunset\", category: \"Nature\", color: .orange),\n        Photo(name: \"Mountain\", category: \"Nature\", color: .green),\n        Photo(name: \"Beach\", category: \"Travel\", color: .blue),\n        Photo(name: \"City\", category: \"Urban\", color: .gray),\n        Photo(name: \"Forest\", category: \"Nature\", color: .green),\n        Photo(name: \"Food\", category: \"Lifestyle\", color: .red),\n        Photo(name: \"Architecture\", category: \"Urban\", color: .brown),\n        Photo(name: \"Portrait\", category: \"People\", color: .purple),\n        Photo(name: \"Abstract\", category: \"Art\", color: .pink),\n        Photo(name: \"Wildlife\", category: \"Nature\", color: .yellow),\n        Photo(name: \"Night\", category: \"Urban\", color: .black),\n        Photo(name: \"Macro\", category: \"Nature\", color: .green),\n        Photo(name: \"Street\", category: \"Urban\", color: .gray),\n        Photo(name: \"Sports\", category: \"Action\", color: .red),\n        Photo(name: \"Concert\", category: \"Events\", color: .purple),\n        Photo(name: \"Wedding\", category: \"Events\", color: .white),\n        Photo(name: \"Product\", category: \"Commercial\", color: .blue),\n        Photo(name: \"Fashion\", category: \"Lifestyle\", color: .pink),\n        Photo(name: \"Aerial\", category: \"Travel\", color: .cyan),\n        Photo(name: \"Black & White\", category: \"Art\", color: .gray)\n    ]\n    \n    @State private var selectedLayout: GridLayout = .adaptive\n    @State private var selectedCategory: String? = nil\n    @State private var searchText = \"\"\n    @State private var isGridView = true\n    @State private var isRefreshing = false\n    @State private var selectedPhoto: Photo?\n    \n    enum GridLayout: CaseIterable {\n        case twoColumn, threeColumn, adaptive\n        \n        var columns: [GridItem] {\n            switch self {\n            case .twoColumn:\n                return [GridItem(.flexible()), GridItem(.flexible())]\n            case .threeColumn:\n                return [GridItem(.flexible()), GridItem(.flexible()), GridItem(.flexible())]\n            case .adaptive:\n                return [GridItem(.adaptive(minimum: 120))]\n            }\n        }\n        \n        var title: String {\n            switch self {\n            case .twoColumn: return \"2 Columns\"\n            case .threeColumn: return \"3 Columns\"\n            case .adaptive: return \"Adaptive\"\n            }\n        }\n    }\n    \n    var categories: [String] {\n        Array(Set(samplePhotos.map { $0.category })).sorted()\n    }\n    \n    var filteredPhotos: [Photo] {\n        var filtered = samplePhotos\n        \n        // Filter by category\n        if let category = selectedCategory {\n            filtered = filtered.filter { $0.category == category }\n        }\n        \n        // Filter by search text\n        if !searchText.isEmpty {\n            filtered = filtered.filter { $0.name.localizedCaseInsensitiveContains(searchText) }\n        }\n        \n        return filtered\n    }\n    \n    var body: some View {\n        NavigationView {\n            VStack(spacing: 0) {\n                // Search Bar\n                HStack {\n                    Image(systemName: \"magnifyingglass\")\n                        .foregroundColor(.secondary)\n                    TextField(\"Search photos...\", text: $searchText)\n                    if !searchText.isEmpty {\n                        Button(action: { searchText = \"\" }) {\n                            Image(systemName: \"xmark.circle.fill\")\n                                .foregroundColor(.secondary)\n                        }\n                    }\n                }\n                .padding(8)\n                .background(Color(.systemGray6))\n                .cornerRadius(8)\n                .padding(.horizontal)\n                .padding(.top, 8)\n                \n                // Category Horizontal Grid\n                ScrollView(.horizontal, showsIndicators: false) {\n                    LazyHGrid(rows: [GridItem(.fixed(40))], spacing: 8) {\n                        ForEach(categories, id: \\.self) { category in\n                            CategoryPill(\n                                category: category,\n                                isSelected: selectedCategory == category,\n                                action: {\n                                    selectedCategory = selectedCategory == category ? nil : category\n                                }\n                            )\n                        }\n                    }\n                    .padding(.horizontal)\n                }\n                .padding(.vertical, 8)\n                \n                // Layout Controls\n                HStack {\n                    Picker(\"Layout\", selection: $selectedLayout) {\n                        ForEach(GridLayout.allCases, id: \\.self) { layout in\n                            Text(layout.title).tag(layout)\n                        }\n                    }\n                    .pickerStyle(SegmentedPickerStyle())\n                    \n                    Button(action: { isGridView.toggle() }) {\n                        Image(systemName: isGridView ? \"square.grid.2x2\" : \"list.bullet\")\n                            .font(.title3)\n                    }\n                }\n                .padding(.horizontal)\n                .padding(.bottom, 8)\n                \n                // Main Content\n                if filteredPhotos.isEmpty {\n                    VStack {\n                        Image(systemName: \"photo.on.rectangle\")\n                            .font(.system(size: 60))\n                            .foregroundColor(.secondary)\n                        Text(\"No photos found\")\n                            .font(.headline)\n                            .foregroundColor(.secondary)\n                    }\n                    .frame(maxWidth: .infinity, maxHeight: .infinity)\n                } else {\n                    ScrollView {\n                        if isGridView {\n                            LazyVGrid(columns: selectedLayout.columns, spacing: 12) {\n                                ForEach(filteredPhotos) { photo in\n                                    PhotoGridItem(photo: photo)\n                                        .onTapGesture {\n                                            selectedPhoto = photo\n                                        }\n                                        .accessibilityLabel(photo.name)\n                                        .accessibilityHint(\"Double tap to view details\")\n                                }\n                            }\n                            .padding()\n                        } else {\n                            LazyVStack(spacing: 12) {\n                                ForEach(filteredPhotos) { photo in\n                                    PhotoListItem(photo: photo)\n                                        .onTapGesture {\n                                            selectedPhoto = photo\n                                        }\n                                }\n                            }\n                            .padding()\n                        }\n                    }\n                    .refreshable {\n                        await refreshData()\n                    }\n                }\n            }\n            .navigationTitle(\"Photo Gallery\")\n            .sheet(item: $selectedPhoto) { photo in\n                PhotoDetailView(photo: photo)\n            }\n        }\n        .animation(.spring(response: 0.3), value: selectedLayout)\n        .animation(.easeInOut, value: isGridView)\n        .animation(.easeInOut, value: filteredPhotos)\n    }\n    \n    private func refreshData() async {\n        isRefreshing = true\n        // Simulate network request\n        try? await Task.sleep(nanoseconds: 1_000_000_000)\n        isRefreshing = false\n    }\n}\n\nstruct CategoryPill: View {\n    let category: String\n    let isSelected: Bool\n    let action: () -> Void\n    \n    var body: some View {\n        Button(action: action) {\n            Text(category)\n                .font(.caption)\n                .fontWeight(.medium)\n                .padding(.horizontal, 12)\n                .padding(.vertical, 6)\n                .background(isSelected ? Color.blue : Color(.systemGray5))\n                .foregroundColor(isSelected ? .white : .primary)\n                .cornerRadius(16)\n        }\n        .buttonStyle(PlainButtonStyle())\n    }\n}\n\nstruct PhotoGridItem: View {\n    let photo: Photo\n    \n    var body: some View {\n        Rectangle()\n            .fill(photo.color)\n            .aspectRatio(1, contentMode: .fill)\n            .overlay(\n                VStack {\n                    Spacer()\n                    HStack {\n                        Text(photo.name)\n                            .font(.caption)\n                            .fontWeight(.medium)\n                            .foregroundColor(.white)\n                            .padding(4)\n                            .background(Color.black.opacity(0.7))\n                            .cornerRadius(4)\n                        Spacer()\n                    }\n                    .padding(4)\n                }\n            )\n            .cornerRadius(8)\n    }\n}\n\nstruct PhotoListItem: View {\n    let photo: Photo\n    \n    var body: some View {\n        HStack(spacing: 12) {\n            Rectangle()\n                .fill(photo.color)\n                .frame(width: 60, height: 60)\n                .cornerRadius(8)\n            \n            VStack(alignment: .leading, spacing: 4) {\n                Text(photo.name)\n                    .font(.headline)\n                Text(photo.category)\n                    .font(.caption)\n                    .foregroundColor(.secondary)\n            }\n            \n            Spacer()\n            \n            Image(systemName: \"chevron.right\")\n                .foregroundColor(.secondary)\n        }\n        .padding(.vertical, 4)\n    }\n}\n\nstruct PhotoDetailView: View {\n    let photo: Photo\n    @Environment(\\.dismiss) private var dismiss\n    \n    var body: some View {\n        NavigationView {\n            VStack {\n                Rectangle()\n                    .fill(photo.color)\n                    .aspectRatio(1, contentMode: .fit)\n                    .overlay(\n                        VStack {\n                            Spacer()\n                            Text(photo.name)\n                                .font(.title)\n                                .fontWeight(.bold)\n                                .foregroundColor(.white)\n                                .padding()\n                                .background(Color.black.opacity(0.7))\n                                .cornerRadius(8)\n                        }\n                        .padding()\n                    )\n                \n                HStack {\n                    VStack(alignment: .leading) {\n                        Text(\"Category\")\n                            .font(.caption)\n                            .foregroundColor(.secondary)\n                        Text(photo.category)\n                            .font(.headline)\n                    }\n                    Spacer()\n                }\n                .padding()\n                \n                Spacer()\n            }\n            .navigationBarTitleDisplayMode(.inline)\n            .toolbar {\n                ToolbarItem(placement: .navigationBarTrailing) {\n                    Button(\"Done\") {\n                        dismiss()\n                    }\n                }\n            }\n        }\n    }\n}\n\nstruct PhotoGalleryView_Previews: PreviewProvider {\n    static var previews: some View {\n        PhotoGalleryView()\n    }\n}",
        "hints": [
          "PART 1: Use LazyVGrid with [GridItem(.adaptive(minimum: 120))] for responsive columns",
          "PART 2: Create an enum for layout options and use @State to manage selection",
          "PART 3: LazyHGrid works well for horizontal scrolling categories",
          "PART 4: Combine multiple filters using && in your computed property",
          "PART 5: Use .accessibilityLabel() and .accessibilityHint() for VoiceOver support",
          "Use .animation() to smooth layout transitions",
          "Implement pull-to-refresh with .refreshable modifier",
          "Keep grid items simple for better performance"
        ],
        "testCases": [
          {
            "input": "filteredPhotos.count <= samplePhotos.count",
            "expectedOutput": "true",
            "description": "Filtered photos should never exceed total photos"
          },
          {
            "input": "categories.count > 0",
            "expectedOutput": "true",
            "description": "Should extract unique categories from photos"
          },
          {
            "input": "GridLayout.allCases.count == 3",
            "expectedOutput": "true",
            "description": "Should have three layout options"
          }
        ]
      }
    },
    {
        "id": "sheets_alerts",
        "title": "Sheets & Alerts",
        "description": "Master modal presentation, user feedback, and interactive dialogs in SwiftUI",
        "difficulty": "beginner",
        "theory": "# Sheets & Alerts - Professional UI Presentation\n\n## 1. Introduction to Modal Presentation (30 min)\n\n### What are Sheets?\nSheets are modal views that slide up from the bottom of the screen, perfect for:\n- Presenting detailed information\n- User input forms\n- Settings panels\n- Contextual actions\n\n### Key Concepts:\n- **Modal Presentation**: Takes focus until dismissed\n- **Non-Destructive**: User can cancel or complete action\n- **Contextual**: Related to the current screen content\n\n## 2. Basic Sheets Implementation (45 min)\n\n### Simple Sheet Presentation:\n```swift\n@State private var showingSheet = false\n\nvar body: some View {\n    Button(\"Show Sheet\") {\n        showingSheet = true\n    }\n    .sheet(isPresented: $showingSheet) {\n        DetailView()\n    }\n}\n```\n\n### Sheet with Custom Content:\n```swift\n.sheet(isPresented: $showSettings) {\n    NavigationView {\n        SettingsView()\n            .navigationTitle(\"Settings\")\n            .navigationBarItems(trailing: Button(\"Done\") {\n                showSettings = false\n            })\n    }\n}\n```\n\n## 3. Advanced Sheet Techniques (60 min)\n\n### Sheets with Data Binding:\n```swift\n@State private var selectedItem: Item?\n\nvar body: some View {\n    List(items) { item in\n        Text(item.name)\n            .onTapGesture {\n                selectedItem = item\n            }\n    }\n    .sheet(item: $selectedItem) { item in\n        ItemDetailView(item: item)\n    }\n}\n```\n\n### Custom Sheet Detents (iOS 16+):\n```swift\n.sheet(isPresented: $showSheet) {\n    CustomView()\n        .presentationDetents([.medium, .large])\n        .presentationDragIndicator(.visible)\n}\n```\n\n### Interactive Dismissal:\n```swift\n.sheet(isPresented: $showSheet) {\n    EditView()\n        .interactiveDismissDisabled(hasUnsavedChanges)\n}\n```\n\n## 4. Full-Screen Cover (30 min)\n\n### When to Use Full-Screen:\n- Immersive experiences\n- Login screens\n- Tutorials\n- Major workflow steps\n\n### Implementation:\n```swift\n@State private var showLogin = false\n\nvar body: some View {\n    Button(\"Login\") {\n        showLogin = true\n    }\n    .fullScreenCover(isPresented: $showLogin) {\n        LoginView()\n    }\n}\n```\n\n## 5. Alert System Fundamentals (45 min)\n\n### Basic Alert Presentation:\n```swift\n@State private var showAlert = false\n\nvar body: some View {\n    Button(\"Delete Item\") {\n        showAlert = true\n    }\n    .alert(\"Confirm Delete\", isPresented: $showAlert) {\n        Button(\"Delete\", role: .destructive) {\n            deleteItem()\n        }\n        Button(\"Cancel\", role: .cancel) { }\n    } message: {\n        Text(\"This action cannot be undone.\")\n    }\n}\n```\n\n### Alert with Dynamic Content:\n```swift\n.alert(\"Error\", isPresented: $showError) {\n    Button(\"OK\") { }\n} message: {\n    Text(errorMessage)\n}\n```\n\n## 6. Advanced Alert Patterns (60 min)\n\n### Multiple Action Alerts:\n```swift\n.alert(\"Choose Action\", isPresented: $showActionSheet) {\n    Button(\"Save\") { saveDocument() }\n    Button(\"Save As...\") { showSaveAs = true }\n    Button(\"Discard\", role: .destructive) { discardChanges() }\n    Button(\"Cancel\", role: .cancel) { }\n} message: {\n    Text(\"What would you like to do with this document?\")\n}\n```\n\n### TextField in Alerts (iOS 15+):\n```swift\n.alert(\"Rename Item\", isPresented: $showRenameAlert) {\n    TextField(\"New name\", text: $newName)\n    Button(\"Rename\") { renameItem() }\n    Button(\"Cancel\", role: .cancel) { }\n} message: {\n    Text(\"Enter a new name for this item\")\n}\n```\n\n## 7. Action Sheets vs Context Menus (30 min)\n\n### Context Menu for Multiple Options:\n```swift\nText(\"File.txt\")\n    .contextMenu {\n        Button(\"Rename\") { showRename = true }\n        Button(\"Duplicate\") { duplicateFile() }\n        Button(\"Share\") { showShareSheet = true }\n        Button(\"Delete\", role: .destructive) { showDeleteAlert = true }\n    }\n```\n\n## 8. Custom Modal Presentations (40 min)\n\n### Custom Sheet Styles:\n```swift\n.sheet(isPresented: $showCustomSheet) {\n    CustomModalView()\n        .background(BackgroundBlurView())\n        .cornerRadius(20)\n        .shadow(radius: 10)\n}\n```\n\n### Half-Modal Presentation:\n```swift\nZStack {\n    // Main content\n    \n    if showHalfModal {\n        HalfModalView()\n            .transition(.move(edge: .bottom))\n            .animation(.spring(), value: showHalfModal)\n    }\n}\n```\n\n## 9. State Management for Modals (30 min)\n\n### Centralized Modal State:\n```swift\nclass ModalManager: ObservableObject {\n    @Published var activeModal: ActiveModal?\n    \n    enum ActiveModal {\n        case settings, profile, createPost, search\n    }\n}\n\n// Usage:\n.sheet(item: $modalManager.activeModal) { modal in\n    switch modal {\n    case .settings: SettingsView()\n    case .profile: ProfileView()\n    case .createPost: CreatePostView()\n    case .search: SearchView()\n    }\n}\n```\n\n## 10. Best Practices & User Experience (30 min)\n\n### When to Use Each Presentation Type:\n- **Sheets**: Forms, settings, detailed views\n- **Alerts**: Critical information, confirmations\n- **Full-Screen Cover**: Major workflow changes\n- **Context Menus**: Quick actions on specific items\n\n### Accessibility Considerations:\n- Provide clear dismissal options\n- Ensure proper focus management\n- Support VoiceOver navigation\n- Consider reduced motion preferences\n\n## Practice Exercises\n\nComplete all exercises to master modal presentation patterns!",
        "codeExample": "import SwiftUI\n\n// === SHEET EXAMPLES ===\n\n// 1. Basic Sheet\nstruct BasicSheetExample: View {\n    @State private var showSimpleSheet = false\n    \n    var body: some View {\n        Button(\"Show Simple Sheet\") {\n            showSimpleSheet = true\n        }\n        .sheet(isPresented: $showSimpleSheet) {\n            VStack {\n                Text(\"This is a simple sheet\")\n                    .font(.title2)\n                Button(\"Dismiss\") {\n                    showSimpleSheet = false\n                }\n                .buttonStyle(.borderedProminent)\n            }\n            .padding()\n        }\n    }\n}\n\n// 2. Sheet with Navigation\nstruct SettingsSheet: View {\n    @Binding var isPresented: Bool\n    @State private var username = \"\"\n    @State private var notificationsEnabled = true\n    \n    var body: some View {\n        NavigationView {\n            Form {\n                Section(\"Account\") {\n                    TextField(\"Username\", text: $username)\n                    Toggle(\"Notifications\", isOn: $notificationsEnabled)\n                }\n                \n                Section(\"Preferences\") {\n                    Toggle(\"Dark Mode\", isOn: .constant(false))\n                    Toggle(\"Auto-save\", isOn: .constant(true))\n                }\n            }\n            .navigationTitle(\"Settings\")\n            .navigationBarItems(\n                leading: Button(\"Cancel\") {\n                    isPresented = false\n                },\n                trailing: Button(\"Save\") {\n                    // Save settings\n                    isPresented = false\n                }\n            )\n        }\n    }\n}\n\n// 3. Sheet with Item Binding\nstruct Item: Identifiable {\n    let id = UUID()\n    let name: String\n    let description: String\n}\n\nstruct ItemDetailSheet: View {\n    let item: Item\n    \n    var body: some View {\n        VStack(alignment: .leading, spacing: 20) {\n            Text(item.name)\n                .font(.largeTitle)\n            \n            Text(item.description)\n                .foregroundColor(.secondary)\n            \n            Spacer()\n        }\n        .padding()\n    }\n}\n\n// === ALERT EXAMPLES ===\n\n// 1. Basic Alert\nstruct BasicAlertExample: View {\n    @State private var showAlert = false\n    \n    var body: some View {\n        Button(\"Show Alert\") {\n            showAlert = true\n        }\n        .alert(\"Important Message\", isPresented: $showAlert) {\n            Button(\"OK\") { }\n            Button(\"Cancel\", role: .cancel) { }\n        } message: {\n            Text(\"Please read this important information.\")\n        }\n    }\n}\n\n// 2. Destructive Action Alert\nstruct DeleteAlertExample: View {\n    @State private var showDeleteAlert = false\n    \n    var body: some View {\n        Button(\"Delete Account\") {\n            showDeleteAlert = true\n        }\n        .alert(\"Delete Account\", isPresented: $showDeleteAlert) {\n            Button(\"Delete\", role: .destructive) {\n                // Perform deletion\n            }\n            Button(\"Cancel\", role: .cancel) { }\n        } message: {\n            Text(\"This will permanently delete your account and all data. This action cannot be undone.\")\n        }\n    }\n}\n\n// 3. TextField Alert (iOS 15+)\nstruct TextFieldAlertExample: View {\n    @State private var showRenameAlert = false\n    @State private var newName = \"\"\n    \n    var body: some View {\n        Button(\"Rename Item\") {\n            showRenameAlert = true\n        }\n        .alert(\"Rename Item\", isPresented: $showRenameAlert) {\n            TextField(\"New name\", text: $newName)\n            Button(\"Rename\") {\n                // Perform rename\n            }\n            Button(\"Cancel\", role: .cancel) { }\n        } message: {\n            Text(\"Enter a new name for this item\")\n        }\n    }\n}\n\n// === COMPREHENSIVE EXAMPLE ===\n\nstruct ContentView: View {\n    @State private var showSettings = false\n    @State private var selectedItem: Item?\n    @State private var showDeleteAlert = false\n    @State private var showActionSheet = false\n    \n    let items = [\n        Item(name: \"Document 1\", description: \"Important project file\"),\n        Item(name: \"Photo Album\", description: \"Vacation photos\"),\n        Item(name: \"Notes\", description: \"Meeting notes from Monday\")\n    ]\n    \n    var body: some View {\n        NavigationView {\n            List {\n                Section {\n                    Button(\"Settings\") {\n                        showSettings = true\n                    }\n                    \n                    Button(\"Show Action Options\") {\n                        showActionSheet = true\n                    }\n                }\n                \n                Section(\"Items\") {\n                    ForEach(items) { item in\n                        Text(item.name)\n                            .onTapGesture {\n                                selectedItem = item\n                            }\n                            .contextMenu {\n                                Button(\"Rename\") {\n                                    selectedItem = item\n                                }\n                                Button(\"Delete\", role: .destructive) {\n                                    showDeleteAlert = true\n                                }\n                            }\n                    }\n                }\n            }\n            .navigationTitle(\"Modal Examples\")\n        }\n        \n        // Sheets\n        .sheet(isPresented: $showSettings) {\n            SettingsSheet(isPresented: $showSettings)\n        }\n        \n        .sheet(item: $selectedItem) { item in\n            NavigationView {\n                ItemDetailSheet(item: item)\n                    .navigationTitle(item.name)\n                    .navigationBarItems(trailing: Button(\"Done\") {\n                        selectedItem = nil\n                    })\n            }\n        }\n        \n        // Alerts\n        .alert(\"Delete Item\", isPresented: $showDeleteAlert) {\n            Button(\"Delete\", role: .destructive) {\n                // Delete logic\n            }\n            Button(\"Cancel\", role: .cancel) { }\n        } message: {\n            Text(\"Are you sure you want to delete this item?\")\n        }\n        \n        .alert(\"Choose Action\", isPresented: $showActionSheet) {\n            Button(\"Save\") { }\n            Button(\"Export\") { }\n            Button(\"Share\") { }\n            Button(\"Cancel\", role: .cancel) { }\n        } message: {\n            Text(\"What would you like to do?\")\n        }\n    }\n}",
        "category": "SwiftUI Beginner",
        "estimatedTime": 240,
        "dependencies": ["variables"],
        "challenge": {
            "instructions": "Create a Task Management app with comprehensive modal presentations:\n\nPART 1: Task List with Sheets (60 min)\n1. Create a task list that shows tasks in a List\n2. Implement a sheet for adding new tasks with form fields (title, description, due date)\n3. Implement a sheet for editing existing tasks using item binding\n4. Add proper navigation bars with Done/Cancel buttons\n\nPART 2: Alert System (45 min)\n5. Create a delete confirmation alert that appears when swiping to delete\n6. Implement an alert for marking tasks as complete\n7. Add a text field alert for quick task renaming\n8. Create an alert for task completion with celebration message\n\nPART 3: Advanced Modals (60 min)\n9. Implement a settings sheet with multiple sections (appearance, notifications, data)\n10. Create a task filter sheet that allows filtering by status, date, or category\n11. Add a full-screen cover for a detailed task view mode\n12. Implement context menus on tasks for quick actions\n\nPART 4: User Experience (45 min)\n13. Add proper dismissal handling for unsaved changes\n14. Implement custom sheet detents for different modal sizes\n15. Add haptic feedback for important actions\n16. Ensure all modals are accessible and support VoiceOver\n\nPART 5: State Management (30 min)\n17. Create a ModalManager to handle multiple modal states\n18. Implement proper data flow between modals and main view\n19. Add loading states during async operations\n20. Handle errors with appropriate alert presentations",
            "starterCode": "import SwiftUI\n\n// Task model\nstruct Task: Identifiable {\n    let id = UUID()\n    var title: String\n    var description: String\n    var isCompleted: Bool\n    var dueDate: Date?\n    var priority: Priority\n    \n    enum Priority: String, CaseIterable {\n        case low, medium, high\n    }\n}\n\n// Main Task Manager View\nstruct TaskManagerView: View {\n    @State private var tasks: [Task] = []\n    \n    // Add your modal state properties here\n    \n    var body: some View {\n        NavigationView {\n            List {\n                // Task list implementation\n            }\n            .navigationTitle(\"Task Manager\")\n            .toolbar {\n                // Toolbar items\n            }\n            \n            // Add your sheets, alerts, and fullScreenCover modifiers here\n        }\n    }\n    \n    // Add your functions for task management here\n}\n\n// Add your modal views here (TaskFormView, SettingsView, etc.)\n\nstruct ContentView: View {\n    var body: some View {\n        TaskManagerView()\n    }\n}",
            "solution": "import SwiftUI\n\n// Task model\nstruct Task: Identifiable {\n    let id = UUID()\n    var title: String\n    var description: String\n    var isCompleted: Bool\n    var dueDate: Date?\n    var priority: Priority\n    \n    enum Priority: String, CaseIterable {\n        case low, medium, high\n        \n        var color: Color {\n            switch self {\n            case .low: return .green\n            case .medium: return .orange\n            case .high: return .red\n            }\n        }\n    }\n}\n\n// Modal Manager\nclass ModalManager: ObservableObject {\n    @Published var activeModal: ActiveModal?\n    \n    enum ActiveModal: Identifiable {\n        case addTask, settings, filters\n        \n        var id: String {\n            switch self {\n            case .addTask: return \"addTask\"\n            case .settings: return \"settings\"\n            case .filters: return \"filters\"\n            }\n        }\n    }\n}\n\n// Main Task Manager View\nstruct TaskManagerView: View {\n    @StateObject private var modalManager = ModalManager()\n    @State private var tasks: [Task] = []\n    @State private var selectedTask: Task?\n    @State private var showDeleteAlert = false\n    @State private var taskToDelete: Task?\n    @State private var showRenameAlert = false\n    @State private var newTaskName = \"\"\n    @State private var taskToRename: Task?\n    @State private var showCompletionAlert = false\n    @State private var taskToComplete: Task?\n    @State private var showDetailView = false\n    @State private var selectedTaskForDetail: Task?\n    \n    var body: some View {\n        NavigationView {\n            List {\n                ForEach(tasks) { task in\n                    TaskRow(task: task)\n                        .onTapGesture {\n                            selectedTask = task\n                        }\n                        .contextMenu {\n                            Button(\"Mark Complete\") {\n                                taskToComplete = task\n                                showCompletionAlert = true\n                            }\n                            Button(\"Rename\") {\n                                taskToRename = task\n                                newTaskName = task.title\n                                showRenameAlert = true\n                            }\n                            Button(\"View Details\") {\n                                selectedTaskForDetail = task\n                                showDetailView = true\n                            }\n                            Button(\"Delete\", role: .destructive) {\n                                taskToDelete = task\n                                showDeleteAlert = true\n                            }\n                        }\n                        .swipeActions(edge: .trailing) {\n                            Button(role: .destructive) {\n                                taskToDelete = task\n                                showDeleteAlert = true\n                            } label: {\n                                Label(\"Delete\", systemImage: \"trash\")\n                            }\n                        }\n                        .swipeActions(edge: .leading) {\n                            Button {\n                                taskToComplete = task\n                                showCompletionAlert = true\n                            } label: {\n                                Label(\"Complete\", systemImage: \"checkmark\")\n                            }\n                            .tint(.green)\n                        }\n                }\n            }\n            .navigationTitle(\"Task Manager\")\n            .toolbar {\n                ToolbarItem(placement: .navigationBarLeading) {\n                    Menu {\n                        Button(\"Settings\") {\n                            modalManager.activeModal = .settings\n                        }\n                        Button(\"Filters\") {\n                            modalManager.activeModal = .filters\n                        }\n                    } label: {\n                        Image(systemName: \"ellipsis.circle\")\n                    }\n                }\n                \n                ToolbarItem(placement: .navigationBarTrailing) {\n                    Button(\"Add Task\") {\n                        modalManager.activeModal = .addTask\n                    }\n                }\n            }\n        }\n        \n        // Sheets\n        .sheet(item: $modalManager.activeModal) { modal in\n            switch modal {\n            case .addTask:\n                TaskFormView(onSave: { newTask in\n                    tasks.append(newTask)\n                    modalManager.activeModal = nil\n                }, onCancel: {\n                    modalManager.activeModal = nil\n                })\n                \n            case .settings:\n                SettingsView(isPresented: .init(\n                    get: { modalManager.activeModal == .settings },\n                    set: { if !$0 { modalManager.activeModal = nil } }\n                ))\n                \n            case .filters:\n                FilterView(isPresented: .init(\n                    get: { modalManager.activeModal == .filters },\n                    set: { if !$0 { modalManager.activeModal = nil } }\n                ))\n            }\n        }\n        \n        .sheet(item: $selectedTask) { task in\n            NavigationView {\n                TaskFormView(task: task, onSave: { updatedTask in\n                    if let index = tasks.firstIndex(where: { $0.id == updatedTask.id }) {\n                        tasks[index] = updatedTask\n                    }\n                    selectedTask = nil\n                }, onCancel: {\n                    selectedTask = nil\n                })\n                .navigationTitle(\"Edit Task\")\n            }\n        }\n        \n        // Full Screen Cover\n        .fullScreenCover(item: $selectedTaskForDetail) { task in\n            NavigationView {\n                TaskDetailView(task: task) {\n                    selectedTaskForDetail = nil\n                }\n                .navigationTitle(\"Task Details\")\n                .navigationBarItems(trailing: Button(\"Done\") {\n                    selectedTaskForDetail = nil\n                })\n            }\n        }\n        \n        // Alerts\n        .alert(\"Delete Task\", isPresented: $showDeleteAlert) {\n            Button(\"Delete\", role: .destructive) {\n                if let task = taskToDelete {\n                    deleteTask(task)\n                }\n            }\n            Button(\"Cancel\", role: .cancel) {\n                taskToDelete = nil\n            }\n        } message: {\n            Text(\"Are you sure you want to delete this task? This action cannot be undone.\")\n        }\n        \n        .alert(\"Rename Task\", isPresented: $showRenameAlert) {\n            TextField(\"New name\", text: $newTaskName)\n            Button(\"Rename\") {\n                if let task = taskToRename {\n                    renameTask(task, to: newTaskName)\n                }\n            }\n            Button(\"Cancel\", role: .cancel) {\n                taskToRename = nil\n                newTaskName = \"\"\n            }\n        } message: {\n            Text(\"Enter a new name for this task\")\n        }\n        \n        .alert(\"Task Completed!\", isPresented: $showCompletionAlert) {\n            Button(\"Great!\") {\n                if let task = taskToComplete {\n                    markTaskComplete(task)\n                }\n            }\n            Button(\"Not Yet\", role: .cancel) {\n                taskToComplete = nil\n            }\n        } message: {\n            Text(\"Congratulations on completing your task! ðŸŽ‰\")\n        }\n    }\n    \n    // Task Management Functions\n    private func deleteTask(_ task: Task) {\n        tasks.removeAll { $0.id == task.id }\n        taskToDelete = nil\n        // Haptic feedback\n        let impact = UIImpactFeedbackGenerator(style: .heavy)\n        impact.impactOccurred()\n    }\n    \n    private func renameTask(_ task: Task, to newName: String) {\n        if let index = tasks.firstIndex(where: { $0.id == task.id }) {\n            tasks[index].title = newName\n        }\n        taskToRename = nil\n        newTaskName = \"\"\n    }\n    \n    private func markTaskComplete(_ task: Task) {\n        if let index = tasks.firstIndex(where: { $0.id == task.id }) {\n            tasks[index].isCompleted = true\n        }\n        taskToComplete = nil\n        // Haptic feedback\n        let notification = UINotificationFeedbackGenerator()\n        notification.notificationOccurred(.success)\n    }\n}\n\n// Supporting Views (TaskFormView, SettingsView, FilterView, TaskDetailView, TaskRow)\n// ... Additional view implementations would go here ...\n\nstruct ContentView: View {\n    var body: some View {\n        TaskManagerView()\n    }\n}",
            "hints": [
                "PART 1: Use @State for modal presentation booleans and @StateObject for ModalManager",
                "PART 2: Implement alerts for destructive actions and use appropriate roles (.destructive, .cancel)",
                "PART 3: Use fullScreenCover for immersive experiences and sheets for forms/settings",
                "PART 4: Add interactiveDismissDisabled() for modals with unsaved changes",
                "PART 5: Create a centralized ModalManager to handle multiple modal states cleanly",
                "Use .contextMenu for quick actions and .swipeActions for swipe gestures",
                "Implement proper navigation bars in sheets with Done/Cancel buttons",
                "Add haptic feedback (UIImpactFeedbackGenerator) for important user actions",
                "Use item-based sheets (.sheet(item:)) for editing specific tasks",
                "Remember to handle optional binding properly with taskToDelete, taskToRename, etc."
            ],
            "testCases": [
                {
                    "input": "modalManager.activeModal == nil",
                    "expectedOutput": "true",
                    "description": "Modal manager should properly handle modal dismissal"
                },
                {
                    "input": "tasks.allSatisfy { $0.title != \"\" }",
                    "expectedOutput": "true",
                    "description": "All tasks should have non-empty titles"
                },
                {
                    "input": "showDeleteAlert == false && taskToDelete == nil",
                    "expectedOutput": "true",
                    "description": "Delete alert should properly reset state after action"
                }
            ]
        }
    },
    {
      "id": "tabview_app_structure",
      "title": "TabView & App Structure",
      "description": "Master multi-tab applications and professional iOS app architecture",
      "difficulty": "beginner",
      "theory": "# TabView & App Structure - Building Professional iOS Apps\n\n## 1. Understanding TabView (45 min)\n\n### What is TabView?\nTabView is SwiftUI's component for creating tab-based navigation, similar to UIKit's UITabBarController. It's perfect for apps with multiple main sections.\n\n### Basic TabView Structure:\n```swift\nTabView {\n    // Tab 1\n    HomeView()\n        .tabItem {\n            Image(systemName: \"house\")\n            Text(\"Home\")\n        }\n    \n    // Tab 2\n    ProfileView()\n        .tabItem {\n            Image(systemName: \"person\")\n            Text(\"Profile\")\n        }\n}\n```\n\n### TabItem Components:\n- **Image**: SF Symbols or custom images\n- **Text**: Tab title\n- **Tag**: Optional identifier for programmatic selection\n\n## 2. TabView Customization (60 min)\n\n### Styling Options:\n```swift\nTabView {\n    // Your tabs...\n}\n.tabViewStyle(DefaultTabViewStyle())  // Default iOS style\n// .tabViewStyle(PageTabViewStyle())  // Page style (for onboarding)\n```\n\n### Badges and Indicators:\n```swift\nHomeView()\n    .tabItem {\n        Image(systemName: \"house\")\n        Text(\"Home\")\n    }\n    .badge(5)  // Show notification count\n```\n\n### Programmatic Tab Selection:\n```swift\n@State private var selectedTab = 0\n\nTabView(selection: $selectedTab) {\n    HomeView()\n        .tabItem { /* ... */ }\n        .tag(0)\n    \n    ProfileView()\n        .tabItem { /* ... */ }\n        .tag(1)\n}\n\n// Change tabs programmatically\nButton(\"Go to Profile\") {\n    selectedTab = 1\n}\n```\n\n## 3. Professional App Architecture (75 min)\n\n### App Structure Patterns:\n\n**1. Single Responsibility Principle:**\n- Each tab handles one main feature\n- Separate concerns: UI, Data, Business Logic\n\n**2. Folder Structure:**\n```\nMyApp/\nâ”œâ”€â”€ Models/\nâ”œâ”€â”€ Views/\nâ”‚   â”œâ”€â”€ Home/\nâ”‚   â”œâ”€â”€ Profile/\nâ”‚   â”œâ”€â”€ Settings/\nâ”‚   â””â”€â”€ Shared/\nâ”œâ”€â”€ ViewModels/\nâ”œâ”€â”€ Services/\nâ””â”€â”€ Utilities/\n```\n\n**3. Dependency Management:**\n```swift\nclass AppState: ObservableObject {\n    @Published var user: User?\n    @Published var isLoggedIn: Bool = false\n}\n\n@main\nstruct MyApp: App {\n    @StateObject private var appState = AppState()\n    \n    var body: some Scene {\n        WindowGroup {\n            ContentView()\n                .environmentObject(appState)\n        }\n    }\n}\n```\n\n## 4. Multi-Tab Application Design (60 min)\n\n### Common Tab Patterns:\n\n**Social Media App:**\n- Home Feed\n- Search\n- Notifications\n- Profile\n- Create Post\n\n**E-commerce App:**\n- Shop\n- Cart\n- Favorites\n- Orders\n- Account\n\n**Productivity App:**\n- Today\n- Projects\n- Calendar\n- Inbox\n- Settings\n\n### Tab Best Practices:\n- 3-5 tabs maximum for mobile\n- Most important feature first\n- Use intuitive icons and labels\n- Consider user mental models\n\n## 5. Navigation Within Tabs (45 min)\n\n### Combining TabView with Navigation:\n```swift\nTabView {\n    NavigationView {\n        HomeView()\n            .navigationTitle(\"Home\")\n    }\n    .tabItem {\n        Image(systemName: \"house\")\n        Text(\"Home\")\n    }\n    \n    NavigationView {\n        ProfileView()\n            .navigationTitle(\"Profile\")\n    }\n    .tabItem {\n        Image(systemName: \"person\")\n        Text(\"Profile\")\n    }\n}\n```\n\n### Deep Linking Between Tabs:\n```swift\nclass TabCoordinator: ObservableObject {\n    @Published var selectedTab = 0\n    @Published var homeDestination: HomeDestination?\n    @Published var profileDestination: ProfileDestination?\n}\n```\n\n## 6. State Management Across Tabs (45 min)\n\n### Shared App State:\n```swift\nclass AppData: ObservableObject {\n    @Published var user: User?\n    @Published var notifications: [Notification] = []\n    @Published var cartItems: [CartItem] = []\n    \n    // Shared methods\n    func addToCart(_ item: Product) { /* ... */ }\n    func markNotificationRead(_ id: String) { /* ... */ }\n}\n```\n\n### Environment Object Usage:\n```swift\nstruct HomeView: View {\n    @EnvironmentObject var appData: AppData\n    \n    var body: some View {\n        List(appData.notifications) { notification in\n            // Display notifications\n        }\n    }\n}\n\nstruct CartView: View {\n    @EnvironmentObject var appData: AppData\n    \n    var body: some View {\n        List(appData.cartItems) { item in\n            // Display cart items\n        }\n    }\n}\n```\n\n## 7. Performance & Best Practices (30 min)\n\n### TabView Performance:\n- Views are lazy-loaded by default\n- Use `.id()` modifier if needed for resetting\n- Consider using `LazyVStack` in tab content\n\n### Memory Management:\n```swift\n// Use weak references in closures\n.onAppear {\n    [weak self] in\n    self?.loadData()\n}\n```\n\n### Accessibility:\n```swift\n.tabItem {\n    Image(systemName: \"house\")\n        .accessibilityLabel(\"Home\")\n    Text(\"Home\")\n}\n.accessibilityElement(children: .combine)\n.accessibilityHint(\"Double tap to view home screen\")\n```\n\n## Practice Project: Build a Complete Multi-Tab App\n\nYou'll create a \"Learning Tracker\" app with 4 main tabs that work together seamlessly!",
      "codeExample": "import SwiftUI\n\n// MARK: - Models\nstruct LearningItem: Identifiable, Codable {\n    let id = UUID()\n    var title: String\n    var description: String\n    var isCompleted: Bool = false\n    var timeSpent: Int = 0 // in minutes\n    var category: String\n    let createdAt: Date = Date()\n}\n\nstruct LearningGoal: Identifiable, Codable {\n    let id = UUID()\n    var title: String\n    var targetHours: Int\n    var currentHours: Int = 0\n    var deadline: Date?\n    var isActive: Bool = true\n}\n\n// MARK: - Main App Structure\n@main\nstruct LearningTrackerApp: App {\n    @StateObject private var appState = AppState()\n    \n    var body: some Scene {\n        WindowGroup {\n            MainTabView()\n                .environmentObject(appState)\n        }\n    }\n}\n\n// MARK: - App State (Shared across tabs)\nclass AppState: ObservableObject {\n    @Published var learningItems: [LearningItem] = []\n    @Published var goals: [LearningGoal] = []\n    @Published var selectedCategory: String = \"All\"\n    @Published var totalLearningTime: Int = 0\n    \n    var categories: [String] {\n        let allCategories = [\"All\"] + Array(Set(learningItems.map { $0.category }))\n        return allCategories.sorted()\n    }\n    \n    var filteredItems: [LearningItem] {\n        if selectedCategory == \"All\" {\n            return learningItems\n        } else {\n            return learningItems.filter { $0.category == selectedCategory }\n        }\n    }\n    \n    func addLearningItem(_ item: LearningItem) {\n        learningItems.append(item)\n        updateTotalTime()\n    }\n    \n    func updateTotalTime() {\n        totalLearningTime = learningItems.reduce(0) { $0 + $1.timeSpent }\n    }\n}\n\n// MARK: - Main Tab View\nstruct MainTabView: View {\n    @State private var selectedTab = 0\n    @EnvironmentObject var appState: AppState\n    \n    var body: some View {\n        TabView(selection: $selectedTab) {\n            // Tab 1: Dashboard\n            NavigationView {\n                DashboardView()\n                    .navigationTitle(\"Learning Dashboard\")\n            }\n            .tabItem {\n                Image(systemName: \"chart.bar\")\n                Text(\"Dashboard\")\n            }\n            .tag(0)\n            \n            // Tab 2: Today's Learning\n            NavigationView {\n                TodayView()\n                    .navigationTitle(\"Today's Learning\")\n            }\n            .tabItem {\n                Image(systemName: \"book\")\n                Text(\"Today\")\n            }\n            .badge(appState.learningItems.filter { !$0.isCompleted }.count)\n            .tag(1)\n            \n            // Tab 3: Goals\n            NavigationView {\n                GoalsView()\n                    .navigationTitle(\"Learning Goals\")\n            }\n            .tabItem {\n                Image(systemName: \"flag\")\n                Text(\"Goals\")\n            }\n            .tag(2)\n            \n            // Tab 4: Profile\n            NavigationView {\n                ProfileView()\n                    .navigationTitle(\"Profile\")\n            }\n            .tabItem {\n                Image(systemName: \"person\")\n                Text(\"Profile\")\n            }\n            .tag(3)\n        }\n        .accentColor(.blue) // Custom tab color\n        .onAppear {\n            // Configure tab bar appearance\n            let appearance = UITabBarAppearance()\n            appearance.configureWithOpaqueBackground()\n            UITabBar.appearance().scrollEdgeAppearance = appearance\n        }\n    }\n}\n\n// MARK: - Tab Views\nstruct DashboardView: View {\n    @EnvironmentObject var appState: AppState\n    \n    var body: some View {\n        ScrollView {\n            VStack(spacing: 20) {\n                // Stats Overview\n                HStack(spacing: 15) {\n                    StatCard(title: \"Total Time\", value: \"\\(appState.totalLearningTime)m\", color: .blue)\n                    StatCard(title: \"Items\", value: \"\\(appState.learningItems.count)\", color: .green)\n                    StatCard(title: \"Completed\", value: \"\\(appState.learningItems.filter { $0.isCompleted }.count)\", color: .orange)\n                }\n                \n                // Recent Activity\n                VStack(alignment: .leading) {\n                    Text(\"Recent Activity\")\n                        .font(.headline)\n                    \n                    ForEach(appState.learningItems.prefix(3)) { item in\n                        HStack {\n                            Image(systemName: item.isCompleted ? \"checkmark.circle.fill\" : \"circle\")\n                                .foregroundColor(item.isCompleted ? .green : .gray)\n                            Text(item.title)\n                            Spacer()\n                            Text(\"\\(item.timeSpent)m\")\n                                .foregroundColor(.secondary)\n                        }\n                        .padding(.vertical, 4)\n                    }\n                }\n                .padding()\n                .background(Color(.systemBackground))\n                .cornerRadius(10)\n                .shadow(radius: 2)\n            }\n            .padding()\n        }\n    }\n}\n\nstruct TodayView: View {\n    @EnvironmentObject var appState: AppState\n    @State private var showingAddItem = false\n    \n    var body: some View {\n        List {\n            // Category Filter\n            Picker(\"Category\", selection: $appState.selectedCategory) {\n                ForEach(appState.categories, id: \\.self) { category in\n                    Text(category).tag(category)\n                }\n            }\n            .pickerStyle(SegmentedPickerStyle())\n            \n            // Learning Items\n            ForEach(appState.filteredItems) { item in\n                HStack {\n                    VStack(alignment: .leading) {\n                        Text(item.title)\n                            .font(.headline)\n                        Text(item.description)\n                            .font(.caption)\n                            .foregroundColor(.secondary)\n                        Text(item.category)\n                            .font(.caption2)\n                            .padding(4)\n                            .background(Color.blue.opacity(0.2))\n                            .cornerRadius(4)\n                    }\n                    \n                    Spacer()\n                    \n                    VStack(alignment: .trailing) {\n                        Text(\"\\(item.timeSpent)m\")\n                        Image(systemName: item.isCompleted ? \"checkmark.circle.fill\" : \"circle\")\n                            .foregroundColor(item.isCompleted ? .green : .gray)\n                    }\n                }\n            }\n        }\n        .toolbar {\n            ToolbarItem(placement: .navigationBarTrailing) {\n                Button {\n                    showingAddItem = true\n                } label: {\n                    Image(systemName: \"plus\")\n                }\n            }\n        }\n        .sheet(isPresented: $showingAddItem) {\n            AddItemView()\n        }\n    }\n}\n\nstruct GoalsView: View {\n    @EnvironmentObject var appState: AppState\n    \n    var body: some View {\n        List {\n            ForEach(appState.goals) { goal in\n                VStack(alignment: .leading) {\n                    Text(goal.title)\n                        .font(.headline)\n                    \n                    ProgressView(value: Double(goal.currentHours), total: Double(goal.targetHours))\n                        .accentColor(.blue)\n                    \n                    HStack {\n                        Text(\"\\(goal.currentHours) / \\(goal.targetHours) hours\")\n                        Spacer()\n                        Text(\"\\(Int(Double(goal.currentHours) / Double(goal.targetHours) * 100))%\")\n                    }\n                    .font(.caption)\n                    .foregroundColor(.secondary)\n                }\n                .padding(.vertical, 8)\n            }\n        }\n    }\n}\n\nstruct ProfileView: View {\n    @EnvironmentObject var appState: AppState\n    \n    var body: some View {\n        Form {\n            Section(header: Text(\"Learning Statistics\")) {\n                HStack {\n                    Text(\"Total Learning Time\")\n                    Spacer()\n                    Text(\"\\(appState.totalLearningTime) minutes\")\n                        .foregroundColor(.secondary)\n                }\n                \n                HStack {\n                    Text(\"Items Completed\")\n                    Spacer()\n                    Text(\"\\(appState.learningItems.filter { $0.isCompleted }.count)\")\n                        .foregroundColor(.secondary)\n                }\n            }\n            \n            Section(header: Text(\"Categories\")) {\n                ForEach(appState.categories.filter { $0 != \"All\" }, id: \\.self) { category in\n                    HStack {\n                        Text(category)\n                        Spacer()\n                        Text(\"\\(appState.learningItems.filter { $0.category == category }.count) items\")\n                            .foregroundColor(.secondary)\n                    }\n                }\n            }\n        }\n    }\n}\n\n// MARK: - Supporting Views\nstruct StatCard: View {\n    let title: String\n    let value: String\n    let color: Color\n    \n    var body: some View {\n        VStack {\n            Text(value)\n                .font(.title2)\n                .fontWeight(.bold)\n                .foregroundColor(color)\n            Text(title)\n                .font(.caption)\n                .foregroundColor(.secondary)\n        }\n        .frame(maxWidth: .infinity)\n        .padding()\n        .background(Color(.systemBackground))\n        .cornerRadius(10)\n        .shadow(radius: 2)\n    }\n}\n\nstruct AddItemView: View {\n    @EnvironmentObject var appState: AppState\n    @Environment(\\.dismiss) private var dismiss\n    \n    @State private var title = \"\"\n    @State private var description = \"\"\n    @State private var timeSpent = \"\"\n    @State private var category = \"Swift\"\n    \n    let categories = [\"Swift\", \"UI/UX\", \"Algorithms\", \"Tools\", \"Other\"]\n    \n    var body: some View {\n        NavigationView {\n            Form {\n                TextField(\"Title\", text: $title)\n                TextField(\"Description\", text: $description)\n                TextField(\"Time Spent (minutes)\", text: $timeSpent)\n                    .keyboardType(.numberPad)\n                \n                Picker(\"Category\", selection: $category) {\n                    ForEach(categories, id: \\.self) { category in\n                        Text(category).tag(category)\n                    }\n                }\n            }\n            .navigationTitle(\"Add Learning Item\")\n            .toolbar {\n                ToolbarItem(placement: .navigationBarLeading) {\n                    Button(\"Cancel\") { dismiss() }\n                }\n                ToolbarItem(placement: .navigationBarTrailing) {\n                    Button(\"Save\") {\n                        saveItem()\n                        dismiss()\n                    }\n                    .disabled(title.isEmpty || timeSpent.isEmpty)\n                }\n            }\n        }\n    }\n    \n    private func saveItem() {\n        let item = LearningItem(\n            title: title,\n            description: description,\n            timeSpent: Int(timeSpent) ?? 0,\n            category: category\n        )\n        appState.addLearningItem(item)\n    }\n}",
      "category": "SwiftUI Basics",
      "estimatedTime": 240,
      "dependencies": ["variables", "optionals"],
      "challenge": {
        "instructions": "Build a complete Fitness Tracker app with 4 tabs that share data and work together seamlessly.\n\nPART 1: App Structure & Tab Setup (60 min)\n1. Create a MainTabView with 4 tabs: Dashboard, Workouts, Progress, Profile\n2. Set up proper navigation with NavigationView in each tab\n3. Add appropriate SF Symbols and labels for each tab\n4. Implement programmatic tab selection\n\nPART 2: Shared App State (45 min)\n5. Create an AppState class with @Published properties for workouts, goals, and user data\n6. Set up environment object injection in the main app\n7. Create models for Workout, FitnessGoal, and UserProfile\n\nPART 3: Dashboard Tab (45 min)\n8. Display workout statistics (total workouts, calories burned, active minutes)\n9. Show recent workout activity\n10. Add quick action buttons to start new workouts\n\nPART 4: Workouts Tab (45 min)\n11. Implement a list of workouts with filtering by type\n12. Add functionality to create new workouts\n13. Include workout details (duration, calories, type)\n\nPART 5: Data Sharing & Integration (45 min)\n14. Ensure all tabs update when new workouts are added\n15. Implement badge notifications on the Workouts tab\n16. Create computed properties in AppState for shared calculations\n\nBONUS: Advanced Features (60 min)\n17. Add deep linking between tabs\n18. Implement workout completion with progress updates\n19. Add haptic feedback for workout actions\n20. Create a settings screen in Profile tab",
        "starterCode": "import SwiftUI\n\n// MARK: - Add your models here\n\n\n// MARK: - App State\n// Create your AppState class here\n\n\n// MARK: - Main App\n@main\nstruct FitnessTrackerApp: App {\n    // Set up your app state here\n    \n    var body: some Scene {\n        WindowGroup {\n            // Set up main tab view with environment object\n        }\n    }\n}\n\n// MARK: - Main Tab View\nstruct MainTabView: View {\n    // Add tab selection state\n    \n    var body: some View {\n        // Implement your 4-tab structure here\n        Text(\"Implement tabs: Dashboard, Workouts, Progress, Profile\")\n    }\n}\n\n// MARK: - Tab Views\n// Create your 4 tab views here\n\n\n// MARK: - Supporting Views\n// Add any supporting components here",
        "solution": "import SwiftUI\n\n// MARK: - Models\nstruct Workout: Identifiable, Codable {\n    let id = UUID()\n    var name: String\n    var type: WorkoutType\n    var duration: Int // in minutes\n    var calories: Int\n    var date: Date = Date()\n    var isCompleted: Bool = false\n}\n\nstruct FitnessGoal: Identifiable, Codable {\n    let id = UUID()\n    var title: String\n    var targetWorkouts: Int\n    var currentWorkouts: Int = 0\n    var targetCalories: Int\n    var currentCalories: Int = 0\n    var deadline: Date?\n}\n\nstruct UserProfile: Codable {\n    var name: String = \"Fitness User\"\n    var weight: Double = 70.0\n    var height: Double = 170.0\n    var fitnessLevel: FitnessLevel = .beginner\n}\n\nenum WorkoutType: String, CaseIterable, Codable {\n    case running, cycling, swimming, strength, yoga, other\n}\n\nenum FitnessLevel: String, CaseIterable, Codable {\n    case beginner, intermediate, advanced\n}\n\n// MARK: - App State\nclass AppState: ObservableObject {\n    @Published var workouts: [Workout] = []\n    @Published var goals: [FitnessGoal] = []\n    @Published var userProfile = UserProfile()\n    @Published var selectedWorkoutType: WorkoutType? = nil\n    \n    // Computed properties\n    var totalWorkouts: Int { workouts.count }\n    var completedWorkouts: Int { workouts.filter { $0.isCompleted }.count }\n    var totalCalories: Int { workouts.reduce(0) { $0 + $1.calories } }\n    var totalMinutes: Int { workouts.reduce(0) { $0 + $1.duration } }\n    \n    var filteredWorkouts: [Workout] {\n        if let type = selectedWorkoutType {\n            return workouts.filter { $0.type == type }\n        }\n        return workouts\n    }\n    \n    func addWorkout(_ workout: Workout) {\n        workouts.append(workout)\n        updateGoals()\n    }\n    \n    func completeWorkout(_ workout: Workout) {\n        if let index = workouts.firstIndex(where: { $0.id == workout.id }) {\n            workouts[index].isCompleted = true\n            updateGoals()\n        }\n    }\n    \n    private func updateGoals() {\n        for i in goals.indices {\n            goals[i].currentWorkouts = completedWorkouts\n            goals[i].currentCalories = totalCalories\n        }\n    }\n}\n\n// MARK: - Main App\n@main\nstruct FitnessTrackerApp: App {\n    @StateObject private var appState = AppState()\n    \n    var body: some Scene {\n        WindowGroup {\n            MainTabView()\n                .environmentObject(appState)\n        }\n    }\n}\n\n// MARK: - Main Tab View\nstruct MainTabView: View {\n    @State private var selectedTab = 0\n    @EnvironmentObject var appState: AppState\n    \n    var body: some View {\n        TabView(selection: $selectedTab) {\n            // Dashboard Tab\n            NavigationView {\n                DashboardView()\n                    .navigationTitle(\"Fitness Dashboard\")\n            }\n            .tabItem {\n                Image(systemName: \"chart.bar\")\n                Text(\"Dashboard\")\n            }\n            .tag(0)\n            \n            // Workouts Tab\n            NavigationView {\n                WorkoutsView()\n                    .navigationTitle(\"Workouts\")\n            }\n            .tabItem {\n                Image(systemName: \"figure.run\")\n                Text(\"Workouts\")\n            }\n            .badge(appState.workouts.filter { !$0.isCompleted }.count)\n            .tag(1)\n            \n            // Progress Tab\n            NavigationView {\n                ProgressView()\n                    .navigationTitle(\"Progress\")\n            }\n            .tabItem {\n                Image(systemName: \"chart.line.uptrend.xyaxis\")\n                Text(\"Progress\")\n            }\n            .tag(2)\n            \n            // Profile Tab\n            NavigationView {\n                ProfileView()\n                    .navigationTitle(\"Profile\")\n            }\n            .tabItem {\n                Image(systemName: \"person\")\n                Text(\"Profile\")\n            }\n            .tag(3)\n        }\n        .accentColor(.green)\n    }\n}\n\n// MARK: - Tab Views\nstruct DashboardView: View {\n    @EnvironmentObject var appState: AppState\n    \n    var body: some View {\n        ScrollView {\n            VStack(spacing: 20) {\n                // Quick Stats\n                LazyVGrid(columns: [GridItem(.flexible()), GridItem(.flexible())], spacing: 15) {\n                    StatCard(title: \"Workouts\", value: \"\\(appState.totalWorkouts)\", color: .blue)\n                    StatCard(title: \"Completed\", value: \"\\(appState.completedWorkouts)\", color: .green)\n                    StatCard(title: \"Calories\", value: \"\\(appState.totalCalories)\", color: .orange)\n                    StatCard(title: \"Minutes\", value: \"\\(appState.totalMinutes)\", color: .purple)\n                }\n                \n                // Recent Activity\n                VStack(alignment: .leading) {\n                    Text(\"Recent Workouts\")\n                        .font(.headline)\n                        .padding(.horizontal)\n                    \n                    ForEach(appState.workouts.prefix(3)) { workout in\n                        WorkoutRow(workout: workout)\n                    }\n                }\n                .padding()\n                .background(Color(.systemBackground))\n                .cornerRadius(10)\n                .shadow(radius: 2)\n                \n                // Quick Actions\n                VStack(alignment: .leading) {\n                    Text(\"Quick Actions\")\n                        .font(.headline)\n                        .padding(.horizontal)\n                    \n                    HStack {\n                        ActionButton(title: \"Start Run\", icon: \"figure.run\", color: .blue)\n                        ActionButton(title: \"Add Workout\", icon: \"plus\", color: .green)\n                    }\n                }\n                .padding()\n                .background(Color(.systemBackground))\n                .cornerRadius(10)\n                .shadow(radius: 2)\n            }\n            .padding()\n        }\n    }\n}\n\nstruct WorkoutsView: View {\n    @EnvironmentObject var appState: AppState\n    @State private var showingAddWorkout = false\n    \n    var body: some View {\n        VStack {\n            // Workout Type Filter\n            ScrollView(.horizontal, showsIndicators: false) {\n                HStack {\n                    Button(\"All\") {\n                        appState.selectedWorkoutType = nil\n                    }\n                    .buttonStyle(FilterButtonStyle(isSelected: appState.selectedWorkoutType == nil))\n                    \n                    ForEach(WorkoutType.allCases, id: \\.self) { type in\n                        Button(type.rawValue.capitalized) {\n                            appState.selectedWorkoutType = type\n                        }\n                        .buttonStyle(FilterButtonStyle(isSelected: appState.selectedWorkoutType == type))\n                    }\n                }\n                .padding(.horizontal)\n            }\n            \n            // Workouts List\n            List {\n                ForEach(appState.filteredWorkouts) { workout in\n                    WorkoutRow(workout: workout)\n                }\n            }\n            .listStyle(PlainListStyle())\n        }\n        .toolbar {\n            ToolbarItem(placement: .navigationBarTrailing) {\n                Button {\n                    showingAddWorkout = true\n                } label: {\n                    Image(systemName: \"plus\")\n                }\n            }\n        }\n        .sheet(isPresented: $showingAddWorkout) {\n            AddWorkoutView()\n        }\n    }\n}\n\nstruct ProgressView: View {\n    @EnvironmentObject var appState: AppState\n    \n    var body: some View {\n        List {\n            Section(header: Text(\"Goals\")) {\n                ForEach(appState.goals) { goal in\n                    VStack(alignment: .leading) {\n                        Text(goal.title)\n                            .font(.headline)\n                        \n                        HStack {\n                            VStack(alignment: .leading) {\n                                Text(\"Workouts: \\(goal.currentWorkouts)/\\(goal.targetWorkouts)\")\n                                Text(\"Calories: \\(goal.currentCalories)/\\(goal.targetCalories)\")\n                            }\n                            \n                            Spacer()\n                            \n                            VStack {\n                                Text(\"\\(Int(Double(goal.currentWorkouts) / Double(goal.targetWorkouts) * 100))%\")\n                                    .font(.title2)\n                                    .fontWeight(.bold)\n                                Text(\"Complete\")\n                                    .font(.caption)\n                            }\n                        }\n                        .font(.caption)\n                        .foregroundColor(.secondary)\n                    }\n                    .padding(.vertical, 8)\n                }\n            }\n            \n            Section(header: Text(\"Weekly Progress\")) {\n                // Add charts or progress visualization here\n                Text(\"Progress charts would go here\")\n                    .foregroundColor(.secondary)\n            }\n        }\n    }\n}\n\nstruct ProfileView: View {\n    @EnvironmentObject var appState: AppState\n    \n    var body: some View {\n        Form {\n            Section(header: Text(\"Profile Information\")) {\n                HStack {\n                    Text(\"Name\")\n                    Spacer()\n                    Text(appState.userProfile.name)\n                        .foregroundColor(.secondary)\n                }\n                \n                HStack {\n                    Text(\"Weight\")\n                    Spacer()\n                    Text(\"\\(appState.userProfile.weight, specifier: \"%.1f\") kg\")\n                        .foregroundColor(.secondary)\n                }\n                \n                HStack {\n                    Text(\"Fitness Level\")\n                    Spacer()\n                    Text(appState.userProfile.fitnessLevel.rawValue.capitalized)\n                        .foregroundColor(.secondary)\n                }\n            }\n            \n            Section(header: Text(\"Lifetime Statistics\")) {\n                HStack {\n                    Text(\"Total Workouts\")\n                    Spacer()\n                    Text(\"\\(appState.totalWorkouts)\")\n                        .foregroundColor(.secondary)\n                }\n                \n                HStack {\n                    Text(\"Total Calories\")\n                    Spacer()\n                    Text(\"\\(appState.totalCalories)\")\n                        .foregroundColor(.secondary)\n                }\n                \n                HStack {\n                    Text(\"Total Active Minutes\")\n                    Spacer()\n                    Text(\"\\(appState.totalMinutes)\")\n                        .foregroundColor(.secondary)\n                }\n            }\n        }\n    }\n}\n\n// MARK: - Supporting Views\nstruct StatCard: View {\n    let title: String\n    let value: String\n    let color: Color\n    \n    var body: some View {\n        VStack {\n            Text(value)\n                .font(.title2)\n                .fontWeight(.bold)\n                .foregroundColor(color)\n            Text(title)\n                .font(.caption)\n                .foregroundColor(.secondary)\n        }\n        .frame(maxWidth: .infinity)\n        .padding()\n        .background(Color(.systemBackground))\n        .cornerRadius(10)\n        .shadow(radius: 2)\n    }\n}\n\nstruct WorkoutRow: View {\n    let workout: Workout\n    \n    var body: some View {\n        HStack {\n            VStack(alignment: .leading) {\n                Text(workout.name)\n                    .font(.headline)\n                Text(workout.type.rawValue.capitalized)\n                    .font(.caption)\n                    .padding(4)\n                    .background(Color.blue.opacity(0.2))\n                    .cornerRadius(4)\n            }\n            \n            Spacer()\n            \n            VStack(alignment: .trailing) {\n                Text(\"\\(workout.duration)m\")\n                Text(\"\\(workout.calories) cal\")\n                    .font(.caption)\n                    .foregroundColor(.secondary)\n            }\n        }\n        .padding(.vertical, 8)\n    }\n}\n\nstruct ActionButton: View {\n    let title: String\n    let icon: String\n    let color: Color\n    \n    var body: some View {\n        Button(action: {}) {\n            VStack {\n                Image(systemName: icon)\n                    .font(.title2)\n                Text(title)\n                    .font(.caption)\n            }\n            .foregroundColor(color)\n            .frame(maxWidth: .infinity)\n            .padding()\n            .background(color.opacity(0.1))\n            .cornerRadius(10)\n        }\n        .buttonStyle(PlainButtonStyle())\n    }\n}\n\nstruct FilterButtonStyle: ButtonStyle {\n    let isSelected: Bool\n    \n    func makeBody(configuration: Configuration) -> some View {\n        configuration.label\n            .padding(.horizontal, 12)\n            .padding(.vertical, 8)\n            .background(isSelected ? Color.blue : Color.gray.opacity(0.2))\n            .foregroundColor(isSelected ? .white : .primary)\n            .cornerRadius(8)\n    }\n}\n\nstruct AddWorkoutView: View {\n    @EnvironmentObject var appState: AppState\n    @Environment(\\.dismiss) private var dismiss\n    \n    @State private var name = \"\"\n    @State private var selectedType = WorkoutType.running\n    @State private var duration = \"\"\n    @State private var calories = \"\"\n    \n    var body: some View {\n        NavigationView {\n            Form {\n                TextField(\"Workout Name\", text: $name)\n                \n                Picker(\"Type\", selection: $selectedType) {\n                    ForEach(WorkoutType.allCases, id: \\.self) { type in\n                        Text(type.rawValue.capitalized).tag(type)\n                    }\n                }\n                \n                TextField(\"Duration (minutes)\", text: $duration)\n                    .keyboardType(.numberPad)\n                \n                TextField(\"Calories Burned\", text: $calories)\n                    .keyboardType(.numberPad)\n            }\n            .navigationTitle(\"Add Workout\")\n            .toolbar {\n                ToolbarItem(placement: .navigationBarLeading) {\n                    Button(\"Cancel\") { dismiss() }\n                }\n                ToolbarItem(placement: .navigationBarTrailing) {\n                    Button(\"Save\") {\n                        saveWorkout()\n                        dismiss()\n                    }\n                    .disabled(name.isEmpty || duration.isEmpty || calories.isEmpty)\n                }\n            }\n        }\n    }\n    \n    private func saveWorkout() {\n        let workout = Workout(\n            name: name,\n            type: selectedType,\n            duration: Int(duration) ?? 0,\n            calories: Int(calories) ?? 0\n        )\n        appState.addWorkout(workout)\n    }\n}",
        "hints": [
          "PART 1: Use TabView with .tabItem modifier for each tab. Add NavigationView inside each tab for proper navigation",
          "PART 2: Create AppState as ObservableObject with @Published properties. Use @StateObject in main app and @EnvironmentObject in views",
          "PART 3: Use LazyVGrid for stats cards and List/ScrollView for recent activity",
          "PART 4: Implement filtering with @State for selection and computed properties in AppState",
          "PART 5: Use .badge() modifier on tab items for notifications. Ensure all views update when data changes",
          "Use proper folder structure: separate files for models, views, and state management",
          "Remember to inject environment objects properly using .environmentObject()",
          "Use computed properties in AppState for shared calculations across tabs"
        ],
        "testCases": [
          {
            "input": "appState.totalWorkouts == appState.workouts.count",
            "expectedOutput": "true",
            "description": "Total workouts should equal the count of workouts array"
          },
          {
            "input": "appState.filteredWorkouts.count <= appState.workouts.count",
            "expectedOutput": "true",
            "description": "Filtered workouts should not exceed total workouts"
          }
        ]
      }
    },
    {
      "id": "recipe_app_project",
      "title": "Project: Recipe App",
      "description": "Build a complete tabbed iOS app with multiple views, data management, and navigation",
      "difficulty": "beginner",
      "theory": "# Recipe App Project - Building Your First Complete iOS App\n\n## Project Overview (30 min)\n\nIn this 4-hour project, you'll build a **complete Recipe App** that demonstrates:\n- **Tab-based navigation** with multiple screens\n- **Data modeling** with Swift structs\n- **List views** with custom cells\n- **Detail views** with comprehensive information\n- **User preferences** and settings\n- **App architecture** and organization\n\n## 1. App Architecture & Planning (45 min)\n\n### Project Structure:\n```\nRecipeApp/\nâ”œâ”€â”€ Models/\nâ”‚   â”œâ”€â”€ Recipe.swift\nâ”‚   â””â”€â”€ Category.swift\nâ”œâ”€â”€ Views/\nâ”‚   â”œâ”€â”€ ContentView.swift\nâ”‚   â”œâ”€â”€ RecipeListView.swift\nâ”‚   â”œâ”€â”€ RecipeDetailView.swift\nâ”‚   â”œâ”€â”€ FavoritesView.swift\nâ”‚   â””â”€â”€ SettingsView.swift\nâ”œâ”€â”€ ViewModels/\nâ”‚   â””â”€â”€ RecipeManager.swift\nâ””â”€â”€ Data/\n    â””â”€â”€ SampleData.swift\n```\n\n### Key Concepts:\n- **MVVM Pattern**: Separating data (Model), UI (View), and logic (ViewModel)\n- **TabView**: iOS tab bar navigation\n- **NavigationView**: Stack-based navigation within tabs\n- **@StateObject**: Managing app state\n- **@EnvironmentObject**: Sharing data across views\n\n## 2. Data Modeling (45 min)\n\n### Recipe Model:\nA well-structured data model is crucial for any app. We'll create a `Recipe` struct that contains:\n- Basic information (title, description)\n- Ingredients and instructions\n- Cooking metadata (time, difficulty)\n- Categorization and images\n\n### Sample Data:\nWe'll create sample recipes to populate our app, including:\n- Breakfast recipes\n- Lunch and dinner options\n- Vegetarian and dessert options\n\n## 3. Building the Main Interface (60 min)\n\n### Tab Bar Implementation:\nWe'll create a tab-based interface with:\n- **Recipes Tab**: Browse all recipes\n- **Favorites Tab**: Saved favorite recipes\n- **Categories Tab**: Browse by food categories\n- **Settings Tab**: User preferences\n\n### Navigation Structure:\nEach tab will have its own navigation stack, allowing users to drill down into details and navigate back.\n\n## 4. Recipe List & Detail Views (60 min)\n\n### List Implementation:\n- Custom list rows with recipe images and basic info\n- Search functionality\n- Filtering by category\n- Pull-to-refresh (simulated)\n\n### Detail View Features:\n- Full recipe information display\n- Ingredient lists with quantities\n- Step-by-step instructions\n- Cooking time and difficulty indicators\n- Favorite toggle functionality\n\n## 5. State Management & Data Flow (30 min)\n\n### Managing App State:\n- Using `@StateObject` for data management\n- Observable objects for reactive updates\n- Environment objects for shared data\n- Persisting user preferences with `@AppStorage`\n\n### Favorite System:\nImplementing a robust favorites system that persists across app launches.\n\n## 6. Polish & Final Touches (30 min)\n\n### UI/UX Improvements:\n- Custom styling and colors\n- Loading states and empty views\n- Error handling\n- Accessibility features\n\n### Code Organization:\n- Proper file structure\n- Code comments and documentation\n- Reusable components\n\n## Learning Outcomes\n\nBy completing this project, you'll have hands-on experience with:\n- Building multi-tab iOS applications\n- Implementing complex navigation flows\n- Managing application state\n- Creating custom UI components\n- Structuring SwiftUI apps for scalability\n- Handling user preferences and data persistence\n\nThis project serves as a foundation for building more complex iOS applications!",
      "codeExample": "// === DATA MODELS ===\nstruct Recipe: Identifiable, Codable {\n    let id = UUID()\n    let title: String\n    let description: String\n    let ingredients: [Ingredient]\n    let instructions: [String]\n    let prepTime: Int // in minutes\n    let cookTime: Int // in minutes\n    let difficulty: Difficulty\n    let category: Category\n    let imageName: String\n    var isFavorite: Bool = false\n    \n    var totalTime: Int {\n        return prepTime + cookTime\n    }\n}\n\nstruct Ingredient: Identifiable, Codable {\n    let id = UUID()\n    let name: String\n    let quantity: String\n    let unit: String?\n}\n\nenum Difficulty: String, CaseIterable, Codable {\n    case easy = \"Easy\"\n    case medium = \"Medium\" \n    case hard = \"Hard\"\n}\n\nenum Category: String, CaseIterable, Codable {\n    case breakfast = \"Breakfast\"\n    case lunch = \"Lunch\"\n    case dinner = \"Dinner\"\n    case dessert = \"Dessert\"\n    case vegetarian = \"Vegetarian\"\n}\n\n// === VIEWMODEL ===\nclass RecipeManager: ObservableObject {\n    @Published var recipes: [Recipe] = []\n    @Published var favorites: [Recipe] = []\n    @Published var selectedCategory: Category? = nil\n    \n    init() {\n        loadSampleData()\n        loadFavorites()\n    }\n    \n    private func loadSampleData() {\n        recipes = [\n            Recipe(\n                title: \"Avocado Toast\",\n                description: \"Simple and delicious breakfast\",\n                ingredients: [\n                    Ingredient(name: \"Bread\", quantity: \"2\", unit: \"slices\"),\n                    Ingredient(name: \"Avocado\", quantity: \"1\", unit: \"large\"),\n                    Ingredient(name: \"Lemon juice\", quantity: \"1\", unit: \"tbsp\")\n                ],\n                instructions: [\n                    \"Toast the bread until golden brown\",\n                    \"Mash avocado with lemon juice and salt\",\n                    \"Spread avocado mixture on toast\",\n                    \"Add optional toppings like red pepper flakes\"\n                ],\n                prepTime: 5,\n                cookTime: 3,\n                difficulty: .easy,\n                category: .breakfast,\n                imageName: \"avocado_toast\"\n            )\n        ]\n    }\n    \n    func toggleFavorite(_ recipe: Recipe) {\n        if let index = recipes.firstIndex(where: { $0.id == recipe.id }) {\n            recipes[index].isFavorite.toggle()\n            updateFavorites()\n        }\n    }\n    \n    private func updateFavorites() {\n        favorites = recipes.filter { $0.isFavorite }\n        saveFavorites()\n    }\n    \n    private func saveFavorites() {\n        // Implementation for saving favorites\n    }\n    \n    private func loadFavorites() {\n        // Implementation for loading favorites\n    }\n}\n\n// === MAIN APP STRUCTURE ===\nstruct RecipeApp: App {\n    @StateObject private var recipeManager = RecipeManager()\n    \n    var body: some Scene {\n        WindowGroup {\n            ContentView()\n                .environmentObject(recipeManager)\n        }\n    }\n}\n\n// === TAB VIEW ===\nstruct ContentView: View {\n    var body: some View {\n        TabView {\n            RecipeListView()\n                .tabItem {\n                    Image(systemName: \"list.bullet\")\n                    Text(\"Recipes\")\n                }\n            \n            FavoritesView()\n                .tabItem {\n                    Image(systemName: \"heart.fill\")\n                    Text(\"Favorites\")\n                }\n            \n            CategoriesView()\n                .tabItem {\n                    Image(systemName: \"square.grid.2x2\")\n                    Text(\"Categories\")\n                }\n            \n            SettingsView()\n                .tabItem {\n                    Image(systemName: \"gearshape.fill\")\n                    Text(\"Settings\")\n                }\n        }\n    }\n}\n\n// === RECIPE LIST VIEW ===\nstruct RecipeListView: View {\n    @EnvironmentObject var recipeManager: RecipeManager\n    @State private var searchText = \"\"\n    \n    var filteredRecipes: [Recipe] {\n        if searchText.isEmpty {\n            return recipeManager.recipes\n        } else {\n            return recipeManager.recipes.filter { \n                $0.title.localizedCaseInsensitiveContains(searchText) ||\n                $0.description.localizedCaseInsensitiveContains(searchText)\n            }\n        }\n    }\n    \n    var body: some View {\n        NavigationView {\n            List(filteredRecipes) { recipe in\n                NavigationLink(destination: RecipeDetailView(recipe: recipe)) {\n                    RecipeRowView(recipe: recipe)\n                }\n            }\n            .navigationTitle(\"All Recipes\")\n            .searchable(text: $searchText)\n        }\n    }\n}\n\n// === RECIPE ROW COMPONENT ===\nstruct RecipeRowView: View {\n    let recipe: Recipe\n    @EnvironmentObject var recipeManager: RecipeManager\n    \n    var body: some View {\n        HStack {\n            // Recipe image placeholder\n            Rectangle()\n                .fill(Color.gray.opacity(0.3))\n                .frame(width: 60, height: 60)\n                .cornerRadius(8)\n            \n            VStack(alignment: .leading, spacing: 4) {\n                Text(recipe.title)\n                    .font(.headline)\n                \n                Text(recipe.description)\n                    .font(.caption)\n                    .foregroundColor(.secondary)\n                    .lineLimit(2)\n                \n                HStack {\n                    Label(\"\\(recipe.totalTime) min\", systemImage: \"clock\")\n                    Text(\"â€¢\")\n                    Text(recipe.difficulty.rawValue)\n                    Spacer()\n                    \n                    Button(action: {\n                        recipeManager.toggleFavorite(recipe)\n                    }) {\n                        Image(systemName: recipe.isFavorite ? \"heart.fill\" : \"heart\")\n                            .foregroundColor(recipe.isFavorite ? .red : .gray)\n                    }\n                }\n                .font(.caption)\n            }\n        }\n        .padding(.vertical, 4)\n    }\n}",
      "category": "Projects",
      "estimatedTime": 240,
      "dependencies": ["variables", "optionals"],
      "challenge": {
        "instructions": "Build a complete Recipe App with the following features:\n\nPART 1: Project Setup & Data Models (45 min)\n1. Create the project structure with proper folders\n2. Implement Recipe, Ingredient, and Category data models\n3. Create sample data with at least 5 different recipes\n4. Set up the RecipeManager as an ObservableObject\n\nPART 2: Main Tab Interface (45 min)\n5. Create a TabView with 4 tabs: Recipes, Favorites, Categories, Settings\n6. Implement the main ContentView that hosts the tab interface\n7. Add proper icons and labels for each tab\n8. Set up environment object for data sharing\n\nPART 3: Recipe List & Navigation (60 min)\n9. Build RecipeListView with search functionality\n10. Create custom RecipeRowView with recipe information\n11. Implement NavigationView for drill-down navigation\n12. Add RecipeDetailView placeholder for navigation\n\nPART 4: Recipe Detail View (45 min)\n13. Build comprehensive RecipeDetailView showing:\n    - Recipe title and description\n    - Cooking time and difficulty\n    - Complete ingredient list\n    - Step-by-step instructions\n    - Favorite toggle button\n14. Add proper styling and layout\n\nPART 5: Favorites System (30 min)\n15. Implement favorite toggling functionality\n16. Create FavoritesView that shows only favorited recipes\n17. Add persistence so favorites survive app restarts\n18. Update UI to reflect favorite status\n\nPART 6: Categories & Filtering (30 min)\n19. Create CategoriesView showing recipes by category\n20. Implement category filtering in RecipeListView\n21. Add category badges or sections\n\nPART 7: Polish & Settings (15 min)\n22. Create SettingsView with app information\n23. Add app version and developer info\n24. Implement any additional user preferences\n\nBONUS CHALLENGES (Optional):\n- Add recipe images from assets or URLs\n- Implement recipe sharing functionality\n- Add cooking timer feature\n- Create recipe creation/editing capability",
        "starterCode": "// === PART 1: Data Models ===\n// Define your Recipe, Ingredient, and related models here\n\n\n// === PART 2: Recipe Manager ===\n// Create ObservableObject to manage recipe data\n\n\n// === PART 3: Main App Structure ===\n// Set up your App and main ContentView with tabs\n\n\n// === PART 4: Recipe List View ===\n// Implement the main recipe list with search\n\n\n// === PART 5: Recipe Detail View ===\n// Create detailed recipe view\n\n\n// === PART 6: Favorites System ===\n// Implement favorites functionality\n\n\n// === PART 7: Categories & Settings ===\n// Add category browsing and settings",
        "solution": "// === COMPLETE SOLUTION WOULD BE TOO LARGE FOR THIS FORMAT ===\n// This is a conceptual structure - actual implementation would be 500+ lines\n\n// Key implementation points:\n// 1. Complete data models with Codable conformance\n// 2. RecipeManager with @Published properties\n// 3. TabView with NavigationView for each tab\n// 4. List views with custom rows\n// 5. Detail view with comprehensive recipe info\n// 6. Favorite persistence using UserDefaults\n// 7. Search and filtering functionality\n// 8. Proper error handling and empty states\n\n// The full solution would demonstrate:\n// - MVVM architecture pattern\n// - SwiftUI best practices\n// - Reactive data flow\n// - User interface design\n// - State management\n// - Navigation patterns",
        "hints": [
          "PART 1: Use structs with Identifiable for data models. Include all properties from the theory section",
          "PART 2: TabView requires each tab to be a separate view. Use .tabItem modifier for icons",
          "PART 3: Use NavigationView with NavigationLink for drill-down. Searchable modifier adds search",
          "PART 4: Detail view should use ScrollView with VStack for different sections (ingredients, instructions)",
          "PART 5: Use @AppStorage or UserDefaults for simple persistence of favorites",
          "PART 6: Filter recipes by category using .filter() on the recipes array",
          "Use environmentObject() to share RecipeManager across all views",
          "Create reusable components like RecipeRowView to keep code organized",
          "Test navigation by ensuring you can tap a recipe and see its details",
          "Add sample data with variety (different categories, difficulties, times)"
        ],
        "testCases": [
          {
            "input": "recipes.count >= 5",
            "expectedOutput": "true",
            "description": "Should have at least 5 sample recipes"
          },
          {
            "input": "favorites.filter { $0.isFavorite }.count == favorites.count",
            "expectedOutput": "true",
            "description": "Favorites list should only contain favorited recipes"
          },
          {
            "input": "tabView.tabCount == 4",
            "expectedOutput": "true",
            "description": "App should have 4 main tabs"
          }
        ]
      }
    },
    {
      "id": "networking_fundamentals",
      "title": "Networking Fundamentals",
      "description": "Master URLSession, REST APIs, and modern Swift concurrency for robust network communication",
      "difficulty": "intermediate",
      "theory": "# Networking Fundamentals - Building Connected Apps\n\n## 1. Understanding HTTP & REST (45 min)\n\n### HTTP Basics:\n- **HTTP Methods**: GET, POST, PUT, DELETE, PATCH\n- **Status Codes**: 200 (OK), 201 (Created), 400 (Bad Request), 401 (Unauthorized), 404 (Not Found), 500 (Server Error)\n- **Headers**: Content-Type, Authorization, User-Agent\n- **REST Principles**: Stateless, cacheable, uniform interface\n\n### RESTful API Design:\n```swift\n// REST endpoints examples\nGET /users          // Fetch all users\nGET /users/123      // Fetch user with ID 123\nPOST /users         // Create new user\nPUT /users/123      // Update user 123\nDELETE /users/123   // Delete user 123\n```\n\n## 2. URLSession Fundamentals (60 min)\n\n### URLSession Components:\n- **URLSession**: Manages network requests\n- **URLSessionConfiguration**: Configures session behavior\n- **URLSessionTask**: Represents a single network task\n\n### Session Configurations:\n```swift\n// Default configuration (persistent storage)\nlet defaultConfig = URLSessionConfiguration.default\n\n// Ephemeral configuration (no caching)\nlet ephemeralConfig = URLSessionConfiguration.ephemeral\n\n// Background configuration\nlet backgroundConfig = URLSessionConfiguration.background(\n    identifier: \"com.yourapp.background\"\n)\n```\n\n## 3. Making Network Requests (90 min)\n\n### GET Requests:\n```swift\n// Basic GET request\nfunc fetchUsers() async throws -> [User] {\n    let url = URL(string: \"https://api.example.com/users\")!\n    let (data, response) = try await URLSession.shared.data(from: url)\n    \n    guard let httpResponse = response as? HTTPURLResponse,\n          httpResponse.statusCode == 200 else {\n        throw NetworkError.invalidResponse\n    }\n    \n    return try JSONDecoder().decode([User].self, from: data)\n}\n```\n\n### POST Requests:\n```swift\n// Creating and sending POST requests\nfunc createUser(_ user: User) async throws -> User {\n    let url = URL(string: \"https://api.example.com/users\")!\n    var request = URLRequest(url: url)\n    request.httpMethod = \"POST\"\n    request.setValue(\"application/json\", forHTTPHeaderField: \"Content-Type\")\n    \n    let encoder = JSONEncoder()\n    request.httpBody = try encoder.encode(user)\n    \n    let (data, response) = try await URLSession.shared.data(for: request)\n    \n    guard let httpResponse = response as? HTTPURLResponse,\n          httpResponse.statusCode == 201 else {\n        throw NetworkError.creationFailed\n    }\n    \n    return try JSONDecoder().decode(User.self, from: data)\n}\n```\n\n## 4. Advanced URLSession Features (60 min)\n\n### Custom URLSession:\n```swift\n// Configure custom session with specific timeouts\nlet config = URLSessionConfiguration.default\nconfig.timeoutIntervalForRequest = 30\nconfig.timeoutIntervalForResource = 60\nconfig.httpAdditionalHeaders = [\n    \"User-Agent\": \"MyApp/1.0\",\n    \"Accept\": \"application/json\"\n]\n\nlet customSession = URLSession(configuration: config)\n```\n\n### Download Tasks:\n```swift\n// Download large files with progress tracking\nfunc downloadFile(from url: URL) async throws -> URL {\n    let (tempURL, response) = try await URLSession.shared.download(from: url)\n    \n    guard let httpResponse = response as? HTTPURLResponse,\n          httpResponse.statusCode == 200 else {\n        throw NetworkError.downloadFailed\n    }\n    \n    // Move file to permanent location\n    let documentsURL = FileManager.default.urls(\n        for: .documentDirectory, \n        in: .userDomainMask\n    )[0]\n    let destinationURL = documentsURL.appendingPathComponent(\"downloadedFile\")\n    \n    try FileManager.default.moveItem(at: tempURL, to: destinationURL)\n    return destinationURL\n}\n```\n\n## 5. Error Handling & Resilience (45 min)\n\n### Network Error Types:\n```swift\nenum NetworkError: Error {\n    case invalidURL\n    case invalidResponse\n    case statusCode(Int)\n    case decodingError\n    case noInternetConnection\n    case timeout\n    case serverError(String)\n}\n```\n\n### Robust Error Handling:\n```swift\nfunc fetchWithRetry<T: Decodable>(\n    url: URL, \n    maxRetries: Int = 3\n) async throws -> T {\n    for attempt in 1...maxRetries {\n        do {\n            let (data, response) = try await URLSession.shared.data(from: url)\n            \n            guard let httpResponse = response as? HTTPURLResponse else {\n                throw NetworkError.invalidResponse\n            }\n            \n            switch httpResponse.statusCode {\n            case 200...299:\n                return try JSONDecoder().decode(T.self, from: data)\n            case 400...499:\n                throw NetworkError.statusCode(httpResponse.statusCode)\n            case 500...599:\n                if attempt < maxRetries {\n                    try await Task.sleep(nanoseconds: 2_000_000_000 * UInt64(attempt)) // Exponential backoff\n                    continue\n                } else {\n                    throw NetworkError.serverError(\"Server error: \\(httpResponse.statusCode)\")\n                }\n            default:\n                throw NetworkError.invalidResponse\n            }\n        } catch {\n            if attempt == maxRetries {\n                throw error\n            }\n            try await Task.sleep(nanoseconds: 2_000_000_000 * UInt64(attempt))\n        }\n    }\n    throw NetworkError.timeout\n}\n```\n\n## 6. Authentication & Security (45 min)\n\n### API Key Authentication:\n```swift\nfunc authenticatedRequest(\n    url: URL, \n    apiKey: String\n) -> URLRequest {\n    var request = URLRequest(url: url)\n    request.setValue(\"Bearer \\(apiKey)\", forHTTPHeaderField: \"Authorization\")\n    request.setValue(\"application/json\", forHTTPHeaderField: \"Content-Type\")\n    return request\n}\n```\n\n### OAuth 2.0:\n```swift\nstruct OAuthManager {\n    private let tokenURL: URL\n    private let clientID: String\n    private let clientSecret: String\n    \n    func refreshToken() async throws -> String {\n        var request = URLRequest(url: tokenURL)\n        request.httpMethod = \"POST\"\n        request.setValue(\"application/x-www-form-urlencoded\", forHTTPHeaderField: \"Content-Type\")\n        \n        let body = \"grant_type=client_credentials&client_id=\\(clientID)&client_secret=\\(clientSecret)\"\n        request.httpBody = body.data(using: .utf8)\n        \n        let (data, _) = try await URLSession.shared.data(for: request)\n        let response = try JSONDecoder().decode(OAuthResponse.self, from: data)\n        return response.accessToken\n    }\n}\n```\n\n## 7. Performance & Optimization (30 min)\n\n### Caching Strategies:\n```swift\n// Configure caching behavior\nlet config = URLSessionConfiguration.default\nconfig.requestCachePolicy = .returnCacheDataElseLoad\nconfig.urlCache = URLCache(\n    memoryCapacity: 50 * 1024 * 1024, // 50MB\n    diskCapacity: 200 * 1024 * 1024,  // 200MB\n    diskPath: \"MyAppCache\"\n)\n```\n\n### Request Prioritization:\n```swift\n// Use different URLSessions for different priorities\nlet highPrioritySession: URLSession = {\n    let config = URLSessionConfiguration.default\n    config.networkServiceType = .responsiveData\n    return URLSession(configuration: config)\n}()\n\nlet lowPrioritySession: URLSession = {\n    let config = URLSessionConfiguration.default\n    config.networkServiceType = .background\n    return URLSession(configuration: config)\n}()\n```\n\n## 8. Testing & Debugging (30 min)\n\n### Mocking Network Responses:\n```swift\n// Protocol for testability\nprotocol NetworkService {\n    func fetch<T: Decodable>(_ url: URL) async throws -> T\n}\n\n// Production implementation\nclass URLSessionNetworkService: NetworkService {\n    func fetch<T: Decodable>(_ url: URL) async throws -> T {\n        let (data, _) = try await URLSession.shared.data(from: url)\n        return try JSONDecoder().decode(T.self, from: data)\n    }\n}\n\n// Mock implementation for testing\nclass MockNetworkService: NetworkService {\n    var mockData: Data?\n    var shouldThrowError = false\n    \n    func fetch<T: Decodable>(_ url: URL) async throws -> T {\n        if shouldThrowError {\n            throw NetworkError.invalidResponse\n        }\n        \n        guard let data = mockData else {\n            throw NetworkError.invalidResponse\n        }\n        \n        return try JSONDecoder().decode(T.self, from: data)\n    }\n}\n```\n\n## Practice Exercises\n\nComplete all exercises to master networking in Swift!",
      "codeExample": "import Foundation\n\n// === NETWORK ERROR TYPES ===\nenum NetworkError: Error {\n    case invalidURL\n    case invalidResponse\n    case statusCode(Int)\n    case decodingError\n    case noInternetConnection\n    case timeout\n    case serverError(String)\n}\n\n// === DATA MODELS ===\nstruct User: Codable, Identifiable {\n    let id: Int\n    let name: String\n    let email: String\n    let website: String?\n}\n\nstruct Post: Codable, Identifiable {\n    let id: Int\n    let userId: Int\n    let title: String\n    let body: String\n}\n\nstruct CreateUserRequest: Codable {\n    let name: String\n    let email: String\n    let website: String?\n}\n\nstruct OAuthResponse: Codable {\n    let accessToken: String\n    let tokenType: String\n    let expiresIn: Int\n}\n\n// === NETWORK SERVICE ===\nclass NetworkManager {\n    private let baseURL = \"https://jsonplaceholder.typicode.com\"\n    private let session: URLSession\n    \n    init(configuration: URLSessionConfiguration = .default) {\n        self.session = URLSession(configuration: configuration)\n    }\n    \n    // === BASIC GET REQUEST ===\n    func fetchUsers() async throws -> [User] {\n        guard let url = URL(string: \"\\(baseURL)/users\") else {\n            throw NetworkError.invalidURL\n        }\n        \n        let (data, response) = try await session.data(from: url)\n        \n        guard let httpResponse = response as? HTTPURLResponse else {\n            throw NetworkError.invalidResponse\n        }\n        \n        guard httpResponse.statusCode == 200 else {\n            throw NetworkError.statusCode(httpResponse.statusCode)\n        }\n        \n        do {\n            return try JSONDecoder().decode([User].self, from: data)\n        } catch {\n            throw NetworkError.decodingError\n        }\n    }\n    \n    // === GET WITH QUERY PARAMETERS ===\n    func fetchPosts(for userId: Int) async throws -> [Post] {\n        var components = URLComponents(string: \"\\(baseURL)/posts\")!\n        components.queryItems = [\n            URLQueryItem(name: \"userId\", value: \"\\(userId)\")\n        ]\n        \n        guard let url = components.url else {\n            throw NetworkError.invalidURL\n        }\n        \n        let (data, response) = try await session.data(from: url)\n        \n        guard let httpResponse = response as? HTTPURLResponse,\n              httpResponse.statusCode == 200 else {\n            throw NetworkError.invalidResponse\n        }\n        \n        return try JSONDecoder().decode([Post].self, from: data)\n    }\n    \n    // === POST REQUEST ===\n    func createUser(_ userRequest: CreateUserRequest) async throws -> User {\n        guard let url = URL(string: \"\\(baseURL)/users\") else {\n            throw NetworkError.invalidURL\n        }\n        \n        var request = URLRequest(url: url)\n        request.httpMethod = \"POST\"\n        request.setValue(\"application/json\", forHTTPHeaderField: \"Content-Type\")\n        \n        let encoder = JSONEncoder()\n        request.httpBody = try encoder.encode(userRequest)\n        \n        let (data, response) = try await session.data(for: request)\n        \n        guard let httpResponse = response as? HTTPURLResponse else {\n            throw NetworkError.invalidResponse\n        }\n        \n        guard (200...299).contains(httpResponse.statusCode) else {\n            throw NetworkError.statusCode(httpResponse.statusCode)\n        }\n        \n        do {\n            return try JSONDecoder().decode(User.self, from: data)\n        } catch {\n            throw NetworkError.decodingError\n        }\n    }\n    \n    // === REQUEST WITH RETRY LOGIC ===\n    func fetchWithRetry<T: Decodable>(\n        url: URL,\n        maxRetries: Int = 3\n    ) async throws -> T {\n        for attempt in 1...maxRetries {\n            do {\n                let (data, response) = try await session.data(from: url)\n                \n                guard let httpResponse = response as? HTTPURLResponse else {\n                    throw NetworkError.invalidResponse\n                }\n                \n                switch httpResponse.statusCode {\n                case 200...299:\n                    return try JSONDecoder().decode(T.self, from: data)\n                case 400...499:\n                    throw NetworkError.statusCode(httpResponse.statusCode)\n                case 500...599:\n                    if attempt < maxRetries {\n                        // Exponential backoff\n                        let delay = UInt64(2_000_000_000 * attempt)\n                        try await Task.sleep(nanoseconds: delay)\n                        continue\n                    } else {\n                        throw NetworkError.serverError(\"Server error: \\(httpResponse.statusCode)\")\n                    }\n                default:\n                    throw NetworkError.invalidResponse\n                }\n            } catch {\n                if attempt == maxRetries {\n                    throw error\n                }\n                let delay = UInt64(2_000_000_000 * attempt)\n                try await Task.sleep(nanoseconds: delay)\n            }\n        }\n        throw NetworkError.timeout\n    }\n    \n    // === DOWNLOAD TASK ===\n    func downloadImage(from url: URL) async throws -> Data {\n        let (tempURL, response) = try await session.download(from: url)\n        \n        guard let httpResponse = response as? HTTPURLResponse,\n              httpResponse.statusCode == 200 else {\n            throw NetworkError.downloadFailed\n        }\n        \n        return try Data(contentsOf: tempURL)\n    }\n}\n\n// === USAGE EXAMPLES ===\nclass UserService {\n    private let networkManager = NetworkManager()\n    \n    func loadAllUsers() async {\n        do {\n            let users = try await networkManager.fetchUsers()\n            print(\"Loaded \\(users.count) users\")\n            \n            for user in users {\n                print(\"User: \\(user.name), Email: \\(user.email)\")\n            }\n        } catch {\n            print(\"Failed to load users: \\(error)\")\n        }\n    }\n    \n    func loadUserPosts(userId: Int) async {\n        do {\n            let posts = try await networkManager.fetchPosts(for: userId)\n            print(\"Loaded \\(posts.count) posts for user \\(userId)\")\n        } catch {\n            print(\"Failed to load posts: \\(error)\")\n        }\n    }\n    \n    func createNewUser() async {\n        let newUser = CreateUserRequest(\n            name: \"John Doe\",\n            email: \"john.doe@example.com\",\n            website: \"https://johndoe.com\"\n        )\n        \n        do {\n            let createdUser = try await networkManager.createUser(newUser)\n            print(\"Created user: \\(createdUser.name)\")\n        } catch {\n            print(\"Failed to create user: \\(error)\")\n        }\n    }\n}",
      "category": "Networking",
      "estimatedTime": 300,
      "dependencies": ["variables", "optionals"],
      "challenge": {
        "instructions": "Build a complete Weather App that fetches data from a weather API and displays it beautifully.\n\nPART 1: API Integration (90 min)\n1. Create a WeatherService that fetches current weather data from OpenWeatherMap API\n2. Implement error handling for network failures and invalid responses\n3. Add retry logic for failed requests with exponential backoff\n\nPART 2: Data Modeling (60 min)\n4. Design comprehensive data models for weather data including:\n   - Current weather (temperature, conditions, humidity, wind)\n   - 5-day forecast with daily summaries\n   - Location data (city, country, coordinates)\n5. Implement Codable protocols for all models\n\nPART 3: Advanced Networking (75 min)\n6. Create a generic network layer that can handle any API endpoint\n7. Implement request caching to reduce API calls\n8. Add support for both metric and imperial units\n9. Create a mock network service for testing\n\nPART 4: User Interface Integration (75 min)\n10. Design a SwiftUI view that displays current weather and forecast\n11. Add loading states and error handling in the UI\n12. Implement pull-to-refresh functionality\n13. Add location-based weather fetching\n\nAPI Endpoints to use:\n- Current weather: https://api.openweathermap.org/data/2.5/weather?q={city}&appid={API_KEY}&units=metric\n- 5-day forecast: https://api.openweathermap.org/data/2.5/forecast?q={city}&appid={API_KEY}&units=metric\n\nNote: You'll need to sign up for a free API key at OpenWeatherMap",
        "starterCode": "import Foundation\nimport SwiftUI\n\n// === PART 1: Data Models ===\n// Define your weather data models here\n\n\n// === PART 2: Network Error Handling ===\nenum WeatherError: Error {\n    // Define comprehensive error cases\n}\n\n// === PART 3: Weather Service ===\nclass WeatherService {\n    private let apiKey = \"YOUR_API_KEY\" // Replace with actual API key\n    private let baseURL = \"https://api.openweathermap.org/data/2.5\"\n    \n    // Implement network methods here\n    \n}\n\n// === PART 4: Mock Service for Testing ===\nclass MockWeatherService {\n    // Implement mock service for testing without network\n}\n\n// === PART 5: SwiftUI Views ===\nstruct WeatherView: View {\n    // Implement your weather UI here\n    \n    var body: some View {\n        Text(\"Implement weather display\")\n    }\n}\n\n// === USAGE EXAMPLE ===\n// Uncomment and implement the challenge solutions\n/*\nlet service = WeatherService()\nTask {\n    do {\n        let weather = try await service.fetchCurrentWeather(city: \"London\")\n        print(\"Current temperature: \\(weather.main.temp)Â°C\")\n    } catch {\n        print(\"Error: \\(error)\")\n    }\n}\n*/",
        "solution": "import Foundation\nimport SwiftUI\n\n// === PART 1: Data Models ===\nstruct WeatherResponse: Codable {\n    let coord: Coordinates\n    let weather: [WeatherCondition]\n    let main: MainWeather\n    let visibility: Int\n    let wind: Wind\n    let clouds: Clouds\n    let dt: TimeInterval\n    let sys: System\n    let timezone: Int\n    let id: Int\n    let name: String\n    let cod: Int\n}\n\nstruct ForecastResponse: Codable {\n    let list: [ForecastItem]\n    let city: City\n}\n\nstruct Coordinates: Codable {\n    let lon: Double\n    let lat: Double\n}\n\nstruct WeatherCondition: Codable {\n    let id: Int\n    let main: String\n    let description: String\n    let icon: String\n}\n\nstruct MainWeather: Codable {\n    let temp: Double\n    let feelsLike: Double\n    let tempMin: Double\n    let tempMax: Double\n    let pressure: Int\n    let humidity: Int\n    let seaLevel: Int?\n    let grndLevel: Int?\n    \n    enum CodingKeys: String, CodingKey {\n        case temp, pressure, humidity\n        case feelsLike = \"feels_like\"\n        case tempMin = \"temp_min\"\n        case tempMax = \"temp_max\"\n        case seaLevel = \"sea_level\"\n        case grndLevel = \"grnd_level\"\n    }\n}\n\nstruct Wind: Codable {\n    let speed: Double\n    let deg: Int\n    let gust: Double?\n}\n\nstruct Clouds: Codable {\n    let all: Int\n}\n\nstruct System: Codable {\n    let type: Int?\n    let id: Int?\n    let country: String\n    let sunrise: TimeInterval\n    let sunset: TimeInterval\n}\n\nstruct ForecastItem: Codable {\n    let dt: TimeInterval\n    let main: MainWeather\n    let weather: [WeatherCondition]\n    let clouds: Clouds\n    let wind: Wind\n    let visibility: Int\n    let pop: Double\n    let dtTxt: String\n    \n    enum CodingKeys: String, CodingKey {\n        case dt, main, weather, clouds, wind, visibility, pop\n        case dtTxt = \"dt_txt\"\n    }\n}\n\nstruct City: Codable {\n    let id: Int\n    let name: String\n    let coord: Coordinates\n    let country: String\n    let population: Int\n    let timezone: Int\n    let sunrise: TimeInterval\n    let sunset: TimeInterval\n}\n\n// === PART 2: Network Error Handling ===\nenum WeatherError: Error {\n    case invalidURL\n    case invalidResponse\n    case statusCode(Int)\n    case decodingError\n    case locationUnavailable\n    case apiKeyMissing\n    case networkUnavailable\n}\n\n// === PART 3: Weather Service ===\nclass WeatherService {\n    private let apiKey: String\n    private let baseURL = \"https://api.openweathermap.org/data/2.5\"\n    private let session: URLSession\n    \n    init(apiKey: String, session: URLSession = .shared) {\n        self.apiKey = apiKey\n        self.session = session\n    }\n    \n    func fetchCurrentWeather(city: String, units: String = \"metric\") async throws -> WeatherResponse {\n        guard let url = URL(string: \"\\(baseURL)/weather?q=\\(city)&appid=\\(apiKey)&units=\\(units)\") else {\n            throw WeatherError.invalidURL\n        }\n        \n        let (data, response) = try await session.data(from: url)\n        \n        guard let httpResponse = response as? HTTPURLResponse else {\n            throw WeatherError.invalidResponse\n        }\n        \n        guard httpResponse.statusCode == 200 else {\n            throw WeatherError.statusCode(httpResponse.statusCode)\n        }\n        \n        do {\n            return try JSONDecoder().decode(WeatherResponse.self, from: data)\n        } catch {\n            throw WeatherError.decodingError\n        }\n    }\n    \n    func fetchFiveDayForecast(city: String, units: String = \"metric\") async throws -> ForecastResponse {\n        guard let url = URL(string: \"\\(baseURL)/forecast?q=\\(city)&appid=\\(apiKey)&units=\\(units)\") else {\n            throw WeatherError.invalidURL\n        }\n        \n        let (data, response) = try await session.data(from: url)\n        \n        guard let httpResponse = response as? HTTPURLResponse else {\n            throw WeatherError.invalidResponse\n        }\n        \n        guard httpResponse.statusCode == 200 else {\n            throw WeatherError.statusCode(httpResponse.statusCode)\n        }\n        \n        do {\n            return try JSONDecoder().decode(ForecastResponse.self, from: data)\n        } catch {\n            throw WeatherError.decodingError\n        }\n    }\n    \n    func fetchWithRetry<T: Decodable>(\n        endpoint: String,\n        parameters: [String: String],\n        maxRetries: Int = 3\n    ) async throws -> T {\n        var components = URLComponents(string: \"\\(baseURL)/\\(endpoint)\")!\n        var queryItems = parameters.map { URLQueryItem(name: $0.key, value: $0.value) }\n        queryItems.append(URLQueryItem(name: \"appid\", value: apiKey))\n        components.queryItems = queryItems\n        \n        guard let url = components.url else {\n            throw WeatherError.invalidURL\n        }\n        \n        for attempt in 1...maxRetries {\n            do {\n                let (data, response) = try await session.data(from: url)\n                \n                guard let httpResponse = response as? HTTPURLResponse else {\n                    throw WeatherError.invalidResponse\n                }\n                \n                switch httpResponse.statusCode {\n                case 200...299:\n                    return try JSONDecoder().decode(T.self, from: data)\n                case 400...499:\n                    throw WeatherError.statusCode(httpResponse.statusCode)\n                case 500...599:\n                    if attempt < maxRetries {\n                        try await Task.sleep(nanoseconds: 2_000_000_000 * UInt64(attempt))\n                        continue\n                    } else {\n                        throw WeatherError.statusCode(httpResponse.statusCode)\n                    }\n                default:\n                    throw WeatherError.invalidResponse\n                }\n            } catch {\n                if attempt == maxRetries {\n                    throw error\n                }\n                try await Task.sleep(nanoseconds: 2_000_000_000 * UInt64(attempt))\n            }\n        }\n        throw WeatherError.networkUnavailable\n    }\n}\n\n// === PART 4: SwiftUI Views ===\nstruct WeatherView: View {\n    @StateObject private var viewModel = WeatherViewModel()\n    \n    var body: some View {\n        NavigationView {\n            ScrollView {\n                VStack(spacing: 20) {\n                    if let weather = viewModel.currentWeather {\n                        CurrentWeatherView(weather: weather)\n                    }\n                    \n                    if let forecast = viewModel.forecast {\n                        ForecastView(forecast: forecast)\n                    }\n                    \n                    if viewModel.isLoading {\n                        ProgressView(\"Loading weather...\")\n                    }\n                    \n                    if let error = viewModel.error {\n                        ErrorView(error: error, retryAction: {\n                            Task { await viewModel.loadWeather() }\n                        })\n                    }\n                }\n                .padding()\n            }\n            .navigationTitle(\"Weather\")\n            .refreshable {\n                await viewModel.loadWeather()\n            }\n        }\n        .task {\n            await viewModel.loadWeather()\n        }\n    }\n}\n\n@MainActor\nclass WeatherViewModel: ObservableObject {\n    @Published var currentWeather: WeatherResponse?\n    @Published var forecast: ForecastResponse?\n    @Published var isLoading = false\n    @Published var error: WeatherError?\n    \n    private let service = WeatherService(apiKey: \"YOUR_API_KEY\")\n    \n    func loadWeather() async {\n        isLoading = true\n        error = nil\n        \n        do {\n            async let current = service.fetchCurrentWeather(city: \"London\")\n            async let forecast = service.fetchFiveDayForecast(city: \"London\")\n            \n            let (currentResult, forecastResult) = try await (current, forecast)\n            \n            self.currentWeather = currentResult\n            self.forecast = forecastResult\n        } catch {\n            self.error = error as? WeatherError\n        }\n        \n        isLoading = false\n    }\n}",
        "hints": [
          "PART 1: Use nested structs to model the complex JSON response from OpenWeatherMap API",
          "PART 2: Create specific error cases for different failure scenarios (network, decoding, API limits)",
          "PART 3: Use async/await for modern concurrency. Handle different HTTP status codes appropriately",
          "PART 4: Use @MainActor for view models to ensure UI updates on the main thread",
          "For the API key, sign up at openweathermap.org for a free account",
          "Use Codable protocol for easy JSON encoding/decoding",
          "Implement proper error handling in the UI with user-friendly messages",
          "Consider adding caching to reduce API calls for the same location",
          "Test your network layer with both success and failure scenarios"
        ],
        "testCases": [
          {
            "input": "weatherService != nil",
            "expectedOutput": "true",
            "description": "Weather service should be properly initialized"
          },
          {
            "input": "weatherModel.conformsToCodable",
            "expectedOutput": "true",
            "description": "Weather models should conform to Codable protocol"
          },
          {
            "input": "errorHandlingCoversNetworkFailures",
            "expectedOutput": "true",
            "description": "Error handling should cover network failures and API errors"
          }
        ]
      }
    }
]
