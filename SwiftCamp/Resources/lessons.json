[
    {
      "id": "variables",
      "title": "Variables & Constants",
      "description": "Master Swift's fundamental building blocks - from basic declarations to advanced type concepts",
      "difficulty": "beginner",
      "theory": "# Variables & Constants - The Foundation of Swift\n\n## 1. Understanding var vs let (15 min)\n\n**Variables (`var`)** - Mutable values that can change:\n```swift\nvar score = 100\nscore = 150  // This works!\n```\n\n**Constants (`let`)** - Immutable values that cannot change:\n```swift\nlet playerName = \"Alex\"\n// playerName = \"Bob\"  // This would cause an error!\n```\n\n**Best Practice**: Always use `let` by default, and only use `var` when you know the value needs to change.\n\n## 2. Swift's Type System (25 min)\n\n### Basic Data Types:\n- **`String`**: Text data - `\"Hello, World!\"`\n- **`Int`**: Whole numbers - `42`, `-5`, `1_000_000`\n- **`Double`**: Decimal numbers - `3.14`, `-2.5`, `1.0e10`\n- **`Bool`**: True/False - `true`, `false`\n\n### Type Inference:\nSwift automatically infers types:\n```swift\nlet name = \"Maria\"     // Inferred as String\nlet age = 25           // Inferred as Int\nlet temperature = 23.5 // Inferred as Double\nlet isActive = true    // Inferred as Bool\n```\n\n### Type Annotations:\nYou can explicitly declare types:\n```swift\nvar username: String = \"john_doe\"\nvar userAge: Int = 30\nvar averageScore: Double = 95.5\nvar isLoggedIn: Bool = false\n```\n\n## 3. Type Safety & Type Checking (20 min)\n\nSwift is **type-safe** - the compiler checks types at compile time to prevent errors:\n\n```swift\nlet score = 100\n// score = \"high\"  // Error: Cannot assign String to Int\n// let result = score + \" points\"  // Error: Cannot add Int and String\n```\n\n### Type Conversions:\n```swift\nlet stringNumber = \"123\"\nlet actualNumber = Int(stringNumber)  // Converts String to Int?\n\nlet doubleScore = Double(score)       // Converts Int to Double\nlet stringScore = String(score)       // Converts Int to String\n```\n\n## 4. Advanced Variable Concepts (30 min)\n\n### Multiple Declarations:\n```swift\nvar x = 0, y = 0, z = 0\nlet width = 100, height = 200, depth = 50\n```\n\n### Computed Properties:\n```swift\nvar radius: Double = 5.0\nvar diameter: Double {\n    get { return radius * 2 }\n    set { radius = newValue / 2 }\n}\n```\n\n### Property Observers:\n```swift\nvar score = 0 {\n    willSet {\n        print(\"About to set score to \\(newValue)\")\n    }\n    didSet {\n        print(\"Score changed from \\(oldValue) to \\(score)\")\n    }\n}\n```\n\n## 5. Naming Conventions & Best Practices (15 min)\n\n### Swift Naming Rules:\n- Use camelCase: `playerName`, `highScore`\n- Be descriptive: `userEmail` not `ue`\n- Start with lowercase: `firstName` not `FirstName`\n\n### Good vs Bad Examples:\n```swift\n// Good\nvar numberOfStudents = 30\nlet maximumFileSize = 1024\nvar isUserLoggedIn = true\n\n// Avoid\nvar nos = 30\nlet mfs = 1024\nvar log = true\n```\n\n## 6. Scope and Lifetime (15 min)\n\n### Global vs Local Variables:\n```swift\n// Global scope\nlet appVersion = \"1.0.0\"\n\nfunc calculateScore() {\n    // Local scope\n    var currentScore = 0\n    currentScore += 10\n    print(appVersion)  // Can access global constants\n}\n\n// print(currentScore)  // Error: currentScore doesn't exist here\n```\n\n## Practice Exercises\n\nComplete all exercises to master these concepts!",
      "codeExample": "// === BASIC DECLARATIONS ===\n// Variables (can change)\nvar currentHealth = 100\nvar playerName = \"Hero\"\nvar gameActive = true\n\n// Update variables\ncurrentHealth = 75\nplayerName = \"Super Hero\"\ngameActive = false\n\n// Constants (cannot change)\nlet maximumHealth = 100\nlet gameTitle = \"Swift Adventure\"\nlet pi = 3.14159265359\n\n// === TYPE ANNOTATIONS ===\n// Explicit type declarations\nvar goldCoins: Int = 50\nvar playerLevel: Int = 1\nvar experience: Double = 0.0\nvar characterClass: String = \"Warrior\"\nvar hasMagic: Bool = true\n\n// === TYPE CONVERSIONS ===\nlet stringLevel = \"5\"\nif let level = Int(stringLevel) {\n    playerLevel = level\n}\n\nlet doubleCoins = Double(goldCoins)\nlet stringCoins = String(goldCoins)\n\n// === MULTIPLE DECLARATIONS ===\nvar health = 100, mana = 50, stamina = 80\nlet attack = 10, defense = 5, speed = 8\n\n// === COMPUTED PROPERTIES ===\nvar baseDamage = 20\nvar totalDamage: Int {\n    return baseDamage + (playerLevel * 2)\n}\n\n// === PROPERTY OBSERVERS ===\nvar playerScore = 0 {\n    willSet {\n        print(\"Player will have \\(newValue) points\")\n    }\n    didSet {\n        if playerScore > oldValue {\n            print(\"Gained \\(playerScore - oldValue) points!\")\n        }\n    }\n}\n\n// === PRACTICAL EXAMPLE ===\nstruct Player {\n    let id: String\n    var name: String\n    var level: Int\n    var experience: Double\n    var isOnline: Bool\n    \n    var description: String {\n        return \"\\(name) (Level \\(level)) - \\(experience) XP\"\n    }\n}\n\nvar newPlayer = Player(\n    id: \"player_123\",\n    name: \"SwiftLearner\",\n    level: 1,\n    experience: 0.0,\n    isOnline: true\n)",
      "category": "Swift Basics",
      "estimatedTime": 120,
      "dependencies": [],
      "challenge": {
        "instructions": "Create a complete player management system:\n\nPART 1: Basic Properties (20 min)\n1. Create variables for: health (starting at 100), mana (starting at 50), gold (starting at 0)\n2. Create constants for: playerID, maximumHealth (200), maximumMana (100)\n3. Use proper type annotations for all declarations\n\nPART 2: Computed Properties (25 min)\n4. Create a computed property 'healthPercentage' that returns health/maximumHealth as Double\n5. Create a computed property 'isAlive' that returns true if health > 0\n6. Create a computed property 'playerStatus' that returns a string description\n\nPART 3: Property Observers (20 min)\n7. Add property observers to 'health' that prevent it from going below 0 or above maximumHealth\n8. Add a property observer to 'gold' that prints when the player gains or loses gold\n\nPART 4: Type Conversions & Operations (15 min)\n9. Convert gold to String for display purposes\n10. Calculate experience needed for next level (currentLevel * 1000)\n\nPART 5: Advanced Challenge (40 min)\n11. Create a function 'takeDamage' that reduces health and prints combat messages\n12. Create a function 'gainExperience' that increases experience and handles level ups",
        "starterCode": "// === PART 1: Basic Properties ===\n// Create your variables and constants here\n\n\n// === PART 2: Computed Properties ===\n// Add computed properties here\n\n\n// === PART 3: Property Observers ===\n// Add property observers here\n\n\n// === PART 4: Type Conversions ===\n// Add type conversion logic here\n\n\n// === PART 5: Advanced Challenge ===\n// Create functions here\n\n",
        "solution": "// === PART 1: Basic Properties ===\nvar health: Int = 100\nvar mana: Int = 50\nvar gold: Int = 0\nvar currentLevel: Int = 1\nvar experience: Double = 0.0\n\nlet playerID: String = \"player_\" + UUID().uuidString.prefix(8)\nlet maximumHealth: Int = 200\nlet maximumMana: Int = 100\n\n// === PART 2: Computed Properties ===\nvar healthPercentage: Double {\n    return Double(health) / Double(maximumHealth)\n}\n\nvar isAlive: Bool {\n    return health > 0\n}\n\nvar playerStatus: String {\n    return \"Level \\(currentLevel) Player - \\(health)/\\(maximumHealth) HP (\\(Int(healthPercentage * 100))%)\"\n}\n\n// === PART 3: Property Observers ===\nvar observedHealth: Int = 100 {\n    didSet {\n        if observedHealth < 0 {\n            observedHealth = 0\n            print(\"Player has been defeated!\")\n        } else if observedHealth > maximumHealth {\n            observedHealth = maximumHealth\n        }\n        \n        if observedHealth > oldValue {\n            print(\"Healed for \\(observedHealth - oldValue) HP\")\n        } else if observedHealth < oldValue {\n            print(\"Took \\(oldValue - observedHealth) damage\")\n        }\n    }\n}\n\nvar observedGold: Int = 0 {\n    didSet {\n        if observedGold > oldValue {\n            print(\"Gained \\(observedGold - oldValue) gold! Total: \\(observedGold)\")\n        } else if observedGold < oldValue {\n            print(\"Spent \\(oldValue - observedGold) gold. Remaining: \\(observedGold)\")\n        }\n    }\n}\n\n// === PART 4: Type Conversions ===\nvar goldDisplay: String {\n    return \"\\(gold) gold\"\n}\n\nvar experienceNeeded: Double {\n    return Double(currentLevel) * 1000.0\n}\n\n// === PART 5: Advanced Challenge ===\nfunc takeDamage(amount: Int) {\n    let newHealth = health - amount\n    \n    if newHealth <= 0 {\n        health = 0\n        print(\"Critical hit! Player has been defeated.\")\n    } else {\n        health = newHealth\n        print(\"Player took \\(amount) damage. Health: \\(health)/\\(maximumHealth)\")\n    }\n}\n\nfunc gainExperience(amount: Double) {\n    experience += amount\n    print(\"Gained \\(amount) experience. Total: \\(experience)/\\(experienceNeeded)\")\n    \n    if experience >= experienceNeeded {\n        levelUp()\n    }\n}\n\nfunc levelUp() {\n    currentLevel += 1\n    experience = 0.0\n    maximumHealth += 20\n    health = maximumHealth\n    print(\"Level up! Reached level \\(currentLevel). Health restored to full!\")\n}",
        "hints": [
          "PART 1: Use 'var' for changing values (health, mana) and 'let' for constants (playerID, maximums)",
          "PART 2: Computed properties use { } without =, and return a computed value",
          "PART 3: Use willSet/didSet to observe property changes. didSet has 'oldValue', willSet has 'newValue'",
          "PART 4: Use String() to convert numbers to strings, Double() to convert to decimals",
          "PART 5: Functions should update the player's state and provide feedback messages",
          "Remember to use type annotations for clarity: var health: Int = 100",
          "For the playerID, you can use a simple string since we can't import UUID in this context"
        ],
        "testCases": [
          {
            "input": "healthPercentage > 0 && healthPercentage <= 1",
            "expectedOutput": "true",
            "description": "Health percentage should be between 0 and 1"
          },
          {
            "input": "isAlive == (health > 0)",
            "expectedOutput": "true",
            "description": "isAlive should be true when health > 0"
          },
          {
            "input": "playerStatus.contains(\"Level\")",
            "expectedOutput": "true",
            "description": "Player status should include level information"
          }
        ]
      }
    },
    {
      "id": "optionals",
      "title": "Optionals",
      "description": "Master Swift's powerful optional system - safely handling missing values and preventing runtime crashes",
      "difficulty": "beginner",
      "theory": "# Optionals - Safely Handling Missing Values\n\n## 1. Understanding Optionals (20 min)\n\n### What are Optionals?\nOptionals represent values that might be **missing** (nil). They're Swift's way of handling the absence of a value safely.\n\n### Why Use Optionals?\n- **Safety**: Prevents null pointer exceptions\n- **Clarity**: Makes it explicit when a value might be missing\n- **Compile-time checking**: Catches potential nil errors before runtime\n\n### Optional Declaration:\n```swift\nvar regularString: String = \"Hello\"  // Must have a value\nvar optionalString: String? = \"Hello\" // Might have a value or be nil\nvar nilString: String? = nil         // Definitely no value\n```\n\n## 2. Optional Unwrapping Methods (30 min)\n\n### 1. Force Unwrapping (Dangerous!):\n```swift\nlet name: String? = \"John\"\nlet forcedName = name!  // Crash if name is nil\n```\n\n**Only use when you're 100% sure the value exists!**\n\n### 2. Optional Binding (Safe):\n```swift\nif let unwrappedName = name {\n    print(\"Hello, \\(unwrappedName)\")  // unwrappedName is String, not String?\n} else {\n    print(\"No name provided\")\n}\n```\n\n### 3. Guard Statements (Early Exit):\n```swift\nfunc greetUser(name: String?) {\n    guard let unwrappedName = name else {\n        print(\"No name to greet\")\n        return\n    }\n    print(\"Hello, \\(unwrappedName)\")  // unwrappedName available here\n}\n```\n\n### 4. Nil Coalescing (Default Values):\n```swift\nlet userName = name ?? \"Anonymous\"  // Use \"Anonymous\" if name is nil\n```\n\n## 3. Optional Chaining (25 min)\n\nAccess properties and methods on optional values safely:\n\n```swift\nstruct User {\n    var profile: Profile?\n}\n\nstruct Profile {\n    var email: String?\n    func sendMessage() -> String {\n        return \"Message sent\"\n    }\n}\n\nlet user: User? = User(profile: Profile(email: \"test@example.com\"))\n\n// Safe property access\nlet userEmail = user?.profile?.email  // Returns String??\n\n// Safe method calls\nlet message = user?.profile?.sendMessage()  // Returns String?\n\n// Combined with nil coalescing\nlet safeEmail = user?.profile?.email ?? \"No email\"\n```\n\n## 4. Implicitly Unwrapped Optionals (15 min)\n\nUse when a value will be set soon after initialization and won't be nil:\n\n```swift\nvar forcedUserName: String! = nil  // Implicitly unwrapped\n// Later...\nforcedUserName = \"John\"\nprint(forcedUserName)  // No need to unwrap, but crashes if nil\n\n// vs regular optional\nvar regularUserName: String? = nil\nregularUserName = \"John\"\nif let name = regularUserName {\n    print(name)  // Safe but requires unwrapping\n}\n```\n\n## 5. Advanced Optional Patterns (20 min)\n\n### Optional Map and FlatMap:\n```swift\nlet numberString: String? = \"123\"\nlet number = numberString.map { Int($0) }  // Int?? - double optional!\nlet flatNumber = numberString.flatMap { Int($0) }  // Int? - single optional\n\nlet positiveNumber: Int? = 5\nlet squared = positiveNumber.map { $0 * $0 }  // 25\nlet nilNumber: Int? = nil\nlet nilSquared = nilNumber.map { $0 * $0 }  // nil\n```\n\n### Optional with Switch:\n```swift\nswitch userEmail {\ncase .some(let email):\n    print(\"User email: \\(email)\")\ncase .none:\n    print(\"No email provided\")\n}\n```\n\n## 6. Real-World Optional Scenarios (10 min)\n\n### API Responses:\n```swift\nstruct APIResponse {\n    var data: Data?\n    var error: Error?\n    var statusCode: Int?\n}\n\nfunc handleResponse(_ response: APIResponse) {\n    if let data = response.data {\n        // Process data\n    } else if let error = response.error {\n        // Handle error\n    }\n}\n```\n\n### User Input:\n```swift\nfunc validateUserInput(_ input: String?) -> Bool {\n    guard let input = input, !input.isEmpty else {\n        return false\n    }\n    return input.count >= 3\n}\n```\n\n## Best Practices Summary\n- Prefer `if let` and `guard let` over force unwrapping\n- Use nil coalescing for default values\n- Use optional chaining for nested optionals\n- Document when and why values might be nil\n- Consider using non-optional types when values are required",
      "codeExample": "// === BASIC OPTIONAL DECLARATIONS ===\nvar userName: String? = \"SwiftLearner\"\nvar userAge: Int? = nil\nvar userScore: Double? = 95.5\nvar isPremium: Bool? = true\n\n// === OPTIONAL UNWRAPPING EXAMPLES ===\n\n// 1. Force Unwrapping (Use sparingly!)\nlet forcedName = userName!  // Only if sure it's not nil\n\n// 2. Optional Binding with if let\nif let age = userAge {\n    print(\"User age: \\(age)\")\n} else {\n    print(\"Age not provided\")\n}\n\n// 3. Multiple Optional Binding\nif let name = userName, let score = userScore {\n    print(\"\\(name) has score: \\(score)\")\n}\n\n// 4. Guard Statement\nfunc processUser(name: String?, age: Int?) {\n    guard let name = name, let age = age else {\n        print(\"Missing user information\")\n        return\n    }\n    print(\"Processing \\(name), age \\(age)\")\n}\n\n// 5. Nil Coalescing Operator\nlet displayName = userName ?? \"Anonymous\"\nlet displayAge = userAge ?? 0\nlet displayScore = userScore ?? 0.0\n\n// === OPTIONAL CHAINING ===\nstruct Address {\n    var street: String?\n    var city: String?\n    var zipCode: String?\n}\n\nstruct UserProfile {\n    var name: String?\n    var address: Address?\n    var friends: [String]?\n}\n\nvar profile: UserProfile? = UserProfile(\n    name: \"John\",\n    address: Address(street: \"123 Main St\", city: \"Techville\", zipCode: nil),\n    friends: [\"Alice\", \"Bob\"]\n)\n\n// Safe property access through multiple levels\nlet city = profile?.address?.city  // String?\nlet firstFriend = profile?.friends?.first  // String?\nlet friendCount = profile?.friends?.count  // Int?\n\n// Method calls with optional chaining\nlet uppercaseName = profile?.name?.uppercased()  // String?\n\n// === IMPLICITLY UNWrapped OPTIONALS ===\nvar uiLabel: UILabel!  // Will be set in viewDidLoad\nvar apiClient: APIClient!  // Will be injected during setup\n\n// === ADVANCED OPTIONAL PATTERNS ===\n\n// Optional map\nlet numberString: String? = \"42\"\nlet number = numberString.map { Int($0) }  // Int??\nlet flatNumber = numberString.flatMap { Int($0) }  // Int?\n\n// Optional with computed properties\nvar formattedAge: String? {\n    guard let age = userAge else { return nil }\n    return \"Age: \\(age)\"\n}\n\n// === REAL-WORLD EXAMPLE ===\nfunc createUserAccount(username: String?, email: String?, password: String?) -> Bool {\n    // Validate all required fields\n    guard let username = username, !username.isEmpty,\n          let email = email, email.contains(\"@\"),\n          let password = password, password.count >= 8 else {\n        print(\"Invalid account creation data\")\n        return false\n    }\n    \n    print(\"Creating account for \\(username) with email \\(email)\")\n    return true\n}\n\n// === OPTIONAL IN COLLECTIONS ===\nlet optionalNumbers: [Int?] = [1, nil, 3, nil, 5]\nlet validNumbers = optionalNumbers.compactMap { $0 }  // [1, 3, 5]\n\nlet userInputs: [String?] = [\"hello\", nil, \"world\", \"\", nil]\nlet nonEmptyInputs = userInputs.compactMap { $0?.isEmpty == false ? $0 : nil }",
      "category": "Swift Basics",
      "estimatedTime": 120,
      "dependencies": ["variables"],
      "challenge": {
        "instructions": "Build a complete user registration system using optionals to safely handle missing data.\n\nPART 1: Basic Optional Handling (25 min)\n1. Create optional properties for: username, email, age, and phone number\n2. Implement a function that safely prints user information using if-let\n3. Create a function that returns a formatted bio using guard statements\n\nPART 2: Optional Chaining & Collections (30 min)\n4. Create a UserProfile struct with optional address and preferences\n5. Implement safe access to nested optional properties (street, city, etc.)\n6. Create a function that safely accesses array elements from optional arrays\n\nPART 3: Nil Coalescing & Default Values (20 min)\n7. Implement display functions that provide default values for missing data\n8. Create a function that calculates user level with safe default values\n9. Build a user settings system with fallback to default settings\n\nPART 4: Advanced Optional Patterns (25 min)\n10. Use optional map/flatMap to transform optional values safely\n11. Implement a validation system that returns optional error messages\n12. Create a function that chains multiple optional operations\n\nPART 5: Real-World Application (20 min)\n13. Build a complete user registration validator\n14. Implement a safe data processing pipeline\n15. Create error handling with optional error types",
        "starterCode": "// === PART 1: Basic Optional Handling ===\n// Create user properties and basic functions here\n\n\n// === PART 2: Optional Chaining & Collections ===\n// Define UserProfile and implement safe access\n\n\n// === PART 3: Nil Coalescing & Default Values ===\n// Implement display functions with defaults\n\n\n// === PART 4: Advanced Optional Patterns ===\n// Use map/flatMap and advanced patterns\n\n\n// === PART 5: Real-World Application ===\n// Build complete validation system\n\n",
        "solution": "// === PART 1: Basic Optional Handling ===\nvar username: String? = \"SwiftMaster\"\nvar email: String? = \"user@example.com\"\nvar age: Int? = 25\nvar phoneNumber: String? = nil\n\nfunc printUserInfo() {\n    if let name = username {\n        print(\"Username: \\(name)\")\n    } else {\n        print(\"Username: Not set\")\n    }\n    \n    if let userEmail = email {\n        print(\"Email: \\(userEmail)\")\n    } else {\n        print(\"Email: Not provided\")\n    }\n    \n    if let userAge = age {\n        print(\"Age: \\(userAge)\")\n    } else {\n        print(\"Age: Unknown\")\n    }\n}\n\nfunc getUserBio() -> String? {\n    guard let name = username else {\n        return nil\n    }\n    \n    var bio = \"User: \\(name)\"\n    \n    if let userAge = age {\n        bio += \", Age: \\(userAge)\"\n    }\n    \n    if let userEmail = email {\n        bio += \", Email: \\(userEmail)\"\n    }\n    \n    return bio\n}\n\n// === PART 2: Optional Chaining & Collections ===\nstruct Address {\n    var street: String?\n    var city: String?\n    var country: String? = \"USA\"\n}\n\nstruct Preferences {\n    var theme: String?\n    var notifications: Bool? = true\n}\n\nstruct UserProfile {\n    var username: String?\n    var address: Address?\n    var preferences: Preferences?\n    var friends: [String]?\n}\n\nvar userProfile = UserProfile(\n    username: \"JohnDoe\",\n    address: Address(street: \"123 Main St\", city: nil, country: \"USA\"),\n    preferences: Preferences(theme: \"dark\", notifications: true),\n    friends: [\"Alice\", \"Bob\", \"Charlie\"]\n)\n\nfunc getFullAddress() -> String? {\n    guard let address = userProfile.address else {\n        return nil\n    }\n    \n    var addressParts: [String] = []\n    \n    if let street = address.street {\n        addressParts.append(street)\n    }\n    \n    if let city = address.city {\n        addressParts.append(city)\n    }\n    \n    if let country = address.country {\n        addressParts.append(country)\n    }\n    \n    return addressParts.isEmpty ? nil : addressParts.joined(separator: \", \")\n}\n\nfunc getFirstFriend() -> String? {\n    return userProfile.friends?.first\n}\n\n// === PART 3: Nil Coalescing & Default Values ===\nfunc getDisplayName() -> String {\n    return username ?? \"Anonymous User\"\n}\n\nfunc getDisplayAge() -> String {\n    return age.map { \"\\($0) years old\" } ?? \"Age not specified\"\n}\n\nfunc getUserLevel() -> Int {\n    let baseLevel = 1\n    let ageBonus = age.map { $0 / 10 } ?? 0  // 1 level per 10 years\n    return baseLevel + ageBonus\n}\n\nstruct UserSettings {\n    var theme: String?\n    var language: String?\n    var volume: Int?\n    \n    var effectiveTheme: String {\n        return theme ?? \"light\"\n    }\n    \n    var effectiveLanguage: String {\n        return language ?? \"en\"\n    }\n    \n    var effectiveVolume: Int {\n        return volume ?? 50\n    }\n}\n\n// === PART 4: Advanced Optional Patterns ===\nfunc validateEmail() -> Bool {\n    return email?.contains(\"@\") == true\n}\n\nfunc getDomainFromEmail() -> String? {\n    return email?.split(separator: \"@\").last.map(String.init)\n}\n\nfunc createWelcomeMessage() -> String? {\n    return username.map { name in\n        let greeting = \"Welcome, \\(name)!\"\n        let emailPart = email.map { \" We sent a confirmation to \\($0).\" } ?? \"\"\n        return greeting + emailPart\n    }\n}\n\nfunc processUserInput(_ input: String?) -> String? {\n    return input?\n        .trimmingCharacters(in: .whitespaces)\n        .isEmpty == false ? input : nil\n}\n\n// === PART 5: Real-World Application ===\nstruct ValidationError {\n    let message: String\n}\n\nfunc validateRegistration(username: String?, email: String?, password: String?) -> ValidationError? {\n    guard let username = username, !username.isEmpty else {\n        return ValidationError(message: \"Username is required\")\n    }\n    \n    guard let email = email, email.contains(\"@\") else {\n        return ValidationError(message: \"Valid email is required\")\n    }\n    \n    guard let password = password, password.count >= 8 else {\n        return ValidationError(message: \"Password must be at least 8 characters\")\n    }\n    \n    return nil\n}\n\nfunc registerUser(username: String?, email: String?, password: String?) -> Bool {\n    if let error = validateRegistration(username: username, email: email, password: password) {\n        print(\"Registration failed: \\(error.message)\")\n        return false\n    }\n    \n    print(\"User \\(username!) registered successfully with email \\(email!)\")\n    return true\n}\n\nfunc safeDataProcessingPipeline() -> String? {\n    return username?\n        .trimmingCharacters(in: .whitespaces)\n        .uppercased()\n        .appending(\" - VERIFIED\")\n}",
        "hints": [
          "PART 1: Use if-let for safe unwrapping and guard for early returns with required values",
          "PART 2: Optional chaining uses ?. to safely access nested properties: object?.property?.nestedProperty",
          "PART 3: Nil coalescing ?? provides default values when optionals are nil",
          "PART 4: map transforms optional values, flatMap handles nested optionals",
          "PART 5: Use guard statements to validate multiple conditions and return early on failure",
          "Remember: Force unwrapping ! should be avoided - use safe unwrapping instead",
          "Optional chaining returns nil if any part of the chain is nil",
          "Use compactMap with collections of optionals to filter out nil values"
        ],
        "testCases": [
          {
            "input": "getDisplayName() == \"SwiftMaster\"",
            "expectedOutput": "true",
            "description": "Display name should return username when available"
          },
          {
            "input": "validateEmail() == true",
            "expectedOutput": "true",
            "description": "Email validation should pass for valid email"
          },
          {
            "input": "getDomainFromEmail() == \"example.com\"",
            "expectedOutput": "true",
            "description": "Should extract domain from email address"
          }
        ]
      }
    },
    {
      "id": "control_flow",
      "title": "Control Flow",
      "description": "Master decision-making and repetition in Swift with if/else, switch, and loops",
      "difficulty": "beginner",
      "theory": "# Control Flow - Directing Your Code's Execution\n\n## 1. Conditional Statements: Making Decisions (45 min)\n\n### if/else Statements\nControl flow starts with making decisions. Use `if` to execute code only when a condition is true:\n\n```swift\nlet temperature = 25\n\nif temperature > 30 {\n    print(\"It's hot outside!\")\n} else if temperature > 20 {\n    print(\"It's warm outside\")\n} else {\n    print(\"It's cool outside\")\n}\n```\n\n### Boolean Logic\nCombine conditions using logical operators:\n- `&&` (AND) - Both conditions must be true\n- `||` (OR) - At least one condition must be true\n- `!` (NOT) - Inverts a boolean value\n\n```swift\nlet isSunny = true\nlet isWeekend = false\n\nif isSunny && isWeekend {\n    print(\"Perfect day for outdoor activities!\")\n} else if isSunny || isWeekend {\n    print(\"Still a good day\")\n} else {\n    print(\"Maybe stay indoors\")\n}\n```\n\n## 2. Switch Statements: Elegant Multi-Case Handling (45 min)\n\n### Basic Switch Syntax\n`switch` provides a cleaner alternative to multiple `if/else if` statements:\n\n```swift\nlet grade = \"B\"\n\nswitch grade {\ncase \"A\":\n    print(\"Excellent!\")\ncase \"B\":\n    print(\"Good job!\")\ncase \"C\":\n    print(\"You passed\")\ncase \"D\":\n    print(\"You barely passed\")\ncase \"F\":\n    print(\"You failed\")\ndefault:\n    print(\"Invalid grade\")\n}\n```\n\n### Advanced Switch Features\nSwift's `switch` is incredibly powerful:\n\n**Interval Matching:**\n```swift\nlet score = 85\n\nswitch score {\ncase 90...100:\n    print(\"A\")\ncase 80..<90:\n    print(\"B\")\ncase 70..<80:\n    print(\"C\")\ncase 60..<70:\n    print(\"D\")\ncase 0..<60:\n    print(\"F\")\ndefault:\n    print(\"Score out of range\")\n}\n```\n\n**Compound Cases:**\n```swift\nlet character: Character = \"e\"\n\nswitch character {\ncase \"a\", \"e\", \"i\", \"o\", \"u\":\n    print(\"Vowel\")\ncase \"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \n     \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\":\n    print(\"Consonant\")\ndefault:\n    print(\"Not a letter\")\n}\n```\n\n**Value Binding:**\n```swift\nlet point = (2, 0)\n\nswitch point {\ncase (let x, 0):\n    print(\"On the x-axis with x = \\(x)\")\ncase (0, let y):\n    print(\"On the y-axis with y = \\(y)\")\ncase let (x, y):\n    print(\"Somewhere else at (\\(x), \\(y))\")\n}\n```\n\n## 3. Loops: Repeating Code Execution (60 min)\n\n### for-in Loops\nIterate over sequences like arrays, ranges, and strings:\n\n```swift\n// Loop through a range\nfor number in 1...5 {\n    print(\"Number: \\(number)\")\n}\n\n// Loop through an array\nlet fruits = [\"Apple\", \"Banana\", \"Orange\"]\nfor fruit in fruits {\n    print(\"I like \\(fruit)\")\n}\n\n// Loop through a dictionary\nlet scores = [\"Alice\": 85, \"Bob\": 92, \"Charlie\": 78]\nfor (name, score) in scores {\n    print(\"\\(name): \\(score)\")\n}\n```\n\n### while Loops\nExecute code while a condition remains true:\n\n```swift\nvar counter = 5\n\nwhile counter > 0 {\n    print(\"\\(counter)...\")\n    counter -= 1\n}\nprint(\"Go!\")\n```\n\n### repeat-while Loops\nExecute at least once, then check condition:\n\n```swift\nvar number: Int\n\nrepeat {\n    print(\"Enter a positive number: \")\n    // In real app, you'd read user input here\n    number = 5 // Simulated input\n} while number <= 0\n\nprint(\"You entered: \\(number)\")\n```\n\n## 4. Loop Control Statements (30 min)\n\n### break and continue\nControl loop execution flow:\n\n**`break`** - Exit the loop immediately\n```swift\nfor number in 1...10 {\n    if number == 5 {\n        break // Stop the loop when number reaches 5\n    }\n    print(number)\n}\n// Output: 1, 2, 3, 4\n```\n\n**`continue`** - Skip to next iteration\n```swift\nfor number in 1...10 {\n    if number % 2 == 0 {\n        continue // Skip even numbers\n    }\n    print(number)\n}\n// Output: 1, 3, 5, 7, 9\n```\n\n### Labeled Statements\nControl specific loops in nested situations:\n```swift\nouterLoop: for i in 1...3 {\n    innerLoop: for j in 1...3 {\n        if i * j == 6 {\n            break outerLoop // Break the outer loop, not just inner\n        }\n        print(\"i: \\(i), j: \\(j)\")\n    }\n}\n```\n\n## 5. Practical Patterns & Best Practices (30 min)\n\n### Early Returns\nUse `guard` statements for early exit:\n```swift\nfunc processOrder(quantity: Int, price: Double) -> Double? {\n    guard quantity > 0 else {\n        print(\"Quantity must be positive\")\n        return nil\n    }\n    \n    guard price >= 0 else {\n        print(\"Price cannot be negative\")\n        return nil\n    }\n    \n    return Double(quantity) * price\n}\n```\n\n### Pattern Matching with where\nAdd conditions to cases:\n```swift\nlet number = 15\n\nswitch number {\ncase let x where x % 2 == 0:\n    print(\"\\(x) is even\")\ncase let x where x % 2 == 1:\n    print(\"\\(x) is odd\")\ndefault:\n    print(\"Unknown\")\n}\n```\n\n### Loop Performance\n- Use `for-in` for known iteration counts\n- Use `while` for unknown iteration counts\n- Consider algorithm complexity with nested loops\n\n## 6. Real-World Applications (30 min)\n\n### Game Development\n```swift\n// Game loop pattern\nvar gameRunning = true\nvar playerHealth = 100\n\nwhile gameRunning {\n    // Process input\n    // Update game state\n    // Render graphics\n    \n    playerHealth -= 5\n    \n    if playerHealth <= 0 {\n        print(\"Game Over!\")\n        gameRunning = false\n    }\n}\n```\n\n### Data Processing\n```swift\nlet transactions = [125.50, -45.00, 200.00, -30.00, 75.25]\nvar balance = 0.0\n\nfor transaction in transactions {\n    balance += transaction\n    \n    switch transaction {\n    case _ where transaction > 0:\n        print(\"Deposit: $\\(transaction)\")\n    case _ where transaction < 0:\n        print(\"Withdrawal: $\\(abs(transaction))\")\n    default:\n        print(\"No transaction\")\n    }\n}\n\nprint(\"Final balance: $\\(balance)\")\n```\n\nMaster these control flow concepts to write dynamic, responsive Swift code!",
      "codeExample": "// === IF/ELSE STATEMENTS ===\nlet temperature = 25\nlet isRaining = false\n\n// Basic if/else\nif temperature > 30 {\n    print(\"It's hot! Stay hydrated.\")\n} else if temperature > 20 && !isRaining {\n    print(\"Perfect weather for a walk!\")\n} else {\n    print(\"Might want to stay indoors.\")\n}\n\n// Nested conditionals\nlet age = 25\nlet hasLicense = true\n\nif age >= 18 {\n    if hasLicense {\n        print(\"You can drive a car!\")\n    } else {\n        print(\"You're old enough but need a license.\")\n    }\n} else {\n    print(\"You're too young to drive.\")\n}\n\n// === SWITCH STATEMENTS ===\nlet direction = \"north\"\n\n// Basic switch\nswitch direction {\ncase \"north\":\n    print(\"Heading north\")\ncase \"south\":\n    print(\"Heading south\")\ncase \"east\":\n    print(\"Heading east\")\ncase \"west\":\n    print(\"Heading west\")\ndefault:\n    print(\"Unknown direction\")\n}\n\n// Switch with ranges\nlet examScore = 87\n\nswitch examScore {\ncase 90...100:\n    print(\"Grade: A - Excellent!\")\ncase 80..<90:\n    print(\"Grade: B - Good job!\")\ncase 70..<80:\n    print(\"Grade: C - Satisfactory\")\ncase 60..<70:\n    print(\"Grade: D - Needs improvement\")\ncase 0..<60:\n    print(\"Grade: F - Failed\")\ndefault:\n    print(\"Invalid score\")\n}\n\n// Switch with tuples\nlet coordinates = (1, 0)\n\nswitch coordinates {\ncase (0, 0):\n    print(\"At the origin\")\ncase (_, 0):\n    print(\"On the x-axis\")\ncase (0, _):\n    print(\"On the y-axis\")\ncase (-2...2, -2...2):\n    print(\"Inside the 5x5 box\")\ncase let (x, y):\n    print(\"At coordinates (\\(x), \\(y))\")\n}\n\n// === FOR-IN LOOPS ===\n// Loop through range\nprint(\"\\nCounting to 5:\")\nfor number in 1...5 {\n    print(number)\n}\n\n// Loop through array\nlet fruits = [\"Apple\", \"Banana\", \"Cherry\", \"Date\"]\nprint(\"\\nFruits:\")\nfor fruit in fruits {\n    print(\"- \\(fruit)\")\n}\n\n// Loop with index\nprint(\"\\nFruits with index:\")\nfor (index, fruit) in fruits.enumerated() {\n    print(\"\\(index + 1). \\(fruit)\")\n}\n\n// Loop through dictionary\nlet inventory = [\"Sword\": 5, \"Shield\": 3, \"Potion\": 10]\nprint(\"\\nInventory:\")\nfor (item, quantity) in inventory {\n    print(\"\\(item): \\(quantity)\")\n}\n\n// === WHILE LOOPS ===\nvar countdown = 3\nprint(\"\\nCountdown:\")\nwhile countdown > 0 {\n    print(\"\\(countdown)...\")\n    countdown -= 1\n}\nprint(\"Go!\")\n\n// === REPEAT-WHILE LOOPS ===\nvar userInput = \"\"\nprint(\"\\nRepeat-while example:\")\nrepeat {\n    print(\"Type 'exit' to quit: \")\n    // Simulate user input\n    userInput = \"exit\"\n} while userInput != \"exit\"\n\n// === LOOP CONTROL ===\nprint(\"\\nBreak and continue:\")\nfor number in 1...10 {\n    if number == 3 {\n        continue // Skip 3\n    }\n    if number == 8 {\n        break // Stop at 8\n    }\n    print(number)\n}\n\n// === PRACTICAL EXAMPLE: GAME MECHANICS ===\nstruct Player {\n    var health: Int\n    var mana: Int\n    var level: Int\n}\n\nvar player = Player(health: 100, mana: 50, level: 1)\nlet enemies = [\"Goblin\", \"Orc\", \"Dragon\"]\nlet enemyHealth = [\"Goblin\": 30, \"Orc\": 50, \"Dragon\": 100]\n\nprint(\"\\n=== BATTLE SIMULATION ===\")\n\n// Simulate battles with different enemies\nfor enemy in enemies {\n    print(\"\\nA wild \\(enemy) appears!\")\n    \n    var currentEnemyHealth = enemyHealth[enemy] ?? 0\n    \n    while currentEnemyHealth > 0 && player.health > 0 {\n        // Player attacks\n        let damage = Int.random(in: 5...15) * player.level\n        currentEnemyHealth -= damage\n        print(\"You hit the \\(enemy) for \\(damage) damage!\")\n        \n        // Enemy attacks (sometimes)\n        if currentEnemyHealth > 0 && Bool.random() {\n            let enemyDamage = Int.random(in: 3...8)\n            player.health -= enemyDamage\n            print(\"The \\(enemy) hits you for \\(enemyDamage) damage!\")\n        }\n        \n        // Check battle status\n        switch (player.health, currentEnemyHealth) {\n        case (..., 0):\n            print(\"You defeated the \\(enemy)!\")\n            player.level += 1\n        case (0, _):\n            print(\"You were defeated by the \\(enemy)!\")\n        case (1...30, _):\n            print(\"Warning: Low health!\")\n        default:\n            break\n        }\n    }\n    \n    if player.health <= 0 {\n        print(\"Game Over!\")\n        break\n    }\n}",
      "category": "Swift Basics",
      "estimatedTime": 180,
      "dependencies": ["variables"],
      "challenge": {
        "instructions": "Create a complete student grading system using all control flow concepts:\n\nPART 1: Grade Calculator (45 min)\n1. Create a function that takes a score (0-100) and returns a letter grade using switch with ranges\n2. Add plus/minus grading: A (90-100), A- (85-89), B+ (80-84), B (75-79), etc.\n3. Handle invalid scores with default case\n\nPART 2: Student Analysis (45 min)\n4. Create an array of student scores and use for-in loops to:\n   - Calculate class average\n   - Count how many students got each letter grade\n   - Find the highest and lowest scores\n\nPART 3: Grade Distribution (45 min)\n5. Use while/repeat-while loops to simulate grade improvement:\n   - Start with a failing student (score < 60)\n   - Add 5 points each \"study session\" until they pass\n   - Print progress after each session\n\nPART 4: Advanced Reporting (45 min)\n6. Create a comprehensive report using nested control flow:\n   - Categorize students by performance level (Excellent, Good, Needs Improvement)\n   - Use if/else chains with boolean logic\n   - Implement a search function that finds students in a specific grade range\n\nBONUS: Create a menu system with switch that lets users choose different reporting options",
        "starterCode": "// === PART 1: Grade Calculator ===\n// Create your grade calculation function here\n\n\n// === PART 2: Student Analysis ===\n// Analyze the student scores array\nlet studentScores = [85, 92, 78, 45, 67, 95, 88, 72, 60, 81, 53, 98, 75, 64, 89]\n\n\n// === PART 3: Grade Improvement ===\n// Simulate student improvement with loops\n\n\n// === PART 4: Advanced Reporting ===\n// Create comprehensive reporting system\n\n\n// === BONUS: Menu System ===\n// Implement interactive menu\n",
        "solution": "// === PART 1: Grade Calculator ===\nfunc calculateLetterGrade(score: Int) -> String {\n    switch score {\n    case 93...100:\n        return \"A\"\n    case 90...92:\n        return \"A-\"\n    case 87...89:\n        return \"B+\"\n    case 83...86:\n        return \"B\"\n    case 80...82:\n        return \"B-\"\n    case 77...79:\n        return \"C+\"\n    case 73...76:\n        return \"C\"\n    case 70...72:\n        return \"C-\"\n    case 67...69:\n        return \"D+\"\n    case 63...66:\n        return \"D\"\n    case 60...62:\n        return \"D-\"\n    case 0...59:\n        return \"F\"\n    default:\n        return \"Invalid Score\"\n    }\n}\n\n// === PART 2: Student Analysis ===\nlet studentScores = [85, 92, 78, 45, 67, 95, 88, 72, 60, 81, 53, 98, 75, 64, 89]\n\n// Calculate average\nvar totalScore = 0\nfor score in studentScores {\n    totalScore += score\n}\nlet averageScore = totalScore / studentScores.count\nprint(\"Class Average: \\(averageScore)\")\n\n// Count grades\nvar gradeCounts = [\"A\": 0, \"B\": 0, \"C\": 0, \"D\": 0, \"F\": 0]\n\nfor score in studentScores {\n    let grade = calculateLetterGrade(score: score)\n    \n    switch grade.first {\n    case \"A\":\n        gradeCounts[\"A\"]! += 1\n    case \"B\":\n        gradeCounts[\"B\"]! += 1\n    case \"C\":\n        gradeCounts[\"C\"]! += 1\n    case \"D\":\n        gradeCounts[\"D\"]! += 1\n    case \"F\":\n        gradeCounts[\"F\"]! += 1\n    default:\n        break\n    }\n}\n\nprint(\"Grade Distribution: \\(gradeCounts)\")\n\n// Find highest and lowest\nvar highestScore = studentScores[0]\nvar lowestScore = studentScores[0]\n\nfor score in studentScores {\n    if score > highestScore {\n        highestScore = score\n    }\n    if score < lowestScore {\n        lowestScore = score\n    }\n}\n\nprint(\"Highest Score: \\(highestScore), Lowest Score: \\(lowestScore)\")\n\n// === PART 3: Grade Improvement ===\nvar failingStudentScore = 45\nvar studySessions = 0\n\nprint(\"\\n=== STUDENT IMPROVEMENT TRACKER ===\")\n\nwhile failingStudentScore < 60 {\n    studySessions += 1\n    failingStudentScore += 5\n    \n    let currentGrade = calculateLetterGrade(score: failingStudentScore)\n    print(\"After session \\(studySessions): Score = \\(failingStudentScore), Grade = \\(currentGrade)\")\n    \n    if failingStudentScore >= 60 {\n        print(\"ðŸŽ‰ Student passed after \\(studySessions) study sessions!\")\n    }\n}\n\n// === PART 4: Advanced Reporting ===\nfunc categorizePerformance(score: Int) -> String {\n    if score >= 90 {\n        return \"Excellent\"\n    } else if score >= 75 {\n        return \"Good\"\n    } else if score >= 60 {\n        return \"Needs Improvement\"\n    } else {\n        return \"Failing\"\n    }\n}\n\nfunc findStudentsInRange(scores: [Int], minScore: Int, maxScore: Int) -> [Int] {\n    var results: [Int] = []\n    \n    for score in scores {\n        if score >= minScore && score <= maxScore {\n            results.append(score)\n        }\n    }\n    \n    return results\n}\n\nprint(\"\\n=== PERFORMANCE CATEGORIZATION ===\")\nfor score in studentScores {\n    let category = categorizePerformance(score: score)\n    let grade = calculateLetterGrade(score: score)\n    print(\"Score \\(score): \\(grade) - \\(category)\")\n}\n\nlet midRangeScores = findStudentsInRange(scores: studentScores, minScore: 70, maxScore: 85)\nprint(\"\\nScores between 70-85: \\(midRangeScores)\")\n\n// === BONUS: Menu System ===\nfunc displayMenu() {\n    print(\"\"\"\n    \\n=== GRADEBOOK MENU ===\n    1. View All Scores\n    2. Calculate Average\n    3. Grade Distribution\n    4. Find Students in Range\n    5. Exit\n    \"\"\")\n}\n\nvar menuRunning = true\n\nwhile menuRunning {\n    displayMenu()\n    let userChoice = 5 // Simulated user input - would be input in real app\n    \n    switch userChoice {\n    case 1:\n        print(\"All Scores: \\(studentScores)\")\n    case 2:\n        print(\"Class Average: \\(averageScore)\")\n    case 3:\n        print(\"Grade Distribution: \\(gradeCounts)\")\n    case 4:\n        let rangeScores = findStudentsInRange(scores: studentScores, minScore: 70, maxScore: 85)\n        print(\"Scores between 70-85: \\(rangeScores)\")\n    case 5:\n        print(\"Goodbye!\")\n        menuRunning = false\n    default:\n        print(\"Invalid choice. Please try again.\")\n    }\n    \n    if userChoice != 5 {\n        // In real app, you'd have a way to continue\n        menuRunning = false // Simulate exit for this example\n    }\n}",
        "hints": [
          "PART 1: Use switch with range operators (...) for inclusive and (..<) for exclusive ranges",
          "PART 2: Use for-in loops to iterate through arrays. Remember arrays are zero-indexed",
          "PART 3: while loops are perfect for unknown iteration counts - keep going until condition met",
          "PART 4: Combine if/else with boolean logic (&&, ||) for complex conditions",
          "Use print() statements to track your progress and debug",
          "For the bonus menu, think about how real applications handle user interaction loops",
          "Remember to handle edge cases: empty arrays, invalid scores, boundary conditions"
        ],
        "testCases": [
          {
            "input": "calculateLetterGrade(score: 95)",
            "expectedOutput": "A",
            "description": "A score of 95 should return A"
          },
          {
            "input": "calculateLetterGrade(score: 82)",
            "expectedOutput": "B-",
            "description": "A score of 82 should return B-"
          },
          {
            "input": "studentScores.count",
            "expectedOutput": "15",
            "description": "Should have 15 student scores"
          }
        ]
      }
    },
    {
      "id": "functions_closures",
      "title": "Functions & Closures",
      "description": "Master function syntax, parameters, return types, and powerful closure expressions",
      "difficulty": "beginner",
      "theory": "# Functions & Closures - Reusable Code Blocks\n\n## 1. Function Fundamentals (45 min)\n\n### What are Functions?\nFunctions are self-contained chunks of code that perform a specific task. They help you:\n- **Avoid repetition**: Write once, use many times\n- **Organize code**: Break complex problems into smaller pieces\n- **Improve readability**: Give names to operations\n\n### Basic Function Syntax:\n```swift\nfunc functionName(parameters) -> ReturnType {\n    // code\n    return value\n}\n```\n\n## 2. Function Parameters (60 min)\n\n### Parameters vs Arguments:\n- **Parameters**: Variables in function declaration\n- **Arguments**: Actual values passed to function\n\n### Parameter Types:\n\n**Default Parameters:**\n```swift\nfunc greet(name: String, withGreeting: String = \"Hello\") {\n    print(\"\\(withGreeting), \\(name)!\")\n}\ngreet(name: \"Alice\")           // \"Hello, Alice!\"\ngreet(name: \"Bob\", withGreeting: \"Hi\") // \"Hi, Bob!\"\n```\n\n**Variadic Parameters:**\n```swift\nfunc average(_ numbers: Double...) -> Double {\n    let total = numbers.reduce(0, +)\n    return total / Double(numbers.count)\n}\naverage(1, 2, 3, 4, 5)  // 3.0\n```\n\n**In-Out Parameters:**\n```swift\nfunc swapValues(_ a: inout Int, _ b: inout Int) {\n    let temp = a\n    a = b\n    b = temp\n}\nvar x = 5, y = 10\nswapValues(&x, &y)  // x = 10, y = 5\n```\n\n## 3. Return Types & Multiple Returns (45 min)\n\n### Returning Multiple Values:\n```swift\nfunc calculateStatistics(scores: [Int]) -> (min: Int, max: Int, sum: Int) {\n    let min = scores.min() ?? 0\n    let max = scores.max() ?? 0\n    let sum = scores.reduce(0, +)\n    return (min, max, sum)\n}\nlet stats = calculateStatistics(scores: [5, 3, 100, 3, 9])\nprint(stats.min)  // 3\nprint(stats.max)  // 100\nprint(stats.sum)  // 120\n```\n\n### Optional Return Types:\n```swift\nfunc findFirstEven(in numbers: [Int]) -> Int? {\n    return numbers.first { $0 % 2 == 0 }\n}\n```\n\n## 4. Function Types & Higher-Order Functions (45 min)\n\n### Function Types:\nEvery function has a specific type made up of parameter types and return type:\n```swift\nfunc add(_ a: Int, _ b: Int) -> Int { return a + b }\n// Type: (Int, Int) -> Int\n\nfunc printNumber(_ number: Int) { print(number) }\n// Type: (Int) -> Void\n```\n\n### Functions as Parameters:\n```swift\nfunc applyOperation(_ a: Int, _ b: Int, operation: (Int, Int) -> Int) -> Int {\n    return operation(a, b)\n}\n\nlet result = applyOperation(5, 3, operation: add)  // 8\n```\n\n## 5. Closures Introduction (45 min)\n\n### What are Closures?\nClosures are self-contained blocks of functionality that can be passed around and used in your code. They capture and store references to variables and constants from the context in which they're defined.\n\n### Closure Syntax:\n```swift\n{ (parameters) -> ReturnType in\n    statements\n}\n```\n\n### Closure Examples:\n```swift\n// As a variable\nlet multiply: (Int, Int) -> Int = { (a, b) in\n    return a * b\n}\n\n// Inline\nlet numbers = [1, 2, 3, 4, 5]\nlet doubled = numbers.map({ (number: Int) -> Int in\n    return number * 2\n})\n```\n\n## 6. Closure Shorthand Syntax (30 min)\n\nSwift provides several ways to write closures more concisely:\n\n### Implicit Returns:\n```swift\nlet squared = numbers.map { number in\n    number * number  // implicit return\n}\n```\n\n### Shorthand Argument Names:\n```swift\nlet doubled = numbers.map { $0 * 2 }  // $0, $1, $2...\n```\n\n### Trailing Closures:\n```swift\n// When closure is last parameter\nlet evens = numbers.filter { $0 % 2 == 0 }\n\n// Multiple trailing closures (Swift 5.3+)\nanimateView {\n    // animation code\n} completion: {\n    // completion code\n}\n```\n\n## 7. Capturing Values & Escaping Closures (30 min)\n\n### Value Capturing:\n```swift\nfunc makeIncrementer(incrementAmount: Int) -> () -> Int {\n    var total = 0\n    let incrementer: () -> Int = {\n        total += incrementAmount\n        return total\n    }\n    return incrementer\n}\n\nlet incrementByTwo = makeIncrementer(incrementAmount: 2)\nincrementByTwo()  // 2\nincrementByTwo()  // 4\nincrementByTwo()  // 6\n```\n\n### Escaping Closures:\n```swift\nvar completionHandlers: [() -> Void] = []\n\nfunc someFunctionWithEscapingClosure(completionHandler: @escaping () -> Void) {\n    completionHandlers.append(completionHandler)\n}\n```\n\n## 8. Common Closure Patterns (30 min)\n\n### Sorting with Closures:\n```swift\nlet names = [\"Chris\", \"Alex\", \"Ewa\", \"Barry\", \"Daniella\"]\nlet sortedNames = names.sorted { $0 < $1 }\n```\n\n### Network Call Completion:\n```swift\nfunc fetchData(completion: @escaping (Result<String, Error>) -> Void) {\n    DispatchQueue.global().async {\n        // Simulate network call\n        DispatchQueue.main.async {\n            completion(.success(\"Data received\"))\n        }\n    }\n}\n```\n\n## 9. Best Practices & Common Pitfalls (30 min)\n\n### Naming Conventions:\n- Use descriptive names for functions\n- Follow the \"verb-noun\" pattern: `calculateAverage`, `fetchUserData`\n- Be clear about side effects\n\n### Memory Management:\n- Use `[weak self]` or `[unowned self]` in closures to avoid retain cycles\n- Understand when to use escaping vs non-escaping closures\n\n### Error Handling in Closures:\n```swift\nfunc processData(completion: (Result<Data, Error>) -> Void) {\n    do {\n        let data = try loadData()\n        completion(.success(data))\n    } catch {\n        completion(.failure(error))\n    }\n}\n```\n\n## Practice Exercises\n\nComplete all exercises to master functions and closures!",
      "codeExample": "// === FUNCTION FUNDAMENTALS ===\n// Basic function\nfunc greet(person: String) -> String {\n    return \"Hello, \\(person)!\"\n}\n\n// Function without return value\nfunc logMessage(_ message: String) {\n    print(\"LOG: \\(message)\")\n}\n\n// === PARAMETER VARIATIONS ===\n// Default parameters\nfunc createGreeting(for name: String, withEmoji: String = \"ðŸ‘‹\") -> String {\n    return \"\\(withEmoji) Hello, \\(name)!\"\n}\n\n// Variadic parameters\nfunc calculateSum(_ numbers: Int...) -> Int {\n    return numbers.reduce(0, +)\n}\n\n// In-out parameters\nfunc doubleInPlace(_ number: inout Int) {\n    number *= 2\n}\n\n// === RETURN TYPES ===\n// Multiple return values\nfunc analyzeNumbers(_ numbers: [Int]) -> (min: Int, max: Int, average: Double) {\n    let min = numbers.min() ?? 0\n    let max = numbers.max() ?? 0\n    let average = Double(numbers.reduce(0, +)) / Double(numbers.count)\n    return (min, max, average)\n}\n\n// Optional return\nfunc findIndex(of value: Int, in array: [Int]) -> Int? {\n    return array.firstIndex(of: value)\n}\n\n// === FUNCTION TYPES ===\n// Function as type\nlet mathOperation: (Int, Int) -> Int = { $0 + $1 }\n\n// Function accepting function parameter\nfunc processNumbers(_ a: Int, _ b: Int, using operation: (Int, Int) -> Int) -> Int {\n    return operation(a, b)\n}\n\n// === CLOSURES ===\n// Basic closure syntax\nlet addClosure: (Int, Int) -> Int = { (a, b) in\n    return a + b\n}\n\n// Closure with shorthand arguments\nlet multiplyClosure = { (a: Int, b: Int) -> Int in\n    a * b\n}\n\n// === CLOSURE SHORTHAND ===\nlet numbers = [1, 2, 3, 4, 5, 6]\n\n// Using map with closures\nlet squared = numbers.map { $0 * $0 }\n\n// Using filter with closures\nlet evens = numbers.filter { $0 % 2 == 0 }\n\n// Using reduce with closures\nlet sum = numbers.reduce(0) { $0 + $1 }\n\n// Using sorted with closures\nlet descending = numbers.sorted { $0 > $1 }\n\n// === CAPTURING VALUES ===\nfunc makeCounter() -> () -> Int {\n    var count = 0\n    return {\n        count += 1\n        return count\n    }\n}\n\nlet counter = makeCounter()\n\n// === PRACTICAL EXAMPLES ===\n// Network simulation with escaping closure\nfunc simulateNetworkCall(delay: Double, completion: @escaping (Result<String, Error>) -> Void) {\n    DispatchQueue.global().asyncAfter(deadline: .now() + delay) {\n        let success = Bool.random()\n        if success {\n            completion(.success(\"Data fetched successfully\"))\n        } else {\n            completion(.failure(NSError(domain: \"NetworkError\", code: 1)))\n        }\n    }\n}\n\n// Data processing pipeline\nfunc processUserData(names: [String], \n                    filter: (String) -> Bool,\n                    transform: (String) -> String,\n                    completion: ([String]) -> Void) {\n    \n    let filteredNames = names.filter(filter)\n    let transformedNames = filteredNames.map(transform)\n    completion(transformedNames)\n}\n\n// === REAL-WORLD USAGE ===\n// Button tap handler simulation\ntypealias ButtonTapHandler = (UIButton) -> Void\n\nfunc createButton(tapHandler: @escaping ButtonTapHandler) {\n    // In real app, this would create a UIButton\n    print(\"Button created with tap handler\")\n    // Simulate button tap\n    tapHandler(UIButton())  // Using UIButton for demonstration\n}\n\n// Animation completion\nfunc animateView(completion: @escaping () -> Void) {\n    DispatchQueue.main.asyncAfter(deadline: .now() + 1.0) {\n        completion()\n    }\n}",
      "category": "Swift Basics",
      "estimatedTime": 240,
      "dependencies": ["variables", "optionals", "control_flow"],
      "challenge": {
        "instructions": "Create a comprehensive data processing system using functions and closures:\n\nPART 1: Basic Functions (45 min)\n1. Create a function 'calculate' that takes two numbers and an operation closure, returns the result\n2. Create a function 'formatCurrency' that takes a Double and returns a formatted String\n3. Create a function 'validateEmail' that takes a String and returns a Bool\n\nPART 2: Advanced Parameters (45 min)\n4. Create a function 'processNumbers' with variadic Int parameters that returns statistics\n5. Create a function 'updateScore' with inout parameter that modifies a score variable\n6. Create a function 'createGreeting' with default parameters for greeting type\n\nPART 3: Closure Implementation (60 min)\n7. Create a closure that filters an array based on a custom condition\n8. Create a closure that transforms an array of strings to uppercase\n9. Create a closure that sorts an array in a custom order\n\nPART 4: Higher-Order Functions (45 min)\n10. Create a function 'applyToAll' that applies a closure to each element in an array\n11. Create a function 'customFilter' that implements filter functionality using closures\n12. Create a function 'chainOperations' that chains multiple closure operations\n\nPART 5: Real-World Scenario (45 min)\n13. Create a data processing pipeline that filters, transforms, and sorts user data\n14. Implement a retry mechanism with escaping closures for network calls\n15. Create a calculator with operation closures stored in a dictionary",
        "starterCode": "// === PART 1: Basic Functions ===\n// Create your basic functions here\n\n\n// === PART 2: Advanced Parameters ===\n// Create functions with advanced parameters here\n\n\n// === PART 3: Closure Implementation ===\n// Create and use closures here\n\n\n// === PART 4: Higher-Order Functions ===\n// Create higher-order functions here\n\n\n// === PART 5: Real-World Scenario ===\n// Implement real-world scenarios here\n\n",
        "solution": "// === PART 1: Basic Functions ===\nfunc calculate(_ a: Double, _ b: Double, operation: (Double, Double) -> Double) -> Double {\n    return operation(a, b)\n}\n\nfunc formatCurrency(_ amount: Double) -> String {\n    return String(format: \"$%.2f\", amount)\n}\n\nfunc validateEmail(_ email: String) -> Bool {\n    let emailRegex = \"[A-Z0-9a-z._%+-]+@[A-Za-z0-9.-]+\\\\.[A-Za-z]{2,}\"\n    return NSPredicate(format: \"SELF MATCHES %@\", emailRegex).evaluate(with: email)\n}\n\n// === PART 2: Advanced Parameters ===\nfunc processNumbers(_ numbers: Int...) -> (sum: Int, average: Double, count: Int) {\n    let sum = numbers.reduce(0, +)\n    let average = Double(sum) / Double(numbers.count)\n    return (sum, average, numbers.count)\n}\n\nfunc updateScore(_ score: inout Int, by points: Int) {\n    score += points\n    if score < 0 { score = 0 }\n}\n\nfunc createGreeting(for name: String, \n                   greeting: String = \"Hello\", \n                   includeEmoji: Bool = true) -> String {\n    let emoji = includeEmoji ? \"ðŸ‘‹\" : \"\"\n    return \"\\(emoji) \\(greeting), \\(name)!\"\n}\n\n// === PART 3: Closure Implementation ===\nlet isEven: (Int) -> Bool = { $0 % 2 == 0 }\nlet toUpperCase: (String) -> String = { $0.uppercased() }\nlet sortDescending: (Int, Int) -> Bool = { $0 > $1 }\n\nlet numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\nlet evenNumbers = numbers.filter(isEven)\nlet names = [\"alice\", \"bob\", \"charlie\"]\nlet upperNames = names.map(toUpperCase)\nlet sortedNumbers = numbers.sorted(by: sortDescending)\n\n// === PART 4: Higher-Order Functions ===\nfunc applyToAll<T>(_ array: [T], transform: (T) -> T) -> [T] {\n    return array.map(transform)\n}\n\nfunc customFilter<T>(_ array: [T], isIncluded: (T) -> Bool) -> [T] {\n    var result: [T] = []\n    for element in array {\n        if isIncluded(element) {\n            result.append(element)\n        }\n    }\n    return result\n}\n\nfunc chainOperations<T>(_ array: [T], \n                       operations: [( [T]) -> [T]]) -> [T] {\n    var result = array\n    for operation in operations {\n        result = operation(result)\n    }\n    return result\n}\n\n// === PART 5: Real-World Scenario ===\n// Data processing pipeline\ntypealias User = (name: String, age: Int, email: String)\n\nfunc processUsers(_ users: [User], \n                 filter: (User) -> Bool,\n                 transform: (User) -> String,\n                 sort: (String, String) -> Bool,\n                 completion: ([String]) -> Void) {\n    \n    let filteredUsers = users.filter(filter)\n    let transformedUsers = filteredUsers.map(transform)\n    let sortedUsers = transformedUsers.sorted(by: sort)\n    completion(sortedUsers)\n}\n\n// Retry mechanism\nfunc fetchWithRetry(attempts: Int, \n                   operation: @escaping (@escaping (Result<String, Error>) -> Void) -> Void,\n                   completion: @escaping (Result<String, Error>) -> Void) {\n    \n    var currentAttempt = 0\n    \n    func attempt() {\n        currentAttempt += 1\n        operation { result in\n            switch result {\n            case .success(let data):\n                completion(.success(data))\n            case .failure(let error):\n                if currentAttempt < attempts {\n                    print(\"Attempt \\(currentAttempt) failed, retrying...\")\n                    attempt()\n                } else {\n                    completion(.failure(error))\n                }\n            }\n        }\n    }\n    \n    attempt()\n}\n\n// Calculator with operation dictionary\nlet operations: [String: (Double, Double) -> Double] = [\n    \"add\": { $0 + $1 },\n    \"subtract\": { $0 - $1 },\n    \"multiply\": { $0 * $1 },\n    \"divide\": { $0 / $1 }\n]\n\nfunc performOperation(_ operation: String, _ a: Double, _ b: Double) -> Double? {\n    return operations[operation]?(a, b)\n}",
        "hints": [
          "PART 1: Remember function syntax: func name(parameters) -> ReturnType { }",
          "PART 2: Use '...' for variadic parameters, 'inout' for modifiable parameters",
          "PART 3: Closure syntax: { (parameters) -> ReturnType in statements }",
          "PART 4: Higher-order functions take functions/closures as parameters",
          "PART 5: Use @escaping for closures that are called after function returns",
          "For email validation, you can use a simple contains(\"@\") check instead of regex",
          "Use type aliases to make complex closure types more readable",
          "Remember to handle edge cases like division by zero"
        ],
        "testCases": [
          {
            "input": "calculate(10, 5, operation: { $0 + $1 }) == 15",
            "expectedOutput": "true",
            "description": "Calculate function should perform addition correctly"
          },
          {
            "input": "validateEmail(\"test@example.com\")",
            "expectedOutput": "true",
            "description": "Email validation should accept valid emails"
          },
          {
            "input": "evenNumbers.count == 5",
            "expectedOutput": "true",
            "description": "Should filter even numbers correctly"
          }
        ]
      }
    },
    {
      "id": "collections",
      "title": "Collections",
      "description": "Master Arrays, Dictionaries, and Sets - the essential data structures for organizing data in Swift",
      "difficulty": "beginner",
      "theory": "# Collections - Organizing Data in Swift\n\n## 1. Arrays: Ordered Collections (1 hour)\n\n### What are Arrays?\nArrays store ordered collections of values of the same type. They maintain the order of elements and allow duplicate values.\n\n### Array Basics:\n```swift\n// Creating arrays\nvar emptyArray: [Int] = []\nvar numbers = [1, 2, 3, 4, 5]\nvar names = [\"Alice\", \"Bob\", \"Charlie\"]\n\n// Array with repeated values\nvar repeated = Array(repeating: 0, count: 5) // [0, 0, 0, 0, 0]\n```\n\n### Array Operations:\n- **Access**: `array[0]`, `array.first`, `array.last`\n- **Count**: `array.count`, `array.isEmpty`\n- **Modification**: `append()`, `insert()`, `remove()`, `removeAll()`\n\n### Array Properties and Methods:\n```swift\nvar fruits = [\"Apple\", \"Banana\", \"Orange\"]\n\n// Properties\nprint(fruits.count)      // 3\nprint(fruits.isEmpty)    // false\nprint(fruits.first)      // Optional(\"Apple\")\nprint(fruits.last)       // Optional(\"Orange\")\n\n// Adding elements\nfruits.append(\"Grape\")           // [\"Apple\", \"Banana\", \"Orange\", \"Grape\"]\nfruits.insert(\"Mango\", at: 1)   // [\"Apple\", \"Mango\", \"Banana\", \"Orange\", \"Grape\"]\n\n// Removing elements\nfruits.remove(at: 2)     // Removes \"Banana\"\nfruits.removeFirst()     // Removes \"Apple\"\nfruits.removeLast()      // Removes \"Grape\"\n```\n\n## 2. Array Iteration and Transformation (45 minutes)\n\n### Looping Through Arrays:\n```swift\nlet scores = [85, 92, 78, 90, 88]\n\n// For-in loop\nfor score in scores {\n    print(\"Score: \\(score)\")\n}\n\n// Enumerated loop (with index)\nfor (index, score) in scores.enumerated() {\n    print(\"Score at index \\(index): \\(score)\")\n}\n\n// While loop\nvar i = 0\nwhile i < scores.count {\n    print(scores[i])\n    i += 1\n}\n```\n\n### Array Transformation Methods:\n```swift\nlet numbers = [1, 2, 3, 4, 5]\n\n// map - transform each element\nlet squared = numbers.map { $0 * $0 } // [1, 4, 9, 16, 25]\n\n// filter - select elements that meet condition\nlet evenNumbers = numbers.filter { $0 % 2 == 0 } // [2, 4]\n\n// reduce - combine all elements\nlet sum = numbers.reduce(0, +) // 15\n\n// sorted - sort elements\nlet sortedNumbers = numbers.sorted(by: >) // [5, 4, 3, 2, 1]\n```\n\n## 3. Dictionaries: Key-Value Collections (1 hour)\n\n### What are Dictionaries?\nDictionaries store unordered collections of key-value pairs. Each value is associated with a unique key.\n\n### Dictionary Basics:\n```swift\n// Creating dictionaries\nvar emptyDict: [String: Int] = [:]\nvar ages = [\"Alice\": 25, \"Bob\": 30, \"Charlie\": 35]\nvar studentScores = [\"Math\": 95, \"Science\": 88, \"History\": 92]\n\n// Accessing values\nlet aliceAge = ages[\"Alice\"] // Optional(25)\nlet unknownAge = ages[\"David\"] // nil\n\n// Adding and updating\nages[\"David\"] = 28        // Add new entry\nages[\"Alice\"] = 26        // Update existing entry\n```\n\n### Dictionary Operations:\n```swift\nvar inventory = [\"apples\": 10, \"oranges\": 5, \"bananas\": 8]\n\n// Properties\nprint(inventory.count)        // 3\nprint(inventory.isEmpty)      // false\nprint(inventory.keys)         // [\"apples\", \"oranges\", \"bananas\"]\nprint(inventory.values)       // [10, 5, 8]\n\n// Safe access with default values\nlet appleCount = inventory[\"apples\", default: 0]\nlet mangoCount = inventory[\"mangoes\", default: 0]\n\n// Removing values\ninventory[\"oranges\"] = nil   // Remove oranges\ninventory.removeAll()         // Remove all items\n```\n\n## 4. Dictionary Iteration and Methods (45 minutes)\n\n### Looping Through Dictionaries:\n```swift\nlet capitals = [\"France\": \"Paris\", \"Japan\": \"Tokyo\", \"Brazil\": \"BrasÃ­lia\"]\n\n// Loop through key-value pairs\nfor (country, capital) in capitals {\n    print(\"\\(country)'s capital is \\(capital)\")\n}\n\n// Loop through keys only\nfor country in capitals.keys {\n    print(\"Country: \\(country)\")\n}\n\n// Loop through values only\nfor capital in capitals.values {\n    print(\"Capital: \\(capital)\")\n}\n```\n\n### Dictionary Transformation:\n```swift\nlet prices = [\"apple\": 1.99, \"banana\": 0.99, \"orange\": 2.49]\n\n// mapValues - transform values only\nlet salePrices = prices.mapValues { $0 * 0.8 } // 20% off\n\n// filter - keep only certain entries\nlet expensiveItems = prices.filter { $0.value > 2.0 }\n\n// map - transform entire dictionary\nlet priceDescriptions = prices.map { (item, price) in\n    return \"\\(item): $\\(price)\"\n}\n```\n\n## 5. Sets: Unique Collections (30 minutes)\n\n### What are Sets?\nSets store unordered collections of unique values of the same type. They don't allow duplicates.\n\n### Set Basics:\n```swift\n// Creating sets\nvar emptySet: Set<String> = []\nvar favoriteGenres: Set = [\"Rock\", \"Classical\", \"Jazz\"]\nvar primeNumbers: Set = [2, 3, 5, 7, 11]\n\n// Set properties\nprint(favoriteGenres.count)   // 3\nprint(favoriteGenres.isEmpty) // false\n\n// Adding and removing\nfavoriteGenres.insert(\"Hip hop\")  // Add new element\nfavoriteGenres.remove(\"Jazz\")     // Remove element\n```\n\n### Set Operations:\n```swift\nlet oddNumbers: Set = [1, 3, 5, 7, 9]\nlet evenNumbers: Set = [2, 4, 6, 8, 10]\nlet primeNumbers: Set = [2, 3, 5, 7]\n\n// Union - combine sets\nlet allNumbers = oddNumbers.union(evenNumbers) // [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\n// Intersection - common elements\nlet oddPrimes = oddNumbers.intersection(primeNumbers) // [3, 5, 7]\n\n// Subtraction - elements in first but not second\nlet nonPrimeOdds = oddNumbers.subtracting(primeNumbers) // [1, 9]\n\n// Symmetric difference - elements in either but not both\nlet uniqueToEach = oddNumbers.symmetricDifference(primeNumbers) // [1, 2, 9]\n```\n\n## 6. Choosing the Right Collection (30 minutes)\n\n### When to Use Each Collection:\n\n**Use Arrays when:**\n- Order matters\n- You need duplicates\n- You'll access elements by index\n- Example: To-do list, playlist\n\n**Use Dictionaries when:**\n- You need key-value pairs\n- Fast lookup by key is important\n- Order doesn't matter\n- Example: User profiles, settings\n\n**Use Sets when:**\n- Uniqueness is required\n- Order doesn't matter\n- You need set operations (union, intersection)\n- Example: Tags, unique categories\n\n### Performance Characteristics:\n- **Arrays**: Fast index access, slow insertion in middle\n- **Dictionaries**: Fast key lookup, no guaranteed order\n- **Sets**: Fast membership testing, unique values only\n\n## Practice Exercises\n\nComplete all exercises to master collection types and their practical applications!",
      "codeExample": "// === ARRAYS ===\n// Creating and manipulating arrays\nvar shoppingList = [\"Milk\", \"Eggs\", \"Bread\"]\nvar numbers = [1, 2, 3, 4, 5]\n\n// Array operations\nprint(\"First item: \\(shoppingList[0])\")           // Milk\nprint(\"Array count: \\(shoppingList.count)\")       // 3\n\n// Adding elements\nshoppingList.append(\"Butter\")\nshoppingList.insert(\"Cheese\", at: 1)\n\n// Removing elements\nlet removedItem = shoppingList.remove(at: 2)\nshoppingList.removeLast()\n\n// Array transformation\nlet doubledNumbers = numbers.map { $0 * 2 }        // [2, 4, 6, 8, 10]\nlet evenNumbers = numbers.filter { $0 % 2 == 0 }   // [2, 4]\nlet sum = numbers.reduce(0, +)                     // 15\n\n// Sorting\nlet sortedNumbers = numbers.sorted(by: >)          // [5, 4, 3, 2, 1]\n\n// === DICTIONARIES ===\n// Creating dictionaries\nvar studentGrades = [\"Alice\": 95, \"Bob\": 87, \"Charlie\": 92]\nvar countryCapitals = [\"USA\": \"Washington D.C.\", \"UK\": \"London\", \"Japan\": \"Tokyo\"]\n\n// Dictionary operations\nprint(\"Alice's grade: \\(studentGrades[\"Alice\"] ?? 0)\") // 95\nprint(\"Dictionary keys: \\(studentGrades.keys)\")        // [\"Alice\", \"Bob\", \"Charlie\"]\n\n// Adding and updating\nstudentGrades[\"David\"] = 88\nstudentGrades[\"Alice\"] = 96\n\n// Safe access with default\nlet eveGrade = studentGrades[\"Eve\", default: 0]\n\n// Dictionary transformation\nlet gradeDescriptions = studentGrades.map { (name, grade) in\n    return \"\\(name): \\(grade)%\"\n}\n\nlet highAchievers = studentGrades.filter { $0.value >= 90 }\n\n// === SETS ===\n// Creating sets\nvar favoriteColors: Set = [\"Red\", \"Blue\", \"Green\"]\nvar visitedCountries: Set = [\"USA\", \"Canada\", \"Mexico\", \"Japan\"]\n\n// Set operations\nfavoriteColors.insert(\"Purple\")\nfavoriteColors.remove(\"Green\")\n\n// Set operations with multiple sets\nlet warmColors: Set = [\"Red\", \"Orange\", \"Yellow\"]\nlet coolColors: Set = [\"Blue\", \"Green\", \"Purple\"]\n\nlet allColors = warmColors.union(coolColors)\nlet warmAndFavorite = warmColors.intersection(favoriteColors)\nlet onlyWarm = warmColors.subtracting(favoriteColors)\n\n// === PRACTICAL EXAMPLES ===\n// Game inventory system\nstruct GameCharacter {\n    var name: String\n    var level: Int\n    var inventory: [String: Int]  // item: quantity\n    var skills: Set<String>\n}\n\nvar player = GameCharacter(\n    name: \"Hero\",\n    level: 5,\n    inventory: [\"Health Potion\": 3, \"Mana Potion\": 5, \"Gold\": 100],\n    skills: [\"Attack\", \"Defend\", \"Heal\"]\n)\n\n// Array of characters\nvar partyMembers = [\n    GameCharacter(name: \"Warrior\", level: 6, inventory: [\"Sword\": 1, \"Shield\": 1], skills: [\"Attack\", \"Defend\"]),\n    GameCharacter(name: \"Mage\", level: 5, inventory: [\"Staff\": 1, \"Mana Potion\": 10], skills: [\"Fireball\", \"Heal\"]),\n    GameCharacter(name: \"Archer\", level: 4, inventory: [\"Bow\": 1, \"Arrows\": 50], skills: [\"Attack\", \"Stealth\"])\n]\n\n// Working with collections\nlet partyLevels = partyMembers.map { $0.level }\nlet averageLevel = Double(partyLevels.reduce(0, +)) / Double(partyLevels.count)\n\nlet allSkills = partyMembers.reduce(Set<String>()) { result, character in\n    return result.union(character.skills)\n}\n\n// Dictionary of party resources\nvar partyInventory: [String: Int] = [:]\nfor member in partyMembers {\n    for (item, quantity) in member.inventory {\n        partyInventory[item, default: 0] += quantity\n    }\n}",
      "category": "Swift Basics",
      "estimatedTime": 240,
      "dependencies": ["variables"],
      "challenge": {
        "instructions": "Create a complete game inventory management system:\n\nPART 1: Array Operations (45 min)\n1. Create an array of player names: [\"Warrior\", \"Mage\", \"Archer\", \"Healer\"]\n2. Add two new players to the party\n3. Remove the player at index 1\n4. Create an array of player levels and calculate average level\n5. Filter players above level 5\n\nPART 2: Dictionary Operations (45 min)\n6. Create a dictionary mapping player names to their classes\n7. Create an inventory dictionary with items and quantities\n8. Add new items to inventory with safe default values\n9. Create a function to use items from inventory\n10. Calculate total value of inventory (each item has different values)\n\nPART 3: Set Operations (30 min)\n11. Create sets of skills for each character class\n12. Find common skills between Warrior and Mage\n13. Create a set of all unique skills in the party\n14. Find skills that only one class has\n\nPART 4: Combined Operations (1 hour)\n15. Create a Player struct with name, level, inventory, and skills\n16. Create an array of Player objects\n17. Write a function to find players who can use a specific skill\n18. Create a trading system between players\n19. Calculate party statistics (total items, unique skills, average level)\n\nPART 5: Advanced Challenges (1 hour)\n20. Implement item crafting system using multiple ingredients\n21. Create skill tree progression using sets\n22. Build party formation optimizer using collection operations\n23. Implement save/load system using collection transformations",
        "starterCode": "// === PART 1: Array Operations ===\n// Create and manipulate arrays here\n\n\n// === PART 2: Dictionary Operations ===\n// Create and manipulate dictionaries here\n\n\n// === PART 3: Set Operations ===\n// Create and manipulate sets here\n\n\n// === PART 4: Combined Operations ===\n// Create Player struct and combined operations here\n\n\n// === PART 5: Advanced Challenges ===\n// Implement advanced systems here\n\n",
        "solution": "// === PART 1: Array Operations ===\nvar playerNames = [\"Warrior\", \"Mage\", \"Archer\", \"Healer\"]\n\n// Add new players\nplayerNames.append(\"Rogue\")\nplayerNames.append(\"Paladin\")\n\n// Remove player at index 1\nlet removedPlayer = playerNames.remove(at: 1)\n\n// Player levels and average\nlet playerLevels = [6, 8, 5, 7, 4]\nlet totalLevel = playerLevels.reduce(0, +)\nlet averageLevel = Double(totalLevel) / Double(playerLevels.count)\n\n// Filter high-level players\nlet highLevelPlayers = playerLevels.filter { $0 > 5 }\n\n// === PART 2: Dictionary Operations ===\nvar playerClasses = [\n    \"Warrior\": \"Fighter\",\n    \"Mage\": \"Spellcaster\", \n    \"Archer\": \"Ranger\",\n    \"Healer\": \"Support\"\n]\n\n// Add new player classes\nplayerClasses[\"Rogue\"] = \"Stealth\"\nplayerClasses[\"Paladin\"] = \"Holy Warrior\"\n\n// Inventory system\nvar inventory = [\n    \"Health Potion\": 5,\n    \"Mana Potion\": 3,\n    \"Gold\": 250,\n    \"Arrows\": 20\n]\n\n// Safe item access\nlet healthPotionCount = inventory[\"Health Potion\", default: 0]\nlet unknownItemCount = inventory[\"Unknown Item\", default: 0]\n\n// Use item function\nfunc useItem(_ item: String, quantity: Int = 1) -> Bool {\n    guard let currentQuantity = inventory[item], currentQuantity >= quantity else {\n        print(\"Not enough \\(item)\")\n        return false\n    }\n    inventory[item] = currentQuantity - quantity\n    print(\"Used \\(quantity) \\(item)\")\n    return true\n}\n\n// Item values and total worth\nlet itemValues = [\"Health Potion\": 10, \"Mana Potion\": 15, \"Gold\": 1, \"Arrows\": 2]\nlet totalInventoryValue = inventory.reduce(0) { result, item in\n    let value = itemValues[item.key, default: 0] * item.value\n    return result + value\n}\n\n// === PART 3: Set Operations ===\nlet warriorSkills: Set = [\"Attack\", \"Defend\", \"Bash\"]\nlet mageSkills: Set = [\"Fireball\", \"Heal\", \"Teleport\"]\nlet archerSkills: Set = [\"Attack\", \"Stealth\", \"Aim\"]\nlet healerSkills: Set = [\"Heal\", \"Protect\", \"Revive\"]\n\n// Common skills between Warrior and Mage\nlet warriorMageCommon = warriorSkills.intersection(mageSkills)\n\n// All unique skills in party\nlet allSkills = warriorSkills.union(mageSkills).union(archerSkills).union(healerSkills)\n\n// Skills unique to each class\nlet warriorOnlySkills = warriorSkills.subtracting(mageSkills).subtracting(archerSkills).subtracting(healerSkills)\nlet mageOnlySkills = mageSkills.subtracting(warriorSkills).subtracting(archerSkills).subtracting(healerSkills)\n\n// === PART 4: Combined Operations ===\nstruct Player {\n    let name: String\n    var level: Int\n    var inventory: [String: Int]\n    var skills: Set<String>\n    var classType: String\n}\n\nvar players = [\n    Player(name: \"Warrior\", level: 6, inventory: [\"Sword\": 1, \"Shield\": 1, \"Health Potion\": 2], skills: warriorSkills, classType: \"Fighter\"),\n    Player(name: \"Mage\", level: 8, inventory: [\"Staff\": 1, \"Mana Potion\": 5, \"Gold\": 100], skills: mageSkills, classType: \"Spellcaster\"),\n    Player(name: \"Archer\", level: 5, inventory: [\"Bow\": 1, \"Arrows\": 30, \"Health Potion\": 1], skills: archerSkills, classType: \"Ranger\"),\n    Player(name: \"Healer\", level: 7, inventory: [\"Wand\": 1, \"Health Potion\": 4, \"Mana Potion\": 3], skills: healerSkills, classType: \"Support\")\n]\n\n// Find players with specific skill\nfunc playersWithSkill(_ skill: String) -> [Player] {\n    return players.filter { $0.skills.contains(skill) }\n}\n\n// Trading system\nfunc tradeItems(from player1: String, to player2: String, item: String, quantity: Int) -> Bool {\n    guard let fromIndex = players.firstIndex(where: { $0.name == player1 }),\n          let toIndex = players.firstIndex(where: { $0.name == player2 }),\n          let fromQuantity = players[fromIndex].inventory[item],\n          fromQuantity >= quantity else {\n        return false\n    }\n    \n    players[fromIndex].inventory[item] = fromQuantity - quantity\n    players[toIndex].inventory[item, default: 0] += quantity\n    return true\n}\n\n// Party statistics\nlet totalItems = players.reduce(0) { result, player in\n    return result + player.inventory.values.reduce(0, +)\n}\n\nlet uniquePartySkills = players.reduce(Set<String>()) { result, player in\n    return result.union(player.skills)\n}\n\nlet partyAverageLevel = Double(players.reduce(0) { $0 + $1.level }) / Double(players.count)\n\n// === PART 5: Advanced Challenges ===\n// Item crafting system\nlet craftingRecipes: [String: [String: Int]] = [\n    \"Health Potion\": [\"Herb\": 2, \"Vial\": 1],\n    \"Mana Potion\": [\"Mana Herb\": 3, \"Vial\": 1],\n    \"Arrows\": [\"Wood\": 1, \"Metal\": 1]\n]\n\nfunc canCraft(item: String, with inventory: [String: Int]) -> Bool {\n    guard let recipe = craftingRecipes[item] else { return false }\n    \n    for (ingredient, needed) in recipe {\n        guard let available = inventory[ingredient], available >= needed else {\n            return false\n        }\n    }\n    return true\n}\n\n// Skill tree progression\nvar skillTrees: [String: Set<String>] = [\n    \"Basic\": [\"Attack\", \"Defend\"],\n    \"Warrior\": [\"Bash\", \"Charge\"],\n    \"Mage\": [\"Fireball\", \"Ice Bolt\"],\n    \"Advanced\": [\"Ultimate\", \"Combo\"]\n]\n\nfunc availableSkills(for player: Player) -> Set<String> {\n    var available: Set<String> = skillTrees[\"Basic\"] ?? []\n    \n    if let classSkills = skillTrees[player.classType] {\n        available = available.union(classSkills)\n    }\n    \n    if player.level >= 10 {\n        available = available.union(skillTrees[\"Advanced\"] ?? [])\n    }\n    \n    return available.subtracting(player.skills)\n}\n\n// Party formation optimizer\nfunc optimizeParty(for missionType: String) -> [Player] {\n    let requiredSkills: Set<String>\n    \n    switch missionType {\n    case \"Combat\":\n        requiredSkills = [\"Attack\", \"Defend\"]\n    case \"Stealth\":\n        requiredSkills = [\"Stealth\", \"Aim\"]\n    case \"Healing\":\n        requiredSkills = [\"Heal\", \"Protect\"]\n    default:\n        requiredSkills = []\n    }\n    \n    return players.filter { player in\n        !requiredSkills.isDisjoint(with: player.skills)\n    }.sorted { $0.level > $1.level }\n}\n\n// Save/load system simulation\nfunc savePartyData() -> [String: Any] {\n    let playerData = players.map { player in\n        return [\n            \"name\": player.name,\n            \"level\": player.level,\n            \"inventory\": player.inventory,\n            \"skills\": Array(player.skills),\n            \"class\": player.classType\n        ]\n    }\n    \n    return [\n        \"players\": playerData,\n        \"totalPlayers\": players.count,\n        \"averageLevel\": partyAverageLevel,\n        \"uniqueSkills\": uniquePartySkills.count\n    ]\n}",
        "hints": [
          "PART 1: Use append() to add elements, remove(at:) to remove, reduce() for sums, filter() for conditions",
          "PART 2: Use dictionary[key] = value to add/update, dictionary[key, default: 0] for safe access",
          "PART 3: Sets use intersection(), union(), subtracting() for mathematical operations",
          "PART 4: Create a Player struct with properties, then use filter() and reduce() on arrays of players",
          "PART 5: Use nested dictionaries for crafting recipes, sets for skill trees, and complex filtering for optimization",
          "Remember that sets automatically handle uniqueness - no duplicates allowed",
          "Use enumerated() when you need both index and value in loops",
          "mapValues() is great for transforming dictionary values without changing keys",
          "reduce() can start with different initial values (0 for sum, [] for arrays, [:]) for dictionaries"
        ],
        "testCases": [
          {
            "input": "playerNames.count == 5",
            "expectedOutput": "true",
            "description": "Should have 5 players after additions and removals"
          },
          {
            "input": "inventory[\"Health Potion\", default: 0] > 0",
            "expectedOutput": "true",
            "description": "Health potions should be available in inventory"
          },
          {
            "input": "allSkills.contains(\"Heal\")",
            "expectedOutput": "true",
            "description": "Heal skill should be in the complete skill set"
          }
        ]
      }
    },
    {
      "id": "structs_classes",
      "title": "Structs & Classes",
      "description": "Master value types vs reference types - the foundation of Swift's data modeling",
      "difficulty": "beginner",
      "theory": "# Structs & Classes - Value vs Reference Types\n\n## 1. Understanding the Fundamental Difference (45 min)\n\n### Value Types (Structs)\n- **Copied** when assigned or passed\n- Each instance has **independent** data\n- Changes don't affect other instances\n- **Stack-allocated** (usually)\n\n### Reference Types (Classes)\n- **Shared** when assigned or passed  \n- Multiple references point to **same** instance\n- Changes affect all references\n- **Heap-allocated** with reference counting\n\n### Real-world Analogy:\n- **Value Type**: Like a PDF file - each copy is independent\n- **Reference Type**: Like a Google Doc - everyone sees the same document\n\n## 2. Structs in Depth (60 min)\n\n### Basic Struct Syntax:\n```swift\nstruct Point {\n    var x: Double\n    var y: Double\n}\n```\n\n### Memberwise Initializer:\nStructs get a free initializer:\n```swift\nlet point = Point(x: 10.0, y: 20.0)\n```\n\n### Methods in Structs:\n```swift\nstruct Point {\n    var x: Double\n    var y: Double\n    \n    func distance(to other: Point) -> Double {\n        let deltaX = x - other.x\n        let deltaY = y - other.y\n        return sqrt(deltaX * deltaX + deltaY * deltaY)\n    }\n    \n    mutating func moveBy(x deltaX: Double, y deltaY: Double) {\n        x += deltaX\n        y += deltaY\n    }\n}\n```\n\n### Computed Properties:\n```swift\nstruct Rectangle {\n    var width: Double\n    var height: Double\n    \n    var area: Double {\n        return width * height\n    }\n    \n    var perimeter: Double {\n        return 2 * (width + height)\n    }\n}\n```\n\n## 3. Classes in Depth (60 min)\n\n### Basic Class Syntax:\n```swift\nclass Person {\n    var name: String\n    var age: Int\n    \n    init(name: String, age: Int) {\n        self.name = name\n        self.age = age\n    }\n}\n```\n\n### Inheritance:\n```swift\nclass Vehicle {\n    var speed: Double = 0.0\n    \n    func makeSound() {\n        print(\"Some vehicle sound\")\n    }\n}\n\nclass Car: Vehicle {\n    var gear: Int = 1\n    \n    override func makeSound() {\n        print(\"Vroom vroom!\")\n    }\n}\n```\n\n### Reference Semantics Demonstration:\n```swift\nclass Student {\n    var name: String\n    var grade: Int\n    \n    init(name: String, grade: Int) {\n        self.name = name\n        self.grade = grade\n    }\n}\n\nlet student1 = Student(name: \"Alice\", grade: 85)\nlet student2 = student1  // Both reference SAME object\nstudent2.grade = 90\nprint(student1.grade) // 90 - both changed!\n```\n\n## 4. When to Use Each (45 min)\n\n### Use Structs For:\n- Simple data values (Point, Size, Color)\n- Data that should be copied, not shared\n- Immutable data patterns\n- When you want value semantics\n\n### Use Classes For:\n- Objects with identity (User, DatabaseConnection)\n- When you need inheritance\n- When shared mutability is desired\n- Reference semantics needed\n\n### Swift Standard Library Examples:\n- **Structs**: Int, String, Array, Dictionary, Set\n- **Classes**: NSObject subclasses, UIView (UIKit)\n\n## 5. Advanced Concepts (45 min)\n\n### Identity Operators (=== and !==):\n```swift\nclass Animal {\n    var name: String\n    init(name: String) { self.name = name }\n}\n\nlet cat1 = Animal(name: \"Whiskers\")\nlet cat2 = cat1\nlet cat3 = Animal(name: \"Whiskers\")\n\nprint(cat1 === cat2) // true - same instance\nprint(cat1 === cat3) // false - different instances\nprint(cat1.name == cat3.name) // true - same values\n```\n\n### Copy-on-Write Optimization:\nSwift uses copy-on-write for large structs:\n```swift\nvar array1 = [1, 2, 3]\nvar array2 = array1  // No copy yet - shared storage\narray2.append(4)     // Now a copy is made\n```\n\n### Deinitializers (Classes Only):\n```swift\nclass FileHandler {\n    let filename: String\n    \n    init(filename: String) {\n        self.filename = filename\n        print(\"Opening file: \\(filename)\")\n    }\n    \n    deinit {\n        print(\"Closing file: \\(filename)\")\n    }\n}\n```\n\n## 6. Practical Patterns & Best Practices (45 min)\n\n### Model Data with Structs:\n```swift\nstruct User {\n    let id: UUID\n    var username: String\n    var email: String\n    var createdAt: Date\n    \n    var displayName: String {\n        return \"@\\(username)\"\n    }\n}\n```\n\n### Reference Types for Shared Resources:\n```swift\nclass GameManager {\n    static let shared = GameManager()\n    private init() {}\n    \n    var currentScore = 0\n    var highScore = 0\n    \n    func updateScore(_ points: Int) {\n        currentScore += points\n        if currentScore > highScore {\n            highScore = currentScore\n        }\n    }\n}\n```\n\n### Choosing Between Value and Reference:\n- **Ask**: \"If I make a copy, should it be independent?\" â†’ Struct\n- **Ask**: \"Do multiple parts need to share the same instance?\" â†’ Class\n- **Default to structs** unless you need specific class features\n\n## Practice Exercises\n\nComplete all exercises to master value vs reference semantics!",
      "codeExample": "// === STRUCT EXAMPLES ===\n\n// Basic struct with properties\nstruct Book {\n    var title: String\n    var author: String\n    var pageCount: Int\n    var isRead: Bool = false\n    \n    // Computed property\n    var description: String {\n        return \"\\\"\\(title)\\\" by \\(author) (\\(pageCount) pages)\"\n    }\n    \n    // Method\n    func isLongBook() -> Bool {\n        return pageCount > 500\n    }\n    \n    // Mutating method\n    mutating func markAsRead() {\n        isRead = true\n    }\n}\n\n// Using the struct\nvar myBook = Book(title: \"Swift Programming\", author: \"Apple\", pageCount: 350)\nprint(myBook.description) // \"Swift Programming\" by Apple (350 pages)\nmyBook.markAsRead()\n\n// Value semantics demonstration\nvar book1 = Book(title: \"Book A\", author: \"Author A\", pageCount: 100)\nvar book2 = book1  // This creates a COPY\nbook2.title = \"Book B\"\nprint(book1.title) // \"Book A\" - unchanged!\nprint(book2.title) // \"Book B\" - changed copy\n\n// === CLASS EXAMPLES ===\n\n// Basic class with inheritance\nclass Animal {\n    var name: String\n    var age: Int\n    \n    init(name: String, age: Int) {\n        self.name = name\n        self.age = age\n    }\n    \n    func makeSound() {\n        print(\"Some animal sound\")\n    }\n}\n\nclass Dog: Animal {\n    var breed: String\n    \n    init(name: String, age: Int, breed: String) {\n        self.breed = breed\n        super.init(name: name, age: age)\n    }\n    \n    override func makeSound() {\n        print(\"Woof!\")\n    }\n    \n    func bark() {\n        print(\"\\(name) the \\(breed) is barking!\")\n    }\n}\n\n// Using the class\nlet myDog = Dog(name: \"Buddy\", age: 3, breed: \"Golden Retriever\")\nmyDog.makeSound() // \"Woof!\"\nmyDog.bark()      // \"Buddy the Golden Retriever is barking!\"\n\n// Reference semantics demonstration\nlet dog1 = Dog(name: \"Max\", age: 2, breed: \"Labrador\")\nlet dog2 = dog1  // Both reference SAME object\ndog2.name = \"Charlie\"\nprint(dog1.name) // \"Charlie\" - both changed!\n\n// Identity comparison\nprint(dog1 === dog2) // true - same instance\n\n// === PRACTICAL COMPARISON ===\n\n// Struct for value semantics (good for data)\nstruct Coordinate {\n    var latitude: Double\n    var longitude: Double\n    \n    // Computed property\n    var isInNorthernHemisphere: Bool {\n        return latitude > 0\n    }\n}\n\n// Class for reference semantics (good for shared state)\nclass Player {\n    var name: String\n    var score: Int\n    var position: Coordinate\n    \n    init(name: String, score: Int = 0, position: Coordinate) {\n        self.name = name\n        self.score = score\n        self.position = position\n    }\n    \n    func moveTo(newPosition: Coordinate) {\n        position = newPosition\n        print(\"\\(name) moved to (\\(position.latitude), \\(position.longitude))\")\n    }\n}\n\n// Usage example\nlet startPosition = Coordinate(latitude: 37.7749, longitude: -122.4194)\nlet player1 = Player(name: \"Hero\", position: startPosition)\n\n// Copy the coordinate (value type)\nvar newPosition = player1.position\nnewPosition.latitude = 40.7128\n\n// Player's position unchanged (value semantics)\nprint(player1.position.latitude) // 37.7749\n\n// Share player reference\nlet player2 = player1\nplayer2.score = 100\nprint(player1.score) // 100 - both changed (reference semantics)",
      "category": "Swift Basics",
      "estimatedTime": 240,
      "dependencies": ["variables"],
      "challenge": {
        "instructions": "Create a complete system modeling a library with both structs and classes:\n\nPART 1: Value Types with Structs (60 min)\n1. Create a 'Book' struct with: title, author, isbn, pageCount, isCheckedOut\n2. Add computed properties: description, canBeBorrowed\n3. Add methods: checkOut(), returnBook() with proper mutating keywords\n4. Demonstrate value semantics by creating copies and modifying them\n\nPART 2: Reference Types with Classes (60 min)\n5. Create a 'LibraryMember' class with: memberID, name, borrowedBooks array\n6. Add methods: borrowBook(_:), returnBook(_:), listBorrowedBooks()\n7. Demonstrate reference semantics by creating multiple references\n8. Add a 'Library' class that manages all members and books\n\nPART 3: Inheritance & Polymorphism (60 min)\n9. Create a base 'LibraryItem' class with common properties\n10. Create subclasses: 'PrintedBook', 'EBook', 'Audiobook'\n11. Implement different due date calculations for each type\n12. Use polymorphism to handle different item types uniformly\n\nPART 4: Advanced Features (60 min)\n13. Add deinitializers to clean up resources\n14. Implement identity operators to compare instances\n15. Create a singleton 'LibrarySystem' for global access\n16. Add error handling for invalid operations\n\nTest your implementation thoroughly to understand value vs reference behavior!",
        "starterCode": "// === PART 1: Book Struct ===\n// Create your Book struct here\n\n\n// === PART 2: LibraryMember Class ===\n// Create your LibraryMember class here\n\n\n// === PART 3: Inheritance Hierarchy ===\n// Create LibraryItem base class and subclasses here\n\n\n// === PART 4: Advanced Features ===\n// Add deinitializers, singleton, and error handling here\n\n",
        "solution": "// === PART 1: Book Struct ===\nstruct Book {\n    let title: String\n    let author: String\n    let isbn: String\n    let pageCount: Int\n    var isCheckedOut: Bool = false\n    \n    // Computed properties\n    var description: String {\n        return \"\\\"\\(title)\\\" by \\(author) (ISBN: \\(isbn))\"\n    }\n    \n    var canBeBorrowed: Bool {\n        return !isCheckedOut\n    }\n    \n    // Mutating methods\n    mutating func checkOut() {\n        if !isCheckedOut {\n            isCheckedOut = true\n            print(\"Book '\\(title)' has been checked out\")\n        } else {\n            print(\"Book '\\(title)' is already checked out\")\n        }\n    }\n    \n    mutating func returnBook() {\n        if isCheckedOut {\n            isCheckedOut = false\n            print(\"Book '\\(title)' has been returned\")\n        } else {\n            print(\"Book '\\(title)' was not checked out\")\n        }\n    }\n}\n\n// Value semantics demonstration\nvar book1 = Book(title: \"Swift Basics\", author: \"Apple\", isbn: \"123\", pageCount: 300)\nvar book2 = book1  // Copy created\nbook2.checkOut()   // Only affects book2\nprint(book1.isCheckedOut) // false\nprint(book2.isCheckedOut) // true\n\n// === PART 2: LibraryMember Class ===\nclass LibraryMember {\n    let memberID: String\n    var name: String\n    private var borrowedBooks: [Book] = []\n    \n    init(memberID: String, name: String) {\n        self.memberID = memberID\n        self.name = name\n    }\n    \n    func borrowBook(_ book: inout Book) {\n        if book.canBeBorrowed {\n            book.checkOut()\n            borrowedBooks.append(book)\n            print(\"\\(name) borrowed '\\(book.title)'\")\n        } else {\n            print(\"Cannot borrow '\\(book.title)' - already checked out\")\n        }\n    }\n    \n    func returnBook(isbn: String) {\n        if let index = borrowedBooks.firstIndex(where: { $0.isbn == isbn }) {\n            // Note: We can't modify the original book through this reference\n            // In a real app, you'd have a way to update the original\n            borrowedBooks.remove(at: index)\n            print(\"\\(name) returned book with ISBN \\(isbn)\")\n        } else {\n            print(\"No book with ISBN \\(isbn) found in \\(name)'s borrowed list\")\n        }\n    }\n    \n    func listBorrowedBooks() {\n        if borrowedBooks.isEmpty {\n            print(\"\\(name) has no borrowed books\")\n        } else {\n            print(\"\\(name)'s borrowed books:\")\n            for book in borrowedBooks {\n                print(\"  - \\(book.description)\")\n            }\n        }\n    }\n}\n\n// Reference semantics demonstration\nlet member1 = LibraryMember(memberID: \"M001\", name: \"Alice\")\nlet member2 = member1  // Same instance!\nmember2.name = \"Bob\"\nprint(member1.name) // \"Bob\" - both changed\n\n// === PART 3: Inheritance Hierarchy ===\nclass LibraryItem {\n    let id: String\n    let title: String\n    var isAvailable: Bool = true\n    \n    init(id: String, title: String) {\n        self.id = id\n        self.title = title\n    }\n    \n    func calculateDueDate() -> Date {\n        let calendar = Calendar.current\n        return calendar.date(byAdding: .day, value: 14, to: Date()) ?? Date()\n    }\n    \n    func checkOut() {\n        if isAvailable {\n            isAvailable = false\n            let dueDate = calculateDueDate()\n            print(\"'\\(title)' checked out. Due: \\(dueDate)\")\n        } else {\n            print(\"'\\(title)' is not available\")\n        }\n    }\n    \n    func returnItem() {\n        isAvailable = true\n        print(\"'\\(title)' has been returned\")\n    }\n}\n\nclass PrintedBook: LibraryItem {\n    let author: String\n    let pageCount: Int\n    \n    init(id: String, title: String, author: String, pageCount: Int) {\n        self.author = author\n        self.pageCount = pageCount\n        super.init(id: id, title: title)\n    }\n    \n    override func calculateDueDate() -> Date {\n        let calendar = Calendar.current\n        return calendar.date(byAdding: .day, value: 21, to: Date()) ?? Date()\n    }\n}\n\nclass EBook: LibraryItem {\n    let fileSize: Double // in MB\n    \n    init(id: String, title: String, fileSize: Double) {\n        self.fileSize = fileSize\n        super.init(id: id, title: title)\n    }\n    \n    override func calculateDueDate() -> Date {\n        let calendar = Calendar.current\n        return calendar.date(byAdding: .day, value: 7, to: Date()) ?? Date()\n    }\n}\n\n// Polymorphism demonstration\nlet items: [LibraryItem] = [\n    PrintedBook(id: \"B001\", title: \"Swift Guide\", author: \"Apple\", pageCount: 400),\n    EBook(id: \"E001\", title: \"Digital Swift\", fileSize: 5.2)\n]\n\nfor item in items {\n    item.checkOut() // Each calls its own calculateDueDate implementation\n}\n\n// === PART 4: Advanced Features ===\nclass LibrarySystem {\n    static let shared = LibrarySystem()\n    private init() {}\n    \n    private var allItems: [LibraryItem] = []\n    \n    func addItem(_ item: LibraryItem) {\n        allItems.append(item)\n    }\n    \n    func findAvailableItems() -> [LibraryItem] {\n        return allItems.filter { $0.isAvailable }\n    }\n}\n\n// Singleton usage\nLibrarySystem.shared.addItem(PrintedBook(id: \"B002\", title: \"Advanced Swift\", author: \"Apple\", pageCount: 600))\n\n// Identity operators\nlet bookA = PrintedBook(id: \"B003\", title: \"Book A\", author: \"Author A\", pageCount: 100)\nlet bookB = bookA\nlet bookC = PrintedBook(id: \"B003\", title: \"Book A\", author: \"Author A\", pageCount: 100)\n\nprint(bookA === bookB) // true - same instance\nprint(bookA === bookC) // false - different instances\n\n// Deinitializer example\nclass ResourceHandler {\n    let resourceName: String\n    \n    init(resourceName: String) {\n        self.resourceName = resourceName\n        print(\"Acquired resource: \\(resourceName)\")\n    }\n    \n    deinit {\n        print(\"Released resource: \\(resourceName)\")\n    }\n}\n\n// Test deinitializer\nfunc testResource() {\n    let handler = ResourceHandler(resourceName: \"Database Connection\")\n    // handler will be deinitialized when this function ends\n}\n\ntestResource() // Prints: \"Released resource: Database Connection\"",
        "hints": [
          "PART 1: Remember structs are value types - copies are independent. Use 'mutating' for methods that change properties",
          "PART 2: Classes are reference types - assignments create references to the same instance",
          "PART 3: Use 'override' for methods in subclasses. Polymorphism means same method, different behavior",
          "PART 4: === compares instance identity, == compares values (if Equatable is implemented)",
          "Singletons use 'static let shared = ClassName()' and a private init()",
          "Deinitializers only work with classes, not structs",
          "For the Book struct challenge, remember you need 'inout' parameter to modify the original book",
          "Use computed properties for derived values that don't need storage"
        ],
        "testCases": [
          {
            "input": "book1.isCheckedOut == book2.isCheckedOut",
            "expectedOutput": "false",
            "description": "Struct copies should have independent state after modification"
          },
          {
            "input": "member1.name == member2.name",
            "expectedOutput": "true",
            "description": "Class references should share the same data"
          },
          {
            "input": "items.count == 2",
            "expectedOutput": "true",
            "description": "Polymorphic array should contain all items"
          }
        ]
      }
    },
    {
      "id": "enums_protocols",
      "title": "Enums & Protocols",
      "description": "Master Swift's powerful enums with associated values and embrace protocol-oriented programming",
      "difficulty": "beginner",
      "theory": "# Enums & Protocols - Swift's Power Duo\n\n## 1. Enums Fundamentals (45 min)\n\n### Basic Enum Syntax:\n```swift\nenum CompassDirection {\n    case north\n    case south\n    case east\n    case west\n}\n\n// Or in one line:\nenum CompassDirection {\n    case north, south, east, west\n}\n```\n\n### Using Enums:\n```swift\nlet direction = CompassDirection.north\n\n// Type inference with enum cases\nvar currentDirection: CompassDirection = .east\n\n// Switch statements with enums\nswitch direction {\ncase .north:\n    print(\"Heading north\")\ncase .south:\n    print(\"Heading south\")\ncase .east:\n    print(\"Heading east\")\ncase .west:\n    print(\"Heading west\")\n}\n```\n\n### Raw Values:\n```swift\n// Enums with raw values\nenum Planet: Int {\n    case mercury = 1, venus, earth, mars, jupiter, saturn, uranus, neptune\n}\n\nenum ProgrammingLanguage: String {\n    case swift = \"Swift\"\n    case python = \"Python\"\n    case javascript = \"JavaScript\"\n}\n\n// Accessing raw values\nlet earth = Planet.earth\nprint(earth.rawValue) // 3\nprint(ProgrammingLanguage.swift.rawValue) // \"Swift\"\n\n// Creating from raw values\nif let planet = Planet(rawValue: 5) {\n    print(planet) // jupiter\n}\n```\n\n## 2. Associated Values (60 min)\n\n### Enums with Associated Values:\n```swift\n// Enum with associated values\nenum Barcode {\n    case upc(Int, Int, Int, Int)\n    case qrCode(String)\n}\n\n// Creating instances with associated values\nvar productBarcode = Barcode.upc(8, 85909, 51226, 3)\nproductBarcode = .qrCode(\"ABCDEFGHIJKLMNOP\")\n\n// Extracting associated values\nswitch productBarcode {\ncase .upc(let numberSystem, let manufacturer, let product, let check):\n    print(\"UPC: \\(numberSystem), \\(manufacturer), \\(product), \\(check)\")\ncase .qrCode(let productCode):\n    print(\"QR code: \\(productCode)\")\n}\n\n// Shorter syntax when all values are extracted\nswitch productBarcode {\ncase let .upc(numberSystem, manufacturer, product, check):\n    print(\"UPC: \\(numberSystem), \\(manufacturer), \\(product), \\(check)\")\ncase let .qrCode(productCode):\n    print(\"QR code: \\(productCode)\")\n}\n```\n\n### Practical Associated Value Examples:\n```swift\n// Network responses\nenum NetworkResult {\n    case success(data: Data, statusCode: Int)\n    case failure(error: Error, statusCode: Int)\n    case loading(progress: Double)\n}\n\n// Authentication states\nenum AuthState {\n    case authenticated(user: User, token: String)\n    case unauthenticated\n    case expired(token: String)\n}\n\n// Form validation\nenum ValidationResult {\n    case valid\n    case invalid(reason: String, field: String)\n    case warning(message: String)\n}\n```\n\n### Methods in Enums:\n```swift\nenum ArithmeticExpression {\n    case number(Double)\n    case addition(ArithmeticExpression, ArithmeticExpression)\n    case multiplication(ArithmeticExpression, ArithmeticExpression)\n    \n    func evaluate() -> Double {\n        switch self {\n        case .number(let value):\n            return value\n        case .addition(let left, let right):\n            return left.evaluate() + right.evaluate()\n        case .multiplication(let left, let right):\n            return left.evaluate() * right.evaluate()\n        }\n    }\n}\n\n// Usage\nlet expression = ArithmeticExpression.addition(\n    .number(5),\n    .multiplication(.number(2), .number(3))\n)\nprint(expression.evaluate()) // 11.0\n```\n\n## 3. Protocols Fundamentals (45 min)\n\n### Basic Protocol Syntax:\n```swift\n// Protocol definition\nprotocol Vehicle {\n    var numberOfWheels: Int { get }\n    var maxSpeed: Double { get }\n    var currentSpeed: Double { get set }\n    \n    func start()\n    func stop()\n    func description() -> String\n}\n\n// Protocol adoption\nclass Car: Vehicle {\n    let numberOfWheels: Int = 4\n    let maxSpeed: Double = 200.0\n    var currentSpeed: Double = 0.0\n    \n    func start() {\n        print(\"Car started\")\n        currentSpeed = 0\n    }\n    \n    func stop() {\n        print(\"Car stopped\")\n        currentSpeed = 0\n    }\n    \n    func description() -> String {\n        return \"Car with \\(numberOfWheels) wheels, max speed: \\(maxSpeed) km/h\"\n    }\n}\n```\n\n### Protocol Requirements:\n```swift\nprotocol FullyNamed {\n    var fullName: String { get }\n}\n\nprotocol Identifiable {\n    var id: String { get }\n    static var type: String { get }\n}\n\n// Protocol with method requirements\nprotocol Togglable {\n    mutating func toggle()\n}\n\n// Enum adopting a protocol\nenum OnOffSwitch: Togglable {\n    case on, off\n    \n    mutating func toggle() {\n        switch self {\n        case .on:\n            self = .off\n        case .off:\n            self = .on\n        }\n    }\n}\n```\n\n## 4. Protocol-Oriented Programming (60 min)\n\n### Protocol Extensions:\n```swift\n// Protocol with extension\nprotocol Describable {\n    var description: String { get }\n}\n\n// Protocol extension providing default implementation\nextension Describable {\n    var description: String {\n        return \"This is a \\(type(of: self))\"\n    }\n    \n    func detailedDescription() -> String {\n        return \"Detailed: \\(description)\"\n    }\n}\n\n// Adopting the protocol gets the default implementations\nstruct Product: Describable {\n    let name: String\n    // Gets default 'description' from protocol extension\n}\n\nlet product = Product(name: \"iPhone\")\nprint(product.description) // \"This is a Product\"\n```\n\n### Protocol Inheritance:\n```swift\n// Protocol inheritance\nprotocol Drawable {\n    func draw()\n}\n\nprotocol Colorable: Drawable {\n    var color: String { get set }\n    func fillColor()\n}\n\nprotocol Resizable: Drawable {\n    var size: Double { get set }\n    func resize(to scale: Double)\n}\n\n// Multiple protocol inheritance\nprotocol Shape: Colorable, Resizable {\n    var name: String { get }\n}\n\n// Concrete type adopting the protocol\nstruct Circle: Shape {\n    let name = \"Circle\"\n    var color: String = \"black\"\n    var size: Double = 1.0\n    \n    func draw() {\n        print(\"Drawing a \\(color) circle of size \\(size)\")\n    }\n    \n    func fillColor() {\n        print(\"Filling circle with \\(color) color\")\n    }\n    \n    func resize(to scale: Double) {\n        size *= scale\n        print(\"Circle resized to size: \\(size)\")\n    }\n}\n```\n\n### Protocol Composition:\n```swift\n// Protocol composition\nprotocol Named {\n    var name: String { get }\n}\n\nprotocol Aged {\n    var age: Int { get }\n}\n\n// Function accepting types that conform to multiple protocols\nfunc wishHappyBirthday(to celebrant: Named & Aged) {\n    print(\"Happy birthday \\(celebrant.name), you're \\(celebrant.age)!\")\n}\n\nstruct Person: Named, Aged {\n    var name: String\n    var age: Int\n}\n\nlet birthdayPerson = Person(name: \"Alice\", age: 25)\nwishHappyBirthday(to: birthdayPerson)\n```\n\n## 5. Advanced Enum & Protocol Patterns (45 min)\n\n### Recursive Enums:\n```swift\n// Recursive enum with indirect keyword\nindirect enum ArithmeticExpression {\n    case number(Int)\n    case addition(ArithmeticExpression, ArithmeticExpression)\n    case multiplication(ArithmeticExpression, ArithmeticExpression)\n}\n\n// Building complex expressions\nlet five = ArithmeticExpression.number(5)\nlet four = ArithmeticExpression.number(4)\nlet sum = ArithmeticExpression.addition(five, four)\nlet product = ArithmeticExpression.multiplication(sum, ArithmeticExpression.number(2))\n```\n\n### Associated Values with Protocols:\n```swift\nprotocol PaymentMethod {\n    var amount: Double { get }\n    func processPayment() -> Bool\n}\n\nenum Payment {\n    case creditCard(number: String, expiry: String, cvv: String)\n    case paypal(email: String)\n    case applePay\n    case cash\n    \n    func process() -> Bool {\n        switch self {\n        case .creditCard(let number, let expiry, let cvv):\n            return validateCreditCard(number: number, expiry: expiry, cvv: cvv)\n        case .paypal(let email):\n            return processPaypal(email: email)\n        case .applePay:\n            return processApplePay()\n        case .cash:\n            return true\n        }\n    }\n    \n    private func validateCreditCard(number: String, expiry: String, cvv: String) -> Bool {\n        // Validation logic\n        return !number.isEmpty && !expiry.isEmpty && !cvv.isEmpty\n    }\n    \n    private func processPaypal(email: String) -> Bool {\n        return email.contains(\"@\")\n    }\n    \n    private func processApplePay() -> Bool {\n        return true\n    }\n}\n```\n\n### Protocol with Associated Types:\n```swift\n// Protocol with associated type\nprotocol Container {\n    associatedtype Item\n    var count: Int { get }\n    mutating func append(_ item: Item)\n    subscript(i: Int) -> Item { get }\n}\n\n// Generic struct adopting the protocol\nstruct Stack<Element>: Container {\n    private var items: [Element] = []\n    \n    var count: Int {\n        return items.count\n    }\n    \n    mutating func append(_ item: Element) {\n        items.append(item)\n    }\n    \n    subscript(i: Int) -> Element {\n        return items[i]\n    }\n}\n\n// Usage\nvar stringStack = Stack<String>()\nstringStack.append(\"Hello\")\nstringStack.append(\"World\")\nprint(stringStack[0]) // \"Hello\"\n```\n\n## 6. Real-World Applications (45 min)\n\n### State Management with Enums:\n```swift\n// App state management\nenum AppState {\n    case launching\n    case authenticated(user: User)\n    case unauthenticated\n    case loading\n    case error(message: String, retryAction: () -> Void)\n}\n\nclass AppStateManager {\n    var currentState: AppState = .launching {\n        didSet {\n            handleStateChange()\n        }\n    }\n    \n    private func handleStateChange() {\n        switch currentState {\n        case .launching:\n            showLaunchScreen()\n        case .authenticated(let user):\n            showMainInterface(for: user)\n        case .unauthenticated:\n            showLoginScreen()\n        case .loading:\n            showLoadingIndicator()\n        case .error(let message, let retryAction):\n            showError(message: message, retryAction: retryAction)\n        }\n    }\n}\n```\n\n### Protocol-Oriented Networking:\n```swift\n// Networking with protocols\nprotocol APIEndpoint {\n    var baseURL: String { get }\n    var path: String { get }\n    var method: String { get }\n    var parameters: [String: Any]? { get }\n}\n\nprotocol NetworkService {\n    func request<T: Decodable>(_ endpoint: APIEndpoint, completion: @escaping (Result<T, Error>) -> Void)\n}\n\n// Concrete implementation\nclass URLSessionNetworkService: NetworkService {\n    func request<T: Decodable>(_ endpoint: APIEndpoint, completion: @escaping (Result<T, Error>) -> Void) {\n        // Implementation using URLSession\n    }\n}\n```\n\n### Best Practices:\n- Use enums for finite states and choices\n- Prefer protocol composition over inheritance\n- Use protocol extensions for default implementations\n- Leverage associated values for flexible data modeling\n- Use recursive enums for tree-like structures\n\n## Practice Exercises\n\nComplete all exercises to master enums with associated values and protocol-oriented programming!",
      "codeExample": "// === ENUM EXAMPLES ===\n\n// Basic enum with raw values\nenum TrafficLight: String {\n    case red = \"Stop\"\n    case yellow = \"Caution\"\n    case green = \"Go\"\n}\n\nlet light = TrafficLight.red\nprint(light.rawValue) // \"Stop\"\n\n// Enum with associated values\nenum Measurement {\n    case distance(Double)\n    case temperature(celsius: Double)\n    case weight(kilograms: Double)\n    case speed(kilometersPerHour: Double)\n}\n\nlet myMeasurement = Measurement.temperature(celsius: 23.5)\n\nswitch myMeasurement {\ncase .temperature(let celsius):\n    print(\"Temperature is \\(celsius)Â°C\")\n    let fahrenheit = (celsius * 9/5) + 32\n    print(\"That's \\(fahrenheit)Â°F\")\ncase .distance(let meters):\n    print(\"Distance: \\(meters) meters\")\ncase .weight(let kg):\n    print(\"Weight: \\(kg) kg\")\ncase .speed(let kmh):\n    print(\"Speed: \\(kmh) km/h\")\n}\n\n// Enum with methods\nenum MathOperation {\n    case add(Double, Double)\n    case subtract(Double, Double)\n    case multiply(Double, Double)\n    case divide(Double, Double)\n    \n    func calculate() -> Double {\n        switch self {\n        case .add(let a, let b):\n            return a + b\n        case .subtract(let a, let b):\n            return a - b\n        case .multiply(let a, let b):\n            return a * b\n        case .divide(let a, let b):\n            return b != 0 ? a / b : 0\n        }\n    }\n    \n    var symbol: String {\n        switch self {\n        case .add: return \"+\"\n        case .subtract: return \"-\"\n        case .multiply: return \"Ã—\"\n        case .divide: return \"Ã·\"\n        }\n    }\n}\n\nlet operation = MathOperation.add(10, 5)\nprint(\"\\(operation.symbol) operation result: \\(operation.calculate())\") // \"+ operation result: 15.0\"\n\n// === PROTOCOL EXAMPLES ===\n\n// Basic protocol\nprotocol SoundMaker {\n    var volume: Int { get set }\n    func makeSound() -> String\n}\n\n// Protocol extension with default implementation\nextension SoundMaker {\n    func makeSound() -> String {\n        return \"Some generic sound at volume \\(volume)\"\n    }\n}\n\n// Adopting the protocol\nstruct Dog: SoundMaker {\n    var volume: Int = 10\n    \n    func makeSound() -> String {\n        return \"Woof! \\(volume > 5 ? \"LOUD \" : \"\")bark!\"\n    }\n}\n\nstruct Car: SoundMaker {\n    var volume: Int = 7\n    // Uses default makeSound() from protocol extension\n}\n\nlet myDog = Dog(volume: 8)\nlet myCar = Car(volume: 5)\n\nprint(myDog.makeSound()) // \"Woof! LOUD bark!\"\nprint(myCar.makeSound()) // \"Some generic sound at volume 5\"\n\n// Protocol composition\nprotocol Flyable {\n    var maxAltitude: Double { get }\n    func fly()\n}\n\nprotocol Swimmable {\n    var maxDepth: Double { get }\n    func swim()\n}\n\n// Type that conforms to multiple protocols\nstruct Duck: Flyable, Swimmable {\n    let maxAltitude: Double = 1000.0\n    let maxDepth: Double = 5.0\n    \n    func fly() {\n        print(\"Duck flying up to \\(maxAltitude) meters\")\n    }\n    \n    func swim() {\n        print(\"Duck swimming down to \\(maxDepth) meters\")\n    }\n}\n\n// Function that requires protocol composition\nfunc describeAmphibiousCreature(_ creature: Flyable & Swimmable) {\n    print(\"This creature can fly up to \\(creature.maxAltitude)m and swim down to \\(creature.maxDepth)m\")\n    creature.fly()\n    creature.swim()\n}\n\nlet donald = Duck()\ndescribeAmphibiousCreature(donald)\n\n// === ADVANCED PATTERNS ===\n\n// Recursive enum for mathematical expressions\nindirect enum Expression {\n    case number(Double)\n    case add(Expression, Expression)\n    case multiply(Expression, Expression)\n    case power(base: Expression, exponent: Expression)\n    \n    func evaluate() -> Double {\n        switch self {\n        case .number(let value):\n            return value\n        case .add(let left, let right):\n            return left.evaluate() + right.evaluate()\n        case .multiply(let left, let right):\n            return left.evaluate() * right.evaluate()\n        case .power(let base, let exponent):\n            return pow(base.evaluate(), exponent.evaluate())\n        }\n    }\n}\n\n// Build expression: (2 + 3) * 4^2\nlet expr = Expression.multiply(\n    Expression.add(.number(2), .number(3)),\n    Expression.power(base: .number(4), exponent: .number(2))\n)\nprint(\"Expression result: \\(expr.evaluate())\") // (2+3) * 4^2 = 5 * 16 = 80\n\n// Protocol with associated type\nprotocol Queue {\n    associatedtype Element\n    var isEmpty: Bool { get }\n    var count: Int { get }\n    mutating func enqueue(_ element: Element)\n    mutating func dequeue() -> Element?\n    func peek() -> Element?\n}\n\n// Generic queue implementing the protocol\nstruct GenericQueue<T>: Queue {\n    private var elements: [T] = []\n    \n    var isEmpty: Bool {\n        return elements.isEmpty\n    }\n    \n    var count: Int {\n        return elements.count\n    }\n    \n    mutating func enqueue(_ element: T) {\n        elements.append(element)\n    }\n    \n    mutating func dequeue() -> T? {\n        return isEmpty ? nil : elements.removeFirst()\n    }\n    \n    func peek() -> T? {\n        return elements.first\n    }\n}\n\n// Usage\nvar stringQueue = GenericQueue<String>()\nstringQueue.enqueue(\"First\")\nstringQueue.enqueue(\"Second\")\nstringQueue.enqueue(\"Third\")\n\nprint(stringQueue.dequeue() ?? \"None\") // \"First\"\nprint(stringQueue.peek() ?? \"None\")    // \"Second\"",
      "category": "Swift Basics",
      "estimatedTime": 180,
      "dependencies": ["structs_classes", "functions"],
      "challenge": {
        "instructions": "Create a complete authentication system using enums with associated values and protocol-oriented programming:\n\nPART 1: Authentication State Enum (45 min)\n1. Create an 'AuthState' enum with cases: authenticated, unauthenticated, loading, error\n2. Add associated values: user & token for authenticated, Error for error case\n3. Implement methods: isLoggedIn, currentUser, errorMessage\n4. Add a mutating method to handle login/logout transitions\n\nPART 2: Authentication Protocol (45 min)\n5. Create an 'Authenticatable' protocol with requirements: username, email, password\n6. Create a 'User' struct implementing Authenticatable\n7. Add protocol extensions for validation methods\n8. Create a 'Validatable' protocol for input validation\n\nPART 3: Authentication Service (45 min)\n9. Create an 'AuthService' protocol with async methods: login, logout, register\n10. Implement a mock 'MockAuthService' class for testing\n11. Use enums with associated values for service responses\n12. Handle different error types with associated values\n\nPART 4: Advanced Protocol Composition (45 min)\n13. Create protocols for different auth providers: EmailAuth, SocialAuth, BiometricAuth\n14. Implement protocol composition for multi-provider authentication\n15. Use associated types in protocols for flexible return types\n16. Create a protocol extension with default implementations\n\nTest your implementation with various authentication scenarios and error cases!",
        "starterCode": "// === PART 1: AuthState Enum ===\n// Create your AuthState enum with associated values here\n\n\n// === PART 2: Authentication Protocol ===\n// Create Authenticatable protocol and User struct here\n\n\n// === PART 3: Authentication Service ===\n// Create AuthService protocol and MockAuthService here\n\n\n// === PART 4: Advanced Protocol Composition ===\n// Create provider protocols and composition here\n\n",
        "solution": "// === PART 1: AuthState Enum ===\nenum AuthState {\n    case authenticated(user: User, token: String)\n    case unauthenticated\n    case loading(message: String)\n    case error(AuthError)\n    \n    // Computed properties\n    var isLoggedIn: Bool {\n        switch self {\n        case .authenticated:\n            return true\n        default:\n            return false\n        }\n    }\n    \n    var currentUser: User? {\n        switch self {\n        case .authenticated(let user, _):\n            return user\n        default:\n            return nil\n        }\n    }\n    \n    var errorMessage: String? {\n        switch self {\n        case .error(let error):\n            return error.localizedDescription\n        default:\n            return nil\n        }\n    }\n    \n    // Mutating methods for state transitions\n    mutating func login(user: User, token: String) {\n        self = .authenticated(user: user, token: token)\n    }\n    \n    mutating func logout() {\n        self = .unauthenticated\n    }\n    \n    mutating func setLoading(_ message: String) {\n        self = .loading(message: message)\n    }\n    \n    mutating func setError(_ error: AuthError) {\n        self = .error(error)\n    }\n}\n\n// Error enum with associated values\nenum AuthError: Error {\n    case invalidCredentials\n    case networkError(underlyingError: Error)\n    case validationFailed(field: String, reason: String)\n    case accountLocked(until: Date)\n    case unknownError(message: String)\n    \n    var localizedDescription: String {\n        switch self {\n        case .invalidCredentials:\n            return \"Invalid username or password\"\n        case .networkError(let underlyingError):\n            return \"Network error: \\(underlyingError.localizedDescription)\"\n        case .validationFailed(let field, let reason):\n            return \"\\(field) validation failed: \\(reason)\"\n        case .accountLocked(let until):\n            let formatter = DateFormatter()\n            formatter.dateFormat = \"HH:mm\"\n            return \"Account locked until \\(formatter.string(from: until))\"\n        case .unknownError(let message):\n            return \"Unknown error: \\(message)\"\n        }\n    }\n}\n\n// === PART 2: Authentication Protocol ===\nprotocol Authenticatable {\n    var username: String { get }\n    var email: String { get }\n    var password: String { get }\n}\n\nprotocol Validatable {\n    func validate() throws\n}\n\n// Protocol extension with default implementations\nextension Authenticatable {\n    var isValidEmail: Bool {\n        let emailRegex = \"[A-Z0-9a-z._%+-]+@[A-Za-z0-9.-]+\\\\.[A-Za-z]{2,}\"\n        return NSPredicate(format: \"SELF MATCHES %@\", emailRegex).evaluate(with: email)\n    }\n    \n    var isValidUsername: Bool {\n        return username.count >= 3 && username.count <= 20\n    }\n    \n    var isValidPassword: Bool {\n        return password.count >= 8\n    }\n}\n\n// User struct implementing protocols\nstruct User: Authenticatable, Validatable {\n    let username: String\n    let email: String\n    let password: String\n    let id: String\n    let createdAt: Date\n    \n    init(username: String, email: String, password: String) throws {\n        self.username = username\n        self.email = email\n        self.password = password\n        self.id = UUID().uuidString\n        self.createdAt = Date()\n        \n        try validate()\n    }\n    \n    func validate() throws {\n        if !isValidUsername {\n            throw AuthError.validationFailed(field: \"username\", reason: \"Must be 3-20 characters\")\n        }\n        \n        if !isValidEmail {\n            throw AuthError.validationFailed(field: \"email\", reason: \"Invalid email format\")\n        }\n        \n        if !isValidPassword {\n            throw AuthError.validationFailed(field: \"password\", reason: \"Must be at least 8 characters\")\n        }\n    }\n}\n\n// === PART 3: Authentication Service ===\n// Result enum with associated values\nenum AuthResult {\n    case success(user: User, token: String)\n    case failure(AuthError)\n    case loading(progress: Double)\n}\n\nprotocol AuthService {\n    func login(username: String, password: String) async -> AuthResult\n    func logout() async -> Bool\n    func register(user: User) async -> AuthResult\n}\n\nclass MockAuthService: AuthService {\n    private var currentState: AuthState = .unauthenticated\n    \n    func login(username: String, password: String) async -> AuthResult {\n        // Simulate network delay\n        await Task.sleep(1_000_000_000) // 1 second\n        \n        // Mock validation\n        if username == \"admin\" && password == \"password\" {\n            do {\n                let user = try User(username: username, email: \"admin@example.com\", password: password)\n                let token = \"mock-jwt-token-\\(UUID().uuidString)\"\n                return .success(user: user, token: token)\n            } catch {\n                return .failure(error as? AuthError ?? .unknownError(message: error.localizedDescription))\n            }\n        } else {\n            return .failure(.invalidCredentials)\n        }\n    }\n    \n    func logout() async -> Bool {\n        await Task.sleep(500_000_000) // 0.5 second\n        currentState = .unauthenticated\n        return true\n    }\n    \n    func register(user: User) async -> AuthResult {\n        await Task.sleep(1_500_000_000) // 1.5 seconds\n        \n        do {\n            try user.validate()\n            let token = \"mock-jwt-token-\\(UUID().uuidString)\"\n            return .success(user: user, token: token)\n        } catch {\n            return .failure(error as? AuthError ?? .unknownError(message: error.localizedDescription))\n        }\n    }\n}\n\n// === PART 4: Advanced Protocol Composition ===\n// Provider protocols\nprotocol EmailAuth {\n    func loginWithEmail(_ email: String, password: String) async -> AuthResult\n}\n\nprotocol SocialAuth {\n    func loginWithSocialProvider(_ provider: SocialProvider) async -> AuthResult\n}\n\nprotocol BiometricAuth {\n    func loginWithBiometrics() async -> AuthResult\n}\n\n// Social provider enum\nenum SocialProvider {\n    case google\n    case facebook\n    case apple\n    case github\n    \n    var name: String {\n        switch self {\n        case .google: return \"Google\"\n        case .facebook: return \"Facebook\"\n        case .apple: return \"Apple\"\n        case .github: return \"GitHub\"\n        }\n    }\n}\n\n// Protocol composition for multi-provider auth\nprotocol MultiProviderAuth: EmailAuth, SocialAuth, BiometricAuth {\n    var availableProviders: [SocialProvider] { get }\n    func switchProvider(_ provider: SocialProvider)\n}\n\n// Protocol with associated type\nprotocol AuthResponse {\n    associatedtype UserType: Authenticatable\n    func getUser() -> UserType?\n    func getToken() -> String?\n}\n\n// Concrete implementation\nstruct TypedAuthResponse<UserType: Authenticatable>: AuthResponse {\n    let user: UserType?\n    let token: String?\n    \n    func getUser() -> UserType? {\n        return user\n    }\n    \n    func getToken() -> String? {\n        return token\n    }\n}\n\n// Complete auth manager using all patterns\nclass AuthManager: MultiProviderAuth {\n    private var authService: AuthService\n    private(set) var currentState: AuthState = .unauthenticated\n    private(set) var availableProviders: [SocialProvider] = [.google, .apple, .github]\n    \n    init(authService: AuthService = MockAuthService()) {\n        self.authService = authService\n    }\n    \n    // EmailAuth implementation\n    func loginWithEmail(_ email: String, password: String) async -> AuthResult {\n        currentState.setLoading(\"Logging in with email...\")\n        return await authService.login(username: email, password: password)\n    }\n    \n    // SocialAuth implementation\n    func loginWithSocialProvider(_ provider: SocialProvider) async -> AuthResult {\n        currentState.setLoading(\"Logging in with \\(provider.name)...\")\n        \n        await Task.sleep(2_000_000_000) // 2 seconds\n        \n        // Mock social login\n        do {\n            let user = try User(username: \"social_user\", email: \"user@example.com\", password: \"social\")\n            let token = \"social-token-\\(provider.name.lowercased())-\\(UUID().uuidString)\"\n            return .success(user: user, token: token)\n        } catch {\n            return .failure(error as? AuthError ?? .unknownError(message: error.localizedDescription))\n        }\n    }\n    \n    // BiometricAuth implementation\n    func loginWithBiometrics() async -> AuthResult {\n        currentState.setLoading(\"Authenticating with biometrics...\")\n        \n        await Task.sleep(1_000_000_000) // 1 second\n        \n        // Mock biometric auth (80% success rate)\n        if Bool.random() {\n            do {\n                let user = try User(username: \"biometric_user\", email: \"bio@example.com\", password: \"bio\")\n                let token = \"bio-token-\\(UUID().uuidString)\"\n                return .success(user: user, token: token)\n            } catch {\n                return .failure(error as? AuthError ?? .unknownError(message: error.localizedDescription))\n            }\n        } else {\n            return .failure(.unknownError(message: \"Biometric authentication failed\"))\n        }\n    }\n    \n    func switchProvider(_ provider: SocialProvider) {\n        print(\"Switched to \\(provider.name) provider\")\n    }\n    \n    // Update state based on auth result\n    func handleAuthResult(_ result: AuthResult) {\n        switch result {\n        case .success(let user, let token):\n            currentState.login(user: user, token: token)\n            print(\"Login successful for user: \\(user.username)\")\n        case .failure(let error):\n            currentState.setError(error)\n            print(\"Login failed: \\(error.localizedDescription)\")\n        case .loading(let progress):\n            currentState.setLoading(\"Loading... \\(Int(progress * 100))%\")\n        }\n    }\n}\n\n// Usage example\nfunc demonstrateAuthSystem() async {\n    let authManager = AuthManager()\n    \n    // Test email login\n    let emailResult = await authManager.loginWithEmail(\"admin\", password: \"password\")\n    authManager.handleAuthResult(emailResult)\n    \n    // Test social login\n    let socialResult = await authManager.loginWithSocialProvider(.google)\n    authManager.handleAuthResult(socialResult)\n    \n    // Test biometric login\n    let bioResult = await authManager.loginWithBiometrics()\n    authManager.handleAuthResult(bioResult)\n}\n\n// Run the demonstration\n// await demonstrateAuthSystem()",
        "hints": [
          "PART 1: Use associated values in enums to carry additional data. Mutating methods change enum cases",
          "PART 2: Protocol extensions can provide default implementations. Use throws for validation that can fail",
          "PART 3: Async/await works well with auth services. Use Task.sleep for mock delays",
          "PART 4: Protocol composition uses 'ProtocolA & ProtocolB'. Associated types make protocols generic",
          "Remember: enums are great for representing finite states like authentication flow",
          "Use protocol-oriented programming to create flexible, testable authentication systems",
          "Associated values in enums can carry different types of data for different cases",
          "Protocol extensions allow you to add functionality to existing protocols without modifying conforming types"
        ],
        "testCases": [
          {
            "input": "AuthState.authenticated(user: User(), token: \"test\").isLoggedIn",
            "expectedOutput": "true",
            "description": "Authenticated state should return true for isLoggedIn"
          },
          {
            "input": "AuthState.unauthenticated.isLoggedIn",
            "expectedOutput": "false",
            "description": "Unauthenticated state should return false for isLoggedIn"
          },
          {
            "input": "User(username: \"test\", email: \"test@test.com\", password: \"password\").isValidEmail",
            "expectedOutput": "true",
            "description": "Valid email should pass validation"
          }
        ]
      }
    },
    {
      "id": "error_handling",
      "title": "Error Handling",
      "description": "Master do-try-catch and throwing functions to write robust Swift code that handles failures gracefully",
      "difficulty": "beginner",
      "theory": "# Error Handling - Writing Robust Swift Code\n\n## 1. Understanding Errors (30 min)\n\n### What are Errors?\n- **Unexpected events** that occur during program execution\n- **Not the same as bugs** - bugs should be fixed, errors should be handled\n- Examples: Network failure, file not found, invalid input\n\n### Why Handle Errors?\n- **Prevent crashes** and unexpected behavior\n- **Provide better user experience** with helpful messages\n- **Make code more predictable** and maintainable\n\n### Real-world Analogy:\n- **No Error Handling**: Driving without brakes - crash when something goes wrong\n- **With Error Handling**: Driving with brakes and airbags - safe even when problems occur\n\n## 2. Defining Custom Errors (30 min)\n\n### Using Enums with Error Protocol:\n```swift\nenum NetworkError: Error {\n    case invalidURL\n    case noInternetConnection\n    case serverError(statusCode: Int)\n    case timeout\n}\n\nenum ValidationError: Error {\n    case emptyField\n    case invalidEmail\n    case passwordTooShort\n    case ageRestriction\n}\n```\n\n### Error Properties:\n```swift\nenum FileError: Error {\n    case fileNotFound(path: String)\n    case permissionDenied\n    case diskFull\n    \n    var description: String {\n        switch self {\n        case .fileNotFound(let path):\n            return \"File not found at path: \\(path)\"\n        case .permissionDenied:\n            return \"Permission denied to access file\"\n        case .diskFull:\n            return \"Disk is full\"\n        }\n    }\n}\n```\n\n## 3. Throwing Functions (45 min)\n\n### Creating Throwing Functions:\n```swift\nfunc divide(_ numerator: Double, by denominator: Double) throws -> Double {\n    if denominator == 0 {\n        throw DivisionError.divisionByZero\n    }\n    return numerator / denominator\n}\n\nfunc validateEmail(_ email: String) throws {\n    guard !email.isEmpty else {\n        throw ValidationError.emptyField\n    }\n    \n    guard email.contains(\"@\") && email.contains(\".\") else {\n        throw ValidationError.invalidEmail\n    }\n}\n```\n\n### Throwing Initializers:\n```swift\nstruct User {\n    let username: String\n    let email: String\n    \n    init(username: String, email: String) throws {\n        guard !username.isEmpty else {\n            throw ValidationError.emptyField\n        }\n        \n        guard email.contains(\"@\") else {\n            throw ValidationError.invalidEmail\n        }\n        \n        self.username = username\n        self.email = email\n    }\n}\n```\n\n## 4. Handling Errors with do-try-catch (45 min)\n\n### Basic do-try-catch:\n```swift\ndo {\n    let result = try divide(10, by: 2)\n    print(\"Result: \\(result)\")\n} catch {\n    print(\"An error occurred: \\(error)\")\n}\n```\n\n### Catching Specific Errors:\n```swift\ndo {\n    try validateEmail(\"user@example.com\")\n    print(\"Email is valid!\")\n} catch ValidationError.emptyField {\n    print(\"Please enter an email address\")\n} catch ValidationError.invalidEmail {\n    print(\"Please enter a valid email address\")\n} catch {\n    print(\"Unexpected error: \\(error)\")\n}\n```\n\n### Pattern Matching in Catch:\n```swift\ndo {\n    let user = try User(username: \"\", email: \"test@example.com\")\n} catch let error as ValidationError {\n    switch error {\n    case .emptyField:\n        print(\"Field cannot be empty\")\n    case .invalidEmail:\n        print(\"Invalid email format\")\n    case .passwordTooShort, .ageRestriction:\n        print(\"Validation failed\")\n    }\n}\n```\n\n## 5. Alternative Error Handling Methods (30 min)\n\n### try? - Converting to Optional:\n```swift\n// Returns nil if error occurs\nif let result = try? divide(10, by: 2) {\n    print(\"Division successful: \\(result)\")\n} else {\n    print(\"Division failed\")\n}\n```\n\n### try! - Force Try (Use Sparingly):\n```swift\n// Crashes if error occurs - only when 100% sure no error will happen\nlet result = try! divide(10, by: 2)  // Only if denominator is never zero\n```\n\n### Optional Try in Guard Statements:\n```swift\nfunc processUserInput(email: String) {\n    guard let _ = try? validateEmail(email) else {\n        print(\"Invalid email provided\")\n        return\n    }\n    print(\"Email validation passed\")\n}\n```\n\n## 6. Practical Error Handling Patterns (45 min)\n\n### Network Request Example:\n```swift\nenum APIError: Error {\n    case invalidResponse\n    case httpError(code: Int)\n    case decodingError\n    case networkUnavailable\n}\n\nfunc fetchUserData(from urlString: String) throws -> User {\n    guard let url = URL(string: urlString) else {\n        throw APIError.invalidResponse\n    }\n    \n    // Simulate network request\n    let data = Data() // Would come from actual network call\n    \n    guard !data.isEmpty else {\n        throw APIError.networkUnavailable\n    }\n    \n    // Would decode JSON here\n    return User(username: \"test\", email: \"test@example.com\")\n}\n```\n\n### File Operations:\n```swift\nfunc readFile(at path: String) throws -> String {\n    // Simulate file reading\n    let fileExists = Bool.random() // Simulate file existence check\n    \n    if !fileExists {\n        throw FileError.fileNotFound(path: path)\n    }\n    \n    return \"File contents\"\n}\n```\n\n### Chaining Throwing Functions:\n```swift\nfunc processUserRegistration(username: String, email: String, password: String) throws -> User {\n    try validateUsername(username)\n    try validateEmail(email)\n    try validatePassword(password)\n    \n    return try User(username: username, email: email)\n}\n```\n\n## 7. Best Practices & Common Pitfalls (30 min)\n\n### Do's and Don'ts:\n- **DO** provide meaningful error messages\n- **DO** handle errors at the appropriate level\n- **DON'T** use empty catch blocks that ignore errors\n- **DON'T** overuse try! - it can crash your app\n\n### Error Propagation:\n```swift\nfunc uploadUserData(_ user: User) throws {\n    // If any step fails, error propagates up\n    try validateUserData(user)\n    try prepareForUpload(user)\n    try performUpload(user)\n}\n\n// Caller handles all possible errors\nfunc completeRegistration(user: User) {\n    do {\n        try uploadUserData(user)\n        print(\"Registration complete!\")\n    } catch {\n        print(\"Registration failed: \\(error)\")\n    }\n}\n```\n\n### Creating User-friendly Error Messages:\n```swift\nextension ValidationError: LocalizedError {\n    var errorDescription: String? {\n        switch self {\n        case .emptyField:\n            return \"This field cannot be empty\"\n        case .invalidEmail:\n            return \"Please enter a valid email address\"\n        case .passwordTooShort:\n            return \"Password must be at least 8 characters\"\n        case .ageRestriction:\n            return \"You must be 13 years or older to register\"\n        }\n    }\n}\n```\n\n## Practice Exercises\n\nComplete all exercises to master error handling in Swift!",
      "codeExample": "// === DEFINING CUSTOM ERRORS ===\n\n// Network-related errors\nenum NetworkError: Error {\n    case invalidURL\n    case noInternetConnection\n    case requestTimeout\n    case serverError(code: Int)\n    case parsingFailed\n}\n\n// User input validation errors\nenum ValidationError: Error {\n    case emptyField(fieldName: String)\n    case invalidFormat(fieldName: String)\n    case tooShort(fieldName: String, minLength: Int)\n    case valueTooLow(fieldName: String, minValue: Int)\n    case valueTooHigh(fieldName: String, maxValue: Int)\n}\n\n// File operation errors\nenum FileSystemError: Error {\n    case fileNotFound(path: String)\n    case permissionDenied\n    case diskFull\n    case invalidFileFormat\n}\n\n// === THROWING FUNCTIONS ===\n\n// Function that validates user age\nfunc validateAge(_ age: Int) throws {\n    guard age >= 0 else {\n        throw ValidationError.valueTooLow(fieldName: \"age\", minValue: 0)\n    }\n    \n    guard age <= 150 else {\n        throw ValidationError.valueTooHigh(fieldName: \"age\", maxValue: 150)\n    }\n    \n    guard age >= 13 else {\n        throw ValidationError.valueTooLow(fieldName: \"age\", minValue: 13)\n    }\n    \n    print(\"Age validation passed: \\(age)\")\n}\n\n// Function that processes user registration\nfunc registerUser(name: String, email: String, age: Int, password: String) throws -> String {\n    // Validate name\n    guard !name.isEmpty else {\n        throw ValidationError.emptyField(fieldName: \"name\")\n    }\n    \n    guard name.count >= 2 else {\n        throw ValidationError.tooShort(fieldName: \"name\", minLength: 2)\n    }\n    \n    // Validate email\n    guard !email.isEmpty else {\n        throw ValidationError.emptyField(fieldName: \"email\")\n    }\n    \n    guard email.contains(\"@\") && email.contains(\".\") else {\n        throw ValidationError.invalidFormat(fieldName: \"email\")\n    }\n    \n    // Validate age\n    try validateAge(age)\n    \n    // Validate password\n    guard !password.isEmpty else {\n        throw ValidationError.emptyField(fieldName: \"password\")\n    }\n    \n    guard password.count >= 8 else {\n        throw ValidationError.tooShort(fieldName: \"password\", minLength: 8)\n    }\n    \n    return \"User '\\(name)' registered successfully!\"\n}\n\n// Function that simulates network request\nfunc fetchData(from urlString: String) throws -> String {\n    guard let url = URL(string: urlString) else {\n        throw NetworkError.invalidURL\n    }\n    \n    // Simulate network conditions\n    let hasInternet = Bool.random()\n    guard hasInternet else {\n        throw NetworkError.noInternetConnection\n    }\n    \n    // Simulate server response\n    let serverIsWorking = Bool.random()\n    guard serverIsWorking else {\n        throw NetworkError.serverError(code: 500)\n    }\n    \n    return \"Data from \\(urlString)\"\n}\n\n// === ERROR HANDLING EXAMPLES ===\n\n// Example 1: Basic do-try-catch\nprint(\"=== Example 1: Basic Error Handling ===\")\ndo {\n    try validateAge(25)\n    print(\"Age is valid!\")\n} catch {\n    print(\"Error: \\(error)\")\n}\n\n// Example 2: Catching specific errors\nprint(\"\\n=== Example 2: Specific Error Handling ===\")\ndo {\n    try registerUser(name: \"\", email: \"test@example.com\", age: 30, password: \"secure123\")\n} catch ValidationError.emptyField(let fieldName) {\n    print(\"Please fill in the \\(fieldName) field\")\n} catch ValidationError.tooShort(let fieldName, let minLength) {\n    print(\"\\(fieldName) must be at least \\(minLength) characters\")\n} catch {\n    print(\"Registration failed: \\(error)\")\n}\n\n// Example 3: Using try? (optional try)\nprint(\"\\n=== Example 3: Optional Try ===\")\nif let data = try? fetchData(from: \"https://api.example.com/data\") {\n    print(\"Success: \\(data)\")\n} else {\n    print(\"Failed to fetch data\")\n}\n\n// Example 4: Multiple throwing operations\nprint(\"\\n=== Example 4: Multiple Operations ===\")\nfunc completeUserSetup() {\n    do {\n        try validateAge(20)\n        let result = try registerUser(name: \"Alice\", email: \"alice@example.com\", age: 20, password: \"password123\")\n        print(result)\n        \n        let data = try fetchData(from: \"https://api.example.com/user\")\n        print(\"Fetched: \\(data)\")\n        \n    } catch ValidationError.emptyField(let fieldName) {\n        print(\"Error: \\(fieldName) cannot be empty\")\n    } catch ValidationError.invalidFormat(let fieldName) {\n        print(\"Error: \\(fieldName) has invalid format\")\n    } catch let networkError as NetworkError {\n        print(\"Network error: \\(networkError)\")\n    } catch {\n        print(\"Unexpected error: \\(error)\")\n    }\n}\n\ncompleteUserSetup()\n\n// Example 5: Error propagation\nprint(\"\\n=== Example 5: Error Propagation ===\")\nfunc processUserData(name: String, email: String) throws -> String {\n    // Each of these can throw errors\n    try validateAge(25)\n    let registrationMessage = try registerUser(name: name, email: email, age: 25, password: \"test123\")\n    let data = try fetchData(from: \"https://api.example.com/users\")\n    \n    return \"\\(registrationMessage) Data: \\(data)\"\n}\n\n// Handle all propagated errors in one place\ndo {\n    let finalResult = try processUserData(name: \"Bob\", email: \"bob@example.com\")\n    print(\"Final result: \\(finalResult)\")\n} catch {\n    print(\"Process failed: \\(error)\")\n}\n\n// Example 6: Practical file operation simulation\nprint(\"\\n=== Example 6: File Operations ===\")\nfunc readConfigurationFile() throws -> String {\n    let fileExists = Bool.random()\n    \n    if !fileExists {\n        throw FileSystemError.fileNotFound(path: \"/config/app.json\")\n    }\n    \n    let diskHasSpace = Bool.random()\n    if !diskHasSpace {\n        throw FileSystemError.diskFull\n    }\n    \n    return \"Configuration data\"\n}\n\nfunc loadAppConfiguration() {\n    do {\n        let config = try readConfigurationFile()\n        print(\"Configuration loaded: \\(config)\")\n    } catch FileSystemError.fileNotFound(let path) {\n        print(\"Configuration file not found at: \\(path)\")\n    } catch FileSystemError.diskFull {\n        print(\"Disk is full. Please free up some space.\")\n    } catch {\n        print(\"Failed to load configuration: \\(error)\")\n    }\n}\n\nloadAppConfiguration()",
      "category": "Swift Basics",
      "estimatedTime": 120,
      "dependencies": ["functions", "enums"],
      "challenge": {
        "instructions": "Create a complete user registration system with comprehensive error handling:\n\nPART 1: Define Error Types (30 min)\n1. Create 'RegistrationError' enum with cases: invalidUsername, invalidEmail, weakPassword, ageRestriction, duplicateUser\n2. Create 'NetworkError' enum with cases: noConnection, serverDown, timeout, invalidResponse\n3. Add descriptive properties to each error case\n\nPART 2: Validation Functions (45 min)\n4. Create 'validateUsername()' that throws RegistrationError for: empty, too short, invalid characters\n5. Create 'validateEmail()' that throws for: empty, missing @, invalid format\n6. Create 'validatePassword()' that throws for: too short, no numbers, no uppercase\n7. Create 'validateAge()' that throws for: under 13, over 150\n\nPART 3: Registration System (45 min)\n8. Create 'registerUser()' function that calls all validations and throws appropriate errors\n9. Simulate network check with 'checkNetworkAvailability()' that throws NetworkError\n10. Simulate database check with 'checkDuplicateUser()' that throws duplicateUser error\n11. Create a main 'completeRegistration()' function that handles all errors gracefully\n\nPART 4: Advanced Error Handling (60 min)\n12. Add retry mechanism for network errors with maximum 3 attempts\n13. Create user-friendly error messages for each error case\n14. Implement different handling strategies for validation vs network errors\n15. Add logging for all errors while showing user-friendly messages\n\nTest your system with various valid and invalid inputs to ensure robust error handling!",
        "starterCode": "// === PART 1: Define Error Types ===\n// Create your error enums here\n\n\n// === PART 2: Validation Functions ===\n// Create validation functions here\n\n\n// === PART 3: Registration System ===\n// Create registration functions here\n\n\n// === PART 4: Advanced Error Handling ===\n// Add retry mechanism and error messaging here\n\n",
        "solution": "// === PART 1: Define Error Types ===\nenum RegistrationError: Error, CustomStringConvertible {\n    case invalidUsername(reason: String)\n    case invalidEmail\n    case weakPassword(strengthIssue: String)\n    case ageRestriction(minAge: Int)\n    case duplicateUser(username: String)\n    \n    var description: String {\n        switch self {\n        case .invalidUsername(let reason):\n            return \"Invalid username: \\(reason)\"\n        case .invalidEmail:\n            return \"Invalid email format\"\n        case .weakPassword(let issue):\n            return \"Weak password: \\(issue)\"\n        case .ageRestriction(let minAge):\n            return \"Must be at least \\(minAge) years old\"\n        case .duplicateUser(let username):\n            return \"Username '\\(username)' is already taken\"\n        }\n    }\n}\n\nenum NetworkError: Error, CustomStringConvertible {\n    case noConnection\n    case serverDown\n    case timeout\n    case invalidResponse\n    \n    var description: String {\n        switch self {\n        case .noConnection:\n            return \"No internet connection\"\n        case .serverDown:\n            return \"Server is temporarily unavailable\"\n        case .timeout:\n            return \"Request timed out\"\n        case .invalidResponse:\n            return \"Received invalid response from server\"\n        }\n    }\n}\n\n// === PART 2: Validation Functions ===\nfunc validateUsername(_ username: String) throws {\n    guard !username.isEmpty else {\n        throw RegistrationError.invalidUsername(reason: \"Username cannot be empty\")\n    }\n    \n    guard username.count >= 3 else {\n        throw RegistrationError.invalidUsername(reason: \"Username must be at least 3 characters\")\n    }\n    \n    guard username.count <= 20 else {\n        throw RegistrationError.invalidUsername(reason: \"Username cannot exceed 20 characters\")\n    }\n    \n    let invalidCharacters = CharacterSet.alphanumerics.inverted\n    guard username.rangeOfCharacter(from: invalidCharacters) == nil else {\n        throw RegistrationError.invalidUsername(reason: \"Username can only contain letters and numbers\")\n    }\n}\n\nfunc validateEmail(_ email: String) throws {\n    guard !email.isEmpty else {\n        throw RegistrationError.invalidEmail\n    }\n    \n    let emailRegex = \"[A-Z0-9a-z._%+-]+@[A-Za-z0-9.-]+\\\\.[A-Za-z]{2,}\"\n    let emailPredicate = NSPredicate(format: \"SELF MATCHES %@\", emailRegex)\n    \n    guard emailPredicate.evaluate(with: email) else {\n        throw RegistrationError.invalidEmail\n    }\n}\n\nfunc validatePassword(_ password: String) throws {\n    guard !password.isEmpty else {\n        throw RegistrationError.weakPassword(strengthIssue: \"Password cannot be empty\")\n    }\n    \n    guard password.count >= 8 else {\n        throw RegistrationError.weakPassword(strengthIssue: \"Password must be at least 8 characters\")\n    }\n    \n    let numberRegex = \".*[0-9].*\"\n    let numberPredicate = NSPredicate(format: \"SELF MATCHES %@\", numberRegex)\n    guard numberPredicate.evaluate(with: password) else {\n        throw RegistrationError.weakPassword(strengthIssue: \"Password must contain at least one number\")\n    }\n    \n    let uppercaseRegex = \".*[A-Z].*\"\n    let uppercasePredicate = NSPredicate(format: \"SELF MATCHES %@\", uppercaseRegex)\n    guard uppercasePredicate.evaluate(with: password) else {\n        throw RegistrationError.weakPassword(strengthIssue: \"Password must contain at least one uppercase letter\")\n    }\n}\n\nfunc validateAge(_ age: Int) throws {\n    guard age >= 13 else {\n        throw RegistrationError.ageRestriction(minAge: 13)\n    }\n    \n    guard age <= 150 else {\n        throw RegistrationError.invalidUsername(reason: \"Age must be 150 or less\")\n    }\n}\n\n// === PART 3: Registration System ===\nfunc checkNetworkAvailability() throws {\n    // Simulate network check\n    let isOnline = Bool.random()\n    if !isOnline {\n        throw NetworkError.noConnection\n    }\n    \n    let serverIsUp = Bool.random()\n    if !serverIsUp {\n        throw NetworkError.serverDown\n    }\n}\n\nfunc checkDuplicateUser(username: String) throws {\n    // Simulate database check\n    let existingUsers = [\"alice\", \"bob\", \"charlie\"]\n    if existingUsers.contains(username.lowercased()) {\n        throw RegistrationError.duplicateUser(username: username)\n    }\n}\n\nfunc registerUser(username: String, email: String, password: String, age: Int) throws -> String {\n    // Validate all inputs\n    try validateUsername(username)\n    try validateEmail(email)\n    try validatePassword(password)\n    try validateAge(age)\n    \n    // Check network\n    try checkNetworkAvailability()\n    \n    // Check for duplicates\n    try checkDuplicateUser(username: username)\n    \n    // Simulate successful registration\n    return \"User '\\(username)' registered successfully!\"\n}\n\n// === PART 4: Advanced Error Handling ===\nfunc completeRegistration(username: String, email: String, password: String, age: Int) {\n    print(\"Starting registration for: \\(username)\")\n    \n    let maxRetries = 3\n    var attempts = 0\n    \n    while attempts < maxRetries {\n        do {\n            attempts += 1\n            print(\"Attempt \\(attempts) of \\(maxRetries)\")\n            \n            let result = try registerUser(username: username, email: email, password: password, age: age)\n            print(\"âœ… SUCCESS: \\(result)\")\n            return\n            \n        } catch let error as RegistrationError {\n            // Validation errors - no retry needed\n            print(\"âŒ Registration Error: \\(error.description)\")\n            return\n            \n        } catch let error as NetworkError {\n            // Network errors - can retry\n            print(\"ðŸŒ Network Error: \\(error.description)\")\n            \n            if attempts >= maxRetries {\n                print(\"ðŸš« Maximum retry attempts reached. Please try again later.\")\n                return\n            } else {\n                print(\"ðŸ”„ Retrying in 2 seconds...\")\n                // In real app, you'd use proper async delay\n                Thread.sleep(forTimeInterval: 2.0)\n            }\n            \n        } catch {\n            // Unexpected errors\n            print(\"ðŸ’¥ Unexpected error: \\(error)\")\n            return\n        }\n    }\n}\n\n// User-friendly error handler\nfunc handleRegistrationError(_ error: Error) -> String {\n    if let registrationError = error as? RegistrationError {\n        switch registrationError {\n        case .invalidUsername(let reason):\n            return \"Please choose a different username. \\(reason)\"\n        case .invalidEmail:\n            return \"Please enter a valid email address\"\n        case .weakPassword(let issue):\n            return \"Please strengthen your password. \\(issue)\"\n        case .ageRestriction(let minAge):\n            return \"You must be at least \\(minAge) years old to register\"\n        case .duplicateUser(let username):\n            return \"The username '\\(username)' is already taken. Please choose another.\"\n        }\n    } else if let networkError = error as? NetworkError {\n        switch networkError {\n        case .noConnection:\n            return \"Please check your internet connection and try again\"\n        case .serverDown:\n            return \"Our servers are temporarily busy. Please try again in a few minutes\"\n        case .timeout:\n            return \"The request took too long. Please try again\"\n        case .invalidResponse:\n            return \"We encountered an issue. Please try again\"\n        }\n    } else {\n        return \"An unexpected error occurred. Please try again\"\n    }\n}\n\n// Test the system\nprint(\"=== TEST 1: Valid Registration ===\")\ncompleteRegistration(username: \"john_doe\", email: \"john@example.com\", password: \"Secure123\", age: 25)\n\nprint(\"\\n=== TEST 2: Invalid Username ===\")\ncompleteRegistration(username: \"ab\", email: \"test@example.com\", password: \"Secure123\", age: 25)\n\nprint(\"\\n=== TEST 3: Weak Password ===\")\ncompleteRegistration(username: \"jane_doe\", email: \"jane@example.com\", password: \"weak\", age: 30)\n\nprint(\"\\n=== TEST 4: Network Issues ===\")\ncompleteRegistration(username: \"test_user\", email: \"test@example.com\", password: \"Secure123\", age: 20)",
        "hints": [
          "PART 1: Use enums with Error protocol. Add CustomStringConvertible for user-friendly messages",
          "PART 2: Use guard statements to check conditions and throw errors when validation fails",
          "PART 3: Chain multiple throwing functions - if any fails, the entire operation fails",
          "PART 4: Use retry loops for recoverable errors (network), but not for validation errors",
          "Create separate error types for different categories (validation vs network)",
          "Use pattern matching in catch blocks to handle specific error cases",
          "Provide both technical logging and user-friendly error messages",
          "Remember: Validation errors should not be retried - they need user input correction"
        ],
        "testCases": [
          {
            "input": "try validateUsername(\"validUser123\")",
            "expectedOutput": "No error thrown",
            "description": "Valid username should pass validation"
          },
          {
            "input": "try validateUsername(\"ab\")",
            "expectedOutput": "RegistrationError.invalidUsername",
            "description": "Short username should throw error"
          },
          {
            "input": "try validatePassword(\"Weak1\")",
            "expectedOutput": "RegistrationError.weakPassword",
            "description": "Short password should throw error"
          },
          {
            "input": "try validateAge(12)",
            "expectedOutput": "RegistrationError.ageRestriction",
            "description": "Age under 13 should throw restriction error"
          }
        ]
      }
    },
    {
      "id": "swiftui_introduction",
      "title": "SwiftUI Introduction - Views, Modifiers & Previews",
      "description": "Build your first SwiftUI apps with declarative syntax, custom views, and live previews",
      "difficulty": "beginner",
      "theory": "# SwiftUI Introduction - Views, Modifiers & Previews\n\n## 1. What is SwiftUI? (45 min)\n\n### Declarative vs Imperative Programming\n- **Imperative**: Tell HOW to do things (UIKit)\n- **Declarative**: Tell WHAT you want (SwiftUI)\n\n### SwiftUI Benefits:\n- **Less code** - up to 70% reduction\n- **Live Preview** - see changes instantly\n- **Automatic support** for Dark Mode, Dynamic Type\n- **Native performance** across all Apple platforms\n\n### Basic Structure:\n```swift\nimport SwiftUI\n\nstruct ContentView: View {\n    var body: some View {\n        Text(\"Hello, SwiftUI!\")\n    }\n}\n```\n\n## 2. Your First Views (60 min)\n\n### Text Views:\n```swift\nText(\"Hello, World!\")\n    .font(.title)\n    .foregroundColor(.blue)\n```\n\n### Stack Containers:\n```swift\n// Vertical Stack\nVStack {\n    Text(\"First\")\n    Text(\"Second\")\n    Text(\"Third\")\n}\n\n// Horizontal Stack\nHStack {\n    Text(\"Left\")\n    Text(\"Right\")\n}\n\n// Overlapping Stack\nZStack {\n    Circle()\n        .fill(Color.blue)\n    Text(\"Center\")\n}\n```\n\n### Basic Shapes:\n```swift\nCircle()\n    .fill(Color.red)\n    .frame(width: 100, height: 100)\n\nRectangle()\n    .fill(Color.green)\n    .frame(width: 200, height: 100)\n\nRoundedRectangle(cornerRadius: 25)\n    .fill(Color.orange)\n    .frame(width: 150, height: 80)\n```\n\n## 3. Modifiers - Styling Your Views (60 min)\n\n### What are Modifiers?\n- Methods that return NEW views with modifications\n- Order matters!\n- Chain multiple modifiers together\n\n### Common Modifiers:\n```swift\nText(\"Styled Text\")\n    .font(.largeTitle)           // Font size\n    .fontWeight(.bold)           // Font weight\n    .foregroundColor(.white)     // Text color\n    .padding()                   // Add space around\n    .background(Color.blue)      // Background color\n    .cornerRadius(10)            // Rounded corners\n    .shadow(radius: 5)           // Drop shadow\n```\n\n### Order Matters Example:\n```swift\n// Different results based on order\nText(\"Order Matters\")\n    .padding()\n    .background(Color.blue)     // Blue background WITH padding\n\nText(\"Order Matters\")\n    .background(Color.blue)     // Blue background ONLY behind text\n    .padding()                  // Padding around blue background\n```\n\n### Frame Modifier:\n```swift\nText(\"Sized Text\")\n    .frame(width: 200, height: 100)        // Fixed size\n    .frame(maxWidth: .infinity)            // Flexible width\n    .frame(height: 50)                     // Fixed height only\n    .frame(maxWidth: .infinity, maxHeight: .infinity)  // Fill all space\n```\n\n## 4. Layout System (45 min)\n\n### SwiftUI Layout Process:\n1. **Parent proposes size** to child\n2. **Child chooses its size**\n3. **Parent places child** in coordinate space\n\n### Spacers and Alignment:\n```swift\nHStack {\n    Text(\"Left\")\n    Spacer()                    // Pushes views apart\n    Text(\"Right\")\n}\n\nVStack(alignment: .leading) {   // Align all children to leading edge\n    Text(\"First\")\n    Text(\"Second\")\n    Text(\"Third\")\n}\n```\n\n### Padding and Margins:\n```swift\nText(\"Padded Text\")\n    .padding()                          // Default padding (16pt)\n    .padding(20)                        // Custom padding\n    .padding(.horizontal, 10)           // Directional padding\n    .padding([.top, .bottom], 5)        // Multiple edges\n```\n\n## 5. Previews - Your Development Superpower (45 min)\n\n### Basic Preview:\n```swift\nstruct ContentView_Previews: PreviewProvider {\n    static var previews: some View {\n        ContentView()\n    }\n}\n```\n\n### Multiple Previews:\n```swift\nstruct ContentView_Previews: PreviewProvider {\n    static var previews: some View {\n        Group {\n            ContentView()\n                .previewDisplayName(\"Light Mode\")\n            \n            ContentView()\n                .preferredColorScheme(.dark)\n                .previewDisplayName(\"Dark Mode\")\n            \n            ContentView()\n                .previewDevice(\"iPhone SE (2nd generation)\")\n                .previewDisplayName(\"Small Screen\")\n        }\n    }\n}\n```\n\n### Preview Modifiers:\n```swift\nContentView()\n    .previewLayout(.sizeThatFits)    // Shows only content size\n    .previewLayout(.fixed(width: 400, height: 300))  // Fixed size\n    .environment(\\.sizeCategory, .accessibilityLarge)  // Large text\n    .environment(\\.locale, .init(identifier: \"es\"))    // Spanish locale\n```\n\n## 6. Building Custom Views (45 min)\n\n### View Composition:\n```swift\nstruct WelcomeHeader: View {\n    let username: String\n    \n    var body: some View {\n        VStack {\n            Image(systemName: \"person.circle.fill\")\n                .font(.system(size: 60))\n                .foregroundColor(.blue)\n            \n            Text(\"Welcome, \\(username)!\")\n                .font(.title2)\n                .fontWeight(.semibold)\n        }\n    }\n}\n\n// Usage\nWelcomeHeader(username: \"John\")\n```\n\n### Reusable Button Style:\n```swift\nstruct PrimaryButton: View {\n    let title: String\n    let action: () -> Void\n    \n    var body: some View {\n        Button(action: action) {\n            Text(title)\n                .fontWeight(.bold)\n                .foregroundColor(.white)\n                .padding()\n                .frame(maxWidth: .infinity)\n                .background(Color.blue)\n                .cornerRadius(10)\n        }\n    }\n}\n\n// Usage\nPrimaryButton(title: \"Tap Me!\") {\n    print(\"Button tapped!\")\n}\n```\n\n## 7. Working with Images (30 min)\n\n### System Icons (SF Symbols):\n```swift\nImage(systemName: \"heart.fill\")\n    .font(.title)\n    .foregroundColor(.red)\n\nImage(systemName: \"star\")\n    .imageScale(.large)\n    .foregroundColor(.yellow)\n```\n\n### Custom Images:\n```swift\nImage(\"myPhoto\")                    // From asset catalog\n    .resizable()                    // Make resizable\n    .scaledToFit()                  // Maintain aspect ratio\n    .frame(width: 200, height: 200)\n    .clipShape(Circle())            // Circular crop\n```\n\n### Image Modifiers:\n```swift\nImage(\"landscape\")\n    .resizable()\n    .aspectRatio(contentMode: .fill)    // Fill space, may crop\n    .frame(width: 300, height: 200)\n    .clipped()                          // Prevent overflow\n    .overlay(\n        Text(\"Scenic View\")\n            .foregroundColor(.white)\n            .padding(5)\n            .background(Color.black.opacity(0.7))\n            .cornerRadius(5)\n            .padding(10),\n        alignment: .bottomTrailing\n    )\n```\n\n## Practical Patterns & Best Practices (30 min)\n\n### Keep Views Small:\n- Break complex views into smaller components\n- Each view should have single responsibility\n- Use descriptive names for custom views\n\n### Modifier Organization:\n```swift\n// Good: Organized and readable\nText(\"Hello\")\n    .font(.title)\n    .foregroundColor(.primary)\n    .padding()\n    .background(Color.secondary)\n    .cornerRadius(8)\n\n// Group related modifiers\n.background(\n    Color.blue\n        .cornerRadius(10)\n        .shadow(radius: 5)\n)\n```\n\n### Preview Best Practices:\n- Preview multiple states (loading, error, success)\n- Test different screen sizes\n- Verify Dark Mode appearance\n- Check accessibility sizes\n\n## Practice Exercises\n\nComplete all exercises to master SwiftUI fundamentals!",
      "codeExample": "// === BASIC VIEWS EXAMPLE ===\n\nimport SwiftUI\n\nstruct BasicViewsExample: View {\n    var body: some View {\n        VStack(spacing: 20) {\n            // Text with various modifiers\n            Text(\"Welcome to SwiftUI!\")\n                .font(.largeTitle)\n                .fontWeight(.bold)\n                .foregroundColor(.blue)\n            \n            // System icon\n            Image(systemName: \"swift\")\n                .font(.system(size: 60))\n                .foregroundColor(.orange)\n            \n            // Horizontal stack with spacer\n            HStack {\n                Text(\"Left\")\n                Spacer()\n                Text(\"Right\")\n            }\n            .padding(.horizontal)\n            \n            // Custom button\n            Button(action: {\n                print(\"Button tapped!\")\n            }) {\n                HStack {\n                    Image(systemName: \"star.fill\")\n                    Text(\"Favorite\")\n                }\n                .foregroundColor(.white)\n                .padding()\n                .background(Color.purple)\n                .cornerRadius(10)\n            }\n        }\n    }\n}\n\n// === MODIFIERS DEMONSTRATION ===\n\nstruct ModifiersExample: View {\n    var body: some View {\n        VStack(spacing: 30) {\n            // Order matters demonstration\n            VStack {\n                Text(\"Order Example 1\")\n                    .padding()\n                    .background(Color.red)\n                \n                Text(\"Order Example 2\")\n                    .background(Color.red)\n                    .padding()\n            }\n            \n            // Frame and alignment\n            HStack {\n                Text(\"Start\")\n                    .frame(width: 100, height: 50)\n                    .background(Color.green)\n                \n                Spacer()\n                \n                Text(\"End\")\n                    .frame(maxWidth: .infinity, minHeight: 40)\n                    .background(Color.blue)\n                    .foregroundColor(.white)\n            }\n            \n            // Complex modifier chain\n            Text(\"Beautiful Text\")\n                .font(.title2)\n                .fontWeight(.semibold)\n                .foregroundColor(.white)\n                .padding()\n                .background(\n                    LinearGradient(\n                        gradient: Gradient(colors: [.blue, .purple]),\n                        startPoint: .leading,\n                        endPoint: .trailing\n                    )\n                )\n                .cornerRadius(15)\n                .shadow(color: .gray, radius: 5, x: 0, y: 2)\n        }\n        .padding()\n    }\n}\n\n// === CUSTOM VIEW EXAMPLE ===\n\nstruct ProfileCard: View {\n    let name: String\n    let role: String\n    let imageName: String\n    \n    var body: some View {\n        VStack {\n            Image(systemName: imageName)\n                .font(.system(size: 70))\n                .foregroundColor(.blue)\n                .padding()\n                .background(Color.blue.opacity(0.1))\n                .clipShape(Circle())\n            \n            Text(name)\n                .font(.title2)\n                .fontWeight(.bold)\n            \n            Text(role)\n                .font(.body)\n                .foregroundColor(.secondary)\n            \n            HStack {\n                Button(\"Follow\") {\n                    print(\"Follow tapped\")\n                }\n                .buttonStyle(ProfileButtonStyle(backgroundColor: .blue))\n                \n                Button(\"Message\") {\n                    print(\"Message tapped\")\n                }\n                .buttonStyle(ProfileButtonStyle(backgroundColor: .green))\n            }\n        }\n        .padding()\n        .background(Color.white)\n        .cornerRadius(20)\n        .shadow(radius: 5)\n        .padding()\n    }\n}\n\nstruct ProfileButtonStyle: ButtonStyle {\n    let backgroundColor: Color\n    \n    func makeBody(configuration: Configuration) -> some View {\n        configuration.label\n            .foregroundColor(.white)\n            .padding(.horizontal, 20)\n            .padding(.vertical, 10)\n            .background(backgroundColor)\n            .cornerRadius(8)\n            .scaleEffect(configuration.isPressed ? 0.95 : 1.0)\n    }\n}\n\n// === COMPLETE EXAMPLE VIEW ===\n\nstruct SwiftUIIntroductionExample: View {\n    var body: some View {\n        ScrollView {\n            VStack(spacing: 30) {\n                ProfileCard(\n                    name: \"Sarah Johnson\",\n                    role: \"iOS Developer\",\n                    imageName: \"person.crop.circle.fill\"\n                )\n                \n                BasicViewsExample()\n                    .padding()\n                    .background(Color.gray.opacity(0.1))\n                    .cornerRadius(15)\n                \n                ModifiersExample()\n            }\n        }\n    }\n}\n\n// === PREVIEWS WITH MULTIPLE CONFIGURATIONS ===\n\nstruct SwiftUIIntroductionExample_Previews: PreviewProvider {\n    static var previews: some View {\n        Group {\n            SwiftUIIntroductionExample()\n                .previewDisplayName(\"Light Mode\")\n            \n            SwiftUIIntroductionExample()\n                .preferredColorScheme(.dark)\n                .previewDisplayName(\"Dark Mode\")\n            \n            SwiftUIIntroductionExample()\n                .previewDevice(\"iPhone SE (2nd generation)\")\n                .previewDisplayName(\"Small Screen\")\n            \n            SwiftUIIntroductionExample()\n                .previewDevice(\"iPad Pro (12.9-inch) (5th generation)\")\n                .previewDisplayName(\"iPad\")\n        }\n    }\n}\n\n// === USAGE EXAMPLE ===\n\nstruct ContentView: View {\n    var body: some View {\n        NavigationView {\n            SwiftUIIntroductionExample()\n                .navigationTitle(\"SwiftUI Basics\")\n                .navigationBarTitleDisplayMode(.large)\n        }\n    }\n}",
      "category": "SwiftUI Basics",
      "estimatedTime": 180,
      "dependencies": ["variables", "structs_classes"],
      "challenge": {
        "instructions": "Create a complete user profile interface using SwiftUI fundamentals:\n\nPART 1: Basic Layout Structure (60 min)\n1. Create a scrollable profile screen with a VStack as the main container\n2. Add a profile header section with user image, name, and title\n3. Create a stats row showing followers, following, and posts count\n4. Add a bio section with placeholder text\n\nPART 2: Custom Modifiers & Styling (60 min)\n5. Create custom view modifiers for:\n   - Primary buttons (blue background, white text, rounded corners)\n   - Secondary buttons (border only, transparent background)\n   - Card containers (white background, shadow, rounded corners)\n6. Apply consistent spacing, colors, and typography throughout\n7. Use SF Symbols for all icons\n\nPART 3: Interactive Components (60 min)\n8. Add a follow button that toggles between \"Follow\" and \"Following\" states\n9. Create a message button that shows an alert when tapped\n10. Build a tabbed section for Posts, Photos, and Likes\n11. Implement a grid layout for user photos (use placeholder rectangles)\n\nPART 4: Advanced Previews & Responsive Design (60 min)\n12. Create comprehensive previews showing light/dark mode, different devices\n13. Ensure layout works on both iPhone and iPad sizes\n14. Add accessibility modifiers for VoiceOver support\n15. Implement responsive design that adapts to orientation changes\n\nTest your implementation thoroughly in the preview canvas!",
        "starterCode": "import SwiftUI\n\nstruct ProfileView: View {\n    var body: some View {\n        Text(\"Build your profile view here!\")\n    }\n}\n\n// === Custom Modifiers ===\n// Create your custom view modifiers here\n\n// === Preview Section ===\nstruct ProfileView_Previews: PreviewProvider {\n    static var previews: some View {\n        ProfileView()\n    }\n}",
        "solution": "import SwiftUI\n\n// === Custom Modifiers ===\nstruct PrimaryButton: ViewModifier {\n    func body(content: Content) -> some View {\n        content\n            .font(.headline)\n            .foregroundColor(.white)\n            .padding(.horizontal, 24)\n            .padding(.vertical, 12)\n            .background(Color.blue)\n            .cornerRadius(25)\n            .shadow(color: .blue.opacity(0.3), radius: 5, x: 0, y: 2)\n    }\n}\n\nstruct SecondaryButton: ViewModifier {\n    func body(content: Content) -> some View {\n        content\n            .font(.headline)\n            .foregroundColor(.blue)\n            .padding(.horizontal, 24)\n            .padding(.vertical, 12)\n            .overlay(\n                RoundedRectangle(cornerRadius: 25)\n                    .stroke(Color.blue, lineWidth: 2)\n            )\n    }\n}\n\nstruct CardModifier: ViewModifier {\n    func body(content: Content) -> some View {\n        content\n            .padding()\n            .background(Color.white)\n            .cornerRadius(12)\n            .shadow(color: .gray.opacity(0.2), radius: 8, x: 0, y: 2)\n    }\n}\n\nextension View {\n    func primaryButton() -> some View {\n        modifier(PrimaryButton())\n    }\n    \n    func secondaryButton() -> some View {\n        modifier(SecondaryButton())\n    }\n    \n    func cardStyle() -> some View {\n        modifier(CardModifier())\n    }\n}\n\n// === Main Profile View ===\nstruct ProfileView: View {\n    @State private var isFollowing = false\n    @State private var selectedTab = 0\n    @State private var showMessageAlert = false\n    \n    let userStats = [\n        (\"12K\", \"Followers\"),\n        (\"563\", \"Following\"), \n        (\"128\", \"Posts\")\n    ]\n    \n    let tabs = [\"Posts\", \"Photos\", \"Likes\"]\n    \n    var body: some View {\n        ScrollView {\n            VStack(spacing: 20) {\n                // Profile Header\n                VStack(spacing: 16) {\n                    Image(systemName: \"person.circle.fill\")\n                        .font(.system(size: 100))\n                        .foregroundColor(.blue)\n                    \n                    VStack(spacing: 8) {\n                        Text(\"Sarah Johnson\")\n                            .font(.title)\n                            .fontWeight(.bold)\n                        \n                        Text(\"iOS Developer @ Apple\")\n                            .font(.body)\n                            .foregroundColor(.secondary)\n                    }\n                    \n                    HStack(spacing: 16) {\n                        Button(action: {\n                            isFollowing.toggle()\n                        }) {\n                            HStack {\n                                Image(systemName: isFollowing ? \"checkmark\" : \"person.badge.plus\")\n                                Text(isFollowing ? \"Following\" : \"Follow\")\n                            }\n                            .primaryButton()\n                        }\n                        \n                        Button(action: {\n                            showMessageAlert = true\n                        }) {\n                            HStack {\n                                Image(systemName: \"message\")\n                                Text(\"Message\")\n                            }\n                            .secondaryButton()\n                        }\n                    }\n                }\n                .padding()\n                .cardStyle()\n                \n                // Stats Row\n                HStack {\n                    ForEach(userStats, id: \\.1) { stat in\n                        VStack {\n                            Text(stat.0)\n                                .font(.title2)\n                                .fontWeight(.bold)\n                                .foregroundColor(.primary)\n                            \n                            Text(stat.1)\n                                .font(.caption)\n                                .foregroundColor(.secondary)\n                        }\n                        .frame(maxWidth: .infinity)\n                    }\n                }\n                .padding()\n                .cardStyle()\n                \n                // Bio Section\n                VStack(alignment: .leading, spacing: 12) {\n                    Text(\"About\")\n                        .font(.headline)\n                        .fontWeight(.semibold)\n                    \n                    Text(\"Passionate iOS developer with 5+ years of experience building beautiful, user-friendly applications. Love working with SwiftUI and exploring new technologies.\")\n                        .font(.body)\n                        .foregroundColor(.secondary)\n                        .lineSpacing(4)\n                }\n                .frame(maxWidth: .infinity, alignment: .leading)\n                .padding()\n                .cardStyle()\n                \n                // Tabbed Content\n                VStack(spacing: 16) {\n                    // Tab Selector\n                    HStack {\n                        ForEach(0..<tabs.count, id: \\.self) { index in\n                            Button(action: {\n                                selectedTab = index\n                            }) {\n                                Text(tabs[index])\n                                    .font(.headline)\n                                    .foregroundColor(selectedTab == index ? .blue : .secondary)\n                                    .padding(.vertical, 8)\n                                    .frame(maxWidth: .infinity)\n                                    .overlay(\n                                        Rectangle()\n                                            .fill(selectedTab == index ? Color.blue : Color.clear)\n                                            .frame(height: 2)\n                                            .offset(y: 16),\n                                        alignment: .bottom\n                                    )\n                            }\n                        }\n                    }\n                    \n                    // Tab Content\n                    Group {\n                        switch selectedTab {\n                        case 0:\n                            PostsTabView()\n                        case 1:\n                            PhotosTabView()\n                        case 2:\n                            LikesTabView()\n                        default:\n                            EmptyView()\n                        }\n                    }\n                    .animation(.easeInOut, value: selectedTab)\n                }\n                .padding()\n                .cardStyle()\n            }\n            .padding()\n        }\n        .background(Color(.systemGroupedBackground))\n        .alert(\"Message Sent!\", isPresented: $showMessageAlert) {\n            Button(\"OK\", role: .cancel) { }\n        } message: {\n            Text(\"Your message has been sent to Sarah.\")\n        }\n    }\n}\n\n// === Tab Views ===\nstruct PostsTabView: View {\n    var body: some View {\n        VStack(spacing: 16) {\n            ForEach(0..<3, id: \\.self) { _ in\n                HStack(alignment: .top, spacing: 12) {\n                    Image(systemName: \"text.alignleft\")\n                        .font(.title2)\n                        .foregroundColor(.blue)\n                        .frame(width: 40)\n                    \n                    VStack(alignment: .leading, spacing: 8) {\n                        Text(\"Latest Project Update\")\n                            .font(.headline)\n                        \n                        Text(\"Just shipped a new feature using SwiftUI! The declarative syntax makes building UIs so much faster and more enjoyable.\")\n                            .font(.body)\n                            .foregroundColor(.secondary)\n                            .lineSpacing(4)\n                        \n                        Text(\"2 hours ago\")\n                            .font(.caption)\n                            .foregroundColor(.secondary)\n                    }\n                    \n                    Spacer()\n                }\n                .padding()\n                .background(Color.gray.opacity(0.1))\n                .cornerRadius(8)\n            }\n        }\n    }\n}\n\nstruct PhotosTabView: View {\n    let columns = [\n        GridItem(.flexible()),\n        GridItem(.flexible()),\n        GridItem(.flexible())\n    ]\n    \n    var body: some View {\n        LazyVGrid(columns: columns, spacing: 8) {\n            ForEach(0..<9, id: \\.self) { index in\n                Rectangle()\n                    .fill(Color.blue.opacity(0.3))\n                    .aspectRatio(1, contentMode: .fit)\n                    .overlay(\n                        Image(systemName: [\"photo\", \"camera\", \"person\"][index % 3])\n                            .font(.title2)\n                            .foregroundColor(.blue)\n                    )\n                    .cornerRadius(8)\n            }\n        }\n    }\n}\n\nstruct LikesTabView: View {\n    var body: some View {\n        VStack(spacing: 20) {\n            Image(systemName: \"heart.fill\")\n                .font(.system(size: 60))\n                .foregroundColor(.red)\n            \n            Text(\"Recent Likes\")\n                .font(.title2)\n                .fontWeight(.semibold)\n            \n            Text(\"Your liked content will appear here\")\n                .font(.body)\n                .foregroundColor(.secondary)\n                .multilineTextAlignment(.center)\n        }\n        .frame(maxWidth: .infinity)\n        .padding(.vertical, 40)\n    }\n}\n\n// === Comprehensive Previews ===\nstruct ProfileView_Previews: PreviewProvider {\n    static var previews: some View {\n        Group {\n            ProfileView()\n                .previewDisplayName(\"iPhone Light\")\n            \n            ProfileView()\n                .preferredColorScheme(.dark)\n                .previewDisplayName(\"iPhone Dark\")\n            \n            ProfileView()\n                .previewDevice(\"iPhone SE (2nd generation)\")\n                .previewDisplayName(\"iPhone SE\")\n            \n            ProfileView()\n                .previewDevice(\"iPad Pro (12.9-inch) (5th generation)\")\n                .previewDisplayName(\"iPad Pro\")\n            \n            // Accessibility preview\n            ProfileView()\n                .environment(\\.sizeCategory, .accessibilityLarge)\n                .previewDisplayName(\"Large Text\")\n        }\n    }\n}",
        "hints": [
          "PART 1: Use VStack as your main container and ScrollView for scrollable content",
          "PART 2: Create ViewModifier protocols for reusable styling. Order matters in modifier chains!",
          "PART 3: Use @State for properties that change and trigger view updates. Toggle boolean values for state changes",
          "PART 4: PreviewProvider can show multiple device configurations. Use Group to organize them",
          "Use .frame(maxWidth: .infinity) to make views fill available space",
          "SF Symbols are Apple's icon system - use Image(systemName:) to access them",
          "LazyVGrid is perfect for creating photo grid layouts",
          "Add accessibility labels with .accessibilityLabel() for VoiceOver support",
          "Use .preferredColorScheme(.dark) to preview dark mode appearance",
          "Chain animations with .animation() modifier for smooth transitions"
        ],
        "testCases": [
          {
            "input": "isFollowing state changes correctly",
            "expectedOutput": "Button text toggles between 'Follow' and 'Following'",
            "description": "Follow button should update its appearance when tapped"
          },
          {
            "input": "Tab selection",
            "expectedOutput": "Content changes based on selected tab",
            "description": "Tabbed interface should display correct content for each tab"
          },
          {
            "input": "Alert presentation",
            "expectedOutput": "Message alert appears when message button tapped",
            "description": "Alert should be shown when message button is pressed"
          }
        ]
      }
    },
    {
      "id": "swiftui_layout_stacks",
      "title": "Layout & Stacks",
      "description": "Master SwiftUI's fundamental layout containers - VStack, HStack, and ZStack to create beautiful UI arrangements",
      "difficulty": "beginner",
      "theory": "# SwiftUI Layout & Stacks - Building UI Foundations\n\n## 1. Understanding SwiftUI Layout System (45 min)\n\n### Declarative UI Principles:\n- **What you see is what you describe**\n- No storyboards or interface builders\n- **Automatic layout** based on content\n- **Responsive by default**\n\n### Stack Containers Overview:\n- **VStack**: Vertical arrangement (top to bottom)\n- **HStack**: Horizontal arrangement (leading to trailing)\n- **ZStack**: Overlapping arrangement (back to front)\n\n### Basic Structure:\n```swift\nimport SwiftUI\n\nstruct ContentView: View {\n    var body: some View {\n        VStack {\n            Text(\"Hello\")\n            Text(\"SwiftUI!\")\n        }\n    }\n}\n```\n\n## 2. VStack - Vertical Stacks (60 min)\n\n### Basic VStack:\n```swift\nVStack {\n    Text(\"First Item\")\n    Text(\"Second Item\")\n    Text(\"Third Item\")\n}\n```\n\n### VStack with Alignment:\n```swift\n// Different alignments\nVStack(alignment: .leading) {\n    Text(\"Left aligned\")\n    Text(\"Also left\")\n}\n\nVStack(alignment: .trailing) {\n    Text(\"Right aligned\")\n    Text(\"Also right\")\n}\n\nVStack(alignment: .center) {\n    Text(\"Centered\")\n    Text(\"Also centered\")\n}\n```\n\n### VStack with Spacing:\n```swift\n// Custom spacing between elements\nVStack(spacing: 20) {\n    Text(\"Item 1\")\n    Text(\"Item 2\")\n    Text(\"Item 3\")\n}\n\n// No spacing\nVStack(spacing: 0) {\n    Text(\"Tight\")\n    Text(\"Layout\")\n}\n```\n\n## 3. HStack - Horizontal Stacks (60 min)\n\n### Basic HStack:\n```swift\nHStack {\n    Text(\"Left\")\n    Text(\"Middle\")\n    Text(\"Right\")\n}\n```\n\n### HStack with Alignment:\n```swift\n// Vertical alignment within horizontal stack\nHStack(alignment: .top) {\n    Text(\"Top\")\n    Rectangle()\n        .fill(Color.blue)\n        .frame(width: 50, height: 100)\n}\n\nHStack(alignment: .center) {\n    Text(\"Center\")\n    Rectangle()\n        .fill(Color.red)\n        .frame(width: 50, height: 100)\n}\n\nHStack(alignment: .bottom) {\n    Text(\"Bottom\")\n    Rectangle()\n        .fill(Color.green)\n        .frame(width: 50, height: 100)\n}\n```\n\n### HStack with Spacing:\n```swift\nHStack(spacing: 30) {\n    Image(systemName: \"star.fill\")\n    Image(systemName: \"heart.fill\")\n    Image(systemName: \"flag.fill\")\n}\n.foregroundColor(.orange)\n.font(.title)\n```\n\n## 4. ZStack - Overlapping Stacks (45 min)\n\n### Basic ZStack:\n```swift\nZStack {\n    Circle()\n        .fill(Color.blue)\n        .frame(width: 200, height: 200)\n    \n    Text(\"Overlay Text\")\n        .foregroundColor(.white)\n        .font(.title)\n}\n```\n\n### ZStack with Alignment:\n```swift\n// Position elements within ZStack\nZStack(alignment: .topLeading) {\n    Rectangle()\n        .fill(Color.red)\n        .frame(width: 300, height: 200)\n    \n    Text(\"Top Left\")\n        .padding()\n        .background(Color.white)\n}\n\nZStack(alignment: .bottomTrailing) {\n    Rectangle()\n        .fill(Color.green)\n        .frame(width: 300, height: 200)\n    \n    Text(\"Bottom Right\")\n        .padding()\n        .background(Color.white)\n}\n```\n\n### Practical ZStack Examples:\n```swift\n// Badge with notification count\nZStack(alignment: .topTrailing) {\n    Image(systemName: \"bell.fill\")\n        .font(.title)\n    \n    Text(\"5\")\n        .font(.caption)\n        .foregroundColor(.white)\n        .padding(5)\n        .background(Circle().fill(Color.red))\n        .offset(x: 10, y: -10)\n}\n```\n\n## 5. Combining Stacks (60 min)\n\n### Nested Stacks:\n```swift\nVStack {\n    HStack {\n        Text(\"Left Column\")\n        Spacer()\n        Text(\"Right Column\")\n    }\n    \n    HStack {\n        VStack {\n            Text(\"Top\")\n            Text(\"Bottom\")\n        }\n        \n        Spacer()\n        \n        VStack {\n            Text(\"Top\")\n            Text(\"Bottom\")\n        }\n    }\n}\n.padding()\n```\n\n### Complex Layout Example:\n```swift\nVStack(spacing: 20) {\n    // Header\n    HStack {\n        Text(\"My App\")\n            .font(.largeTitle)\n            .fontWeight(.bold)\n        Spacer()\n        Image(systemName: \"person.circle\")\n            .font(.title)\n    }\n    \n    // Content\n    HStack(spacing: 15) {\n        VStack {\n            Image(systemName: \"photo\")\n                .font(.largeTitle)\n            Text(\"Gallery\")\n        }\n        \n        VStack {\n            Image(systemName: \"music.note\")\n                .font(.largeTitle)\n            Text(\"Music\")\n        }\n        \n        VStack {\n            Image(systemName: \"map\")\n                .font(.largeTitle)\n            Text(\"Maps\")\n        }\n    }\n    \n    // Footer\n    HStack {\n        Text(\"Status: Online\")\n        Spacer()\n        Text(\"Version 1.0\")\n    }\n    .font(.caption)\n    .foregroundColor(.gray)\n}\n.padding()\n```\n\n## 6. Spacing & Layout Controls (45 min)\n\n### Using Spacer:\n```swift\nHStack {\n    Text(\"Left\")\n    Spacer() // Pushes elements apart\n    Text(\"Right\")\n}\n\nVStack {\n    Text(\"Top\")\n    Spacer() // Takes all available space\n    Text(\"Bottom\")\n}\n```\n\n### Fixed vs Flexible Spacing:\n```swift\n// Fixed spacing\nHStack(spacing: 20) {\n    Text(\"Fixed\")\n    Text(\"Space\")\n}\n\n// Flexible spacing with Spacer\nHStack {\n    Text(\"Left\")\n    Spacer()\n    Text(\"Middle\")\n    Spacer()\n    Text(\"Right\")\n}\n```\n\n### Padding and Margins:\n```swift\nVStack {\n    Text(\"No Padding\")\n    \n    Text(\"With Padding\")\n        .padding() // All sides\n    \n    Text(\"Custom Padding\")\n        .padding(.horizontal, 20) // Horizontal only\n    \n    Text(\"Multiple Padding\")\n        .padding(.top, 10)\n        .padding(.bottom, 5)\n}\n```\n\n## 7. Real-World Layout Patterns (45 min)\n\n### Card Layout:\n```swift\nVStack(alignment: .leading, spacing: 12) {\n    HStack {\n        Text(\"Featured Article\")\n            .font(.headline)\n        Spacer()\n        Image(systemName: \"bookmark\")\n    }\n    \n    Text(\"This is a sample card layout with proper spacing and alignment.\")\n        .font(.body)\n        .foregroundColor(.secondary)\n    \n    HStack {\n        Image(systemName: \"clock\")\n        Text(\"5 min read\")\n        Spacer()\n        Text(\"SwiftUI\")\n            .padding(.horizontal, 8)\n            .padding(.vertical, 4)\n            .background(Color.blue)\n            .foregroundColor(.white)\n            .cornerRadius(4)\n    }\n    .font(.caption)\n}\n.padding()\n.background(Color(.systemBackground))\n.cornerRadius(12)\n.shadow(radius: 2)\n```\n\n### Form Layout:\n```swift\nVStack(spacing: 0) {\n    ForEach(0..<5) { index in\n        HStack {\n            Image(systemName: \"\\(index).circle\")\n            Text(\"Item \\(index + 1)\")\n            Spacer()\n            Image(systemName: \"chevron.right\")\n                .foregroundColor(.gray)\n        }\n        .padding()\n        \n        if index < 4 {\n            Divider()\n                .padding(.leading)\n        }\n    }\n}\n.background(Color(.systemBackground))\n.cornerRadius(10)\n```\n\n## Best Practices & Common Patterns\n\n### Layout Tips:\n- **Start simple** and build complexity gradually\n- **Use spacing** for visual separation\n- **Combine stacks** for complex layouts\n- **Test on different screen sizes**\n- **Use padding** for comfortable margins\n\n### Performance Considerations:\n- **Avoid deep nesting** when possible\n- **Use LazyVStack/LazyHStack** for long lists\n- **Prefer simple layouts** for better performance\n\n## Practice Exercises\n\nComplete all exercises to master SwiftUI layout fundamentals!",
      "codeExample": "// === VSTACK EXAMPLES ===\n\n// Basic vertical stack\nVStack {\n    Text(\"Welcome to\")\n    Text(\"SwiftUI\")\n        .font(.title)\n        .fontWeight(.bold)\n    Text(\"Layout Basics\")\n}\n\n// VStack with alignment and spacing\nVStack(alignment: .leading, spacing: 15) {\n    Text(\"Left Aligned Title\")\n        .font(.headline)\n    \n    Text(\"This text is left aligned within the VStack with custom spacing between elements.\")\n        .font(.body)\n        .foregroundColor(.secondary)\n    \n    HStack {\n        Image(systemName: \"calendar\")\n        Text(\"January 1, 2024\")\n    }\n    .font(.caption)\n}\n.padding()\n\n// === HSTACK EXAMPLES ===\n\n// Basic horizontal stack\nHStack {\n    Image(systemName: \"person.circle.fill\")\n        .font(.largeTitle)\n    \n    VStack(alignment: .leading) {\n        Text(\"John Appleseed\")\n            .font(.headline)\n        Text(\"iOS Developer\")\n            .font(.subheadline)\n            .foregroundColor(.secondary)\n    }\n    \n    Spacer()\n    \n    Image(systemName: \"chevron.right\")\n        .foregroundColor(.gray)\n}\n.padding()\n\n// HStack with different alignments\nHStack(alignment: .top, spacing: 20) {\n    VStack {\n        Text(\"Short\")\n        Rectangle()\n            .fill(Color.blue)\n            .frame(width: 60, height: 40)\n    }\n    \n    VStack {\n        Text(\"Medium Height\")\n        Rectangle()\n            .fill(Color.green)\n            .frame(width: 60, height: 80)\n    }\n    \n    VStack {\n        Text(\"Tall Element\")\n        Rectangle()\n            .fill(Color.orange)\n            .frame(width: 60, height: 120)\n    }\n}\n\n// === ZSTACK EXAMPLES ===\n\n// Overlapping elements\nZStack {\n    // Background\n    RoundedRectangle(cornerRadius: 15)\n        .fill(\n            LinearGradient(\n                gradient: Gradient(colors: [.blue, .purple]),\n                startPoint: .topLeading,\n                endPoint: .bottomTrailing\n            )\n        )\n        .frame(height: 200)\n    \n    // Content\n    VStack(spacing: 10) {\n        Image(systemName: \"star.fill\")\n            .font(.largeTitle)\n            .foregroundColor(.yellow)\n        \n        Text(\"Premium Feature\")\n            .font(.title2)\n            .fontWeight(.semibold)\n            .foregroundColor(.white)\n        \n        Text(\"Unlock amazing capabilities\")\n            .font(.body)\n            .foregroundColor(.white.opacity(0.8))\n    }\n}\n.padding()\n\n// Badge overlay\nZStack(alignment: .topTrailing) {\n    // Main content\n    VStack {\n        Image(systemName: \"envelope.fill\")\n            .font(.system(size: 50))\n        Text(\"Messages\")\n            .font(.headline)\n    }\n    .foregroundColor(.blue)\n    \n    // Badge\n    Text(\"3\")\n        .font(.caption)\n        .fontWeight(.bold)\n        .foregroundColor(.white)\n        .padding(6)\n        .background(Circle().fill(Color.red))\n        .offset(x: 10, y: -10)\n}\n\n// === COMBINED STACKS EXAMPLE ===\n\n// Profile card using all three stacks\nVStack(spacing: 0) {\n    // Header with background\n    ZStack(alignment: .bottom) {\n        Rectangle()\n            .fill(Color.blue)\n            .frame(height: 120)\n        \n        // Profile image overlapping the header\n        Image(systemName: \"person.circle.fill\")\n            .font(.system(size: 80))\n            .foregroundColor(.white)\n            .offset(y: 40)\n    }\n    \n    // Spacer to push content down for profile image\n    Spacer()\n        .frame(height: 40)\n    \n    // Content area\n    VStack(spacing: 15) {\n        Text(\"Alex Johnson\")\n            .font(.title2)\n            .fontWeight(.bold)\n        \n        Text(\"iOS Developer at TechCo\")\n            .font(.body)\n            .foregroundColor(.secondary)\n        \n        HStack(spacing: 30) {\n            VStack {\n                Text(\"125\")\n                    .font(.headline)\n                    .fontWeight(.bold)\n                Text(\"Posts\")\n                    .font(.caption)\n                    .foregroundColor(.secondary)\n            }\n            \n            VStack {\n                Text(\"1.2K\")\n                    .font(.headline)\n                    .fontWeight(.bold)\n                Text(\"Followers\")\n                    .font(.caption)\n                    .foregroundColor(.secondary)\n            }\n            \n            VStack {\n                Text(\"350\")\n                    .font(.headline)\n                    .fontWeight(.bold)\n                Text(\"Following\")\n                    .font(.caption)\n                    .foregroundColor(.secondary)\n            }\n        }\n        \n        // Action buttons\n        HStack(spacing: 15) {\n            Button(\"Follow\") {\n                // Follow action\n            }\n            .padding(.horizontal, 30)\n            .padding(.vertical, 10)\n            .background(Color.blue)\n            .foregroundColor(.white)\n            .cornerRadius(8)\n            \n            Button(\"Message\") {\n                // Message action\n            }\n            .padding(.horizontal, 30)\n            .padding(.vertical, 10)\n            .background(Color.gray.opacity(0.2))\n            .foregroundColor(.primary)\n            .cornerRadius(8)\n        }\n    }\n    .padding()\n}\n.background(Color(.systemBackground))\n.cornerRadius(15)\n.shadow(radius: 5)\n.padding()",
      "category": "SwiftUI Basics",
      "estimatedTime": 240,
      "dependencies": ["swiftui_intro"],
      "challenge": {
        "instructions": "Create a complete social media post component using VStack, HStack, and ZStack:\n\nPART 1: Basic Post Layout (60 min)\n1. Create a VStack for the main post structure\n2. Add HStack for header with profile picture, name, and timestamp\n3. Add post content (text and optional image)\n4. Add HStack for engagement buttons (like, comment, share)\n5. Use proper spacing and alignment throughout\n\nPART 2: Advanced Features with ZStack (60 min)\n6. Add a verified badge overlay on profile picture using ZStack\n7. Create a like animation with heart overlay\n8. Add a premium content badge for special posts\n9. Implement a read-time indicator overlay on images\n\nPART 3: Interactive Elements (60 min)\n10. Make like button change color when tapped\n11. Add expand/collapse functionality for long text\n12. Create a share sheet overlay using ZStack\n13. Implement profile picture tap with scale animation\n\nPART 4: Complex Layout Composition (60 min)\n14. Build a feed view with multiple posts in a ScrollView\n15. Add different post types (text-only, image, video, link)\n16. Create a sticky header using ZStack\n17. Implement pull-to-refresh indicator\n\nTest your implementation on different device sizes and orientations!",
        "starterCode": "import SwiftUI\n\nstruct SocialMediaPost: View {\n    var body: some View {\n        // TODO: Implement social media post layout\n        Text(\"Implement your social media post here\")\n    }\n}\n\nstruct SocialMediaFeed: View {\n    var body: some View {\n        // TODO: Implement feed with multiple posts\n        Text(\"Implement your social media feed here\")\n    }\n}\n\n// Preview\nstruct ContentView_Previews: PreviewProvider {\n    static var previews: some View {\n        SocialMediaFeed()\n    }\n}",
        "solution": "import SwiftUI\n\nstruct SocialMediaPost: View {\n    let post: Post\n    @State private var isLiked = false\n    @State private var isExpanded = false\n    @State private var showShareSheet = false\n    @State private var profileScale: CGFloat = 1.0\n    \n    var body: some View {\n        VStack(alignment: .leading, spacing: 12) {\n            // Header\n            HStack(alignment: .top, spacing: 12) {\n                // Profile picture with verified badge\n                ZStack(alignment: .bottomTrailing) {\n                    Image(systemName: \"person.circle.fill\")\n                        .font(.system(size: 44))\n                        .foregroundColor(.blue)\n                        .scaleEffect(profileScale)\n                        .onTapGesture {\n                            withAnimation(.spring(response: 0.3, dampingFraction: 0.6)) {\n                                profileScale = 0.8\n                            }\n                            withAnimation(.spring(response: 0.3, dampingFraction: 0.6).delay(0.1)) {\n                                profileScale = 1.0\n                            }\n                        }\n                    \n                    // Verified badge\n                    if post.isVerified {\n                        Image(systemName: \"checkmark.seal.fill\")\n                            .font(.system(size: 12))\n                            .foregroundColor(.blue)\n                            .background(Circle().fill(Color.white))\n                    }\n                }\n                \n                VStack(alignment: .leading, spacing: 2) {\n                    HStack {\n                        Text(post.authorName)\n                            .font(.headline)\n                            .fontWeight(.semibold)\n                        \n                        if post.isPremium {\n                            Image(systemName: \"crown.fill\")\n                                .font(.caption)\n                                .foregroundColor(.yellow)\n                        }\n                    }\n                    \n                    Text(post.timestamp)\n                        .font(.caption)\n                        .foregroundColor(.secondary)\n                }\n                \n                Spacer()\n                \n                Image(systemName: \"ellipsis\")\n                    .foregroundColor(.secondary)\n            }\n            \n            // Post content\n            VStack(alignment: .leading, spacing: 8) {\n                Text(post.content)\n                    .font(.body)\n                    .lineLimit(isExpanded ? nil : 3)\n                \n                if post.content.count > 150 {\n                    Button(isExpanded ? \"Show less\" : \"Show more\") {\n                        withAnimation(.easeInOut(duration: 0.3)) {\n                            isExpanded.toggle()\n                        }\n                    }\n                    .font(.caption)\n                    .fontWeight(.medium)\n                    .foregroundColor(.blue)\n                }\n            }\n            \n            // Post image with overlay\n            if let imageName = post.imageName {\n                ZStack(alignment: .bottomTrailing) {\n                    Rectangle()\n                        .fill(Color.gray.opacity(0.3))\n                        .aspectRatio(1.5, contentMode: .fit)\n                        .overlay(\n                            Image(systemName: imageName)\n                                .font(.system(size: 50))\n                                .foregroundColor(.gray)\n                        )\n                    \n                    // Read time indicator\n                    if post.hasReadTime {\n                        Text(\"5 min read\")\n                            .font(.caption2)\n                            .fontWeight(.medium)\n                            .foregroundColor(.white)\n                            .padding(.horizontal, 8)\n                            .padding(.vertical, 4)\n                            .background(Color.black.opacity(0.7))\n                            .cornerRadius(4)\n                            .padding(8)\n                    }\n                }\n                .cornerRadius(12)\n            }\n            \n            // Engagement stats\n            HStack {\n                HStack(spacing: 4) {\n                    // Like count with animation\n                    ZStack {\n                        Image(systemName: \"heart.fill\")\n                            .font(.caption)\n                            .foregroundColor(isLiked ? .red : .clear)\n                        \n                        Image(systemName: \"heart\")\n                            .font(.caption)\n                            .foregroundColor(.secondary)\n                    }\n                    \n                    Text(\"\\(post.likeCount + (isLiked ? 1 : 0))\")\n                        .font(.caption)\n                        .foregroundColor(.secondary)\n                }\n                \n                Text(\"\\(post.commentCount) comments\")\n                    .font(.caption)\n                    .foregroundColor(.secondary)\n                \n                Spacer()\n                \n                Text(\"\\(post.shareCount) shares\")\n                    .font(.caption)\n                    .foregroundColor(.secondary)\n            }\n            \n            // Engagement buttons\n            HStack(spacing: 0) {\n                Button(action: {\n                    withAnimation(.spring(response: 0.3, dampingFraction: 0.6)) {\n                        isLiked.toggle()\n                    }\n                }) {\n                    HStack {\n                        Image(systemName: isLiked ? \"heart.fill\" : \"heart\")\n                            .foregroundColor(isLiked ? .red : .secondary)\n                        Text(\"Like\")\n                            .foregroundColor(isLiked ? .red : .secondary)\n                    }\n                    .frame(maxWidth: .infinity)\n                    .padding(.vertical, 8)\n                }\n                \n                Button(action: {\n                    // Comment action\n                }) {\n                    HStack {\n                        Image(systemName: \"bubble.right\")\n                        Text(\"Comment\")\n                    }\n                    .frame(maxWidth: .infinity)\n                    .padding(.vertical, 8)\n                    .foregroundColor(.secondary)\n                }\n                \n                Button(action: {\n                    showShareSheet = true\n                }) {\n                    HStack {\n                        Image(systemName: \"arrowshape.turn.up.right\")\n                        Text(\"Share\")\n                    }\n                    .frame(maxWidth: .infinity)\n                    .padding(.vertical, 8)\n                    .foregroundColor(.secondary)\n                }\n            }\n            .font(.subheadline)\n            .fontWeight(.medium)\n            \n            Divider()\n        }\n        .padding(.horizontal)\n        .sheet(isPresented: $showShareSheet) {\n            Text(\"Share Sheet\")\n                .presentationDetents([.medium])\n        }\n    }\n}\n\nstruct SocialMediaFeed: View {\n    let posts: [Post] = Post.mockPosts\n    @State private var isRefreshing = false\n    \n    var body: some View {\n        ZStack(alignment: .top) {\n            ScrollView {\n                LazyVStack(spacing: 0) {\n                    // Pull to refresh indicator\n                    if isRefreshing {\n                        ProgressView()\n                            .padding()\n                    }\n                    \n                    ForEach(posts) { post in\n                        SocialMediaPost(post: post)\n                    }\n                }\n                .background(\n                    GeometryReader { geometry in\n                        Color.clear\n                            .onChange(of: geometry.frame(in: .global).minY) { value in\n                                // Simple pull-to-refresh logic\n                                if value > 50 && !isRefreshing {\n                                    isRefreshing = true\n                                    // Simulate refresh\n                                    DispatchQueue.main.asyncAfter(deadline: .now() + 2) {\n                                        isRefreshing = false\n                                    }\n                                }\n                            }\n                    }\n                )\n            }\n            \n            // Sticky header\n            VStack(spacing: 0) {\n                HStack {\n                    Text(\"Social Feed\")\n                        .font(.title2)\n                        .fontWeight(.bold)\n                    \n                    Spacer()\n                    \n                    Image(systemName: \"bell\")\n                        .font(.title3)\n                }\n                .padding()\n                .background(\n                    Color(.systemBackground)\n                        .shadow(radius: 2)\n                )\n                \n                Spacer()\n            }\n        }\n    }\n}\n\n// Data models\nstruct Post: Identifiable {\n    let id = UUID()\n    let authorName: String\n    let timestamp: String\n    let content: String\n    let imageName: String?\n    let likeCount: Int\n    let commentCount: Int\n    let shareCount: Int\n    let isVerified: Bool\n    let isPremium: Bool\n    let hasReadTime: Bool\n    \n    static let mockPosts = [\n        Post(authorName: \"Sarah Chen\", timestamp: \"2h ago\", content: \"Just launched my new SwiftUI course! It covers everything from basics to advanced animations. So excited to share this with the iOS community! #SwiftUI #iOSDev\", imageName: \"photo\", likeCount: 124, commentCount: 23, shareCount: 8, isVerified: true, isPremium: true, hasReadTime: true),\n        Post(authorName: \"Mike Johnson\", timestamp: \"5h ago\", content: \"Beautiful sunset from the office today. Sometimes you need to appreciate the small moments. ðŸŒ…\", imageName: nil, likeCount: 56, commentCount: 12, shareCount: 2, isVerified: false, isPremium: false, hasReadTime: false),\n        Post(authorName: \"Tech News\", timestamp: \"1d ago\", content: \"Apple announces new SwiftUI features at WWDC. The new APIs make complex layouts even easier to build. Can't wait to try them out!\", imageName: \"newspaper\", likeCount: 342, commentCount: 45, shareCount: 32, isVerified: true, isPremium: false, hasReadTime: true)\n    ]\n}\n\n// Preview\nstruct ContentView_Previews: PreviewProvider {\n    static var previews: some View {\n        SocialMediaFeed()\n    }\n}",
        "hints": [
          "PART 1: Use VStack as the main container, HStack for horizontal elements like header and buttons",
          "PART 2: ZStack is perfect for overlays like badges and indicators. Use alignment parameters to position them",
          "PART 3: Use @State variables to track interactive states like isLiked, isExpanded",
          "PART 4: Combine ScrollView with LazyVStack for efficient feed rendering",
          "Use Spacer() to push elements to edges in HStack and VStack",
          "Apply padding() for comfortable spacing around content",
          "Use .cornerRadius() and .shadow() to create card-like appearance",
          "Experiment with different spacing values in stacks for visual hierarchy",
          "Use .frame(maxWidth: .infinity) to make buttons fill available space",
          "Apply animations with withAnimation for smooth state transitions"
        ],
        "testCases": [
          {
            "input": "Post header should contain profile image, name, and timestamp",
            "expectedOutput": "HStack with proper alignment and spacing",
            "description": "Header layout uses HStack with profile, text, and spacer"
          },
          {
            "input": "Like button should change color when tapped",
            "expectedOutput": "Heart icon turns red when isLiked is true",
            "description": "Interactive state change with visual feedback"
          },
          {
            "input": "Long text should be expandable",
            "expectedOutput": "Show more/less button appears for long content",
            "description": "Conditional UI based on content length"
          },
          {
            "input": "Verified badge should overlay profile image",
            "expectedOutput": "ZStack with alignment for badge positioning",
            "description": "Overlay elements using ZStack alignment"
          }
        ]
      }
    },
    {
      "id": "swiftui_state_management",
      "title": "SwiftUI State Management",
      "description": "Master data flow in SwiftUI with @State, @Binding, and @ObservedObject - the foundation of reactive UI",
      "difficulty": "beginner",
      "theory": "# SwiftUI State Management - Data Flow in Modern UI\n\n## 1. Understanding State in SwiftUI (60 min)\n\n### What is State?\n- **State**: Data that can change over time and affects the UI\n- **Single Source of Truth**: Each piece of data should have one definitive source\n- **Reactive Updates**: UI automatically updates when state changes\n\n### The Problem State Solves:\n```swift\n// Without State Management - UI won't update!\nvar counter = 0\nButton(\"Tap me\") {\n    counter += 1 // UI doesn't know to update!\n}\nText(\"Count: \\(counter)\") // Stays at 0\n```\n\n### State Property Wrapper:\n```swift\n// With @State - UI updates automatically!\n@State private var counter = 0\nButton(\"Tap me\") {\n    counter += 1 // UI automatically updates!\n}\nText(\"Count: \\(counter)\") // Updates in real-time\n```\n\n## 2. @State Property Wrapper (75 min)\n\n### Basic @State Usage:\n```swift\nstruct CounterView: View {\n    @State private var count = 0\n    \n    var body: some View {\n        VStack {\n            Text(\"Count: \\(count)\")\n                .font(.largeTitle)\n            \n            Button(\"Increment\") {\n                count += 1\n            }\n            .buttonStyle(.borderedProminent)\n        }\n    }\n}\n```\n\n### State with Different Data Types:\n```swift\nstruct UserSettingsView: View {\n    @State private var username = \"\"\n    @State private var isOn = false\n    @State private var selectedColor = Color.red\n    @State private var score = 0.0\n    \n    var body: some View {\n        Form {\n            TextField(\"Username\", text: $username)\n            Toggle(\"Notifications\", isOn: $isOn)\n            ColorPicker(\"Theme Color\", selection: $selectedColor)\n            Slider(value: $score, in: 0...100)\n        }\n    }\n}\n```\n\n### State Best Practices:\n- Use `private` access control for @State properties\n- Initialize with default values\n- Use for local, simple data owned by the view\n- Store value types (String, Int, Bool, structs)\n\n## 3. @Binding Property Wrapper (75 min)\n\n### What is @Binding?\n- **Two-way connection** between parent and child views\n- Creates a **reference** to state owned by a parent\n- Allows child views to **read and write** parent's state\n\n### Creating Custom Bindings:\n```swift\nstruct ToggleView: View {\n    @Binding var isOn: Bool\n    \n    var body: some View {\n        Toggle(\"Switch\", isOn: $isOn)\n            .toggleStyle(.switch)\n    }\n}\n\nstruct ParentView: View {\n    @State private var settingsOn = false\n    \n    var body: some View {\n        VStack {\n            Text(\"Settings are: \\(settingsOn ? \"ON\" : \"OFF\")\")\n            ToggleView(isOn: $settingsOn) // Pass binding\n        }\n    }\n}\n```\n\n### Binding with Custom Controls:\n```swift\nstruct BrightnessSlider: View {\n    @Binding var brightness: Double\n    \n    var body: some View {\n        VStack {\n            Text(\"Brightness: \\(Int(brightness * 100))%\")\n            Slider(value: $brightness)\n        }\n    }\n}\n\nstruct LightControlView: View {\n    @State private var brightness = 0.5\n    \n    var body: some View {\n        BrightnessSlider(brightness: $brightness)\n    }\n}\n```\n\n### Custom Binding Creation:\n```swift\nstruct VolumeControl: View {\n    @State private var volume = 0.5\n    \n    private var isMuted: Binding<Bool> {\n        Binding(\n            get: { volume == 0 },\n            set: { newValue in\n                volume = newValue ? 0 : 0.5\n            }\n        )\n    }\n    \n    var body: some View {\n        VStack {\n            Slider(value: $volume)\n            Toggle(\"Mute\", isOn: isMuted)\n        }\n    }\n}\n```\n\n## 4. @ObservedObject for Complex State (90 min)\n\n### When to Use @ObservedObject:\n- **Complex data** that multiple views need\n- **External data** not owned by the view\n- **Reference types** (classes) instead of value types\n- Data that conforms to **ObservableObject**\n\n### Creating Observable Objects:\n```swift\nclass UserSettings: ObservableObject {\n    @Published var username = \"\"\n    @Published var isLoggedIn = false\n    @Published var themeColor = Color.blue\n}\n\nstruct ProfileView: View {\n    @ObservedObject var settings: UserSettings\n    \n    var body: some View {\n        VStack {\n            TextField(\"Username\", text: $settings.username)\n            Toggle(\"Logged In\", isOn: $settings.isLoggedIn)\n            ColorPicker(\"Theme\", selection: $settings.themeColor)\n        }\n    }\n}\n```\n\n### Multiple Views Sharing ObservedObject:\n```swift\nclass GameState: ObservableObject {\n    @Published var score = 0\n    @Published var level = 1\n    @Published var isGameActive = false\n}\n\nstruct GameView: View {\n    @ObservedObject var gameState: GameState\n    \n    var body: some View {\n        VStack {\n            ScoreView(gameState: gameState)\n            LevelView(gameState: gameState)\n            GameControls(gameState: gameState)\n        }\n    }\n}\n\nstruct ScoreView: View {\n    @ObservedObject var gameState: GameState\n    \n    var body: some View {\n        Text(\"Score: \\(gameState.score)\")\n    }\n}\n```\n\n### Manual ObjectWillChange:\n```swift\nclass Inventory: ObservableObject {\n    var items: [String] = [] {\n        willSet {\n            objectWillChange.send()\n        }\n    }\n    \n    func addItem(_ item: String) {\n        items.append(item)\n    }\n}\n```\n\n## 5. Choosing the Right Tool (60 min)\n\n### @State vs @Binding vs @ObservedObject:\n\n| Property Wrapper | Ownership | Use Case | Data Type |\n|------------------|-----------|----------|-----------|\n| `@State` | View owns it | Simple local state | Value types |\n| `@Binding` | Parent owns it | Child modifies parent state | Value types |\n| `@ObservedObject` | External source | Complex shared state | Reference types |\n\n### Decision Flow:\n1. **Is data simple and local?** â†’ `@State`\n2. **Does child need to modify parent's state?** â†’ `@Binding`\n3. **Is data complex and shared?** â†’ `@ObservedObject`\n\n### Real-world Examples:\n```swift\n// @State - User input in a form\nstruct LoginView: View {\n    @State private var email = \"\"\n    @State private var password = \"\"\n}\n\n// @Binding - Settings that affect multiple components\nstruct ThemeSettings: View {\n    @Binding var isDarkMode: Bool\n}\n\n// @ObservedObject - App-wide user data\nclass UserData: ObservableObject {\n    @Published var user: User?\n    @Published var preferences: Preferences\n}\n```\n\n## 6. Common Patterns & Best Practices (60 min)\n\n### State Management Patterns:\n\n#### Single Source of Truth:\n```swift\nstruct TodoApp: View {\n    @StateObject private var store = TodoStore()\n    \n    var body: some View {\n        NavigationView {\n            List {\n                ForEach(store.todos) { todo in\n                    TodoRow(todo: todo)\n                }\n            }\n            .navigationTitle(\"Todos\")\n        }\n        .environmentObject(store)\n    }\n}\n```\n\n#### Derived State:\n```swift\nstruct TaskListView: View {\n    @State private var tasks: [Task] = []\n    \n    // Computed property - derived from state\n    var completedTasks: [Task] {\n        tasks.filter { $0.isCompleted }\n    }\n    \n    var incompleteTasks: [Task] {\n        tasks.filter { !$0.isCompleted }\n    }\n}\n```\n\n### Performance Considerations:\n- Use @State for simple, local data\n- Use @ObservedObject for shared, complex data\n- Avoid putting large objects in @State\n- Use computed properties for derived data\n\n### Testing State:\n```swift\nstruct CounterView: View {\n    @State private var count = 0\n    \n    func increment() {\n        count += 1\n    }\n    \n    var body: some View {\n        Button(\"Count: \\(count)\") {\n            increment()\n        }\n    }\n}\n\n// Testable because logic is separated\nclass CounterViewModel: ObservableObject {\n    @Published var count = 0\n    \n    func increment() {\n        count += 1\n    }\n}\n```\n\n## Practice Exercises\n\nComplete all exercises to master SwiftUI state management!",
      "codeExample": "// === @STATE EXAMPLES ===\n\n// Basic counter with @State\nstruct CounterView: View {\n    @State private var count = 0\n    \n    var body: some View {\n        VStack(spacing: 20) {\n            Text(\"Count: \\(count)\")\n                .font(.title)\n            \n            HStack {\n                Button(\"Decrement\") {\n                    count -= 1\n                }\n                .buttonStyle(.bordered)\n                \n                Button(\"Reset\") {\n                    count = 0\n                }\n                .buttonStyle(.bordered)\n                \n                Button(\"Increment\") {\n                    count += 1\n                }\n                .buttonStyle(.borderedProminent)\n            }\n        }\n        .padding()\n    }\n}\n\n// Form with multiple @State properties\nstruct UserProfileView: View {\n    @State private var name = \"\"\n    @State private var email = \"\"\n    @State private var age = 18\n    @State private var receiveNewsletter = true\n    @State private var selectedColor = Color.blue\n    \n    var body: some View {\n        Form {\n            Section(\"Personal Information\") {\n                TextField(\"Name\", text: $name)\n                TextField(\"Email\", text: $email)\n                    .keyboardType(.emailAddress)\n                Stepper(\"Age: \\(age)\", value: $age, in: 13...100)\n            }\n            \n            Section(\"Preferences\") {\n                Toggle(\"Newsletter\", isOn: $receiveNewsletter)\n                ColorPicker(\"Theme Color\", selection: $selectedColor)\n            }\n            \n            Section(\"Summary\") {\n                Text(\"Name: \\(name)\")\n                Text(\"Email: \\(email)\")\n                Text(\"Age: \\(age)\")\n                Text(\"Newsletter: \\(receiveNewsletter ? \"Yes\" : \"No\")\")\n            }\n        }\n        .navigationTitle(\"Profile\")\n    }\n}\n\n// === @BINDING EXAMPLES ===\n\n// Custom toggle with @Binding\nstruct CustomToggle: View {\n    let title: String\n    @Binding var isOn: Bool\n    \n    var body: some View {\n        HStack {\n            Text(title)\n            Spacer()\n            RoundedRectangle(cornerRadius: 16)\n                .fill(isOn ? Color.green : Color.gray)\n                .frame(width: 50, height: 30)\n                .overlay(\n                    Circle()\n                        .fill(Color.white)\n                        .padding(3)\n                        .offset(x: isOn ? 10 : -10)\n                )\n                .onTapGesture {\n                    withAnimation(.spring()) {\n                        isOn.toggle()\n                    }\n                }\n        }\n        .padding()\n        .background(Color(.systemBackground))\n        .cornerRadius(10)\n    }\n}\n\n// Parent view using the custom toggle\nstruct SettingsView: View {\n    @State private var darkMode = false\n    @State private var notifications = true\n    @State private var autoSave = true\n    \n    var body: some View {\n        VStack(spacing: 16) {\n            CustomToggle(title: \"Dark Mode\", isOn: $darkMode)\n            CustomToggle(title: \"Notifications\", isOn: $notifications)\n            CustomToggle(title: \"Auto Save\", isOn: $autoSave)\n            \n            Spacer()\n            \n            Text(\"Current Settings:\")\n                .font(.headline)\n            Text(\"Dark Mode: \\(darkMode ? \"ON\" : \"OFF\")\")\n            Text(\"Notifications: \\(notifications ? \"ON\" : \"OFF\")\")\n            Text(\"Auto Save: \\(autoSave ? \"ON\" : \"OFF\")\")\n        }\n        .padding()\n        .background(darkMode ? Color.black : Color.white)\n        .foregroundColor(darkMode ? Color.white : Color.black)\n    }\n}\n\n// === @OBSERVEDOBJECT EXAMPLES ===\n\n// ObservableObject for game state\nclass GameState: ObservableObject {\n    @Published var score = 0\n    @Published var level = 1\n    @Published var lives = 3\n    @Published var isGameOver = false\n    \n    func addPoints(_ points: Int) {\n        score += points\n        if score >= level * 1000 {\n            level += 1\n            lives += 1\n        }\n    }\n    \n    func loseLife() {\n        lives -= 1\n        if lives <= 0 {\n            isGameOver = true\n        }\n    }\n    \n    func reset() {\n        score = 0\n        level = 1\n        lives = 3\n        isGameOver = false\n    }\n}\n\n// Multiple views sharing the same ObservedObject\nstruct GameView: View {\n    @ObservedObject var gameState: GameState\n    \n    var body: some View {\n        VStack(spacing: 30) {\n            GameHeaderView(gameState: gameState)\n            GameContentView(gameState: gameState)\n            GameControlsView(gameState: gameState)\n        }\n    }\n}\n\nstruct GameHeaderView: View {\n    @ObservedObject var gameState: GameState\n    \n    var body: some View {\n        HStack {\n            VStack {\n                Text(\"Score\")\n                    .font(.caption)\n                Text(\"\\(gameState.score)\")\n                    .font(.title2)\n                    .bold()\n            }\n            \n            Spacer()\n            \n            VStack {\n                Text(\"Level\")\n                    .font(.caption)\n                Text(\"\\(gameState.level)\")\n                    .font(.title2)\n                    .bold()\n            }\n            \n            Spacer()\n            \n            VStack {\n                Text(\"Lives\")\n                    .font(.caption)\n                Text(\"\\(gameState.lives)\")\n                    .font(.title2)\n                    .bold()\n            }\n        }\n        .padding()\n        .background(Color.blue.opacity(0.1))\n        .cornerRadius(10)\n    }\n}\n\nstruct GameContentView: View {\n    @ObservedObject var gameState: GameState\n    \n    var body: some View {\n        VStack {\n            if gameState.isGameOver {\n                Text(\"Game Over!\")\n                    .font(.largeTitle)\n                    .foregroundColor(.red)\n                Text(\"Final Score: \\(gameState.score)\")\n                    .font(.title2)\n            } else {\n                Text(\"Playing Level \\(gameState.level)\")\n                    .font(.title)\n                Text(\"Collect points and avoid losing lives!\")\n                    .font(.body)\n                    .foregroundColor(.secondary)\n            }\n        }\n    }\n}\n\nstruct GameControlsView: View {\n    @ObservedObject var gameState: GameState\n    \n    var body: some View {\n        VStack(spacing: 16) {\n            if !gameState.isGameOver {\n                Button(\"Collect Points\") {\n                    gameState.addPoints(100)\n                }\n                .buttonStyle(.borderedProminent)\n                \n                Button(\"Lose Life\") {\n                    gameState.loseLife()\n                }\n                .buttonStyle(.bordered)\n                .tint(.red)\n            }\n            \n            Button(\"Reset Game\") {\n                gameState.reset()\n            }\n            .buttonStyle(.bordered)\n        }\n    }\n}\n\n// === COMPREHENSIVE EXAMPLE ===\n\nstruct StateManagementDemo: View {\n    // @State for local view state\n    @State private var showGame = false\n    \n    // @StateObject for creating observed objects (we'll learn this next!)\n    @State private var gameState = GameState()\n    \n    var body: some View {\n        NavigationView {\n            VStack(spacing: 30) {\n                if showGame {\n                    GameView(gameState: gameState)\n                } else {\n                    WelcomeView(showGame: $showGame)\n                }\n            }\n            .navigationTitle(\"State Management Demo\")\n            .padding()\n        }\n    }\n}\n\nstruct WelcomeView: View {\n    @Binding var showGame: Bool\n    \n    var body: some View {\n        VStack(spacing: 20) {\n            Text(\"Welcome to State Management!\")\n                .font(.title)\n                .multilineTextAlignment(.center)\n            \n            Text(\"This demo shows @State, @Binding, and @ObservedObject in action\")\n                .font(.body)\n                .foregroundColor(.secondary)\n                .multilineTextAlignment(.center)\n            \n            Button(\"Start Game\") {\n                showGame = true\n            }\n            .buttonStyle(.borderedProminent)\n            .controlSize(.large)\n        }\n    }\n}",
      "category": "SwiftUI Basics",
      "estimatedTime": 300,
      "dependencies": ["swiftui_intro", "views_layout"],
      "challenge": {
        "instructions": "Create a complete shopping cart application using all three state management tools:\n\nPART 1: @State for Local UI (60 min)\n1. Create a 'ProductListView' with @State for search query and filter options\n2. Implement search functionality that filters products based on @State\n3. Add sorting options (name, price) managed with @State\n4. Create a cart badge that shows item count using @State\n\nPART 2: @Binding for Component Communication (60 min)\n5. Create a 'ProductRow' component that uses @Binding for quantity\n6. Build a 'FilterView' that uses @Binding for filter criteria\n7. Implement a 'CartSummary' view that binds to cart total\n8. Create a 'QuantityStepper' component with @Binding for value\n\nPART 3: @ObservedObject for Shared Data (60 min)\n9. Create 'ShoppingCart' class conforming to ObservableObject\n10. Implement cart operations: add, remove, update quantity\n11. Create 'InventoryManager' class to manage product stock\n12. Build multiple views that observe the same cart instance\n\nPART 4: Integration & Advanced Features (60 min)\n13. Connect all components to work together\n14. Add persistence to save cart between app launches\n15. Implement error handling for stock limitations\n16. Add animations for cart updates and state changes\n\nTest your implementation thoroughly to understand how data flows between components!",
        "starterCode": "// === PART 1: @State for Local UI ===\n// Create ProductListView with search and filters\n\n\n// === PART 2: @Binding for Components ===\n// Create ProductRow, FilterView, and QuantityStepper\n\n\n// === PART 3: @ObservedObject for Shared Data ===\n// Create ShoppingCart and InventoryManager classes\n\n\n// === PART 4: Integration ===\n// Connect all components and add advanced features\n\n",
        "solution": "// === PART 1: @State for Local UI ===\nstruct ProductListView: View {\n    let products: [Product]\n    \n    // @State for local UI state\n    @State private var searchQuery = \"\"\n    @State private var selectedCategory = \"All\"\n    @State private var sortOption = \"name\"\n    @State private var showFilters = false\n    \n    // Computed properties for filtered and sorted products\n    private var filteredProducts: [Product] {\n        let filtered = products.filter { product in\n            (selectedCategory == \"All\" || product.category == selectedCategory) &&\n            (searchQuery.isEmpty || product.name.localizedCaseInsensitiveContains(searchQuery))\n        }\n        \n        switch sortOption {\n        case \"name\":\n            return filtered.sorted { $0.name < $1.name }\n        case \"priceLow\":\n            return filtered.sorted { $0.price < $1.price }\n        case \"priceHigh\":\n            return filtered.sorted { $0.price > $1.price }\n        default:\n            return filtered\n        }\n    }\n    \n    private var categories: [String] {\n        [\"All\"] + Array(Set(products.map { $0.category })).sorted()\n    }\n    \n    var body: some View {\n        NavigationView {\n            VStack {\n                // Search bar\n                HStack {\n                    Image(systemName: \"magnifyingglass\")\n                        .foregroundColor(.secondary)\n                    TextField(\"Search products...\", text: $searchQuery)\n                    \n                    Button(\"Filters\") {\n                        showFilters.toggle()\n                    }\n                    .buttonStyle(.bordered)\n                }\n                .padding()\n                .background(Color(.systemGray6))\n                .cornerRadius(10)\n                .padding(.horizontal)\n                \n                // Filters sheet\n                .sheet(isPresented: $showFilters) {\n                    FilterView(\n                        selectedCategory: $selectedCategory,\n                        sortOption: $sortOption,\n                        categories: categories\n                    )\n                }\n                \n                // Product list\n                List(filteredProducts) { product in\n                    ProductRow(product: product)\n                }\n                .listStyle(.plain)\n            }\n            .navigationTitle(\"Products\")\n        }\n    }\n}\n\n// === PART 2: @Binding for Components ===\nstruct ProductRow: View {\n    let product: Product\n    @Binding var cart: [CartItem]\n    \n    private var quantity: Int {\n        cart.first { $0.product.id == product.id }?.quantity ?? 0\n    }\n    \n    var body: some View {\n        HStack {\n            // Product info\n            VStack(alignment: .leading) {\n                Text(product.name)\n                    .font(.headline)\n                Text(product.category)\n                    .font(.caption)\n                    .foregroundColor(.secondary)\n                Text(\"$\\(product.price, specifier: \"%.2f\")\")\n                    .font(.subheadline)\n                    .bold()\n            }\n            \n            Spacer()\n            \n            // Quantity controls\n            if quantity > 0 {\n                QuantityStepper(quantity: Binding(\n                    get: { quantity },\n                    set: { newValue in\n                        if let index = cart.firstIndex(where: { $0.product.id == product.id }) {\n                            if newValue > 0 {\n                                cart[index].quantity = newValue\n                            } else {\n                                cart.remove(at: index)\n                            }\n                        } else if newValue > 0 {\n                            cart.append(CartItem(product: product, quantity: newValue))\n                        }\n                    }\n                ))\n            } else {\n                Button(\"Add to Cart\") {\n                    if let index = cart.firstIndex(where: { $0.product.id == product.id }) {\n                        cart[index].quantity += 1\n                    } else {\n                        cart.append(CartItem(product: product, quantity: 1))\n                    }\n                }\n                .buttonStyle(.bordered)\n            }\n        }\n        .padding(.vertical, 8)\n    }\n}\n\nstruct QuantityStepper: View {\n    @Binding var quantity: Int\n    \n    var body: some View {\n        HStack {\n            Button(\"-\") {\n                if quantity > 0 {\n                    quantity -= 1\n                }\n            }\n            .buttonStyle(.bordered)\n            \n            Text(\"\\(quantity)\")\n                .frame(minWidth: 30)\n            \n            Button(\"+\") {\n                quantity += 1\n            }\n            .buttonStyle(.bordered)\n        }\n    }\n}\n\nstruct FilterView: View {\n    @Binding var selectedCategory: String\n    @Binding var sortOption: String\n    let categories: [String]\n    @Environment(\\.dismiss) private var dismiss\n    \n    var body: some View {\n        NavigationView {\n            Form {\n                Section(\"Category\") {\n                    Picker(\"Category\", selection: $selectedCategory) {\n                        ForEach(categories, id: \\.self) { category in\n                            Text(category).tag(category)\n                        }\n                    }\n                    .pickerStyle(.segmented)\n                }\n                \n                Section(\"Sort By\") {\n                    Picker(\"Sort By\", selection: $sortOption) {\n                        Text(\"Name\").tag(\"name\")\n                        Text(\"Price: Low to High\").tag(\"priceLow\")\n                        Text(\"Price: High to Low\").tag(\"priceHigh\")\n                    }\n                    .pickerStyle(.segmented)\n                }\n            }\n            .navigationTitle(\"Filters\")\n            .navigationBarItems(trailing: Button(\"Done\") { dismiss() })\n        }\n    }\n}\n\n// === PART 3: @ObservedObject for Shared Data ===\nclass ShoppingCart: ObservableObject {\n    @Published var items: [CartItem] = []\n    @Published var lastUpdate = Date()\n    \n    var total: Double {\n        items.reduce(0) { $0 + ($1.product.price * Double($1.quantity)) }\n    }\n    \n    var itemCount: Int {\n        items.reduce(0) { $0 + $1.quantity }\n    }\n    \n    func addProduct(_ product: Product, quantity: Int = 1) {\n        if let index = items.firstIndex(where: { $0.product.id == product.id }) {\n            items[index].quantity += quantity\n        } else {\n            items.append(CartItem(product: product, quantity: quantity))\n        }\n        lastUpdate = Date()\n    }\n    \n    func removeProduct(_ product: Product) {\n        items.removeAll { $0.product.id == product.id }\n        lastUpdate = Date()\n    }\n    \n    func updateQuantity(for product: Product, to quantity: Int) {\n        if quantity <= 0 {\n            removeProduct(product)\n        } else if let index = items.firstIndex(where: { $0.product.id == product.id }) {\n            items[index].quantity = quantity\n            lastUpdate = Date()\n        }\n    }\n    \n    func clear() {\n        items.removeAll()\n        lastUpdate = Date()\n    }\n}\n\nclass InventoryManager: ObservableObject {\n    @Published var products: [Product] = [\n        Product(id: 1, name: \"iPhone\", category: \"Electronics\", price: 999.99),\n        Product(id: 2, name: \"MacBook\", category: \"Electronics\", price: 1299.99),\n        Product(id: 3, name: \"Coffee Mug\", category: \"Home\", price: 12.99),\n        Product(id: 4, name: \"Desk Lamp\", category: \"Home\", price: 45.99),\n        Product(id: 5, name: \"T-shirt\", category: \"Clothing\", price: 24.99),\n        Product(id: 6, name: \"Jeans\", category: \"Clothing\", price: 59.99)\n    ]\n}\n\n// === PART 4: Integration ===\nstruct ShoppingApp: View {\n    @StateObject private var inventory = InventoryManager()\n    @StateObject private var cart = ShoppingCart()\n    @State private var selectedTab = 0\n    \n    var body: some View {\n        TabView(selection: $selectedTab) {\n            // Products Tab\n            ProductListView(products: inventory.products)\n                .tabItem {\n                    Image(systemName: \"list.bullet\")\n                    Text(\"Products\")\n                }\n                .tag(0)\n            \n            // Cart Tab\n            CartView()\n                .tabItem {\n                    Image(systemName: \"cart\")\n                    Text(\"Cart\")\n                }\n                .badge(cart.itemCount)\n                .tag(1)\n        }\n        .environmentObject(cart)\n        .environmentObject(inventory)\n    }\n}\n\nstruct CartView: View {\n    @EnvironmentObject var cart: ShoppingCart\n    \n    var body: some View {\n        NavigationView {\n            Group {\n                if cart.items.isEmpty {\n                    VStack {\n                        Image(systemName: \"cart\")\n                            .font(.system(size: 60))\n                            .foregroundColor(.secondary)\n                        Text(\"Your cart is empty\")\n                            .font(.title2)\n                            .foregroundColor(.secondary)\n                    }\n                } else {\n                    List {\n                        ForEach(cart.items) { item in\n                            HStack {\n                                VStack(alignment: .leading) {\n                                    Text(item.product.name)\n                                        .font(.headline)\n                                    Text(\"$\\(item.product.price, specifier: \"%.2f\") each\")\n                                        .font(.caption)\n                                        .foregroundColor(.secondary)\n                                }\n                                \n                                Spacer()\n                                \n                                QuantityStepper(quantity: Binding(\n                                    get: { item.quantity },\n                                    set: { newValue in\n                                        cart.updateQuantity(for: item.product, to: newValue)\n                                    }\n                                ))\n                                \n                                Text(\"$\\(item.total, specifier: \"%.2f\")\")\n                                    .font(.headline)\n                                    .frame(width: 80, alignment: .trailing)\n                            }\n                        }\n                        .onDelete { indexSet in\n                            for index in indexSet {\n                                cart.removeProduct(cart.items[index].product)\n                            }\n                        }\n                        \n                        // Total section\n                        Section {\n                            HStack {\n                                Text(\"Total\")\n                                    .font(.title2)\n                                    .bold()\n                                Spacer()\n                                Text(\"$\\(cart.total, specifier: \"%.2f\")\")\n                                    .font(.title2)\n                                    .bold()\n                            }\n                        }\n                    }\n                    .listStyle(.insetGrouped)\n                }\n            }\n            .navigationTitle(\"Shopping Cart\")\n            .toolbar {\n                if !cart.items.isEmpty {\n                    Button(\"Clear All\") {\n                        cart.clear()\n                    }\n                }\n            }\n        }\n    }\n}\n\n// Data Models\nstruct Product: Identifiable {\n    let id: Int\n    let name: String\n    let category: String\n    let price: Double\n}\n\nstruct CartItem: Identifiable {\n    let id = UUID()\n    let product: Product\n    var quantity: Int\n    \n    var total: Double {\n        product.price * Double(quantity)\n    }\n}",
        "hints": [
          "PART 1: Use @State for UI-only state like search queries and filters. Computed properties are great for derived data",
          "PART 2: @Binding creates two-way connections. Use it when child views need to modify parent state",
          "PART 3: ObservableObject classes should contain your app's business logic and shared state",
          "PART 4: Use @EnvironmentObject to share data across multiple views without passing through each one",
          "Remember: @State for view-owned data, @Binding for shared value types, @ObservedObject for shared reference types",
          "Use computed properties to transform state instead of storing derived values",
          "For complex bindings, you can create custom Binding instances with get/set closures",
          "Always mark @State properties as private to ensure they're only modified by the view that owns them"
        ],
        "testCases": [
          {
            "input": "cart.items.count after adding 2 different products",
            "expectedOutput": "2",
            "description": "Cart should contain unique products with quantities"
          },
          {
            "input": "cart.total after adding 3 items of $10 product",
            "expectedOutput": "30.0",
            "description": "Total should calculate price Ã— quantity correctly"
          },
          {
            "input": "filteredProducts.count when searching for non-existent product",
            "expectedOutput": "0",
            "description": "Search should filter products correctly"
          }
        ]
      }
    },
    {
      "id": "lists_navigation",
      "title": "Lists & Navigation",
      "description": "Master displaying data collections and building navigation flows in SwiftUI apps",
      "difficulty": "beginner",
      "theory": "# Lists & Navigation - Building Data-Driven Interfaces\n\n## 1. Understanding Lists in SwiftUI (60 min)\n\n### What are Lists?\n- **Container views** that display rows of data\n- Similar to UITableView but **much simpler**\n- Automatically handles **scrolling, selection, and styling**\n- Built on top of SwiftUI's declarative syntax\n\n### Basic List Syntax:\n```swift\nList {\n    Text(\"Row 1\")\n    Text(\"Row 2\")\n    Text(\"Row 3\")\n}\n```\n\n### Lists with Arrays:\n```swift\nlet fruits = [\"Apple\", \"Banana\", \"Orange\"]\n\nList(fruits, id: \\.self) { fruit in\n    Text(fruit)\n}\n```\n\n### Why Lists are Powerful:\n- **Automatic recycling** (like UITableView reuse)\n- **Smooth performance** with large datasets\n- **Built-in gestures** and interactions\n- **Consistent styling** across iOS\n\n## 2. Building Basic Lists (60 min)\n\n### Static Lists:\n```swift\nList {\n    Text(\"Settings\")\n    Text(\"Profile\")\n    Text(\"Notifications\")\n    Text(\"Help\")\n}\n```\n\n### Dynamic Lists from Arrays:\n```swift\nstruct TodoItem: Identifiable {\n    let id = UUID()\n    let title: String\n    let isCompleted: Bool\n}\n\nlet todos = [\n    TodoItem(title: \"Buy groceries\", isCompleted: false),\n    TodoItem(title: \"Walk the dog\", isCompleted: true),\n    TodoItem(title: \"Learn SwiftUI\", isCompleted: false)\n]\n\nList(todos) { todo in\n    HStack {\n        Image(systemName: todo.isCompleted ? \"checkmark.circle.fill\" : \"circle\")\n        Text(todo.title)\n    }\n}\n```\n\n### Mixed Static and Dynamic Content:\n```swift\nList {\n    Section(header: Text(\"Favorites\")) {\n        Text(\"Starred Items\")\n        Text(\"Recent\")\n    }\n    \n    Section(header: Text(\"All Items\")) {\n        ForEach(items) { item in\n            Text(item.name)\n        }\n    }\n    \n    Section(footer: Text(\"End of list\")) {\n        Button(\"Load More...\") {\n            // Load more action\n        }\n    }\n}\n```\n\n## 3. Navigation Fundamentals (60 min)\n\n### NavigationView Basics:\n- **Container** for navigable content\n- Provides **navigation bar** and **hierarchy management**\n- Automatically handles **back buttons** and **transitions**\n\n### Basic Navigation Setup:\n```swift\nNavigationView {\n    List {\n        Text(\"Home Screen\")\n        Text(\"Profile Screen\")\n        Text(\"Settings Screen\")\n    }\n    .navigationTitle(\"Main Menu\")\n}\n```\n\n### NavigationLink - The Navigation Trigger:\n```swift\nNavigationView {\n    List {\n        NavigationLink(\"Go to Details\") {\n            Text(\"Detail Screen\")\n        }\n        \n        NavigationLink(destination: Text(\"Another Screen\")) {\n            HStack {\n                Image(systemName: \"star\")\n                Text(\"Favorites\")\n            }\n        }\n    }\n    .navigationTitle(\"Navigation Demo\")\n}\n```\n\n### Navigation Modifiers:\n```swift\n.navigationTitle(\"My App\")          // Large title\n.navigationBarTitleDisplayMode(.large) // .large or .inline\n.navigationBarHidden(false)           // Show/hide bar\n.navigationBarBackButtonHidden(false) // Show/hide back button\n```\n\n## 4. Combining Lists & Navigation (60 min)\n\n### Typical App Pattern:\n```swift\nstruct ContentView: View {\n    let categories = [\"Tech\", \"Sports\", \"Food\", \"Travel\"]\n    \n    var body: some View {\n        NavigationView {\n            List(categories, id: \\.self) { category in\n                NavigationLink(destination: CategoryDetail(category: category)) {\n                    HStack {\n                        Image(systemName: \"folder\")\n                        Text(category)\n                        Spacer()\n                        Text(\"5 items\")\n                            .foregroundColor(.gray)\n                    }\n                }\n            }\n            .navigationTitle(\"Categories\")\n        }\n    }\n}\n\nstruct CategoryDetail: View {\n    let category: String\n    \n    var body: some View {\n        List {\n            Text(\"Item 1 in \\(category)\")\n            Text(\"Item 2 in \\(category)\")\n            Text(\"Item 3 in \\(category)\")\n        }\n        .navigationTitle(category)\n    }\n}\n```\n\n### Passing Data Between Screens:\n```swift\nstruct User: Identifiable {\n    let id = UUID()\n    let name: String\n    let email: String\n}\n\nstruct UserListView: View {\n    let users = [\n        User(name: \"John Doe\", email: \"john@example.com\"),\n        User(name: \"Jane Smith\", email: \"jane@example.com\")\n    ]\n    \n    var body: some View {\n        NavigationView {\n            List(users) { user in\n                NavigationLink(destination: UserDetailView(user: user)) {\n                    VStack(alignment: .leading) {\n                        Text(user.name)\n                            .font(.headline)\n                        Text(user.email)\n                            .font(.subheadline)\n                            .foregroundColor(.gray)\n                    }\n                }\n            }\n            .navigationTitle(\"Users\")\n        }\n    }\n}\n\nstruct UserDetailView: View {\n    let user: User\n    \n    var body: some View {\n        VStack(alignment: .leading, spacing: 16) {\n            Text(user.name)\n                .font(.largeTitle)\n            Text(user.email)\n                .font(.title2)\n                .foregroundColor(.blue)\n            Spacer()\n        }\n        .padding()\n        .navigationTitle(\"User Details\")\n        .navigationBarTitleDisplayMode(.inline)\n    }\n}\n```\n\n## 5. Advanced List Features (60 min)\n\n### List Sections:\n```swift\nList {\n    Section(header: Text(\"Important\")) {\n        Text(\"Urgent Task\")\n        Text(\"Critical Update\")\n    }\n    \n    Section(header: Text(\"Regular\"), footer: Text(\"End of regular tasks\")) {\n        ForEach(regularTasks) { task in\n            Text(task.title)\n        }\n    }\n    \n    Section(header: Text(\"Completed\")) {\n        Toggle(\"Show completed\", isOn: $showCompleted)\n        if showCompleted {\n            ForEach(completedTasks) { task in\n                Text(task.title)\n                    .strikethrough()\n                    .foregroundColor(.gray)\n            }\n        }\n    }\n}\n.listStyle(InsetGroupedListStyle())\n```\n\n### List Styles:\n```swift\n.listStyle(PlainListStyle())           // Basic full-width\n.listStyle(GroupedListStyle())         // iOS 13 grouped\n.listStyle(InsetGroupedListStyle())    // iOS 14+ inset grouped\n.listStyle(SidebarListStyle())         // For sidebar navigation\n```\n\n### Swipe Actions (iOS 15+):\n```swift\nList {\n    ForEach(todos) { todo in\n        Text(todo.title)\n            .swipeActions(edge: .trailing) {\n                Button(\"Delete\", role: .destructive) {\n                    deleteTodo(todo)\n                }\n                \n                Button(\"Edit\") {\n                    editTodo(todo)\n                }\n                .tint(.blue)\n            }\n            .swipeActions(edge: .leading) {\n                Button(\"Complete\") {\n                    completeTodo(todo)\n                }\n                .tint(.green)\n            }\n    }\n}\n```\n\n### Pull to Refresh:\n```swift\nList(items) { item in\n    Text(item.name)\n}\n.refreshable {\n    await loadData()\n}\n```\n\n## 6. Navigation Patterns & Best Practices (60 min)\n\n### Programmatic Navigation:\n```swift\nstruct ContentView: View {\n    @State private var isShowingDetail = false\n    @State private var selectedItem: String? = nil\n    \n    var body: some View {\n        NavigationView {\n            List {\n                Button(\"Show Detail Programmatically\") {\n                    selectedItem = \"Manual Selection\"\n                    isShowingDetail = true\n                }\n                \n                NavigationLink(\n                    \"Go to Detail\", \n                    destination: Text(\"Detail Screen\"),\n                    isActive: $isShowingDetail\n                )\n            }\n            .navigationTitle(\"Programmatic Nav\")\n        }\n    }\n}\n```\n\n### Navigation Stack Management:\n```swift\n.navigationBarItems(\n    leading: Button(\"Cancel\") { /* action */ },\n    trailing: HStack {\n        Button(\"Edit\") { /* action */ }\n        Button(\"Add\") { /* action */ }\n    }\n)\n```\n\n### Tab-Based Navigation with Lists:\n```swift\nTabView {\n    NavigationView {\n        List {\n            // Home content\n        }\n        .navigationTitle(\"Home\")\n    }\n    .tabItem {\n        Image(systemName: \"house\")\n        Text(\"Home\")\n    }\n    \n    NavigationView {\n        List {\n            // Settings content\n        }\n        .navigationTitle(\"Settings\")\n    }\n    .tabItem {\n        Image(systemName: \"gear\")\n        Text(\"Settings\")\n    }\n}\n```\n\n### Common Navigation Patterns:\n- **Master-Detail**: List â†’ Detail screen\n- **Tab-Based**: Multiple main sections\n- **Hierarchical**: Deep navigation trees\n- **Modal**: Temporary screens on top\n\n## Practice Exercises\n\nComplete all exercises to master Lists & Navigation in SwiftUI!",
      "codeExample": "// === COMPLETE LIST & NAVIGATION EXAMPLE ===\n\nimport SwiftUI\n\n// Model\nstruct Book: Identifiable {\n    let id = UUID()\n    let title: String\n    let author: String\n    let year: Int\n    let genre: String\n}\n\n// Sample Data\nlet sampleBooks = [\n    Book(title: \"The Great Gatsby\", author: \"F. Scott Fitzgerald\", year: 1925, genre: \"Fiction\"),\n    Book(title: \"To Kill a Mockingbird\", author: \"Harper Lee\", year: 1960, genre: \"Fiction\"),\n    Book(title: \"1984\", author: \"George Orwell\", year: 1949, genre: \"Dystopian\"),\n    Book(title: \"Pride and Prejudice\", author: \"Jane Austen\", year: 1813, genre: \"Romance\"),\n    Book(title: \"The Hobbit\", author: \"J.R.R. Tolkien\", year: 1937, genre: \"Fantasy\")\n]\n\n// Main List View\nstruct BookListView: View {\n    let books: [Book]\n    @State private var searchText = \"\"\n    \n    var filteredBooks: [Book] {\n        if searchText.isEmpty {\n            return books\n        } else {\n            return books.filter { \n                $0.title.localizedCaseInsensitiveContains(searchText) ||\n                $0.author.localizedCaseInsensitiveContains(searchText)\n            }\n        }\n    }\n    \n    var body: some View {\n        NavigationView {\n            List {\n                // Featured Section\n                Section(header: Text(\"Featured Books\")) {\n                    ForEach(filteredBooks.prefix(2)) { book in\n                        NavigationLink(destination: BookDetailView(book: book)) {\n                            FeaturedBookRow(book: book)\n                        }\n                    }\n                }\n                \n                // All Books Section\n                Section(header: Text(\"All Books\")) {\n                    ForEach(filteredBooks) { book in\n                        NavigationLink(destination: BookDetailView(book: book)) {\n                            BookRow(book: book)\n                        }\n                        .swipeActions(edge: .trailing) {\n                            Button(\"Favorite\") {\n                                print(\"Favorited: \\(book.title)\")\n                            }\n                            .tint(.yellow)\n                        }\n                    }\n                }\n            }\n            .searchable(text: $searchText, prompt: \"Search books or authors\")\n            .navigationTitle(\"Book Library\")\n            .listStyle(InsetGroupedListStyle())\n            .toolbar {\n                ToolbarItem(placement: .navigationBarTrailing) {\n                    Button(\"Add Book\") {\n                        print(\"Add new book tapped\")\n                    }\n                }\n            }\n        }\n    }\n}\n\n// Book Row Component\nstruct BookRow: View {\n    let book: Book\n    \n    var body: some View {\n        HStack {\n            VStack(alignment: .leading, spacing: 4) {\n                Text(book.title)\n                    .font(.headline)\n                Text(book.author)\n                    .font(.subheadline)\n                    .foregroundColor(.secondary)\n            }\n            \n            Spacer()\n            \n            VStack(alignment: .trailing, spacing: 4) {\n                Text(\"\\(book.year)\")\n                    .font(.caption)\n                    .foregroundColor(.secondary)\n                Text(book.genre)\n                    .font(.caption)\n                    .padding(4)\n                    .background(Color.blue.opacity(0.1))\n                    .cornerRadius(4)\n            }\n        }\n        .padding(.vertical, 4)\n    }\n}\n\n// Featured Book Row Component\nstruct FeaturedBookRow: View {\n    let book: Book\n    \n    var body: some View {\n        HStack {\n            RoundedRectangle(cornerRadius: 8)\n                .fill(Color.blue.opacity(0.1))\n                .frame(width: 60, height: 80)\n                .overlay(\n                    Image(systemName: \"book\")\n                        .foregroundColor(.blue)\n                )\n            \n            VStack(alignment: .leading, spacing: 4) {\n                Text(book.title)\n                    .font(.headline)\n                Text(book.author)\n                    .font(.subheadline)\n                    .foregroundColor(.secondary)\n                \n                HStack {\n                    Text(book.genre)\n                        .font(.caption)\n                        .padding(4)\n                        .background(Color.blue.opacity(0.2))\n                        .cornerRadius(4)\n                    \n                    Text(\"\\(book.year)\")\n                        .font(.caption)\n                        .foregroundColor(.secondary)\n                }\n            }\n            \n            Spacer()\n            \n            Image(systemName: \"star.fill\")\n                .foregroundColor(.yellow)\n        }\n        .padding(.vertical, 8)\n    }\n}\n\n// Detail View\nstruct BookDetailView: View {\n    let book: Book\n    @Environment(\\.presentationMode) var presentationMode\n    \n    var body: some View {\n        ScrollView {\n            VStack(alignment: .leading, spacing: 20) {\n                // Header\n                HStack {\n                    RoundedRectangle(cornerRadius: 12)\n                        .fill(Color.blue.opacity(0.1))\n                        .frame(width: 100, height: 140)\n                        .overlay(\n                            VStack {\n                                Image(systemName: \"book\")\n                                    .font(.largeTitle)\n                                    .foregroundColor(.blue)\n                                Text(\"BOOK\")\n                                    .font(.caption)\n                                    .foregroundColor(.blue)\n                            }\n                        )\n                    \n                    VStack(alignment: .leading, spacing: 8) {\n                        Text(book.title)\n                            .font(.title2)\n                            .bold()\n                        Text(\"by \\(book.author)\")\n                            .font(.headline)\n                            .foregroundColor(.secondary)\n                        \n                        HStack {\n                            Text(book.genre)\n                                .padding(6)\n                                .background(Color.blue.opacity(0.2))\n                                .cornerRadius(6)\n                            \n                            Text(\"Published: \\(book.year)\")\n                                .font(.caption)\n                                .foregroundColor(.secondary)\n                        }\n                    }\n                    \n                    Spacer()\n                }\n                \n                Divider()\n                \n                // Actions\n                LazyVGrid(columns: [GridItem(.flexible()), GridItem(.flexible())], spacing: 12) {\n                    ActionButton(title: \"Read Now\", icon: \"book.fill\", color: .blue)\n                    ActionButton(title: \"Add to Library\", icon: \"plus.circle.fill\", color: .green)\n                    ActionButton(title: \"Share\", icon: \"square.and.arrow.up\", color: .orange)\n                    ActionButton(title: \"Write Review\", icon: \"pencil\", color: .purple)\n                }\n                \n                Divider()\n                \n                // Description\n                VStack(alignment: .leading, spacing: 12) {\n                    Text(\"About This Book\")\n                        .font(.headline)\n                    \n                    Text(\"This is a detailed description of the book '\\(book.title)' by \\(book.author). Published in \\(book.year), this \\(book.genre.lowercased()) novel has captivated readers for generations.\")\n                        .font(.body)\n                        .foregroundColor(.secondary)\n                }\n            }\n            .padding()\n        }\n        .navigationTitle(book.title)\n        .navigationBarTitleDisplayMode(.inline)\n        .navigationBarBackButtonHidden(false)\n        .toolbar {\n            ToolbarItem(placement: .navigationBarTrailing) {\n                Button(\"Favorite\") {\n                    print(\"Favorited \\(book.title)\")\n                }\n            }\n        }\n    }\n}\n\n// Reusable Action Button\nstruct ActionButton: View {\n    let title: String\n    let icon: String\n    let color: Color\n    \n    var body: some View {\n        Button(action: {\n            print(\"\\(title) tapped\")\n        }) {\n            VStack {\n                Image(systemName: icon)\n                    .font(.title2)\n                    .foregroundColor(color)\n                Text(title)\n                    .font(.caption)\n                    .foregroundColor(.primary)\n            }\n            .frame(maxWidth: .infinity)\n            .padding()\n            .background(Color.gray.opacity(0.1))\n            .cornerRadius(10)\n        }\n    }\n}\n\n// Main App\nstruct BooksApp: App {\n    var body: some Scene {\n        WindowGroup {\n            BookListView(books: sampleBooks)\n        }\n    }\n}\n\n// Preview\nstruct BookListView_Previews: PreviewProvider {\n    static var previews: some View {\n        BookListView(books: sampleBooks)\n    }\n}",
      "category": "SwiftUI Basics",
      "estimatedTime": 240,
      "dependencies": ["swiftui_intro", "data_models"],
      "challenge": {
        "instructions": "Create a complete restaurant discovery app using Lists and Navigation in SwiftUI:\n\nPART 1: Data Modeling & Basic List (60 min)\n1. Create 'Restaurant' struct with: id, name, cuisine, priceRange, rating, imageName, isFavorite\n2. Create sample restaurant data with at least 8 different restaurants\n3. Build a basic list displaying restaurant names and cuisines\n4. Add sections to group restaurants by cuisine type\n\nPART 2: Enhanced List UI (60 min)\n5. Create a custom 'RestaurantRow' view with: name, cuisine, rating stars, price range indicators\n6. Add swipe actions to toggle favorite status and quick actions\n7. Implement search functionality to filter restaurants by name or cuisine\n8. Add pull-to-refresh simulation\n\nPART 3: Navigation & Detail Views (60 min)\n9. Create 'RestaurantDetailView' showing: large header, full details, action buttons\n10. Implement navigation from list to detail view\n11. Add navigation bar buttons for sharing and favoriting\n12. Create a favorites screen that shows only favorited restaurants\n\nPART 4: Advanced Features (60 min)\n13. Implement programmatic navigation to show specific restaurants\n14. Add a filter screen to filter by cuisine, price range, and minimum rating\n15. Create a tab-based navigation with: Home, Favorites, Search tabs\n16. Add a map view integration (placeholder) in the detail screen\n\nTest your app thoroughly to ensure smooth navigation and list performance!",
        "starterCode": "import SwiftUI\n\n// === PART 1: Data Models ===\n// Define your Restaurant struct and sample data here\n\n\n// === PART 2: Restaurant List ===\n// Create your main list view with search and sections\n\n\n// === PART 3: Detail View ===\n// Build the restaurant detail view with navigation\n\n\n// === PART 4: Advanced Navigation ===\n// Implement tab navigation and filtering\n\n\n// Preview Provider\nstruct ContentView_Previews: PreviewProvider {\n    static var previews: some View {\n        // Add your main view here for preview\n        Text(\"Restaurant App Preview\")\n    }\n}",
        "solution": "import SwiftUI\n\n// === PART 1: Data Models ===\nstruct Restaurant: Identifiable {\n    let id = UUID()\n    let name: String\n    let cuisine: String\n    let priceRange: Int // 1-3 ($, $$, $$$)\n    let rating: Double // 1-5\n    let imageName: String\n    let description: String\n    let address: String\n    var isFavorite: Bool = false\n}\n\n// Sample data\nlet sampleRestaurants = [\n    Restaurant(name: \"Italian Bistro\", cuisine: \"Italian\", priceRange: 2, rating: 4.5, imageName: \"italian\", description: \"Authentic Italian cuisine with fresh ingredients\", address: \"123 Main St\"),\n    Restaurant(name: \"Sushi Heaven\", cuisine: \"Japanese\", priceRange: 3, rating: 4.8, imageName: \"sushi\", description: \"Premium sushi and sashimi\", address: \"456 Oak Ave\"),\n    Restaurant(name: \"Burger Palace\", cuisine: \"American\", priceRange: 1, rating: 4.2, imageName: \"burger\", description: \"Classic American burgers and fries\", address: \"789 Elm St\"),\n    Restaurant(name: \"Taco Fiesta\", cuisine: \"Mexican\", priceRange: 1, rating: 4.0, imageName: \"mexican\", description: \"Fresh Mexican street food\", address: \"321 Pine Rd\"),\n    Restaurant(name: \"French Delight\", cuisine: \"French\", priceRange: 3, rating: 4.7, imageName: \"french\", description: \"Elegant French dining experience\", address: \"654 Maple Dr\"),\n    Restaurant(name: \"Dragon Palace\", cuisine: \"Chinese\", priceRange: 2, rating: 4.3, imageName: \"chinese\", description: \"Traditional Chinese dishes\", address: \"987 Cedar Ln\"),\n    Restaurant(name: \"Spice Garden\", cuisine: \"Indian\", priceRange: 2, rating: 4.6, imageName: \"indian\", description: \"Aromatic Indian curries and breads\", address: \"147 Birch St\"),\n    Restaurant(name: \"Mediterranean Grill\", cuisine: \"Mediterranean\", priceRange: 2, rating: 4.4, imageName: \"mediterranean\", description: \"Healthy Mediterranean flavors\", address: \"258 Willow Ave\")\n]\n\n// === PART 2: Restaurant List ===\nstruct RestaurantListView: View {\n    let restaurants: [Restaurant]\n    @State private var searchText = \"\"\n    @State private var isRefreshing = false\n    \n    var filteredRestaurants: [Restaurant] {\n        if searchText.isEmpty {\n            return restaurants\n        } else {\n            return restaurants.filter {\n                $0.name.localizedCaseInsensitiveContains(searchText) ||\n                $0.cuisine.localizedCaseInsensitiveContains(searchText)\n            }\n        }\n    }\n    \n    var groupedRestaurants: [String: [Restaurant]] {\n        Dictionary(grouping: filteredRestaurants) { $0.cuisine }\n    }\n    \n    var body: some View {\n        NavigationView {\n            List {\n                ForEach(Array(groupedRestaurants.keys.sorted()), id: \\.self) { cuisine in\n                    Section(header: Text(cuisine).font(.headline)) {\n                        ForEach(groupedRestaurants[cuisine]!) { restaurant in\n                            NavigationLink(destination: RestaurantDetailView(restaurant: restaurant)) {\n                                RestaurantRow(restaurant: restaurant)\n                            }\n                            .swipeActions(edge: .trailing) {\n                                Button {\n                                    toggleFavorite(for: restaurant)\n                                } label: {\n                                    Label(\"Favorite\", systemImage: restaurant.isFavorite ? \"heart.slash\" : \"heart\")\n                                }\n                                .tint(restaurant.isFavorite ? .gray : .red)\n                            }\n                        }\n                    }\n                }\n            }\n            .searchable(text: $searchText, prompt: \"Search restaurants or cuisines\")\n            .refreshable {\n                await simulateRefresh()\n            }\n            .navigationTitle(\"Restaurants\")\n            .listStyle(InsetGroupedListStyle())\n        }\n    }\n    \n    private func toggleFavorite(for restaurant: Restaurant) {\n        // In a real app, you'd update this in your data model\n        print(\"Toggled favorite for \\(restaurant.name)\")\n    }\n    \n    private func simulateRefresh() async {\n        isRefreshing = true\n        try? await Task.sleep(nanoseconds: 1_000_000_000) // 1 second\n        isRefreshing = false\n    }\n}\n\nstruct RestaurantRow: View {\n    let restaurant: Restaurant\n    \n    var body: some View {\n        HStack {\n            // Restaurant icon\n            Circle()\n                .fill(Color.blue.opacity(0.2))\n                .frame(width: 50, height: 50)\n                .overlay(\n                    Text(String(restaurant.name.prefix(1)))\n                        .font(.title2)\n                        .foregroundColor(.blue)\n                )\n            \n            VStack(alignment: .leading, spacing: 4) {\n                Text(restaurant.name)\n                    .font(.headline)\n                \n                Text(restaurant.cuisine)\n                    .font(.subheadline)\n                    .foregroundColor(.secondary)\n                \n                HStack {\n                    // Rating stars\n                    HStack(spacing: 2) {\n                        ForEach(1...5, id: \\.self) { star in\n                            Image(systemName: star <= Int(restaurant.rating) ? \"star.fill\" : \"star\")\n                                .foregroundColor(.yellow)\n                                .font(.caption)\n                        }\n                        Text(\"(\\(restaurant.rating, specifier: \"%.1f\"))\")\n                            .font(.caption)\n                            .foregroundColor(.secondary)\n                    }\n                }\n            }\n            \n            Spacer()\n            \n            // Price range\n            VStack(alignment: .trailing) {\n                Text(String(repeating: \"$\", count: restaurant.priceRange))\n                    .font(.subheadline)\n                    .foregroundColor(.green)\n                \n                if restaurant.isFavorite {\n                    Image(systemName: \"heart.fill\")\n                        .foregroundColor(.red)\n                        .font(.caption)\n                }\n            }\n        }\n        .padding(.vertical, 4)\n    }\n}\n\n// === PART 3: Detail View ===\nstruct RestaurantDetailView: View {\n    let restaurant: Restaurant\n    @Environment(\\.presentationMode) var presentationMode\n    @State private var isShowingMap = false\n    \n    var body: some View {\n        ScrollView {\n            VStack(alignment: .leading, spacing: 16) {\n                // Header\n                ZStack(alignment: .bottomLeading) {\n                    Rectangle()\n                        .fill(Color.blue.opacity(0.3))\n                        .frame(height: 200)\n                        .overlay(\n                            Text(restaurant.name)\n                                .font(.largeTitle)\n                                .bold()\n                                .foregroundColor(.white)\n                                .shadow(radius: 5)\n                        )\n                    \n                    VStack(alignment: .leading) {\n                        Text(restaurant.cuisine)\n                            .font(.title3)\n                            .foregroundColor(.white)\n                        \n                        HStack {\n                            ForEach(1...5, id: \\.self) { star in\n                                Image(systemName: star <= Int(restaurant.rating) ? \"star.fill\" : \"star\")\n                                    .foregroundColor(.yellow)\n                            }\n                            Text(\"\\(restaurant.rating, specifier: \"%.1f\")\")\n                                .foregroundColor(.white)\n                        }\n                    }\n                    .padding()\n                    .background(Color.black.opacity(0.5))\n                }\n                \n                // Info Section\n                VStack(alignment: .leading, spacing: 12) {\n                    InfoRow(icon: \"mappin.circle\", text: restaurant.address)\n                    InfoRow(icon: \"dollarsign.circle\", text: \"Price: \\(String(repeating: \"$\", count: restaurant.priceRange))\")\n                }\n                .padding(.horizontal)\n                \n                // Actions\n                LazyVGrid(columns: [GridItem(.flexible()), GridItem(.flexible())], spacing: 12) {\n                    ActionButton(title: \"Call\", icon: \"phone\", color: .green) {\n                        print(\"Call \\(restaurant.name)\")\n                    }\n                    ActionButton(title: \"Directions\", icon: \"map\", color: .blue) {\n                        isShowingMap = true\n                    }\n                    ActionButton(title: \"Website\", icon: \"globe\", color: .orange) {\n                        print(\"Open website\")\n                    }\n                    ActionButton(title: \"Share\", icon: \"square.and.arrow.up\", color: .purple) {\n                        print(\"Share restaurant\")\n                    }\n                }\n                .padding(.horizontal)\n                \n                // Description\n                VStack(alignment: .leading, spacing: 8) {\n                    Text(\"About\")\n                        .font(.headline)\n                    \n                    Text(restaurant.description)\n                        .foregroundColor(.secondary)\n                }\n                .padding(.horizontal)\n                \n                Spacer()\n            }\n        }\n        .navigationTitle(restaurant.name)\n        .navigationBarTitleDisplayMode(.inline)\n        .toolbar {\n            ToolbarItem(placement: .navigationBarTrailing) {\n                Button(action: { toggleFavorite() }) {\n                    Image(systemName: restaurant.isFavorite ? \"heart.fill\" : \"heart\")\n                        .foregroundColor(restaurant.isFavorite ? .red : .primary)\n                }\n            }\n        }\n        .sheet(isPresented: $isShowingMap) {\n            MapView(restaurant: restaurant)\n        }\n    }\n    \n    private func toggleFavorite() {\n        print(\"Toggled favorite for \\(restaurant.name)\")\n    }\n}\n\nstruct InfoRow: View {\n    let icon: String\n    let text: String\n    \n    var body: some View {\n        HStack {\n            Image(systemName: icon)\n                .foregroundColor(.blue)\n                .frame(width: 30)\n            Text(text)\n            Spacer()\n        }\n    }\n}\n\nstruct ActionButton: View {\n    let title: String\n    let icon: String\n    let color: Color\n    let action: () -> Void\n    \n    var body: some View {\n        Button(action: action) {\n            VStack {\n                Image(systemName: icon)\n                    .font(.title2)\n                    .foregroundColor(color)\n                Text(title)\n                    .font(.caption)\n                    .foregroundColor(.primary)\n            }\n            .frame(maxWidth: .infinity)\n            .padding()\n            .background(Color.gray.opacity(0.1))\n            .cornerRadius(10)\n        }\n    }\n}\n\n// Placeholder Map View\nstruct MapView: View {\n    let restaurant: Restaurant\n    @Environment(\\.presentationMode) var presentationMode\n    \n    var body: some View {\n        NavigationView {\n            VStack {\n                Rectangle()\n                    .fill(Color.blue.opacity(0.3))\n                    .overlay(\n                        VStack {\n                            Image(systemName: \"map\")\n                                .font(.system(size: 60))\n                                .foregroundColor(.blue)\n                            Text(\"Map View\")\n                                .font(.title2)\n                            Text(restaurant.address)\n                                .font(.body)\n                                .foregroundColor(.secondary)\n                        }\n                    )\n                    .frame(height: 300)\n                \n                Spacer()\n            }\n            .navigationTitle(\"Location\")\n            .navigationBarTitleDisplayMode(.inline)\n            .toolbar {\n                ToolbarItem(placement: .navigationBarTrailing) {\n                    Button(\"Done\") {\n                        presentationMode.wrappedValue.dismiss()\n                    }\n                }\n            }\n        }\n    }\n}\n\n// === PART 4: Advanced Navigation ===\nstruct RestaurantApp: App {\n    var body: some Scene {\n        WindowGroup {\n            MainTabView()\n        }\n    }\n}\n\nstruct MainTabView: View {\n    var body: some View {\n        TabView {\n            RestaurantListView(restaurants: sampleRestaurants)\n                .tabItem {\n                    Image(systemName: \"house\")\n                    Text(\"Home\")\n                }\n            \n            FavoritesView()\n                .tabItem {\n                    Image(systemName: \"heart\")\n                    Text(\"Favorites\")\n                }\n            \n            SearchView()\n                .tabItem {\n                    Image(systemName: \"magnifyingglass\")\n                    Text(\"Search\")\n                }\n        }\n    }\n}\n\nstruct FavoritesView: View {\n    var body: some View {\n        NavigationView {\n            VStack {\n                Text(\"Your Favorite Restaurants\")\n                    .font(.title2)\n                    .padding()\n                \n                // In a real app, you'd filter restaurants that are favorited\n                List(sampleRestaurants.filter { $0.isFavorite }) { restaurant in\n                    RestaurantRow(restaurant: restaurant)\n                }\n                .overlay(\n                    Group {\n                        if sampleRestaurants.filter({ $0.isFavorite }).isEmpty {\n                            Text(\"No favorites yet\\nTap the heart icon to add some!\")\n                                .multilineTextAlignment(.center)\n                                .foregroundColor(.secondary)\n                        }\n                    }\n                )\n            }\n            .navigationTitle(\"Favorites\")\n        }\n    }\n}\n\nstruct SearchView: View {\n    @State private var searchText = \"\"\n    \n    var body: some View {\n        NavigationView {\n            VStack {\n                Text(\"Advanced Search\")\n                    .font(.title2)\n                    .padding()\n                \n                // Search filters would go here\n                List(sampleRestaurants) { restaurant in\n                    RestaurantRow(restaurant: restaurant)\n                }\n            }\n            .navigationTitle(\"Search\")\n        }\n    }\n}\n\n// Preview\nstruct RestaurantListView_Previews: PreviewProvider {\n    static var previews: some View {\n        RestaurantListView(restaurants: sampleRestaurants)\n    }\n}",
        "hints": [
          "PART 1: Use Dictionary(grouping:by:) to create sections by cuisine. Make sure your struct conforms to Identifiable",
          "PART 2: Implement swipeActions with different colors for different actions. Use .searchable modifier for search functionality",
          "PART 3: Use @Environment(\\.presentationMode) to handle custom back button actions. Create reusable components for buttons and info rows",
          "PART 4: TabView with NavigationView in each tab creates proper navigation hierarchies. Use @State for filter selections",
          "For rating stars, use ForEach with range and conditional SF Symbols",
          "Use .overlay modifier to show empty state messages when lists are empty",
          "Implement refreshable with async/await for pull-to-refresh",
          "Create reusable ActionButton component for consistent button styling"
        ],
        "testCases": [
          {
            "input": "groupedRestaurants.keys.count",
            "expectedOutput": "7",
            "description": "Should group restaurants by 7 different cuisines"
          },
          {
            "input": "filteredRestaurants.count when searching 'Italian'",
            "expectedOutput": "1",
            "description": "Search should filter restaurants by name or cuisine"
          },
          {
            "input": "sampleRestaurants.filter { $0.priceRange == 1 }.count",
            "expectedOutput": "2",
            "description": "Should correctly filter by price range"
          }
        ]
      }
    },
    {
      "id": "swiftui_user_input",
      "title": "User Input in SwiftUI",
      "description": "Master interactive controls - buttons, text fields, pickers and forms to create engaging user interfaces",
      "difficulty": "beginner",
      "theory": "# User Input in SwiftUI - Interactive Controls\\n\\n## 1. Understanding State & Binding (60 min)\\n\\n### The Foundation of SwiftUI Interaction\\n- **@State**: For local view state that changes over time\\n- **@Binding**: Creates two-way connection between parent and child views\\n- **@StateObject**: For reference types that conform to ObservableObject\\n- **@Published**: Marks properties that should trigger view updates\\n\\n### State Management Basics:\\n```swift\\nstruct ContentView: View {\\n    @State private var username = \\\"\\\"\\n    @State private var isOn = false\\n    \\n    var body: some View {\\n        VStack {\\n            Text(\\\"Hello, \\\\(username)!\\\")\\n            Toggle(\\\"Active\\\", isOn: $isOn)\\n        }\\n    }\\n}\\n```\\n\\n### Real-world Analogy:\\n- **@State**: Like your personal notebook - you control what's written\\n- **@Binding**: Like a shared whiteboard - multiple people can read and write\\n- **ObservableObject**: Like a company announcement board - everyone gets updates\\n\\n## 2. Buttons & Actions (45 min)\\n\\n### Basic Button Syntax:\\n```swift\\nButton(\\\"Tap Me!\\\") {\\n    print(\\\"Button was tapped!\\\")\\n}\\n\\n// With custom styling\\nButton(action: {\\n    // Action code here\\n}) {\\n    Text(\\\"Custom Button\\\")\\n        .padding()\\n        .background(Color.blue)\\n        .foregroundColor(.white)\\n        .cornerRadius(8)\\n}\\n```\\n\\n### Button Styles & Variations:\\n```swift\\n// Different button styles\\nVStack {\\n    Button(\\\"Plain Style\\\") { }\\n        .buttonStyle(PlainButtonStyle())\\n    \\n    Button(\\\"Bordered\\\") { }\\n        .buttonStyle(.bordered)\\n    \\n    Button(\\\"Bordered Prominent\\\") { }\\n        .buttonStyle(.borderedProminent)\\n    \\n    Button(\\\"Destructive\\\") { }\\n        .buttonStyle(.borderedProminent)\\n        .tint(.red)\\n}\\n```\\n\\n### Advanced Button Features:\\n```swift\\n// Button with role\\nButton(\\\"Delete\\\", role: .destructive) {\\n    deleteItem()\\n}\\n\\n// Disabled state\\nButton(\\\"Submit\\\") {\\n    submitForm()\\n}\\n.disabled(username.isEmpty)\\n\\n// Button with system icon\\nButton {\\n    shareContent()\\n} label: {\\n    Label(\\\"Share\\\", systemImage: \\\"square.and.arrow.up\\\")\\n}\\n```\\n\\n## 3. Text Fields & Text Editors (60 min)\\n\\n### Basic Text Input:\\n```swift\\nstruct LoginView: View {\\n    @State private var email = \\\"\\\"\\n    @State private var password = \\\"\\\"\\n    \\n    var body: some View {\\n        Form {\\n            TextField(\\\"Email address\\\", text: $email)\\n                .textContentType(.emailAddress)\\n                .keyboardType(.emailAddress)\\n                .autocapitalization(.none)\\n            \\n            SecureField(\\\"Password\\\", text: $password)\\n                .textContentType(.password)\\n        }\\n    }\\n}\\n```\\n\\n### Text Field Modifiers & Validation:\\n```swift\\nTextField(\\\"Username\\\", text: $username)\\n    .textFieldStyle(.roundedBorder)\\n    .disableAutocorrection(true)\\n    .textInputAutocapitalization(.never)\\n    .onSubmit {\\n        validateUsername()\\n    }\\n    .onChange(of: username) { newValue in\\n        // React to text changes\\n        if newValue.count > 20 {\\n            username = String(newValue.prefix(20))\\n        }\\n    }\\n```\\n\\n### Text Editor for Multi-line Input:\\n```swift\\nstruct NoteView: View {\\n    @State private var noteText = \\\"Enter your notes here...\\\"\\n    \\n    var body: some View {\\n        TextEditor(text: $noteText)\\n            .font(.body)\\n            .lineSpacing(5)\\n            .border(Color.gray, width: 1)\\n            .frame(height: 200)\\n    }\\n}\\n```\\n\\n### Input Formatting & Masks:\\n```swift\\nTextField(\\\"Phone Number\\\", text: $phoneNumber)\\n    .keyboardType(.phonePad)\\n    .onChange(of: phoneNumber) { newValue in\\n        // Simple phone number formatting\\n        let filtered = newValue.filter { $0.isNumber }\\n        if filtered.count <= 10 {\\n            phoneNumber = formatPhoneNumber(filtered)\\n        }\\n    }\\n```\\n\\n## 4. Pickers & Selection Controls (60 min)\\n\\n### Segmented Picker:\\n```swift\\nstruct ThemePicker: View {\\n    @State private var selectedTheme = 0\\n    let themes = [\\\"Light\\\", \\\"Dark\\\", \\\"Auto\\\"]\\n    \\n    var body: some View {\\n        Picker(\\\"Theme\\\", selection: $selectedTheme) {\\n            ForEach(0..<themes.count, id: \\\\.self) { index in\\n                Text(themes[index]).tag(index)\\n            }\\n        }\\n        .pickerStyle(.segmented)\\n    }\\n}\\n```\\n\\n### Wheel & Menu Pickers:\\n```swift\\n// Wheel picker\\nPicker(\\\"Select Age\\\", selection: $selectedAge) {\\n    ForEach(0..<100, id: \\\\.self) { age in\\n        Text(\\\"\\\\(age) years\\\").tag(age)\\n    }\\n}\\n.pickerStyle(.wheel)\\n\\n// Menu picker (dropdown)\\nPicker(\\\"Color Theme\\\", selection: $selectedColor) {\\n    Text(\\\"Red\\\").tag(Color.red)\\n    Text(\\\"Green\\\").tag(Color.green)\\n    Text(\\\"Blue\\\").tag(Color.blue)\\n}\\n.pickerStyle(.menu)\\n```\\n\\n### Toggle Switches:\\n```swift\\nstruct SettingsView: View {\\n    @State private var notificationsEnabled = true\\n    @State private var darkMode = false\\n    @State private var autoPlay = false\\n    \\n    var body: some View {\\n        Form {\\n            Toggle(\\\"Enable Notifications\\\", isOn: $notificationsEnabled)\\n            Toggle(\\\"Dark Mode\\\", isOn: $darkMode)\\n            Toggle(\\\"Auto-play Videos\\\", isOn: $autoPlay)\\n        }\\n    }\\n}\\n```\\n\\n### Stepper & Slider Controls:\\n```swift\\nVStack {\\n    Stepper(\\\"Age: \\\\(age)\\\", value: $age, in: 0...120)\\n    \\n    Slider(value: $volume, in: 0...1) {\\n        Text(\\\"Volume\\\")\\n    } minimumValueLabel: {\\n        Image(systemName: \\\"speaker.fill\\\")\\n    } maximumValueLabel: {\\n        Image(systemName: \\\"speaker.wave.3.fill\\\")\\n    }\\n    \\n    Text(\\\"Volume: \\\\(Int(volume * 100))%\\\")\\n}\\n```\\n\\n## 5. Forms & Data Validation (45 min)\\n\\n### Building Forms:\\n```swift\\nstruct RegistrationView: View {\\n    @State private var firstName = \\\"\\\"\\n    @State private var lastName = \\\"\\\"\\n    @State private var email = \\\"\\\"\\n    @State private var birthDate = Date()\\n    @State private var receiveNewsletter = true\\n    \\n    var body: some View {\\n        NavigationView {\\n            Form {\\n                Section(header: Text(\\\"Personal Information\\\")) {\\n                    TextField(\\\"First Name\\\", text: $firstName)\\n                    TextField(\\\"Last Name\\\", text: $lastName)\\n                    DatePicker(\\\"Birth Date\\\", selection: $birthDate, displayedComponents: .date)\\n                }\\n                \\n                Section(header: Text(\\\"Contact\\\")) {\\n                    TextField(\\\"Email\\\", text: $email)\\n                        .keyboardType(.emailAddress)\\n                    Toggle(\\\"Receive Newsletter\\\", isOn: $receiveNewsletter)\\n                }\\n                \\n                Section {\\n                    Button(\\\"Create Account\\\") {\\n                        registerUser()\\n                    }\\n                    .disabled(!isFormValid)\\n                }\\n            }\\n            .navigationTitle(\\\"Registration\\\")\\n        }\\n    }\\n    \\n    var isFormValid: Bool {\\n        !firstName.isEmpty && !lastName.isEmpty && !email.isEmpty\\n    }\\n}\\n```\\n\\n### Input Validation & Feedback:\\n```swift\\nTextField(\\\"Email\\\", text: $email)\\n    .onChange(of: email) { _ in\\n        validateEmail()\\n    }\\n    .overlay(\\n        Group {\\n            if showEmailError {\\n                Image(systemName: \\\"exclamationmark.triangle.fill\\\")\\n                    .foregroundColor(.red)\\n                    .offset(x: -10)\\n            }\\n        },\\n        alignment: .trailing\\n    )\\n```\\n\\n### Custom Input Styles:\\n```swift\\n// Custom text field style\\nstruct RoundedTextFieldStyle: TextFieldStyle {\\n    func _body(configuration: TextField<Self._Label>) -> some View {\\n        configuration\\n            .padding(10)\\n            .background(Color(.systemGray6))\\n            .cornerRadius(8)\\n            .overlay(\\n                RoundedRectangle(cornerRadius: 8)\\n                    .stroke(Color.blue, lineWidth: 1)\\n            )\\n    }\\n}\\n\\n// Usage\\nTextField(\\\"Search...\\\", text: $searchText)\\n    .textFieldStyle(RoundedTextFieldStyle())\\n```\\n\\n## 6. Advanced Input Patterns (30 min)\\n\\n### Custom Bindings:\\n```swift\\n// Custom binding with validation\\nvar validatedEmail: Binding<String> {\\n    Binding(\\n        get: { self.email },\\n        set: { newValue in\\n            // Only allow valid email characters\\n            let filtered = newValue.filter { $0.isLetter || $0.isNumber || \\\"@.-_\\\".contains($0) }\\n            self.email = String(filtered.prefix(50))\\n        }\\n    )\\n}\\n\\nTextField(\\\"Email\\\", text: validatedEmail)\\n```\\n\\n### Focus Management:\\n```swift\\nstruct LoginForm: View {\\n    @State private var username = \\\"\\\"\\n    @State private var password = \\\"\\\"\\n    @FocusState private var focusedField: Field?\\n    \\n    enum Field {\\n        case username, password\\n    }\\n    \\n    var body: some View {\\n        Form {\\n            TextField(\\\"Username\\\", text: $username)\\n                .focused($focusedField, equals: .username)\\n                .submitLabel(.next)\\n                .onSubmit {\\n                    focusedField = .password\\n                }\\n            \\n            SecureField(\\\"Password\\\", text: $password)\\n                .focused($focusedField, equals: .password)\\n                .submitLabel(.done)\\n        }\\n        .onAppear {\\n            focusedField = .username\\n        }\\n    }\\n}\\n```\\n\\n### Input Accessibility:\\n```swift\\nTextField(\\\"Name\\\", text: $name)\\n    .accessibilityLabel(\\\"Full name\\\")\\n    .accessibilityHint(\\\"Enter your first and last name\\\")\\n    .accessibilityValue(name.isEmpty ? \\\"Empty\\\" : name)\\n\\nButton(\\\"Submit\\\") { submit() }\\n    .accessibilityLabel(\\\"Submit form\\\")\\n    .accessibilityHint(\\\"Double tap to complete registration\\\")\\n```\\n\\n## Best Practices & Common Patterns\\n\\n### Do's and Don'ts:\\n- **DO** use appropriate keyboard types for different input types\\n- **DO** validate input as users type with `.onChange`\\n- **DO** provide clear feedback for invalid input\\n- **DON'T** store sensitive data in @State without encryption\\n- **DON'T** forget to handle different screen sizes and orientations\\n- **DO** use `.focused` and `@FocusState` for form navigation\\n\\n### Performance Tips:\\n- Use `.onChange` sparingly with expensive operations\\n- Consider debouncing rapid input changes\\n- Use `@StateObject` for complex validation logic\\n- Implement custom bindings for input formatting\\n\\nComplete all practice exercises to master SwiftUI user input controls!\\\"",
      "codeExample": "// === COMPREHENSIVE USER INPUT DEMO ===\\n\\nimport SwiftUI\\n\\nstruct UserInputDemo: View {\\n    // Form State\\n    @State private var username = \\\"\\\"\\n    @State private var email = \\\"\\\"\\n    @State private var password = \\\"\\\"\\n    @State private var age = 18\\n    @State private var rating = 3.0\\n    @State private var isNotificationsOn = true\\n    @State private var selectedColor = \\\"Red\\\"\\n    @State private var birthDate = Date()\\n    @State private var bio = \\\"Tell us about yourself...\\\"\\n    \\n    // UI State\\n    @State private var isSubmitted = false\\n    @State private var showAlert = false\\n    \\n    let colors = [\\\"Red\\\", \\\"Green\\\", \\\"Blue\\\", \\\"Yellow\\\", \\\"Purple\\\"]\\n    \\n    var body: some View {\\n        NavigationView {\\n            Form {\\n                // Section 1: Basic Info\\n                Section(header: Text(\\\"Basic Information\\\")) {\\n                    TextField(\\\"Username\\\", text: $username)\\n                        .textContentType(.username)\\n                        .autocapitalization(.none)\\n                    \\n                    TextField(\\\"Email\\\", text: $email)\\n                        .keyboardType(.emailAddress)\\n                        .textContentType(.emailAddress)\\n                        .autocapitalization(.none)\\n                    \\n                    SecureField(\\\"Password\\\", text: $password)\\n                        .textContentType(.newPassword)\\n                }\\n                \\n                // Section 2: Preferences\\n                Section(header: Text(\\\"Preferences\\\")) {\\n                    Picker(\\\"Favorite Color\\\", selection: $selectedColor) {\\n                        ForEach(colors, id: \\\\.self) { color in\\n                            Text(color)\\n                        }\\n                    }\\n                    .pickerStyle(.menu)\\n                    \\n                    Stepper(\\\"Age: \\\\(age)\\\", value: $age, in: 13...100)\\n                    \\n                    VStack {\\n                        HStack {\\n                            Text(\\\"Satisfaction Rating\\\")\\n                            Spacer()\\n                            Text(\\\"\\\\(rating, specifier: \\\"%.1f\\\")\\\")\\n                        }\\n                        Slider(value: $rating, in: 1...5, step: 0.5)\\n                    }\\n                    \\n                    Toggle(\\\"Enable Notifications\\\", isOn: $isNotificationsOn)\\n                }\\n                \\n                // Section 3: Additional Info\\n                Section(header: Text(\\\"Additional Information\\\")) {\\n                    DatePicker(\\\"Birth Date\\\", selection: $birthDate, displayedComponents: .date)\\n                    \\n                    VStack(alignment: .leading) {\\n                        Text(\\\"Bio\\\")\\n                            .font(.caption)\\n                            .foregroundColor(.secondary)\\n                        TextEditor(text: $bio)\\n                            .frame(height: 100)\\n                            .overlay(\\n                                RoundedRectangle(cornerRadius: 8)\\n                                    .stroke(Color.gray.opacity(0.3), lineWidth: 1)\\n                            )\\n                    }\\n                }\\n                \\n                // Section 4: Actions\\n                Section {\\n                    Button(\\\"Submit Profile\\\") {\\n                        submitProfile()\\n                    }\\n                    .disabled(!isFormValid)\\n                    .frame(maxWidth: .infinity)\\n                    \\n                    Button(\\\"Reset Form\\\", role: .destructive) {\\n                        resetForm()\\n                    }\\n                    .frame(maxWidth: .infinity)\\n                }\\n            }\\n            .navigationTitle(\\\"User Profile\\\")\\n            .alert(\\\"Profile Submitted!\\\", isPresented: $showAlert) {\\n                Button(\\\"OK\\\") { }\\n            } message: {\\n                Text(\\\"Your profile has been successfully updated.\\\")\\n            }\\n        }\\n    }\\n    \\n    // Form Validation\\n    var isFormValid: Bool {\\n        !username.isEmpty && \\n        !email.isEmpty && \\n        !password.isEmpty && \\n        password.count >= 6\\n    }\\n    \\n    // Actions\\n    func submitProfile() {\\n        // In a real app, you would save to a database here\\n        print(\\\"Profile submitted:\\\")\\n        print(\\\"Username: \\\\(username)\\\")\\n        print(\\\"Email: \\\\(email)\\\")\\n        print(\\\"Age: \\\\(age)\\\")\\n        print(\\\"Color: \\\\(selectedColor)\\\")\\n        print(\\\"Rating: \\\\(rating)\\\")\\n        \\n        isSubmitted = true\\n        showAlert = true\\n    }\\n    \\n    func resetForm() {\\n        username = \\\"\\\"\\n        email = \\\"\\\"\\n        password = \\\"\\\"\\n        age = 18\\n        rating = 3.0\\n        isNotificationsOn = true\\n        selectedColor = \\\"Red\\\"\\n        birthDate = Date()\\n        bio = \\\"Tell us about yourself...\\\"\\n        isSubmitted = false\\n    }\\n}\\n\\n// === CUSTOM INPUT COMPONENTS ===\\n\\nstruct CustomTextField: View {\\n    let title: String\\n    @Binding var text: String\\n    var isSecure = false\\n    \\n    var body: some View {\\n        VStack(alignment: .leading) {\\n            Text(title)\\n                .font(.caption)\\n                .foregroundColor(.secondary)\\n            \\n            if isSecure {\\n                SecureField(\\\"\\\", text: $text)\\n                    .textFieldStyle(RoundedBorderTextFieldStyle())\\n            } else {\\n                TextField(\\\"\\\", text: $text)\\n                    .textFieldStyle(RoundedBorderTextFieldStyle())\\n            }\\n        }\\n    }\\n}\\n\\nstruct RatingView: View {\\n    let title: String\\n    @Binding var rating: Int\\n    \\n    var body: some View {\\n        VStack(alignment: .leading) {\\n            Text(title)\\n                .font(.caption)\\n                .foregroundColor(.secondary)\\n            \\n            HStack {\\n                ForEach(1..<6) { star in\\n                    Image(systemName: star <= rating ? \\\"star.fill\\\" : \\\"star\\\")\\n                        .foregroundColor(.yellow)\\n                        .onTapGesture {\\n                            rating = star\\n                        }\\n                }\\n            }\\n        }\\n    }\\n}\\n\\n// === PREVIEW ===\\n\\nstruct UserInputDemo_Previews: PreviewProvider {\\n    static var previews: some View {\\n        UserInputDemo()\\n    }\\n}\\n",
      "category": "SwiftUI Basics",
      "estimatedTime": 240,
      "dependencies": ["swiftui_introduction"],
      "challenge": {
        "instructions": "Create a complete user registration app with multiple input types and validation:\\n\\nPART 1: Basic Form Structure (60 min)\\n1. Create a registration form with sections for personal info, preferences, and account settings\\n2. Implement TextField for name/email, SecureField for passwords\\n3. Add DatePicker for birth date with age validation (18+ only)\\n4. Use Toggle for newsletter subscription option\\n\\nPART 2: Advanced Input Controls (60 min)\\n5. Implement a custom color picker using Picker with segmented style\\n6. Add a Slider for user experience level (1-10) with value display\\n7. Create a Stepper for number of programming languages known\\n8. Add a TextEditor for bio/description with character limit\\n\\nPART 3: Form Validation & UX (60 min)\\n9. Implement real-time validation for email format and password strength\\n10. Add visual feedback for invalid fields (red borders, error messages)\\n11. Create computed properties to enable/disable submit button\\n12. Implement @FocusState for automatic field navigation\\n\\nPART 4: Custom Components & Accessibility (60 min)\\n13. Create custom reusable input components (CustomTextField, RatingView)\\n14. Add full accessibility support with labels, hints, and values\\n15. Implement dark mode compatibility\\n16. Add form reset functionality and confirmation alerts\\n\\nTest your form thoroughly with various input scenarios!",
        "starterCode": "import SwiftUI\\n\\nstruct RegistrationChallenge: View {\\n    // Add your @State properties here\\n    \\n    var body: some View {\\n        NavigationView {\\n            Form {\\n                // PART 1: Build your form sections here\\n                \\n                // PART 2: Add advanced controls here\\n                \\n                // PART 3: Add validation feedback here\\n                \\n                // PART 4: Add action buttons here\\n            }\\n            .navigationTitle(\\\"Complete Registration\\\")\\n        }\\n    }\\n    \\n    // Add your validation logic and methods here\\n    \\n}\\n\\n// PART 4: Create your custom components here\\n\\nstruct RegistrationChallenge_Previews: PreviewProvider {\\n    static var previews: some View {\\n        RegistrationChallenge()\\n    }\\n}\\n",
        "solution": "import SwiftUI\\n\\nstruct RegistrationChallenge: View {\\n    // Form State\\n    @State private var firstName = \\\"\\\"\\n    @State private var lastName = \\\"\\\"\\n    @State private var email = \\\"\\\"\\n    @State private var password = \\\"\\\"\\n    @State private var confirmPassword = \\\"\\\"\\n    @State private var birthDate = Date()\\n    @State private var subscribeNewsletter = true\\n    @State private var selectedTheme = \\\"System\\\"\\n    @State private var experienceLevel = 5.0\\n    @State private var languagesKnown = 1\\n    @State private var bio = \\\"\\\"\\n    @State private var agreedToTerms = false\\n    \\n    // UI State\\n    @State private var showAlert = false\\n    @State private var alertMessage = \\\"\\\"\\n    @FocusState private var focusedField: Field?\\n    \\n    // Validation State\\n    @State private var emailError = \\\"\\\"\\n    @State private var passwordError = \\\"\\\"\\n    \\n    let themes = [\\\"Light\\\", \\\"Dark\\\", \\\"System\\\"]\\n    \\n    enum Field {\\n        case firstName, lastName, email, password, confirmPassword, bio\\n    }\\n    \\n    var body: some View {\\n        NavigationView {\\n            Form {\\n                // Section 1: Personal Information\\n                Section(header: Text(\\\"Personal Information\\\")) {\\n                    CustomTextField(\\\"First Name\\\", text: $firstName)\\n                        .focused($focusedField, equals: .firstName)\\n                        .submitLabel(.next)\\n                        .onSubmit { focusedField = .lastName }\\n                    \\n                    CustomTextField(\\\"Last Name\\\", text: $lastName)\\n                        .focused($focusedField, equals: .lastName)\\n                        .submitLabel(.next)\\n                        .onSubmit { focusedField = .email }\\n                    \\n                    CustomTextField(\\\"Email\\\", text: $email)\\n                        .focused($focusedField, equals: .email)\\n                        .keyboardType(.emailAddress)\\n                        .textContentType(.emailAddress)\\n                        .autocapitalization(.none)\\n                        .onChange(of: email) { _ in validateEmail() }\\n                        .overlay(validationOverlay(for: emailError))\\n                        .submitLabel(.next)\\n                        .onSubmit { focusedField = .password }\\n                    \\n                    DatePicker(\\\"Birth Date\\\", selection: $birthDate, in: ...Date(), displayedComponents: .date)\\n                    \\n                    if !isAdult {\\n                        Text(\\\"Must be 18 years or older to register\\\")\\n                            .font(.caption)\\n                            .foregroundColor(.red)\\n                    }\\n                }\\n                \\n                // Section 2: Account Security\\n                Section(header: Text(\\\"Account Security\\\")) {\\n                    SecureField(\\\"Password\\\", text: $password)\\n                        .focused($focusedField, equals: .password)\\n                        .textContentType(.newPassword)\\n                        .onChange(of: password) { _ in validatePassword() }\\n                        .overlay(validationOverlay(for: passwordError))\\n                        .submitLabel(.next)\\n                        .onSubmit { focusedField = .confirmPassword }\\n                    \\n                    SecureField(\\\"Confirm Password\\\", text: $confirmPassword)\\n                        .focused($focusedField, equals: .confirmPassword)\\n                        .textContentType(.newPassword)\\n                        .overlay(validationOverlay(for: passwordsMatch ? \\\"\\\" : \\\"Passwords do not match\\\"))\\n                        .submitLabel(.next)\\n                        .onSubmit { focusedField = .bio }\\n                    \\n                    PasswordStrengthView(password: password)\\n                }\\n                \\n                // Section 3: Preferences\\n                Section(header: Text(\\\"Preferences\\\")) {\\n                    Picker(\\\"Theme\\\", selection: $selectedTheme) {\\n                        ForEach(themes, id: \\\\.self) { theme in\\n                            Text(theme)\\n                        }\\n                    }\\n                    .pickerStyle(.segmented)\\n                    \\n                    VStack {\\n                        HStack {\\n                            Text(\\\"Experience Level\\\")\\n                            Spacer()\\n                            Text(\\\"\\\\(Int(experienceLevel))/10\\\")\\n                                .foregroundColor(.secondary)\\n                        }\\n                        Slider(value: $experienceLevel, in: 1...10, step: 1)\\n                    }\\n                    \\n                    Stepper(\\\"Programming Languages: \\\\(languagesKnown)\\\", value: $languagesKnown, in: 0...20)\\n                    \\n                    Toggle(\\\"Subscribe to Newsletter\\\", isOn: $subscribeNewsletter)\\n                }\\n                \\n                // Section 4: Additional Info\\n                Section(header: Text(\\\"About You\\\")) {\\n                    VStack(alignment: .leading) {\\n                        Text(\\\"Bio\\\")\\n                            .font(.caption)\\n                            .foregroundColor(.secondary)\\n                        TextEditor(text: $bio)\\n                            .focused($focusedField, equals: .bio)\\n                            .frame(height: 100)\\n                            .overlay(\\n                                RoundedRectangle(cornerRadius: 8)\\n                                    .stroke(bioColor, lineWidth: 1)\\n                            )\\n                        HStack {\\n                            Spacer()\\n                            Text(\\\"\\\\(bio.count)/200\\\")\\n                                .font(.caption)\\n                                .foregroundColor(bioCountColor)\\n                        }\\n                    }\\n                    \\n                    Toggle(\\\"I agree to the Terms and Conditions\\\", isOn: $agreedToTerms)\\n                }\\n                \\n                // Section 5: Actions\\n                Section {\\n                    Button(\\\"Create Account\\\") {\\n                        submitRegistration()\\n                    }\\n                    .disabled(!canSubmit)\\n                    .frame(maxWidth: .infinity)\\n                    \\n                    Button(\\\"Clear Form\\\", role: .destructive) {\\n                        resetForm()\\n                    }\\n                    .frame(maxWidth: .infinity)\\n                }\\n            }\\n            .navigationTitle(\\\"Complete Registration\\\")\\n            .alert(\\\"Registration\\\", isPresented: $showAlert) {\\n                Button(\\\"OK\\\") { }\\n            } message: {\\n                Text(alertMessage)\\n            }\\n            .onAppear {\\n                focusedField = .firstName\\n            }\\n        }\\n    }\\n    \\n    // MARK: - Validation Computed Properties\\n    \\n    var isAdult: Bool {\\n        let calendar = Calendar.current\\n        let age = calendar.dateComponents([.year], from: birthDate, to: Date()).year ?? 0\\n        return age >= 18\\n    }\\n    \\n    var passwordsMatch: Bool {\\n        !password.isEmpty && password == confirmPassword\\n    }\\n    \\n    var isBioValid: Bool {\\n        bio.count <= 200\\n    }\\n    \\n    var bioColor: Color {\\n        isBioValid ? .gray.opacity(0.3) : .red\\n    }\\n    \\n    var bioCountColor: Color {\\n        if bio.isEmpty {\\n            return .secondary\\n        } else if isBioValid {\\n            return .green\\n        } else {\\n            return .red\\n        }\\n    }\\n    \\n    var canSubmit: Bool {\\n        !firstName.isEmpty &&\\n        !lastName.isEmpty &&\\n        emailError.isEmpty &&\\n        passwordError.isEmpty &&\\n        passwordsMatch &&\\n        isAdult &&\\n        isBioValid &&\\n        agreedToTerms\\n    }\\n    \\n    // MARK: - Methods\\n    \\n    func validateEmail() {\\n        let emailRegex = #\\\"^[A-Z0-9a-z._%+-]+@[A-Za-z0-9.-]+\\\\\\\\.[A-Za-z]{2,}$\\\"#\\n        let isValid = NSPredicate(format: \\\"SELF MATCHES %@\\\", emailRegex).evaluate(with: email)\\n        emailError = isValid || email.isEmpty ? \\\"\\\" : \\\"Please enter a valid email address\\\"\\n    }\\n    \\n    func validatePassword() {\\n        if password.count < 8 {\\n            passwordError = \\\"Password must be at least 8 characters\\\"\\n        } else if !password.contains(where: { $0.isUppercase }) {\\n            passwordError = \\\"Password must contain an uppercase letter\\\"\\n        } else if !password.contains(where: { $0.isLowercase }) {\\n            passwordError = \\\"Password must contain a lowercase letter\\\"\\n        } else if !password.contains(where: { $0.isNumber }) {\\n            passwordError = \\\"Password must contain a number\\\"\\n        } else {\\n            passwordError = \\\"\\\"\\n        }\\n    }\\n    \\n    func submitRegistration() {\\n        // In real app, this would call an API\\n        alertMessage = \\\"Welcome, \\\\(firstName)! Your account has been created successfully.\\\"\\n        showAlert = true\\n    }\\n    \\n    func resetForm() {\\n        firstName = \\\"\\\"\\n        lastName = \\\"\\\"\\n        email = \\\"\\\"\\n        password = \\\"\\\"\\n        confirmPassword = \\\"\\\"\\n        birthDate = Date()\\n        subscribeNewsletter = true\\n        selectedTheme = \\\"System\\\"\\n        experienceLevel = 5.0\\n        languagesKnown = 1\\n        bio = \\\"\\\"\\n        agreedToTerms = false\\n        emailError = \\\"\\\"\\n        passwordError = \\\"\\\"\\n        focusedField = .firstName\\n    }\\n    \\n    func validationOverlay(for error: String) -> some View {\\n        Group {\\n            if !error.isEmpty {\\n                HStack {\\n                    Spacer()\\n                    Image(systemName: \\\"exclamationmark.triangle.fill\\\")\\n                        .foregroundColor(.red)\\n                        .padding(.trailing, 8)\\n                }\\n            }\\n        }\\n    }\\n}\\n\\n// MARK: - Custom Components\\n\\nstruct CustomTextField: View {\\n    let title: String\\n    @Binding var text: String\\n    \\n    var body: some View {\\n        VStack(alignment: .leading) {\\n            Text(title)\\n                .font(.caption)\\n                .foregroundColor(.secondary)\\n            \\n            TextField(title, text: $text)\\n                .textFieldStyle(RoundedBorderTextFieldStyle())\\n        }\\n    }\\n}\\n\\nstruct PasswordStrengthView: View {\\n    let password: String\\n    \\n    var strength: (color: Color, text: String) {\\n        if password.isEmpty {\\n            return (.secondary, \\\"Enter a password\\\")\\n        } else if password.count < 8 {\\n            return (.red, \\\"Weak\\\")\\n        } else if password.count < 12 {\\n            return (.orange, \\\"Medium\\\")\\n        } else {\\n            return (.green, \\\"Strong\\\")\\n        }\\n    }\\n    \\n    var body: some View {\\n        VStack(alignment: .leading) {\\n            HStack {\\n                Text(\\\"Password Strength\\\")\\n                    .font(.caption)\\n                    .foregroundColor(.secondary)\\n                Spacer()\\n                Text(strength.text)\\n                    .font(.caption)\\n                    .foregroundColor(strength.color)\\n            }\\n            \\n            GeometryReader { geometry in\\n                ZStack(alignment: .leading) {\\n                    Rectangle()\\n                        .fill(Color.gray.opacity(0.3))\\n                        .frame(height: 4)\\n                    \\n                    Rectangle()\\n                        .fill(strength.color)\\n                        .frame(width: progressWidth(in: geometry.size.width), height: 4)\\n                }\\n            }\\n            .frame(height: 4)\\n        }\\n    }\\n    \\n    func progressWidth(in totalWidth: CGFloat) -> CGFloat {\\n        if password.isEmpty {\\n            return 0\\n        } else if password.count < 8 {\\n            return totalWidth * 0.33\\n        } else if password.count < 12 {\\n            return totalWidth * 0.66\\n        } else {\\n            return totalWidth\\n        }\\n    }\\n}\\n\\n// MARK: - Preview\\n\\nstruct RegistrationChallenge_Previews: PreviewProvider {\\n    static var previews: some View {\\n        RegistrationChallenge()\\n    }\\n}\\n",
        "hints": [
          "PART 1: Use @State for form data and Form container for better iOS styling",
          "PART 2: Picker with .segmented style works well for small option sets like themes",
          "PART 3: Use .onChange modifier to validate fields as users type. Computed properties are great for validation logic",
          "PART 4: @FocusState automatically moves keyboard focus between fields. Add .focused() modifier to each input",
          "For password validation, check length, uppercase, lowercase, and numbers separately",
          "Use .overlay modifier to show validation icons and messages",
          "DatePicker with 'in: ...Date()' restricts to past dates only for birth date",
          "For character limits, use .onChange to truncate text or show warnings",
          "Accessibility: Add .accessibilityLabel, .accessibilityHint, and .accessibilityValue to all interactive elements",
          "Custom components should be reusable and configurable with @Binding"
        ],
        "testCases": [
          {
            "input": "isAdult with birth date 20 years ago",
            "expectedOutput": "true",
            "description": "Age validation should pass for users 18+"
          },
          {
            "input": "password 'Short1' validation",
            "expectedOutput": "Weak or error",
            "description": "Password validation should fail for short passwords"
          },
          {
            "input": "email 'invalid-email' format check",
            "expectedOutput": "Error message shown",
            "description": "Email validation should catch invalid formats"
          },
          {
            "input": "bio with 250 characters",
            "expectedOutput": "Error state",
            "description": "Bio character limit should be enforced"
          }
        ]
      }
    },
    {
      "id": "animation_basics",
      "title": "Animation Basics - Implicit vs Explicit",
      "description": "Master SwiftUI animations with implicit and explicit approaches - bring your UI to life",
      "difficulty": "beginner",
      "theory": "# Animation Basics - Implicit vs Explicit Animations\n\n## 1. Understanding SwiftUI Animations (60 min)\n\n### What are Animations?\nAnimations make your app feel alive and responsive by smoothly transitioning between states.\n\n### Why Animate?\n- **Better User Experience**: Guides user attention\n- **Visual Feedback**: Shows state changes clearly\n- **Professional Polish**: Makes apps feel premium\n- **Intuitive Interactions**: Users understand what's happening\n\n### Animation Principles in SwiftUI:\n- **Declarative**: Describe what you want, not how to do it\n- **Automatic**: Handle timing, curves, and interpolation automatically\n- **Simple**: Often just one line of code\n- **Powerful**: Complex animations made easy\n\n## 2. Implicit Animations (90 min)\n\n### What are Implicit Animations?\nAnimations that are attached to views and automatically animate when specific properties change.\n\n### Basic Syntax:\n```swift\n.viewModifier()\n    .animation(.easeInOut, value: watchedProperty)\n```\n\n### Simple Implicit Animation:\n```swift\nstruct SimpleAnimation: View {\n    @State private var isScaled = false\n    \n    var body: some View {\n        Circle()\n            .frame(width: 100, height: 100)\n            .scaleEffect(isScaled ? 1.5 : 1.0)\n            .animation(.easeInOut(duration: 0.3), value: isScaled)\n            .onTapGesture {\n                isScaled.toggle()\n            }\n    }\n}\n```\n\n### Animating Multiple Properties:\n```swift\nstruct MultiAnimation: View {\n    @State private var isAnimated = false\n    \n    var body: some View {\n        RoundedRectangle(cornerRadius: 20)\n            .fill(isAnimated ? .blue : .red)\n            .frame(width: isAnimated ? 200 : 100, \n                   height: isAnimated ? 200 : 100)\n            .rotationEffect(.degrees(isAnimated ? 180 : 0))\n            .animation(.spring(response: 0.6, dampingFraction: 0.8), value: isAnimated)\n            .onTapGesture {\n                isAnimated.toggle()\n            }\n    }\n}\n```\n\n## 3. Animation Curves and Timing (60 min)\n\n### Built-in Animation Curves:\n\n#### Ease Animations:\n```swift\n.animation(.easeIn, value: property)      // Slow start\n.animation(.easeOut, value: property)     // Slow end\n.animation(.easeInOut, value: property)   // Slow start and end\n```\n\n#### Spring Animations:\n```swift\n.animation(.spring(), value: property)                    // Default spring\n.animation(.spring(response: 0.6, dampingFraction: 0.8), value: property)\n.animation(.interpolatingSpring(mass: 1.0, stiffness: 100, damping: 10), value: property)\n```\n\n#### Linear Animation:\n```swift\n.animation(.linear(duration: 1.0), value: property)  // Constant speed\n```\n\n### Timing Parameters:\n```swift\n// Duration-based\n.animation(.easeInOut(duration: 2.0), value: property)\n\n// Delay\n.animation(.easeInOut(duration: 1.0).delay(0.5), value: property)\n\n// Repeat\n.animation(.easeInOut(duration: 1.0).repeatCount(3), value: property)\n.animation(.easeInOut(duration: 1.0).repeatForever(), value: property)\n\n// Auto-reverse\n.animation(.easeInOut(duration: 1.0).repeatForever(autoreverses: true), value: property)\n```\n\n## 4. Explicit Animations (90 min)\n\n### What are Explicit Animations?\nAnimations that you explicitly trigger using `withAnimation` blocks. They give you more control over when and how animations occur.\n\n### Basic Syntax:\n```swift\nwithAnimation(.animationType) {\n    // State changes here will be animated\n}\n```\n\n### Simple Explicit Animation:\n```swift\nstruct ExplicitAnimation: View {\n    @State private var isExpanded = false\n    \n    var body: some View {\n        VStack {\n            Rectangle()\n                .fill(.blue)\n                .frame(width: isExpanded ? 300 : 100, \n                       height: isExpanded ? 300 : 100)\n                .cornerRadius(isExpanded ? 0 : 50)\n            \n            Button(\"Toggle\") {\n                withAnimation(.spring()) {\n                    isExpanded.toggle()\n                }\n            }\n            \n            Button(\"Reset\") {\n                // No animation\n                isExpanded = false\n            }\n        }\n    }\n}\n```\n\n### Multiple State Changes in One Animation:\n```swift\nstruct ComplexAnimation: View {\n    @State private var isActive = false\n    @State private var rotation = 0.0\n    @State private var color: Color = .blue\n    \n    var body: some View {\n        VStack {\n            Capsule()\n                .fill(color)\n                .frame(width: isActive ? 350 : 100, height: 60)\n                .rotationEffect(.degrees(rotation))\n            \n            Button(\"Animate All\") {\n                withAnimation(.easeInOut(duration: 1.0)) {\n                    isActive.toggle()\n                    rotation += 360\n                    color = isActive ? .orange : .blue\n                }\n            }\n        }\n    }\n}\n```\n\n## 5. When to Use Each Approach (60 min)\n\n### Use Implicit Animations When:\n- Simple property changes\n- You want consistent animation behavior\n- Animating individual view properties\n- Quick prototyping\n\n### Use Explicit Animations When:\n- Complex state changes\n- Coordinating multiple animations\n- Conditional animations\n- User-triggered actions\n- Need precise control over timing\n\n### Real-world Examples:\n\n#### Implicit - Loading Indicator:\n```swift\nstruct LoadingView: View {\n    @State private var isLoading = false\n    \n    var body: some View {\n        Circle()\n            .trim(from: 0.0, to: 0.7)\n            .stroke(Color.blue, lineWidth: 5)\n            .frame(width: 50, height: 50)\n            .rotationEffect(Angle(degrees: isLoading ? 360 : 0))\n            .animation(.linear(duration: 1).repeatForever(autoreverses: false), \n                      value: isLoading)\n            .onAppear { isLoading = true }\n    }\n}\n```\n\n#### Explicit - User Interaction:\n```swift\nstruct LikeButton: View {\n    @State private var isLiked = false\n    @State private var scale = 1.0\n    \n    var body: some View {\n        Button(action: {\n            withAnimation(.spring(response: 0.3, dampingFraction: 0.6)) {\n                isLiked.toggle()\n                scale = 1.2\n            }\n            \n            // Second animation for scale back\n            DispatchQueue.main.asyncAfter(deadline: .now() + 0.1) {\n                withAnimation(.spring()) {\n                    scale = 1.0\n                }\n            }\n        }) {\n            Image(systemName: isLiked ? \"heart.fill\" : \"heart\")\n                .foregroundColor(isLiked ? .red : .gray)\n                .scaleEffect(scale)\n        }\n    }\n}\n```\n\n## 6. Advanced Animation Patterns (60 min)\n\n### Animation Callbacks:\n```swift\nstruct CallbackAnimation: View {\n    @State private var isVisible = false\n    \n    var body: some View {\n        Circle()\n            .scaleEffect(isVisible ? 1.0 : 0.1)\n            .onAppear {\n                withAnimation(.easeOut(duration: 0.5)) {\n                    isVisible = true\n                }\n            }\n    }\n}\n```\n\n### Chained Animations:\n```swift\nstruct ChainedAnimation: View {\n    @State private var phase = 0\n    \n    var body: some View {\n        VStack {\n            ForEach(0..<3) { index in\n                Circle()\n                    .frame(width: 50, height: 50)\n                    .offset(x: phase > index ? 100 : 0)\n                    .animation(.easeInOut.delay(Double(index) * 0.2), \n                              value: phase)\n            }\n            \n            Button(\"Animate\") {\n                phase += 1\n            }\n        }\n    }\n}\n```\n\n### Conditional Animations:\n```swift\nstruct ConditionalAnimation: View {\n    @State private var isOn = false\n    @State private var useSpring = true\n    \n    var body: some View {\n        VStack {\n            Toggle(\"Use Spring Animation\", isOn: $useSpring)\n            \n            Rectangle()\n                .fill(isOn ? .green : .red)\n                .frame(width: 100, height: 100)\n                .scaleEffect(isOn ? 1.5 : 1.0)\n                .onTapGesture {\n                    if useSpring {\n                        withAnimation(.spring()) {\n                            isOn.toggle()\n                        }\n                    } else {\n                        withAnimation(.easeInOut(duration: 0.5)) {\n                            isOn.toggle()\n                        }\n                    }\n                }\n        }\n    }\n}\n```\n\n## Practice Exercises\n\nComplete all exercises to master SwiftUI animations and understand when to use implicit vs explicit approaches!",
      "codeExample": "// === IMPLICIT ANIMATION EXAMPLES ===\n\n// Simple scale animation\nstruct ScaleAnimation: View {\n    @State private var isScaled = false\n    \n    var body: some View {\n        Circle()\n            .fill(.blue)\n            .frame(width: 100, height: 100)\n            .scaleEffect(isScaled ? 1.5 : 1.0)\n            .animation(.easeInOut(duration: 0.3), value: isScaled)\n            .onTapGesture {\n                isScaled.toggle()\n            }\n    }\n}\n\n// Multiple property animation\nstruct MultiPropertyAnimation: View {\n    @State private var isActive = false\n    \n    var body: some View {\n        RoundedRectangle(cornerRadius: isActive ? 50 : 10)\n            .fill(isActive ? .orange : .purple)\n            .frame(width: isActive ? 200 : 100, \n                   height: isActive ? 200 : 100)\n            .rotationEffect(.degrees(isActive ? 180 : 0))\n            .animation(.spring(response: 0.6, dampingFraction: 0.8), value: isActive)\n            .onTapGesture {\n                isActive.toggle()\n            }\n    }\n}\n\n// Loading spinner with implicit animation\nstruct LoadingSpinner: View {\n    @State private var isRotating = false\n    \n    var body: some View {\n        Circle()\n            .trim(from: 0.0, to: 0.7)\n            .stroke(Color.blue, lineWidth: 4)\n            .frame(width: 50, height: 50)\n            .rotationEffect(Angle(degrees: isRotating ? 360 : 0))\n            .animation(.linear(duration: 1.0).repeatForever(autoreverses: false), \n                      value: isRotating)\n            .onAppear {\n                isRotating = true\n            }\n    }\n}\n\n// === EXPLICIT ANIMATION EXAMPLES ===\n\n// Button with explicit animation\nstruct AnimatedButton: View {\n    @State private var isPressed = false\n    \n    var body: some View {\n        Button(\"Press Me\") {\n            withAnimation(.spring(response: 0.3, dampingFraction: 0.6)) {\n                isPressed = true\n            }\n            \n            // Reset after animation\n            DispatchQueue.main.asyncAfter(deadline: .now() + 0.2) {\n                withAnimation(.spring()) {\n                    isPressed = false\n                }\n            }\n        }\n        .padding()\n        .background(Color.blue)\n        .foregroundColor(.white)\n        .cornerRadius(10)\n        .scaleEffect(isPressed ? 0.9 : 1.0)\n    }\n}\n\n// Card flip animation\nstruct CardFlip: View {\n    @State private var isFlipped = false\n    @State private var rotation = 0.0\n    \n    var body: some View {\n        VStack {\n            RoundedRectangle(cornerRadius: 20)\n                .fill(isFlipped ? .green : .red)\n                .frame(width: 200, height: 300)\n                .overlay(\n                    Text(isFlipped ? \"Back\" : \"Front\")\n                        .font(.largeTitle)\n                        .foregroundColor(.white)\n                )\n                .rotation3DEffect(\n                    .degrees(rotation),\n                    axis: (x: 0.0, y: 1.0, z: 0.0)\n                )\n            \n            Button(\"Flip Card\") {\n                withAnimation(.easeInOut(duration: 0.6)) {\n                    rotation += 180\n                    if rotation.truncatingRemainder(dividingBy: 360) == 0 {\n                        isFlipped = false\n                    } else {\n                        isFlipped = true\n                    }\n                }\n            }\n        }\n    }\n}\n\n// Sequential animation\nstruct SequentialAnimation: View {\n    @State private var animateStep = 0\n    \n    var body: some View {\n        VStack(spacing: 20) {\n            ForEach(0..<3) { index in\n                Circle()\n                    .frame(width: 50, height: 50)\n                    .foregroundColor([.red, .green, .blue][index])\n                    .offset(x: animateStep > index ? 100 : 0)\n                    .animation(.easeInOut.delay(Double(index) * 0.3), \n                              value: animateStep)\n            }\n            \n            Button(\"Start Sequence\") {\n                animateStep += 1\n            }\n            \n            Button(\"Reset\") {\n                animateStep = 0\n            }\n        }\n    }\n}\n\n// === PRACTICAL COMPARISON ===\n\n// Same animation implemented both ways\nstruct ComparisonView: View {\n    @State private var isAnimated = false\n    \n    var body: some View {\n        VStack(spacing: 50) {\n            // Implicit version\n            VStack {\n                Text(\"Implicit Animation\")\n                    .font(.headline)\n                \n                Circle()\n                    .fill(.blue)\n                    .frame(width: 80, height: 80)\n                    .scaleEffect(isAnimated ? 1.5 : 1.0)\n                    .animation(.easeInOut(duration: 0.5), value: isAnimated)\n            }\n            \n            // Explicit version  \n            VStack {\n                Text(\"Explicit Animation\")\n                    .font(.headline)\n                \n                Circle()\n                    .fill(.green)\n                    .frame(width: 80, height: 80)\n                    .scaleEffect(isAnimated ? 1.5 : 1.0)\n            }\n            \n            Button(\"Toggle Both\") {\n                // This will only animate the explicit one\n                withAnimation(.easeInOut(duration: 0.5)) {\n                    isAnimated.toggle()\n                }\n            }\n            \n            Button(\"Toggle Implicit Only\") {\n                // This will only animate the implicit one\n                isAnimated.toggle()\n            }\n        }\n    }\n}",
      "category": "SwiftUI Basics",
      "estimatedTime": 300,
      "dependencies": ["swiftui_intro", "state_management"],
      "challenge": {
        "instructions": "Create a complete animated onboarding screen using both implicit and explicit animations:\n\nPART 1: Implicit Animations for UI Elements (75 min)\n1. Create a welcome card that scales and fades in using implicit animation\n2. Add feature list items that animate in sequentially with delays\n3. Create animated progress indicators using implicit .repeatForever\n4. Implement color theme transitions that animate smoothly\n\nPART 2: Explicit Animations for User Interactions (75 min)\n5. Create an animated button that scales and changes color on tap\n6. Implement a card flip animation for showing details\n7. Add drag gesture with spring animation for interactive elements\n8. Create a success confirmation with sequenced animations\n\nPART 3: Combined Animation System (75 min)\n9. Build an animated onboarding flow with multiple screens\n10. Implement page transitions with coordinated animations\n11. Add loading states with combined implicit/explicit animations\n12. Create interactive previews that respond to hover/tap\n\nPART 4: Advanced Animation Patterns (75 min)\n13. Implement staggered animations for complex layouts\n14. Add animation callbacks and state coordination\n15. Create reusable animated components\n16. Implement accessibility-friendly animations\n\nTest your animations thoroughly and ensure smooth performance!",
        "starterCode": "// === PART 1: Implicit Animations ===\nstruct OnboardingView: View {\n    @State private var isVisible = false\n    \n    var body: some View {\n        VStack {\n            // Add your welcome card here\n            \n            // Add feature list here\n            \n            // Add progress indicators here\n        }\n        .onAppear {\n            // Trigger initial animations\n        }\n    }\n}\n\n// === PART 2: Explicit Animations ===\nstruct AnimatedButton: View {\n    @State private var isPressed = false\n    \n    var body: some View {\n        // Create animated button here\n        EmptyView()\n    }\n}\n\n// === PART 3: Combined System ===\nstruct OnboardingFlow: View {\n    @State private var currentPage = 0\n    \n    var body: some View {\n        // Build multi-screen flow here\n        EmptyView()\n    }\n}\n\n// === PART 4: Advanced Patterns ===\nstruct StaggeredGrid: View {\n    var body: some View {\n        // Create staggered animation layout\n        EmptyView()\n    }\n}",
        "solution": "// === PART 1: Implicit Animations ===\nstruct OnboardingView: View {\n    @State private var isVisible = false\n    @State private var featureOpacity = 0.0\n    @State private var progress: Double = 0.0\n    \n    var body: some View {\n        VStack(spacing: 30) {\n            // Welcome card with implicit animation\n            RoundedRectangle(cornerRadius: 20)\n                .fill(LinearGradient(\n                    colors: [.blue, .purple],\n                    startPoint: .topLeading,\n                    endPoint: .bottomTrailing\n                ))\n                .frame(width: isVisible ? 300 : 10, height: 200)\n                .opacity(isVisible ? 1.0 : 0.0)\n                .overlay(\n                    Text(\"Welcome!\")\n                        .font(.largeTitle)\n                        .foregroundColor(.white)\n                        .opacity(isVisible ? 1.0 : 0.0)\n                )\n                .animation(.spring(response: 0.6, dampingFraction: 0.8), value: isVisible)\n            \n            // Feature list with sequential implicit animations\n            VStack(alignment: .leading, spacing: 10) {\n                FeatureRow(text: \"Easy to use\", delay: 0.0, opacity: featureOpacity)\n                FeatureRow(text: \"Powerful features\", delay: 0.2, opacity: featureOpacity)\n                FeatureRow(text: \"Fast performance\", delay: 0.4, opacity: featureOpacity)\n            }\n            \n            // Animated progress indicator\n            Circle()\n                .trim(from: 0.0, to: progress)\n                .stroke(Color.blue, lineWidth: 8)\n                .frame(width: 60, height: 60)\n                .rotationEffect(.degrees(-90))\n                .animation(.easeInOut(duration: 1.0), value: progress)\n        }\n        .onAppear {\n            isVisible = true\n            \n            // Sequence the animations\n            DispatchQueue.main.asyncAfter(deadline: .now() + 0.5) {\n                withAnimation(.easeInOut(duration: 0.5)) {\n                    featureOpacity = 1.0\n                }\n            }\n            \n            DispatchQueue.main.asyncAfter(deadline: .now() + 1.0) {\n                withAnimation(.easeInOut(duration: 2.0)) {\n                    progress = 0.75\n                }\n            }\n        }\n    }\n}\n\nstruct FeatureRow: View {\n    let text: String\n    let delay: Double\n    let opacity: Double\n    \n    var body: some View {\n        HStack {\n            Image(systemName: \"checkmark.circle.fill\")\n                .foregroundColor(.green)\n                .scaleEffect(opacity > 0 ? 1.0 : 0.1)\n            \n            Text(text)\n                .opacity(opacity)\n        }\n        .animation(.spring().delay(delay), value: opacity)\n    }\n}\n\n// === PART 2: Explicit Animations ===\nstruct AnimatedButton: View {\n    @State private var isPressed = false\n    @State private var isSuccess = false\n    \n    var body: some View {\n        Button(action: {\n            withAnimation(.spring(response: 0.3, dampingFraction: 0.6)) {\n                isPressed = true\n                isSuccess.toggle()\n            }\n            \n            // Reset press state\n            DispatchQueue.main.asyncAfter(deadline: .now() + 0.1) {\n                withAnimation(.spring()) {\n                    isPressed = false\n                }\n            }\n        }) {\n            HStack {\n                if isSuccess {\n                    Image(systemName: \"checkmark\")\n                        .transition(.scale.combined(with: .opacity))\n                }\n                \n                Text(isSuccess ? \"Completed!\" : \"Get Started\")\n            }\n            .foregroundColor(.white)\n            .padding()\n            .frame(width: isPressed ? 170 : 160)\n            .background(isSuccess ? Color.green : Color.blue)\n            .cornerRadius(isPressed ? 12 : 8)\n        }\n    }\n}\n\n// Card flip with explicit animation\nstruct FlipCard: View {\n    @State private var isFlipped = false\n    @State private var rotation = 0.0\n    \n    var body: some View {\n        VStack {\n            RoundedRectangle(cornerRadius: 20)\n                .fill(isFlipped ? Color.green : Color.blue)\n                .frame(width: 200, height: 150)\n                .overlay(\n                    Group {\n                        if isFlipped {\n                            Text(\"Back Side\")\n                                .foregroundColor(.white)\n                                .font(.title2)\n                        } else {\n                            Text(\"Front Side\")\n                                .foregroundColor(.white)\n                                .font(.title2)\n                        }\n                    }\n                )\n                .rotation3DEffect(\n                    .degrees(rotation),\n                    axis: (x: 0.0, y: 1.0, z: 0.0)\n                )\n            \n            Button(\"Flip Card\") {\n                withAnimation(.easeInOut(duration: 0.6)) {\n                    rotation += 180\n                    if rotation.truncatingRemainder(dividingBy: 360) == 0 {\n                        isFlipped = false\n                    } else {\n                        isFlipped = true\n                    }\n                }\n            }\n        }\n    }\n}\n\n// === PART 3: Combined System ===\nstruct OnboardingFlow: View {\n    @State private var currentPage = 0\n    @State private var isAnimating = false\n    \n    var body: some View {\n        ZStack {\n            // Background color transition\n            Rectangle()\n                .fill(backgroundGradient)\n                .ignoresSafeArea()\n                .animation(.easeInOut(duration: 0.5), value: currentPage)\n            \n            VStack {\n                // Page content with transition\n                Group {\n                    switch currentPage {\n                    case 0:\n                        WelcomePage()\n                    case 1:\n                        FeaturesPage()\n                    case 2:\n                        GetStartedPage()\n                    default:\n                        WelcomePage()\n                    }\n                }\n                .transition(.asymmetric(\n                    insertion: .move(edge: .trailing).combined(with: .opacity),\n                    removal: .move(edge: .leading).combined(with: .opacity)\n                ))\n                \n                Spacer()\n                \n                // Page indicators with implicit animation\n                HStack(spacing: 8) {\n                    ForEach(0..<3, id: \\.self) { index in\n                        Circle()\n                            .fill(index == currentPage ? Color.white : Color.white.opacity(0.3))\n                            .frame(width: 8, height: 8)\n                            .scaleEffect(index == currentPage ? 1.2 : 1.0)\n                            .animation(.spring(response: 0.3, dampingFraction: 0.6), value: currentPage)\n                    }\n                }\n                \n                // Navigation buttons\n                HStack {\n                    if currentPage > 0 {\n                        Button(\"Previous\") {\n                            withAnimation(.easeInOut(duration: 0.4)) {\n                                currentPage -= 1\n                            }\n                        }\n                    }\n                    \n                    Spacer()\n                    \n                    Button(currentPage == 2 ? \"Get Started\" : \"Next\") {\n                        withAnimation(.easeInOut(duration: 0.4)) {\n                            if currentPage < 2 {\n                                currentPage += 1\n                            }\n                        }\n                    }\n                }\n                .padding()\n            }\n        }\n    }\n    \n    private var backgroundGradient: LinearGradient {\n        let colors: [Color] = [\n            [.blue, .purple],\n            [.purple, .pink],\n            [.orange, .red]\n        ][currentPage]\n        \n        return LinearGradient(\n            colors: colors,\n            startPoint: .topLeading,\n            endPoint: .bottomTrailing\n        )\n    }\n}\n\n// === PART 4: Advanced Patterns ===\nstruct StaggeredGrid: View {\n    @State private var isVisible = false\n    let items = Array(1...6)\n    \n    var body: some View {\n        LazyVGrid(columns: [GridItem(.flexible()), GridItem(.flexible())], spacing: 10) {\n            ForEach(Array(items.enumerated()), id: \\.offset) { index, item in\n                RoundedRectangle(cornerRadius: 12)\n                    .fill(Color.blue)\n                    .frame(height: 80)\n                    .overlay(Text(\"Item \\(item)\").foregroundColor(.white))\n                    .scaleEffect(isVisible ? 1.0 : 0.1)\n                    .opacity(isVisible ? 1.0 : 0.0)\n                    .animation(\n                        .spring(response: 0.6, dampingFraction: 0.8)\n                        .delay(Double(index) * 0.1),\n                        value: isVisible\n                    )\n            }\n        }\n        .padding()\n        .onAppear {\n            withAnimation {\n                isVisible = true\n            }\n        }\n    }\n}",
        "hints": [
          "PART 1: Use .animation() modifier for implicit animations. Remember to watch specific values with the 'value' parameter",
          "PART 2: Wrap state changes in withAnimation {} blocks for explicit control. You can chain multiple animations with delays",
          "PART 3: Combine both approaches - use implicit for continuous UI updates and explicit for user-triggered actions",
          "PART 4: Use .delay() with animations for staggered effects. Calculate delays based on index for grid layouts",
          "For smooth transitions, prefer spring animations over ease animations",
          "Use .transition() with asymmetric transitions for better page navigation",
          "Remember to use @State for properties that trigger animations",
          "Test animations on real devices - simulator performance may differ"
        ],
        "testCases": [
          {
            "input": "isVisible == true",
            "expectedOutput": "Welcome card should be fully visible and scaled",
            "description": "Implicit animation should trigger on state change"
          },
          {
            "input": "isPressed == true",
            "expectedOutput": "Button should scale down when pressed",
            "description": "Explicit animation should trigger in withAnimation block"
          },
          {
            "input": "currentPage changes",
            "expectedOutput": "Smooth page transition with background color change",
            "description": "Combined animations should coordinate properly"
          }
        ]
      }
    },
    {
      "id": "building_first_app",
      "title": "Building Your First iOS App - Todo List",
      "description": "Create a complete todo list app from scratch, learning iOS development fundamentals along the way",
      "difficulty": "beginner",
      "theory": "# Building Your First iOS App - Todo List (5 hours)\n\n## 1. iOS App Architecture & Setup (60 min)\n\n### Understanding MVC (Model-View-Controller)\n- **Model**: Data and business logic (Todo items)\n- **View**: User interface elements (Table, buttons, text fields)\n- **Controller**: Mediates between Model and View (ViewController)\n\n### Xcode Workspace Tour\n- **Project Navigator**: File organization\n- **Interface Builder**: Visual UI design\n- **Code Editor**: Swift programming\n- **Utilities Panel**: Properties and connections\n\n### Creating Your First Project\n1. Open Xcode â†’ \"Create New Project\"\n2. Choose \"iOS\" â†’ \"App\" template\n3. Name: \"MyTodoList\"\n4. Interface: \"Storyboard\"\n5. Language: \"Swift\"\n\n## 2. Building the User Interface (60 min)\n\n### Storyboard Fundamentals\n- **View Controllers**: Screens of your app\n- **Views**: UI components (buttons, labels, tables)\n- **Auto Layout**: Responsive design for all screen sizes\n\n### Key UI Components for Todo App\n```swift\n// UITableView - displays list of todos\n// UIButton - add new todos\n// UITextField - input for new todos\n// UINavigationController - navigation between screens\n```\n\n### Auto Layout Constraints\n- **Leading/Trailing**: Horizontal spacing\n- **Top/Bottom**: Vertical spacing\n- **Width/Height**: Size constraints\n- **Aspect Ratio**: Proportional sizing\n\n## 3. Model: Data Structure (45 min)\n\n### Designing the Todo Model\n```swift\nstruct TodoItem {\n    let id: UUID\n    var title: String\n    var isCompleted: Bool\n    var createdAt: Date\n    var priority: Priority\n}\n\nenum Priority: String, CaseIterable {\n    case low = \"Low\"\n    case medium = \"Medium\"\n    case high = \"High\"\n}\n```\n\n### Data Persistence Options\n- **UserDefaults**: Simple key-value storage\n- **Codable + FileManager**: JSON file storage\n- **Core Data**: Advanced database (future topic)\n\n### Model Management\n```swift\nclass TodoManager {\n    private var todos: [TodoItem] = []\n    \n    func addTodo(_ title: String, priority: Priority = .medium) { ... }\n    func toggleComplete(_ id: UUID) { ... }\n    func deleteTodo(_ id: UUID) { ... }\n    func getTodos() -> [TodoItem] { ... }\n}\n```\n\n## 4. View Controller & Data Binding (60 min)\n\n### ViewController Lifecycle\n```swift\nclass TodoViewController: UIViewController {\n    override func viewDidLoad() { \n        // Called once when view loads\n    }\n    \n    override func viewWillAppear() { \n        // Called before view appears\n    }\n    \n    override func viewDidAppear() { \n        // Called after view appears\n    }\n}\n```\n\n### UITableView DataSource & Delegate\n```swift\n// Required methods:\nfunc tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int\nfunc tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell\n\n// Optional methods:\nfunc tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath)\nfunc tableView(_ tableView: UITableView, commit editingStyle: UITableViewCell.EditingStyle, forRowAt indexPath: IndexPath)\n```\n\n### Custom Table View Cells\n- Create subclass of UITableViewCell\n- Design layout in Interface Builder\n- Connect UI elements via @IBOutlet\n- Configure cell with model data\n\n## 5. User Interactions & Events (45 min)\n\n### Handling Button Taps\n```swift\n@IBAction func addButtonTapped(_ sender: UIButton) {\n    // Handle add todo action\n}\n```\n\n### Text Field Delegates\n```swift\nfunc textFieldShouldReturn(_ textField: UITextField) -> Bool {\n    textField.resignFirstResponder() // Dismiss keyboard\n    return true\n}\n```\n\n### Gesture Recognizers\n- **Tap**: Single finger tap\n- **Swipe**: Left/right swipe actions\n- **Long Press**: Extended touch\n\n### Table View Swipe Actions\n```swift\nfunc tableView(_ tableView: UITableView, \n               trailingSwipeActionsConfigurationForRowAt indexPath: IndexPath) -> UISwipeActionsConfiguration?\n```\n\n## 6. Data Persistence & State Management (45 min)\n\n### Saving Data with UserDefaults\n```swift\n// Saving\nlet encoder = JSONEncoder()\nif let encoded = try? encoder.encode(todos) {\n    UserDefaults.standard.set(encoded, forKey: \"todos\")\n}\n\n// Loading\nif let savedData = UserDefaults.standard.data(forKey: \"todos\") {\n    let decoder = JSONDecoder()\n    if let loadedTodos = try? decoder.decode([TodoItem].self, from: savedData) {\n        todos = loadedTodos\n    }\n}\n```\n\n### State Restoration\n- Save app state when backgrounded\n- Restore state when app relaunches\n- Handle app termination gracefully\n\n### Error Handling\n```swift\ndo {\n    try saveTodos()\n} catch {\n    showErrorAlert(message: \"Failed to save todos\")\n}\n```\n\n## 7. Polish & Final Touches (30 min)\n\n### User Experience Improvements\n- **Empty State**: Show message when no todos\n- **Loading States**: Activity indicators\n- **Error Messages**: User-friendly alerts\n- **Haptic Feedback**: Tactile responses\n\n### Accessibility Features\n- **VoiceOver**: Screen reader support\n- **Dynamic Type**: Adjustable text sizes\n- **Color Contrast**: Readable color schemes\n\n### App Icon & Launch Screen\n- Design app icon in different sizes\n- Create simple launch screen\n- Test on various devices\n\n## Best Practices Summary\n\n1. **Keep MVC separation clean**\n2. **Use meaningful variable names**\n3. **Handle all error cases**\n4. **Test on different screen sizes**\n5. **Follow iOS Human Interface Guidelines**\n\nYou now have all the knowledge to build a complete, functional todo list app!",
      "codeExample": "// === COMPLETE TODO APP IMPLEMENTATION ===\n\n// 1. MODEL: Data Structures\nimport Foundation\n\nenum Priority: String, CaseIterable {\n    case low = \"Low\"\n    case medium = \"Medium\" \n    case high = \"High\"\n    \n    var color: UIColor {\n        switch self {\n        case .low: return .systemGreen\n        case .medium: return .systemOrange\n        case .high: return .systemRed\n        }\n    }\n}\n\nstruct TodoItem: Codable {\n    let id: UUID\n    var title: String\n    var isCompleted: Bool\n    var createdAt: Date\n    var priority: Priority\n    \n    init(title: String, priority: Priority = .medium) {\n        self.id = UUID()\n        self.title = title\n        self.isCompleted = false\n        self.createdAt = Date()\n        self.priority = priority\n    }\n}\n\n// 2. MODEL MANAGER\nclass TodoManager {\n    static let shared = TodoManager()\n    private init() {}\n    \n    private var todos: [TodoItem] = []\n    private let userDefaultsKey = \"savedTodos\"\n    \n    // CRUD Operations\n    func addTodo(_ title: String, priority: Priority = .medium) -> TodoItem {\n        let newTodo = TodoItem(title: title, priority: priority)\n        todos.append(newTodo)\n        saveTodos()\n        return newTodo\n    }\n    \n    func toggleComplete(_ id: UUID) {\n        if let index = todos.firstIndex(where: { $0.id == id }) {\n            todos[index].isCompleted.toggle()\n            saveTodos()\n        }\n    }\n    \n    func deleteTodo(_ id: UUID) {\n        todos.removeAll { $0.id == id }\n        saveTodos()\n    }\n    \n    func getTodos() -> [TodoItem] {\n        return todos\n    }\n    \n    func getIncompleteTodos() -> [TodoItem] {\n        return todos.filter { !$0.isCompleted }\n    }\n    \n    func getCompletedTodos() -> [TodoItem] {\n        return todos.filter { $0.isCompleted }\n    }\n    \n    // Data Persistence\n    private func saveTodos() {\n        let encoder = JSONEncoder()\n        if let encoded = try? encoder.encode(todos) {\n            UserDefaults.standard.set(encoded, forKey: userDefaultsKey)\n        }\n    }\n    \n    func loadTodos() {\n        if let savedData = UserDefaults.standard.data(forKey: userDefaultsKey) {\n            let decoder = JSONDecoder()\n            if let loadedTodos = try? decoder.decode([TodoItem].self, from: savedData) {\n                todos = loadedTodos\n            }\n        }\n    }\n}\n\n// 3. VIEW: Custom Table View Cell\nimport UIKit\n\nclass TodoCell: UITableViewCell {\n    @IBOutlet weak var titleLabel: UILabel!\n    @IBOutlet weak var priorityView: UIView!\n    @IBOutlet weak var completedButton: UIButton!\n    \n    var toggleCompletion: (() -> Void)?\n    \n    @IBAction func completeButtonTapped(_ sender: UIButton) {\n        toggleCompletion?()\n    }\n    \n    func configure(with todo: TodoItem) {\n        titleLabel.text = todo.title\n        priorityView.backgroundColor = todo.priority.color\n        \n        // Strikethrough for completed todos\n        let attributes: [NSAttributedString.Key: Any] = todo.isCompleted ?\n            [.strikethroughStyle: NSUnderlineStyle.single.rawValue,\n             .foregroundColor: UIColor.systemGray] :\n            [.foregroundColor: UIColor.label]\n            \n        titleLabel.attributedText = NSAttributedString(\n            string: todo.title, \n            attributes: attributes\n        )\n        \n        let buttonImage = todo.isCompleted ? \n            UIImage(systemName: \"checkmark.circle.fill\") : \n            UIImage(systemName: \"circle\")\n        completedButton.setImage(buttonImage, for: .normal)\n    }\n}\n\n// 4. CONTROLLER: Main View Controller\nclass TodoViewController: UIViewController {\n    @IBOutlet weak var tableView: UITableView!\n    @IBOutlet weak var addButton: UIButton!\n    @IBOutlet weak var textField: UITextField!\n    @IBOutlet weak var prioritySegmentedControl: UISegmentedControl!\n    \n    private var todos: [TodoItem] = []\n    \n    override func viewDidLoad() {\n        super.viewDidLoad()\n        setupUI()\n        loadData()\n    }\n    \n    private func setupUI() {\n        tableView.dataSource = self\n        tableView.delegate = self\n        textField.delegate = self\n        \n        // Register custom cell\n        let nib = UINib(nibName: \"TodoCell\", bundle: nil)\n        tableView.register(nib, forCellReuseIdentifier: \"TodoCell\")\n        \n        // Style add button\n        addButton.layer.cornerRadius = 8\n        addButton.backgroundColor = .systemBlue\n        addButton.setTitleColor(.white, for: .normal)\n    }\n    \n    private func loadData() {\n        TodoManager.shared.loadTodos()\n        todos = TodoManager.shared.getTodos()\n        tableView.reloadData()\n    }\n    \n    @IBAction func addButtonTapped(_ sender: UIButton) {\n        addNewTodo()\n    }\n    \n    private func addNewTodo() {\n        guard let title = textField.text, !title.isEmpty else { return }\n        \n        let priorityIndex = prioritySegmentedControl.selectedSegmentIndex\n        let priority = Priority.allCases[priorityIndex]\n        \n        let newTodo = TodoManager.shared.addTodo(title, priority: priority)\n        todos.append(newTodo)\n        \n        // Update UI\n        tableView.reloadData()\n        textField.text = \"\"\n        textField.resignFirstResponder()\n        \n        // Show confirmation haptic\n        let generator = UIImpactFeedbackGenerator(style: .medium)\n        generator.impactOccurred()\n    }\n    \n    private func showEmptyState() {\n        if todos.isEmpty {\n            let emptyLabel = UILabel()\n            emptyLabel.text = \"No todos yet!\\nTap + to add your first todo.\"\n            emptyLabel.textAlignment = .center\n            emptyLabel.numberOfLines = 0\n            emptyLabel.textColor = .systemGray\n            tableView.backgroundView = emptyLabel\n        } else {\n            tableView.backgroundView = nil\n        }\n    }\n}\n\n// MARK: - TableView DataSource\nextension TodoViewController: UITableViewDataSource {\n    func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {\n        showEmptyState()\n        return todos.count\n    }\n    \n    func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {\n        let cell = tableView.dequeueReusableCell(withIdentifier: \"TodoCell\", for: indexPath) as! TodoCell\n        let todo = todos[indexPath.row]\n        cell.configure(with: todo)\n        \n        cell.toggleCompletion = { [weak self] in\n            TodoManager.shared.toggleComplete(todo.id)\n            self?.loadData()\n        }\n        \n        return cell\n    }\n}\n\n// MARK: - TableView Delegate\nextension TodoViewController: UITableViewDelegate {\n    func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) {\n        tableView.deselectRow(at: indexPath, animated: true)\n    }\n    \n    func tableView(_ tableView: UITableView, trailingSwipeActionsConfigurationForRowAt indexPath: IndexPath) -> UISwipeActionsConfiguration? {\n        let deleteAction = UIContextualAction(style: .destructive, title: \"Delete\") { [weak self] _, _, completion in\n            let todo = self?.todos[indexPath.row]\n            if let id = todo?.id {\n                TodoManager.shared.deleteTodo(id)\n                self?.loadData()\n            }\n            completion(true)\n        }\n        \n        deleteAction.backgroundColor = .systemRed\n        deleteAction.image = UIImage(systemName: \"trash\")\n        \n        return UISwipeActionsConfiguration(actions: [deleteAction])\n    }\n}\n\n// MARK: - TextField Delegate\nextension TodoViewController: UITextFieldDelegate {\n    func textFieldShouldReturn(_ textField: UITextField) -> Bool {\n        addNewTodo()\n        return true\n    }\n}",
      "category": "iOS Development",
      "estimatedTime": 300,
      "dependencies": ["structs_classes", "optionals"],
      "challenge": {
        "instructions": "Build a complete Todo List iOS App with the following features:\n\nPART 1: Project Setup & Basic UI (60 min)\n1. Create new Xcode project with Storyboard interface\n2. Design main screen with: UITableView, UITextField, UIButton, UISegmentedControl\n3. Set up Auto Layout constraints for all screen sizes\n4. Create custom UITableViewCell with todo item display\n\nPART 2: Data Model & Management (60 min)\n5. Implement TodoItem struct with properties: id, title, isCompleted, createdAt, priority\n6. Create TodoManager singleton class with CRUD operations\n7. Add data persistence using UserDefaults and Codable\n8. Implement priority system with enum (low, medium, high)\n\nPART 3: View Controller Implementation (60 min)\n9. Connect UI elements via @IBOutlet and @IBAction\n10. Implement UITableViewDataSource and UITableViewDelegate\n11. Handle todo creation, completion toggling, and deletion\n12. Add swipe actions for deleting todos\n\nPART 4: User Experience & Polish (60 min)\n13. Implement empty state when no todos exist\n14. Add haptic feedback for user actions\n15. Style the app with colors and proper typography\n16. Add accessibility features (VoiceOver, Dynamic Type)\n\nPART 5: Advanced Features (60 min)\n17. Add search/filter functionality\n18. Implement categories or tags for todos\n19. Add due dates and notifications\n20. Create settings screen for app preferences\n\nTest your app thoroughly on different devices and scenarios!",
        "starterCode": "// === PROJECT SETUP INSTRUCTIONS ===\n// 1. Create new Xcode project: iOS â†’ App â†’ Name: \"TodoApp\"\n// 2. Use Storyboard interface, Swift language\n// 3. Add the following files to your project:\n\n// === TodoItem.swift ===\n// Define your TodoItem struct here\n\n// === TodoManager.swift ===\n// Implement the TodoManager class here\n\n// === TodoCell.swift ===\n// Create custom UITableViewCell subclass\n\n// === TodoViewController.swift ===\n// Main view controller implementation\n\n// === Main.storyboard ===\n// Design your user interface here",
        "solution": "// === COMPLETE SOLUTION ===\n\n// TodoItem.swift\nimport Foundation\n\nenum Priority: String, CaseIterable, Codable {\n    case low = \"Low\", medium = \"Medium\", high = \"High\"\n    \n    var colorName: String {\n        switch self {\n        case .low: return \"systemGreen\"\n        case .medium: return \"systemOrange\"\n        case .high: return \"systemRed\"\n        }\n    }\n}\n\nstruct TodoItem: Codable {\n    let id: UUID\n    var title: String\n    var isCompleted: Bool\n    let createdAt: Date\n    var priority: Priority\n    \n    init(title: String, priority: Priority = .medium) {\n        self.id = UUID()\n        self.title = title\n        self.isCompleted = false\n        self.createdAt = Date()\n        self.priority = priority\n    }\n}\n\n// TodoManager.swift\nimport Foundation\n\nclass TodoManager {\n    static let shared = TodoManager()\n    private init() { loadTodos() }\n    \n    private var todos: [TodoItem] = []\n    private let saveKey = \"userTodos\"\n    \n    // MARK: - Public API\n    func addTodo(_ title: String, priority: Priority = .medium) -> TodoItem {\n        let newTodo = TodoItem(title: title, priority: priority)\n        todos.append(newTodo)\n        saveTodos()\n        return newTodo\n    }\n    \n    func toggleComplete(_ id: UUID) {\n        if let index = todos.firstIndex(where: { $0.id == id }) {\n            todos[index].isCompleted.toggle()\n            saveTodos()\n        }\n    }\n    \n    func deleteTodo(_ id: UUID) {\n        todos.removeAll { $0.id == id }\n        saveTodos()\n    }\n    \n    func updateTodo(_ id: UUID, newTitle: String? = nil, newPriority: Priority? = nil) {\n        if let index = todos.firstIndex(where: { $0.id == id }) {\n            if let newTitle = newTitle {\n                todos[index].title = newTitle\n            }\n            if let newPriority = newPriority {\n                todos[index].priority = newPriority\n            }\n            saveTodos()\n        }\n    }\n    \n    func getTodos() -> [TodoItem] { return todos }\n    func getIncomplete() -> [TodoItem] { return todos.filter { !$0.isCompleted } }\n    func getCompleted() -> [TodoItem] { return todos.filter { $0.isCompleted } }\n    \n    // MARK: - Persistence\n    private func saveTodos() {\n        if let encoded = try? JSONEncoder().encode(todos) {\n            UserDefaults.standard.set(encoded, forKey: saveKey)\n        }\n    }\n    \n    private func loadTodos() {\n        if let data = UserDefaults.standard.data(forKey: saveKey),\n           let decoded = try? JSONDecoder().decode([TodoItem].self, from: data) {\n            todos = decoded\n        }\n    }\n}\n\n// TodoCell.swift\nimport UIKit\n\nclass TodoCell: UITableViewCell {\n    @IBOutlet weak var titleLabel: UILabel!\n    @IBOutlet weak var priorityIndicator: UIView!\n    @IBOutlet weak var completeButton: UIButton!\n    @IBOutlet weak var dateLabel: UILabel!\n    \n    private var todo: TodoItem?\n    var onToggle: ((UUID) -> Void)?\n    \n    override func awakeFromNib() {\n        super.awakeFromNib()\n        priorityIndicator.layer.cornerRadius = 4\n        completeButton.layer.cornerRadius = 12\n    }\n    \n    @IBAction func completeTapped(_ sender: UIButton) {\n        guard let todo = todo else { return }\n        onToggle?(todo.id)\n    }\n    \n    func configure(with todo: TodoItem) {\n        self.todo = todo\n        \n        // Title with strikethrough if completed\n        let attributes: [NSAttributedString.Key: Any] = todo.isCompleted ?\n            [.strikethroughStyle: NSUnderlineStyle.single.rawValue,\n             .foregroundColor: UIColor.systemGray] :\n            [.foregroundColor: UIColor.label]\n        \n        titleLabel.attributedText = NSAttributedString(string: todo.title, attributes: attributes)\n        \n        // Priority color\n        priorityIndicator.backgroundColor = UIColor(named: todo.priority.colorName)\n        \n        // Date formatting\n        let formatter = DateFormatter()\n        formatter.dateStyle = .short\n        formatter.timeStyle = .none\n        dateLabel.text = formatter.string(from: todo.createdAt)\n        dateLabel.isHidden = !todo.isCompleted\n        \n        // Complete button state\n        let imageName = todo.isCompleted ? \"checkmark.circle.fill\" : \"circle\"\n        let image = UIImage(systemName: imageName)\n        completeButton.setImage(image, for: .normal)\n        completeButton.tintColor = todo.isCompleted ? .systemGreen : .systemGray\n    }\n}\n\n// TodoViewController.swift\nimport UIKit\n\nclass TodoViewController: UIViewController {\n    @IBOutlet weak var tableView: UITableView!\n    @IBOutlet weak var addButton: UIButton!\n    @IBOutlet weak var textField: UITextField!\n    @IBOutlet weak var priorityControl: UISegmentedControl!\n    @IBOutlet weak var emptyStateView: UIView!\n    @IBOutlet weak var emptyStateLabel: UILabel!\n    \n    private var todos: [TodoItem] = []\n    \n    override func viewDidLoad() {\n        super.viewDidLoad()\n        setupUI()\n        loadData()\n    }\n    \n    override func viewWillAppear(_ animated: Bool) {\n        super.viewWillAppear(animated)\n        loadData()\n    }\n    \n    private func setupUI() {\n        title = \"My Todos\"\n        \n        // Table View\n        tableView.dataSource = self\n        tableView.delegate = self\n        tableView.rowHeight = UITableView.automaticDimension\n        tableView.estimatedRowHeight = 60\n        \n        // Text Field\n        textField.delegate = self\n        textField.placeholder = \"Add a new todo...\"\n        \n        // Add Button\n        addButton.layer.cornerRadius = 8\n        addButton.backgroundColor = .systemBlue\n        addButton.setTitleColor(.white, for: .normal)\n        \n        // Priority Control\n        priorityControl.removeAllSegments()\n        for (index, priority) in Priority.allCases.enumerated() {\n            priorityControl.insertSegment(withTitle: priority.rawValue, at: index, animated: false)\n        }\n        priorityControl.selectedSegmentIndex = 1 // Medium\n        \n        // Empty State\n        emptyStateLabel.text = \"No todos yet!\\nTap the + button to add your first todo.\"\n        emptyStateLabel.textAlignment = .center\n        emptyStateLabel.numberOfLines = 0\n        \n        // Register cell\n        let nib = UINib(nibName: \"TodoCell\", bundle: nil)\n        tableView.register(nib, forCellReuseIdentifier: \"TodoCell\")\n    }\n    \n    private func loadData() {\n        todos = TodoManager.shared.getTodos()\n        updateEmptyState()\n        tableView.reloadData()\n    }\n    \n    private func updateEmptyState() {\n        let isEmpty = todos.isEmpty\n        emptyStateView.isHidden = !isEmpty\n        tableView.isHidden = isEmpty\n    }\n    \n    @IBAction func addButtonTapped(_ sender: UIButton) {\n        addNewTodo()\n    }\n    \n    private func addNewTodo() {\n        guard let title = textField.text?.trimmingCharacters(in: .whitespaces), !title.isEmpty else {\n            showAlert(title: \"Oops!\", message: \"Please enter a todo title\")\n            return\n        }\n        \n        let priority = Priority.allCases[priorityControl.selectedSegmentIndex]\n        _ = TodoManager.shared.addTodo(title, priority: priority)\n        \n        // Reset UI\n        textField.text = \"\"\n        textField.resignFirstResponder()\n        \n        // Update data\n        loadData()\n        \n        // Haptic feedback\n        UIImpactFeedbackGenerator(style: .medium).impactOccurred()\n        \n        // Scroll to bottom\n        if !todos.isEmpty {\n            let indexPath = IndexPath(row: todos.count - 1, section: 0)\n            tableView.scrollToRow(at: indexPath, at: .bottom, animated: true)\n        }\n    }\n    \n    private func showAlert(title: String, message: String) {\n        let alert = UIAlertController(title: title, message: message, preferredStyle: .alert)\n        alert.addAction(UIAlertAction(title: \"OK\", style: .default))\n        present(alert, animated: true)\n    }\n}\n\n// MARK: - TableView DataSource & Delegate\nextension TodoViewController: UITableViewDataSource, UITableViewDelegate {\n    func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {\n        return todos.count\n    }\n    \n    func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {\n        let cell = tableView.dequeueReusableCell(withIdentifier: \"TodoCell\", for: indexPath) as! TodoCell\n        let todo = todos[indexPath.row]\n        cell.configure(with: todo)\n        \n        cell.onToggle = { [weak self] id in\n            TodoManager.shared.toggleComplete(id)\n            self?.loadData()\n            UISelectionFeedbackGenerator().selectionChanged()\n        }\n        \n        return cell\n    }\n    \n    func tableView(_ tableView: UITableView, trailingSwipeActionsConfigurationForRowAt indexPath: IndexPath) -> UISwipeActionsConfiguration? {\n        let delete = UIContextualAction(style: .destructive, title: \"Delete\") { [weak self] _, _, completion in\n            let todo = self?.todos[indexPath.row]\n            if let id = todo?.id {\n                TodoManager.shared.deleteTodo(id)\n                self?.loadData()\n                UINotificationFeedbackGenerator().notificationOccurred(.success)\n            }\n            completion(true)\n        }\n        \n        delete.image = UIImage(systemName: \"trash\")\n        return UISwipeActionsConfiguration(actions: [delete])\n    }\n}\n\n// MARK: - TextField Delegate\nextension TodoViewController: UITextFieldDelegate {\n    func textFieldShouldReturn(_ textField: UITextField) -> Bool {\n        addNewTodo()\n        return true\n    }\n}",
        "hints": [
          "Use Auto Layout constraints to make your UI responsive on all device sizes",
          "Remember to call tableView.reloadData() after modifying your data",
          "Use @IBAction for button taps and @IBOutlet for UI element connections",
          "Implement both UITableViewDataSource required methods: numberOfRows and cellForRowAt",
          "UserDefaults + Codable is perfect for simple data persistence",
          "Use UISwipeActionsConfiguration for swipe-to-delete functionality",
          "Don't forget to set the delegate for UITableView and UITextField",
          "Use UIImpactFeedbackGenerator for haptic feedback on user actions",
          "Create a custom UITableViewCell for better todo item display",
          "Handle empty state by showing/hiding a view when todos array is empty"
        ],
        "testCases": [
          {
            "input": "Add todo â†’ Check if appears in table",
            "expectedOutput": "New todo visible in list",
            "description": "Todo creation should update UI immediately"
          },
          {
            "input": "Toggle completion â†’ Check strikethrough",
            "expectedOutput": "Title shows strikethrough when completed",
            "description": "Completion state should visually update"
          },
          {
            "input": "Swipe to delete â†’ Confirm removal",
            "expectedOutput": "Todo removed from list",
            "description": "Swipe deletion should work correctly"
          },
          {
            "input": "Relaunch app â†’ Check data persistence",
            "expectedOutput": "Todos still present after restart",
            "description": "UserDefaults should persist data between launches"
          }
        ]
      }
    },
    {
      "id": "xcode_deep_dive",
      "title": "Xcode Deep Dive",
      "description": "Master Xcode interface, debugging tools, and productivity shortcuts to become a more efficient Swift developer",
      "difficulty": "beginner",
      "theory": "# Xcode Deep Dive - Master Your Development Environment\n\n## 1. Xcode Interface Overview (45 min)\n\n### Main Components:\n- **Navigator Area** (Left sidebar) - File structure, search, warnings\n- **Editor Area** (Center) - Code editing, interface builder\n- **Inspector Area** (Right sidebar) - File info, attributes, connections\n- **Toolbar** (Top) - Run button, scheme selector, status\n- **Debug Area** (Bottom) - Console, variables, breakpoints\n\n### Key Panels Explained:\n\n#### Project Navigator (âŒ˜1):\n- Hierarchical view of all project files\n- Folder references vs. groups\n- Target membership controls\n\n#### Source Control Navigator (âŒ˜2):\n- Git branch management\n- Commit history\n- Conflict resolution\n\n#### Issue Navigator (âŒ˜5):\n- Compiler errors and warnings\n- Static analysis results\n- Quick jump to problematic code\n\n#### Debug Navigator (âŒ˜6):\n- Thread and queue overview\n- Memory usage monitoring\n- Performance metrics\n\n## 2. Essential Editor Features (60 min)\n\n### Code Completion (âŒƒSpace):\n```swift\n// Start typing and use autocomplete\nlet myArray = [\"Apple\", \"Banana\", \"Cherry\"]\nmyArray. // Press âŒƒSpace here\n```\n\n### Quick Help (âŒ¥Click):\n- Option-click any symbol for documentation\n- See declarations, parameters, and discussions\n- Links to related symbols\n\n### Code Folding (âŒ¥âŒ˜â† / âŒ¥âŒ˜â†’):\n- Collapse methods and classes\n- Focus on relevant code sections\n- Use folding ribbons in the gutter\n\n### Multiple Cursors (âŒ¥Drag):\n```swift\n// Select multiple lines with âŒ¥Drag\nlet firstName = \"\"\nlet lastName = \"\"\nlet email = \"\"\n// Edit all three simultaneously\n```\n\n### Jump to Definition (âŒƒâŒ˜J):\n- Quickly navigate to symbol definitions\n- Understand code structure\n- Explore framework APIs\n\n## 3. Powerful Navigation Shortcuts (45 min)\n\n### File Navigation:\n- **Quick Open** (âŒ˜â‡§O) - Jump to any file or symbol\n- **Open Quickly** (âŒ˜â‡§O) - Type partial names\n- **Jump to Line** (âŒ˜L) - Go to specific line number\n\n### Code Navigation:\n- **Go Back** (âŒƒâŒ˜â†) - Return to previous location\n- **Go Forward** (âŒƒâŒ˜â†’) - Move forward in navigation history\n- **Show Callers** (âŒƒâ‡§âŒ˜H) - Find all references\n\n### Editor Navigation:\n- **Move Line Up/Down** (âŒ¥âŒ˜â†‘ / âŒ¥âŒ˜â†“)\n- **Duplicate Line** (âŒ˜D)\n- **Comment/Uncomment** (âŒ˜/)\n\n## 4. Debugging Mastery (60 min)\n\n### Breakpoints:\n```swift\nfunc calculateTotal(items: [Double]) -> Double {\n    var total = 0.0\n    for item in items {        // Set breakpoint here\n        total += item\n    }\n    return total\n}\n```\n\n### Breakpoint Types:\n- **Regular Breakpoints** - Pause execution\n- **Conditional Breakpoints** - Break only when condition met\n- **Exception Breakpoints** - Catch all exceptions\n- **Symbolic Breakpoints** - Break on specific methods\n\n### Debug Area Controls:\n- **Continue** (âŒƒâŒ˜Y) - Resume execution\n- **Step Over** (F6) - Execute next line\n- **Step Into** (F7) - Go into function call\n- **Step Out** (F8) - Complete current function\n\n### LLDB Console Commands:\n```swift\n// In debug console:\npo items          // Print object description\np total           // Print primitive value\nexpr total = 100  // Change value during debugging\nframe variable    // Show all local variables\n```\n\n### View Debugging:\n- **View Hierarchy** (âŒ˜â‡§V) - 3D view of UI layers\n- **View Debugger** - Identify auto layout issues\n- **Color Blended Layers** - Performance optimization\n\n## 5. Interface Builder Essentials (45 min)\n\n### Storyboard Navigation:\n- **Zoom** (âŒ˜Â±) - Fit to screen, zoom in/out\n- **Assistant Editor** (âŒ¥âŒ˜â†©) - Split view with code\n- **Show Document Outline** (âŒ˜â‡§O) - View hierarchy\n\n### Auto Layout Tools:\n- **Add New Constraints** - Pin views precisely\n- **Resolve Auto Layout Issues** - Clear warnings/errors\n- **Update Frames** (âŒ¥âŒ˜=) - Apply constraint changes\n\n### Connections Inspector:\n- **Outlets** - Connect UI to code\n- **Actions** - Link events to methods\n- **Referencing Outlets** - See all connections\n\n### Preview Assistant:\n- Multiple device previews\n- Dark/light mode testing\n- Dynamic type sizes\n- Localization preview\n\n## 6. Build System & Schemes (30 min)\n\n### Build Configurations:\n- **Debug** - Full symbols, no optimization\n- **Release** - Optimized, minimal symbols\n- **Profile** - Instruments-ready\n\n### Scheme Management:\n- **Edit Scheme** (âŒ˜<) - Configure run/test/archive\n- **Environment Variables** - Debug configuration\n- **Launch Arguments** - Custom app behavior\n\n### Build Shortcuts:\n- **Build** (âŒ˜B) - Compile without running\n- **Run** (âŒ˜R) - Build and launch\n- **Test** (âŒ˜U) - Run unit tests\n- **Clean** (âŒ˜â‡§K) - Remove build artifacts\n\n## 7. Productivity Workflows (45 min)\n\n### Code Snippets:\n```swift\n// Create reusable code templates\n// Drag from snippet library to editor\n// Use placeholders for dynamic content\n```\n\n### Behaviors (âŒ˜â‡§B):\n- Customize Xcode actions\n- Show debugger on build failures\n- Play sound on test completion\n- Open specific tabs for tasks\n\n### Source Control Integration:\n- **Commit** (âŒ˜âŒ¥C) - Review and commit changes\n- **Push** (âŒ˜â‡§P) - Send commits to remote\n- **Pull** (âŒ˜â‡§X) - Fetch and merge changes\n\n### Refactoring Tools:\n- **Rename** (âŒƒâŒ˜E) - Update symbol everywhere\n- **Extract Method** - Create function from selection\n- **Generate Missing Code** - Stub implementations\n\n## Best Practices Summary\n\n1. **Learn Keyboard Shortcuts** - Muscle memory beats mouse clicks\n2. **Use Multiple Workspaces** - Organize different project aspects\n3. **Master Breakpoints** - Efficient debugging saves hours\n4. **Customize Your Environment** - Tailor Xcode to your workflow\n5. **Stay Updated** - New Xcode versions bring productivity boosts\n\nComplete all exercises to build Xcode proficiency!",
      "codeExample": "// === XCODE SHORTCUTS PRACTICE ===\n\n// Practice these common workflows:\n\n// 1. Code Completion & Quick Help\nstruct User {\n    let name: String\n    let age: Int\n    let email: String\n}\n\nlet users = [\n    User(name: \"Alice\", age: 25, email: \"alice@example.com\"),\n    User(name: \"Bob\", age: 30, email: \"bob@example.com\")\n]\n\n// Try: Type 'users.' then press âŒƒSpace for autocomplete\n// Try: Option-click on 'User' to see documentation\n\n// 2. Multiple Cursors Practice\nclass DataProcessor {\n    // Select all three properties with âŒ¥Drag\n    var inputData: String = \"\"\n    var processedData: String = \"\"\n    var outputData: String = \"\"\n    \n    func process() {\n        // Set breakpoint on next line\n        let results = inputData.split(separator: \",\")\n        processedData = results.joined(separator: \"-\")\n        outputData = processedData.uppercased()\n        \n        // Use debug console: 'po results'\n        // Use debug console: 'p processedData'\n    }\n}\n\n// 3. Navigation Practice\nprotocol DataSource {\n    func fetchData() -> [String]\n}\n\nclass NetworkDataSource: DataSource {\n    func fetchData() -> [String] {\n        return [\"Item 1\", \"Item 2\", \"Item 3\"]\n    }\n}\n\nclass LocalDataSource: DataSource {\n    func fetchData() -> [String] {\n        return [\"Local 1\", \"Local 2\"]\n    }\n}\n\n// Try: âŒƒâŒ˜J on 'DataSource' to jump to protocol\n// Try: âŒ˜â‡§O and type 'User' to quickly open files\n\n// 4. Debugging Practice\nfunc calculateStatistics(scores: [Int]) -> (min: Int, max: Int, average: Double) {\n    // Set conditional breakpoint: 'scores.count > 5'\n    guard !scores.isEmpty else {\n        return (0, 0, 0.0)\n    }\n    \n    var minScore = scores[0]\n    var maxScore = scores[0]\n    var total = 0\n    \n    for score in scores {\n        if score < minScore { minScore = score }\n        if score > maxScore { maxScore = score }\n        total += score\n    }\n    \n    let average = Double(total) / Double(scores.count)\n    return (minScore, maxScore, average)\n}\n\n// Test function with breakpoints\nlet testScores = [85, 92, 78, 90, 88]\nlet stats = calculateStatistics(scores: testScores)\n\n// === INTERFACE BUILDER CONNECTIONS ===\n\n// Practice connecting UI to code:\n/*\n1. Create a button in storyboard\n2. Open Assistant Editor (âŒ¥âŒ˜â†©)\n3. Control-drag from button to create:\n*/\n\n@IBAction func buttonTapped(_ sender: UIButton) {\n    // Handle button tap\n    sender.setTitle(\"Tapped!\", for: .normal)\n}\n\n@IBOutlet weak var statusLabel: UILabel!\n\n// === SCHEME CONFIGURATION ===\n\n// Practice different configurations:\n#if DEBUG\nlet apiBaseURL = \"https://api-dev.example.com\"\nlet enableLogging = true\n#else\nlet apiBaseURL = \"https://api.example.com\"\nlet enableLogging = false\n#endif",
      "category": "Development Tools",
      "estimatedTime": 180,
      "dependencies": [],
      "challenge": {
        "instructions": "Complete this comprehensive Xcode mastery challenge to become proficient with the development environment:\n\nPART 1: Project Setup & Navigation (45 min)\n1. Create a new iOS project called 'XcodeMastery'\n2. Organize files into logical groups (Models, Views, Controllers, Utilities)\n3. Create 5 different Swift files and practice navigating between them using keyboard shortcuts\n4. Set up a custom code snippet for a common UIView subclass pattern\n\nPART 2: Debugging Skills (45 min)\n5. Create a function with a logical error and use breakpoints to identify it\n6. Set up conditional breakpoints that only trigger under specific conditions\n7. Use LLDB commands to inspect and modify variables during debugging\n8. Add an exception breakpoint and trigger it intentionally\n\nPART 3: Interface Builder Proficiency (45 min)\n9. Design a simple login screen with Auto Layout constraints\n10. Connect UI elements to code using both outlets and actions\n11. Use the View Debugger to identify and fix layout issues\n12. Test your interface across different device sizes using previews\n\nPART 4: Productivity Workflow (45 min)\n13. Configure custom behaviors for testing and debugging\n14. Set up source control and make your first commit\n15. Create a custom scheme for debugging with specific environment variables\n16. Use refactoring tools to rename a class and update all references\n\nTest each skill thoroughly and document any issues you encounter!",
        "starterCode": "// === PART 1: Project Structure ===\n// Create these files and organize in groups:\n// - Models/User.swift\n// - Views/LoginView.swift  \n// - Controllers/ViewController.swift\n// - Utilities/NetworkManager.swift\n\n// User.swift\nstruct User {\n    // Add properties here\n}\n\n// === PART 2: Debugging Practice ===\nclass DataProcessor {\n    func processNumbers(_ numbers: [Int]) -> [Int] {\n        var results: [Int] = []\n        for number in numbers {\n            // Intentional bug: should be number * 2\n            results.append(number * 3)\n        }\n        return results\n    }\n}\n\n// === PART 3: UI Connections ===\n// Connect these to your storyboard elements\nclass LoginViewController: UIViewController {\n    // Add IBOutlets and IBActions here\n    \n    @IBAction func loginButtonTapped(_ sender: UIButton) {\n        // Handle login logic\n    }\n}\n\n// === PART 4: Environment Configuration ===\nclass AppConfig {\n    // Configure different environments\n}",
        "solution": "// === PART 1: Project Structure Solution ===\n\n// Models/User.swift\nstruct User {\n    let id: String\n    let username: String\n    let email: String\n    \n    var displayName: String {\n        return \"@\\(username)\"\n    }\n}\n\n// Views/LoginView.swift\nimport UIKit\n\nclass LoginView: UIView {\n    let emailTextField = UITextField()\n    let passwordTextField = UITextField()\n    let loginButton = UIButton(type: .system)\n    \n    override init(frame: CGRect) {\n        super.init(frame: frame)\n        setupView()\n    }\n    \n    required init?(coder: NSCoder) {\n        super.init(coder: coder)\n        setupView()\n    }\n    \n    private func setupView() {\n        // Configure subviews and constraints\n        emailTextField.placeholder = \"Email\"\n        passwordTextField.placeholder = \"Password\"\n        passwordTextField.isSecureTextEntry = true\n        loginButton.setTitle(\"Login\", for: .normal)\n        \n        // Add to view hierarchy and set constraints\n    }\n}\n\n// Utilities/NetworkManager.swift\nclass NetworkManager {\n    static let shared = NetworkManager()\n    \n    private init() {}\n    \n    func login(username: String, password: String, completion: @escaping (Result<User, Error>) -> Void) {\n        // Simulate network request\n        DispatchQueue.main.asyncAfter(deadline: .now() + 1.0) {\n            let user = User(id: \"1\", username: username, email: \"\\(username)@example.com\")\n            completion(.success(user))\n        }\n    }\n}\n\n// === PART 2: Debugging Solution ===\n\nclass DataProcessor {\n    func processNumbers(_ numbers: [Int]) -> [Int] {\n        var results: [Int] = []\n        \n        // Set breakpoint on next line\n        for number in numbers {\n            // Conditional breakpoint: number > 50\n            if number > 50 {\n                print(\"Processing large number: \\(number)\")\n            }\n            \n            // Fixed bug: now correctly doubles numbers\n            results.append(number * 2)\n        }\n        \n        // LLDB practice: 'po numbers' then 'expr numbers = [1,2,3]'\n        return results\n    }\n    \n    func triggerException() {\n        // This will trigger exception breakpoint\n        let array = [1, 2, 3]\n        let _ = array[5] // Index out of bounds\n    }\n}\n\n// Debugging test\nlet processor = DataProcessor()\nlet input = [10, 25, 60, 45]\nlet output = processor.processNumbers(input)\nprint(\"Input: \\(input), Output: \\(output)\")\n\n// === PART 3: UI Connections Solution ===\n\nimport UIKit\n\nclass LoginViewController: UIViewController {\n    \n    // IBOutlets\n    @IBOutlet weak var emailTextField: UITextField!\n    @IBOutlet weak var passwordTextField: UITextField!\n    @IBOutlet weak var loginButton: UIButton!\n    @IBOutlet weak var statusLabel: UILabel!\n    \n    override func viewDidLoad() {\n        super.viewDidLoad()\n        setupUI()\n    }\n    \n    private func setupUI() {\n        loginButton.layer.cornerRadius = 8\n        statusLabel.isHidden = true\n        \n        // Auto Layout constraints should be set in storyboard\n        // Use View Debugger (âŒ˜â‡§V) to verify hierarchy\n    }\n    \n    // IBActions\n    @IBAction func loginButtonTapped(_ sender: UIButton) {\n        guard let email = emailTextField.text, !email.isEmpty,\n              let password = passwordTextField.text, !password.isEmpty else {\n            showStatus(\"Please fill all fields\", isError: true)\n            return\n        }\n        \n        loginButton.isEnabled = false\n        showStatus(\"Logging in...\", isError: false)\n        \n        NetworkManager.shared.login(username: email, password: password) { [weak self] result in\n            DispatchQueue.main.async {\n                self?.loginButton.isEnabled = true\n                \n                switch result {\n                case .success(let user):\n                    self?.showStatus(\"Welcome \\(user.displayName)!\", isError: false)\n                case .failure:\n                    self?.showStatus(\"Login failed\", isError: true)\n                }\n            }\n        }\n    }\n    \n    @IBAction func textFieldDidChange(_ sender: UITextField) {\n        // Real-time validation\n        statusLabel.isHidden = true\n    }\n    \n    private func showStatus(_ message: String, isError: Bool) {\n        statusLabel.text = message\n        statusLabel.textColor = isError ? .red : .systemGreen\n        statusLabel.isHidden = false\n    }\n}\n\n// === PART 4: Environment Configuration Solution ===\n\nclass AppConfig {\n    \n    #if DEBUG\n    static let environment = \"Development\"\n    static let apiBaseURL = \"https://api-dev.example.com\"\n    static let logLevel = \"debug\"\n    #elseif STAGING\n    static let environment = \"Staging\"\n    static let apiBaseURL = \"https://api-staging.example.com\"\n    static let logLevel = \"info\"\n    #else\n    static let environment = \"Production\"\n    static let apiBaseURL = \"https://api.example.com\"\n    static let logLevel = \"warning\"\n    #endif\n    \n    static var description: String {\n        return \"\\(environment) Environment - \\(apiBaseURL)\"\n    }\n}\n\n// Custom scheme configuration:\n// 1. Edit Scheme (âŒ˜<)\n// 2. Duplicate Debug scheme to create Staging\n// 3. Add STAGING flag in Build Settings\n// 4. Set environment variables if needed\n\n// Code Snippet creation:\n// Create snippet for \"UIView Subclass Template\" with:\n// - Custom initializers\n// - Auto Layout setup method\n// - Common configuration",
        "hints": [
          "PART 1: Use âŒ˜1 to navigate files, âŒ˜N to create new files. Right-click in project navigator to create groups",
          "PART 2: Right-click breakpoints for conditions. Use 'po' for objects, 'p' for primitives in LLDB",
          "PART 3: Hold control and drag from storyboard to code to create connections. Use âŒ˜â‡§V for view debugging",
          "PART 4: Behaviors are in Xcode â†’ Behaviors. Schemes are managed with âŒ˜<",
          "Use âŒ˜â‡§O to quickly open any file. Remember the shortcut saves hunting through folders",
          "For conditional breakpoints, right-click the breakpoint and add a condition like 'someVar == 5'",
          "In Interface Builder, use the 'Resolve Auto Layout Issues' button (right-most toolbar button) to quickly fix constraints",
          "Create code snippets by selecting code and dragging to the snippets library (bottom-right of window)"
        ],
        "testCases": [
          {
            "input": "DataProcessor().processNumbers([1, 2, 3])",
            "expectedOutput": "[2, 4, 6]",
            "description": "Debugging practice should correctly double input numbers"
          },
          {
            "input": "AppConfig.environment",
            "expectedOutput": "Development",
            "description": "Scheme configuration should set correct environment"
          },
          {
            "input": "User(id: \"123\", username: \"test\", email: \"test@example.com\").displayName",
            "expectedOutput": "@test",
            "description": "Project structure should organize models correctly"
          }
        ]
      }
    },
    {
      "id": "app_architecture_mvvm",
      "title": "App Architecture - MVVM Pattern",
      "description": "Learn the Model-View-ViewModel pattern - the standard architecture for SwiftUI apps",
      "difficulty": "beginner",
      "theory": "# MVVM Architecture - Organizing Your SwiftUI Apps\n\n## 1. Understanding MVVM Pattern (45 min)\n\n### What is MVVM?\nMVVM stands for **Model-View-ViewModel** - a design pattern that separates your app into three distinct layers:\n\n### The Three Layers:\n- **Model**: Your data and business logic\n- **View**: UI components that display data\n- **ViewModel**: Bridge between Model and View\n\n### Why Use MVVM?\n- **Separation of Concerns**: Each layer has a single responsibility\n- **Testability**: ViewModels can be tested without UI\n- **Maintainability**: Changes in one layer don't break others\n- **SwiftUI Friendly**: Perfect fit for SwiftUI's declarative syntax\n\n### Real-world Analogy:\n- **Model**: Kitchen ingredients and recipes\n- **View**: Restaurant dining area and menu\n- **ViewModel**: Waiters who take orders and deliver food\n\n## 2. Model Layer (45 min)\n\n### What Goes in the Model?\n- Data structures\n- Business logic\n- Data validation\n- API communication\n- Database operations\n\n### Simple Model Example:\n```swift\nstruct User: Identifiable, Codable {\n    let id: UUID\n    var name: String\n    var email: String\n    var joinDate: Date\n    \n    var isEmailValid: Bool {\n        return email.contains(\"@\") && email.contains(\".\")\n    }\n    \n    var membershipDuration: Int {\n        let calendar = Calendar.current\n        return calendar.dateComponents([.day], from: joinDate, to: Date()).day ?? 0\n    }\n}\n```\n\n### Business Logic in Models:\n```swift\nstruct Product {\n    let id: UUID\n    var name: String\n    var price: Double\n    var stockQuantity: Int\n    \n    var isInStock: Bool {\n        return stockQuantity > 0\n    }\n    \n    func applyDiscount(percentage: Double) -> Double {\n        let discount = price * (percentage / 100)\n        return max(0, price - discount)\n    }\n}\n```\n\n## 3. ViewModel Layer (60 min)\n\n### ViewModel Responsibilities:\n- Preparing data for the View\n- Handling user interactions\n- Managing state and business logic\n- Coordinating with Models\n\n### Basic ViewModel Structure:\n```swift\nimport Foundation\nimport Combine\n\nclass UserViewModel: ObservableObject {\n    // MARK: - Published Properties\n    @Published var users: [User] = []\n    @Published var isLoading = false\n    @Published var errorMessage: String?\n    \n    // MARK: - Business Logic\n    func loadUsers() {\n        isLoading = true\n        errorMessage = nil\n        \n        // Simulate API call\n        DispatchQueue.main.asyncAfter(deadline: .now() + 1.0) {\n            self.users = [\n                User(id: UUID(), name: \"John Doe\", email: \"john@example.com\", joinDate: Date()),\n                User(id: UUID(), name: \"Jane Smith\", email: \"jane@example.com\", joinDate: Date())\n            ]\n            self.isLoading = false\n        }\n    }\n    \n    func addUser(name: String, email: String) {\n        let newUser = User(id: UUID(), name: name, email: email, joinDate: Date())\n        users.append(newUser)\n    }\n    \n    func deleteUser(at offsets: IndexSet) {\n        users.remove(atOffsets: offsets)\n    }\n}\n```\n\n### State Management in ViewModels:\n```swift\nclass ShoppingCartViewModel: ObservableObject {\n    @Published var items: [CartItem] = []\n    @Published var totalPrice: Double = 0.0\n    @Published var isCheckingOut = false\n    \n    var itemCount: Int {\n        return items.count\n    }\n    \n    func addItem(_ product: Product, quantity: Int = 1) {\n        if let index = items.firstIndex(where: { $0.product.id == product.id }) {\n            items[index].quantity += quantity\n        } else {\n            let newItem = CartItem(product: product, quantity: quantity)\n            items.append(newItem)\n        }\n        calculateTotal()\n    }\n    \n    private func calculateTotal() {\n        totalPrice = items.reduce(0) { $0 + ($1.product.price * Double($1.quantity)) }\n    }\n}\n```\n\n## 4. View Layer (60 min)\n\n### Connecting View to ViewModel:\n```swift\nimport SwiftUI\n\nstruct UserListView: View {\n    @StateObject private var viewModel = UserViewModel()\n    \n    var body: some View {\n        NavigationView {\n            VStack {\n                if viewModel.isLoading {\n                    ProgressView(\"Loading users...\")\n                } else if let error = viewModel.errorMessage {\n                    ErrorView(message: error) {\n                        viewModel.loadUsers()\n                    }\n                } else {\n                    List {\n                        ForEach(viewModel.users) { user in\n                            UserRowView(user: user)\n                        }\n                        .onDelete(perform: viewModel.deleteUser)\n                    }\n                }\n            }\n            .navigationTitle(\"Users\")\n            .toolbar {\n                Button(\"Add User\") {\n                    // Add user logic\n                }\n            }\n        }\n        .onAppear {\n            viewModel.loadUsers()\n        }\n    }\n}\n\nstruct UserRowView: View {\n    let user: User\n    \n    var body: some View {\n        VStack(alignment: .leading) {\n            Text(user.name)\n                .font(.headline)\n            Text(user.email)\n                .font(.subheadline)\n                .foregroundColor(.secondary)\n            Text(\"Member for \\(user.membershipDuration) days\")\n                .font(.caption)\n        }\n    }\n}\n```\n\n### Handling User Input:\n```swift\nstruct AddUserView: View {\n    @Environment(\\.dismiss) private var dismiss\n    @ObservedObject var viewModel: UserViewModel\n    @State private var name = \"\"\n    @State private var email = \"\"\n    \n    var body: some View {\n        NavigationView {\n            Form {\n                Section(\"User Details\") {\n                    TextField(\"Name\", text: $name)\n                    TextField(\"Email\", text: $email)\n                        .keyboardType(.emailAddress)\n                        .autocapitalization(.none)\n                }\n                \n                Section {\n                    Button(\"Add User\") {\n                        viewModel.addUser(name: name, email: email)\n                        dismiss()\n                    }\n                    .disabled(name.isEmpty || email.isEmpty)\n                }\n            }\n            .navigationTitle(\"Add User\")\n            .toolbar {\n                ToolbarItem(placement: .cancellationAction) {\n                    Button(\"Cancel\") {\n                        dismiss()\n                    }\n                }\n            }\n        }\n    }\n}\n```\n\n## 5. Data Flow in MVVM (45 min)\n\n### One-Way Data Flow:\n- **View â†’ ViewModel**: User actions (button taps, text input)\n- **ViewModel â†’ View**: Published property updates\n- **ViewModel â†’ Model**: Business logic operations\n- **Model â†’ ViewModel**: Data updates and computations\n\n### @StateObject vs @ObservedObject:\n```swift\n// Use @StateObject for ownership - this view creates and owns the ViewModel\nstruct ParentView: View {\n    @StateObject private var viewModel = UserViewModel()\n    \n    var body: some View {\n        ChildView(viewModel: viewModel)\n    }\n}\n\n// Use @ObservedObject for sharing - this view uses a ViewModel created elsewhere\nstruct ChildView: View {\n    @ObservedObject var viewModel: UserViewModel\n    \n    var body: some View {\n        Text(\"\\(viewModel.users.count) users\")\n    }\n}\n```\n\n### Binding Data Between Views:\n```swift\nclass SettingsViewModel: ObservableObject {\n    @Published var username: String = \"\"\n    @Published var notificationsEnabled: Bool = true\n    @Published var theme: Theme = .light\n}\n\nstruct SettingsView: View {\n    @ObservedObject var viewModel: SettingsViewModel\n    \n    var body: some View {\n        Form {\n            TextField(\"Username\", text: $viewModel.username)\n            Toggle(\"Notifications\", isOn: $viewModel.notificationsEnabled)\n            Picker(\"Theme\", selection: $viewModel.theme) {\n                ForEach(Theme.allCases, id: \\.self) { theme in\n                    Text(theme.rawValue.capitalized)\n                }\n            }\n        }\n    }\n}\n```\n\n## 6. Best Practices & Common Patterns (45 min)\n\n### Dependency Injection:\n```swift\nclass UserViewModel: ObservableObject {\n    private let userService: UserServiceProtocol\n    \n    // Inject dependencies through initializer\n    init(userService: UserServiceProtocol = UserService()) {\n        self.userService = userService\n    }\n    \n    func loadUsers() async {\n        do {\n            let users = try await userService.fetchUsers()\n            await MainActor.run {\n                self.users = users\n            }\n        } catch {\n            await MainActor.run {\n                self.errorMessage = error.localizedDescription\n            }\n        }\n    }\n}\n```\n\n### Error Handling in MVVM:\n```swift\nclass WeatherViewModel: ObservableObject {\n    @Published var weather: Weather?\n    @Published var isLoading = false\n    @Published var error: WeatherError?\n    \n    @MainActor\n    func fetchWeather(for city: String) async {\n        isLoading = true\n        error = nil\n        \n        do {\n            weather = try await WeatherService().fetchWeather(for: city)\n        } catch {\n            self.error = WeatherError(message: error.localizedDescription)\n        }\n        \n        isLoading = false\n    }\n}\n```\n\n### Testing ViewModels:\n```swift\nclass UserViewModelTests: XCTestCase {\n    func testAddUser() {\n        // Given\n        let viewModel = UserViewModel()\n        let initialCount = viewModel.users.count\n        \n        // When\n        viewModel.addUser(name: \"Test User\", email: \"test@example.com\")\n        \n        // Then\n        XCTAssertEqual(viewModel.users.count, initialCount + 1)\n        XCTAssertEqual(viewModel.users.last?.name, \"Test User\")\n    }\n}\n```\n\n## Practice Exercises\n\nComplete all exercises to master the MVVM pattern in SwiftUI!",
      "codeExample": "// === COMPLETE MVVM EXAMPLE ===\n\n// MARK: - Model\nstruct Task: Identifiable, Codable {\n    let id: UUID\n    var title: String\n    var description: String\n    var isCompleted: Bool\n    var dueDate: Date?\n    var priority: Priority\n    \n    enum Priority: String, CaseIterable, Codable {\n        case low, medium, high\n    }\n    \n    init(id: UUID = UUID(), title: String, description: String = \"\", isCompleted: Bool = false, dueDate: Date? = nil, priority: Priority = .medium) {\n        self.id = id\n        self.title = title\n        self.description = description\n        self.isCompleted = isCompleted\n        self.dueDate = dueDate\n        self.priority = priority\n    }\n    \n    var isOverdue: Bool {\n        guard let dueDate = dueDate else { return false }\n        return !isCompleted && dueDate < Date()\n    }\n}\n\n// MARK: - ViewModel\nclass TaskViewModel: ObservableObject {\n    @Published var tasks: [Task] = []\n    @Published var isLoading = false\n    @Published var errorMessage: String?\n    @Published var searchText = \"\"\n    @Published var selectedPriority: Task.Priority?\n    \n    var filteredTasks: [Task] {\n        tasks.filter { task in\n            let matchesSearch = searchText.isEmpty || \n                task.title.localizedCaseInsensitiveContains(searchText) ||\n                task.description.localizedCaseInsensitiveContains(searchText)\n            \n            let matchesPriority = selectedPriority == nil || task.priority == selectedPriority\n            \n            return matchesSearch && matchesPriority\n        }\n    }\n    \n    var completedTasks: [Task] {\n        filteredTasks.filter { $0.isCompleted }\n    }\n    \n    var incompleteTasks: [Task] {\n        filteredTasks.filter { !$0.isCompleted }\n    }\n    \n    var overdueTasks: [Task] {\n        filteredTasks.filter { $0.isOverdue }\n    }\n    \n    // MARK: - Intent Methods\n    \n    @MainActor\n    func loadTasks() async {\n        isLoading = true\n        errorMessage = nil\n        \n        // Simulate network request\n        do {\n            try await Task.sleep(nanoseconds: 1_000_000_000) // 1 second\n            \n            // Sample data\n            tasks = [\n                Task(title: \"Learn SwiftUI\", description: \"Complete MVVM tutorial\", priority: .high),\n                Task(title: \"Build Todo App\", isCompleted: true, priority: .medium),\n                Task(title: \"Study Combine\", description: \"Reactive programming\", dueDate: Date().addingTimeInterval(86400), priority: .high),\n                Task(title: \"Read documentation\", dueDate: Date().addingTimeInterval(-86400), priority: .low)\n            ]\n        } catch {\n            errorMessage = \"Failed to load tasks: \\(error.localizedDescription)\"\n        }\n        \n        isLoading = false\n    }\n    \n    func addTask(title: String, description: String = \"\", dueDate: Date? = nil, priority: Task.Priority = .medium) {\n        let newTask = Task(title: title, description: description, dueDate: dueDate, priority: priority)\n        tasks.append(newTask)\n    }\n    \n    func toggleTaskCompletion(_ task: Task) {\n        if let index = tasks.firstIndex(where: { $0.id == task.id }) {\n            tasks[index].isCompleted.toggle()\n        }\n    }\n    \n    func deleteTask(_ task: Task) {\n        tasks.removeAll { $0.id == task.id }\n    }\n    \n    func deleteTasks(at offsets: IndexSet) {\n        tasks.remove(atOffsets: offsets)\n    }\n    \n    func updateTask(_ task: Task) {\n        if let index = tasks.firstIndex(where: { $0.id == task.id }) {\n            tasks[index] = task\n        }\n    }\n}\n\n// MARK: - View\nstruct TaskListView: View {\n    @StateObject private var viewModel = TaskViewModel()\n    @State private var showingAddTask = false\n    \n    var body: some View {\n        NavigationView {\n            VStack {\n                // Search and Filter\n                VStack {\n                    TextField(\"Search tasks...\", text: $viewModel.searchText)\n                        .textFieldStyle(RoundedBorderTextFieldStyle())\n                        .padding(.horizontal)\n                    \n                    ScrollView(.horizontal, showsIndicators: false) {\n                        HStack {\n                            FilterButton(title: \"All\", isSelected: viewModel.selectedPriority == nil) {\n                                viewModel.selectedPriority = nil\n                            }\n                            \n                            ForEach(Task.Priority.allCases, id: \\.self) { priority in\n                                FilterButton(\n                                    title: priority.rawValue.capitalized,\n                                    isSelected: viewModel.selectedPriority == priority\n                                ) {\n                                    viewModel.selectedPriority = priority\n                                }\n                            }\n                        }\n                        .padding(.horizontal)\n                    }\n                }\n                \n                // Content\n                if viewModel.isLoading {\n                    ProgressView(\"Loading tasks...\")\n                        .frame(maxHeight: .infinity)\n                } else if let error = viewModel.errorMessage {\n                    VStack {\n                        Image(systemName: \"exclamationmark.triangle\")\n                            .font(.largeTitle)\n                            .foregroundColor(.orange)\n                        Text(\"Error loading tasks\")\n                        Text(error)\n                            .font(.caption)\n                            .foregroundColor(.secondary)\n                        Button(\"Try Again\") {\n                            Task {\n                                await viewModel.loadTasks()\n                            }\n                        }\n                        .buttonStyle(.bordered)\n                    }\n                    .frame(maxHeight: .infinity)\n                } else {\n                    List {\n                        // Overdue Section\n                        if !viewModel.overdueTasks.isEmpty {\n                            Section(\"Overdue\") {\n                                ForEach(viewModel.overdueTasks) { task in\n                                    TaskRowView(task: task, viewModel: viewModel)\n                                        .foregroundColor(.red)\n                                }\n                            }\n                        }\n                        \n                        // Incomplete Tasks\n                        Section(\"To Do (\\(viewModel.incompleteTasks.count))\" ) {\n                            ForEach(viewModel.incompleteTasks) { task in\n                                TaskRowView(task: task, viewModel: viewModel)\n                            }\n                            .onDelete { offsets in\n                                let incompleteTasks = viewModel.incompleteTasks\n                                let tasksToDelete = offsets.map { incompleteTasks[$0] }\n                                for task in tasksToDelete {\n                                    viewModel.deleteTask(task)\n                                }\n                            }\n                        }\n                        \n                        // Completed Tasks\n                        Section(\"Completed (\\(viewModel.completedTasks.count))\" ) {\n                            ForEach(viewModel.completedTasks) { task in\n                                TaskRowView(task: task, viewModel: viewModel)\n                                    .foregroundColor(.green)\n                            }\n                        }\n                    }\n                    .listStyle(InsetGroupedListStyle())\n                }\n            }\n            .navigationTitle(\"My Tasks\")\n            .toolbar {\n                ToolbarItem(placement: .navigationBarTrailing) {\n                    Button(action: { showingAddTask = true }) {\n                        Image(systemName: \"plus\")\n                    }\n                }\n            }\n            .sheet(isPresented: $showingAddTask) {\n                AddTaskView(viewModel: viewModel)\n            }\n        }\n        .task {\n            await viewModel.loadTasks()\n        }\n    }\n}\n\n// MARK: - Supporting Views\nstruct TaskRowView: View {\n    let task: Task\n    let viewModel: TaskViewModel\n    \n    var body: some View {\n        HStack {\n            Button(action: {\n                viewModel.toggleTaskCompletion(task)\n            }) {\n                Image(systemName: task.isCompleted ? \"checkmark.circle.fill\" : \"circle\")\n                    .foregroundColor(task.isCompleted ? .green : .gray)\n            }\n            .buttonStyle(PlainButtonStyle())\n            \n            VStack(alignment: .leading) {\n                Text(task.title)\n                    .strikethrough(task.isCompleted)\n                    .font(.headline)\n                \n                if !task.description.isEmpty {\n                    Text(task.description)\n                        .font(.caption)\n                        .foregroundColor(.secondary)\n                        .strikethrough(task.isCompleted)\n                }\n                \n                if let dueDate = task.dueDate {\n                    HStack {\n                        Image(systemName: \"calendar\")\n                            .font(.caption2)\n                        Text(dueDate, style: .date)\n                            .font(.caption2)\n                    }\n                    .foregroundColor(task.isOverdue ? .red : .secondary)\n                }\n            }\n            \n            Spacer()\n            \n            PriorityView(priority: task.priority)\n        }\n        .padding(.vertical, 4)\n    }\n}\n\nstruct PriorityView: View {\n    let priority: Task.Priority\n    \n    var color: Color {\n        switch priority {\n        case .low: return .green\n        case .medium: return .orange\n        case .high: return .red\n        }\n    }\n    \n    var body: some View {\n        Text(priority.rawValue.capitalized)\n            .font(.caption)\n            .padding(.horizontal, 8)\n            .padding(.vertical, 4)\n            .background(color.opacity(0.2))\n            .foregroundColor(color)\n            .cornerRadius(4)\n    }\n}\n\nstruct FilterButton: View {\n    let title: String\n    let isSelected: Bool\n    let action: () -> Void\n    \n    var body: some View {\n        Button(action: action) {\n            Text(title)\n                .font(.caption)\n                .padding(.horizontal, 12)\n                .padding(.vertical, 6)\n                .background(isSelected ? Color.blue : Color.gray.opacity(0.2))\n                .foregroundColor(isSelected ? .white : .primary)\n                .cornerRadius(8)\n        }\n    }\n}\n\nstruct AddTaskView: View {\n    @Environment(\\.dismiss) private var dismiss\n    @ObservedObject var viewModel: TaskViewModel\n    \n    @State private var title = \"\"\n    @State private var description = \"\"\n    @State private var dueDate = Date()\n    @State private var hasDueDate = false\n    @State private var priority: Task.Priority = .medium\n    \n    var body: some View {\n        NavigationView {\n            Form {\n                Section(\"Task Details\") {\n                    TextField(\"Title\", text: $title)\n                    TextField(\"Description (optional)\", text: $description)\n                }\n                \n                Section(\"Priority\") {\n                    Picker(\"Priority\", selection: $priority) {\n                        ForEach(Task.Priority.allCases, id: \\.self) { priority in\n                            Text(priority.rawValue.capitalized).tag(priority)\n                        }\n                    }\n                    .pickerStyle(SegmentedPickerStyle())\n                }\n                \n                Section(\"Due Date\") {\n                    Toggle(\"Add due date\", isOn: $hasDueDate)\n                    \n                    if hasDueDate {\n                        DatePicker(\"Due Date\", selection: $dueDate, in: Date()..., displayedComponents: .date)\n                    }\n                }\n            }\n            .navigationTitle(\"Add Task\")\n            .toolbar {\n                ToolbarItem(placement: .cancellationAction) {\n                    Button(\"Cancel\") {\n                        dismiss()\n                    }\n                }\n                \n                ToolbarItem(placement: .confirmationAction) {\n                    Button(\"Add\") {\n                        viewModel.addTask(\n                            title: title,\n                            description: description,\n                            dueDate: hasDueDate ? dueDate : nil,\n                            priority: priority\n                        )\n                        dismiss()\n                    }\n                    .disabled(title.isEmpty)\n                }\n            }\n        }\n    }\n}\n\n// MARK: - Preview\n#Preview {\n    TaskListView()\n}",
      "category": "App Architecture",
      "estimatedTime": 240,
      "dependencies": ["structs_classes", "swiftui_basics"],
      "challenge": {
        "instructions": "Create a complete Weather App using MVVM architecture with the following requirements:\n\nPART 1: Model Layer (60 min)\n1. Create 'Weather' struct with: location, temperature, condition, humidity, windSpeed\n2. Add computed properties: temperatureString, conditionIcon, feelsLikeTemperature\n3. Create 'WeatherService' protocol and mock implementation for testing\n4. Add error types for network failures and invalid data\n\nPART 2: ViewModel Layer (60 min)\n5. Create 'WeatherViewModel' with @Published properties for weather data, loading state, and errors\n6. Implement methods: fetchWeather(for:), searchLocation(_:), toggleTemperatureUnit()\n7. Add business logic for temperature conversion (Celsius/Fahrenheit)\n8. Implement search functionality with debouncing\n\nPART 3: View Layer (60 min)\n9. Create 'WeatherView' with current weather display and search field\n10. Build 'WeatherDetailView' showing extended forecast\n11. Add loading states, error handling, and empty states\n12. Implement temperature unit toggle with animations\n\nPART 4: Advanced Features (60 min)\n13. Add location services to get user's current location\n14. Implement offline support with cached weather data\n15. Add weather alerts and notifications\n16. Create widget extension showing current weather\n\nTest your MVVM implementation by verifying that business logic is in ViewModel and UI is in Views!",
        "starterCode": "// === PART 1: Model Layer ===\n// Define Weather model and service protocol here\n\n\n// === PART 2: ViewModel Layer ===\n// Create WeatherViewModel with @Published properties\n\n\n// === PART 3: View Layer ===\n// Build SwiftUI views that observe the ViewModel\n\n\n// === PART 4: Advanced Features ===\n// Add location services, caching, and widgets\n\n",
        "solution": "// === PART 1: Model Layer ===\nimport Foundation\n\nstruct Weather: Identifiable, Codable {\n    let id = UUID()\n    let location: String\n    let temperature: Double\n    let condition: WeatherCondition\n    let humidity: Int\n    let windSpeed: Double\n    let feelsLike: Double\n    let sunrise: Date\n    let sunset: Date\n    \n    var temperatureString: String {\n        return \"\\(Int(temperature))Â°\"\n    }\n    \n    var feelsLikeString: String {\n        return \"\\(Int(feelsLike))Â°\"\n    }\n    \n    var conditionIcon: String {\n        switch condition {\n        case .sunny: return \"sun.max.fill\"\n        case .cloudy: return \"cloud.fill\"\n        case .rainy: return \"cloud.rain.fill\"\n        case .snowy: return \"snow\"\n        case .thunderstorm: return \"cloud.bolt.fill\"\n        }\n    }\n    \n    var isDaytime: Bool {\n        let now = Date()\n        return now >= sunrise && now <= sunset\n    }\n}\n\nenum WeatherCondition: String, Codable, CaseIterable {\n    case sunny, cloudy, rainy, snowy, thunderstorm\n}\n\nenum TemperatureUnit: String, CaseIterable {\n    case celsius, fahrenheit\n    \n    var symbol: String {\n        switch self {\n        case .celsius: return \"Â°C\"\n        case .fahrenheit: return \"Â°F\"\n        }\n    }\n}\n\nenum WeatherError: LocalizedError {\n    case networkError\n    case locationNotFound\n    case invalidData\n    \n    var errorDescription: String? {\n        switch self {\n        case .networkError: return \"Unable to fetch weather data\"\n        case .locationNotFound: return \"Location not found\"\n        case .invalidData: return \"Invalid weather data received\"\n        }\n    }\n}\n\n// Service Protocol for dependency injection\nprotocol WeatherServiceProtocol {\n    func fetchWeather(for location: String) async throws -> Weather\n    func fetchWeather(for coordinates: (Double, Double)) async throws -> Weather\n}\n\n// Mock implementation for testing\nclass MockWeatherService: WeatherServiceProtocol {\n    func fetchWeather(for location: String) async throws -> Weather {\n        // Simulate network delay\n        try await Task.sleep(nanoseconds: 1_000_000_000)\n        \n        return Weather(\n            location: location,\n            temperature: 22.0,\n            condition: .sunny,\n            humidity: 65,\n            windSpeed: 5.5,\n            feelsLike: 24.0,\n            sunrise: Date(),\n            sunset: Date().addingTimeInterval(43200)\n        )\n    }\n    \n    func fetchWeather(for coordinates: (Double, Double)) async throws -> Weather {\n        try await fetchWeather(for: \"Current Location\")\n    }\n}\n\n// === PART 2: ViewModel Layer ===\nimport Combine\nimport SwiftUI\n\nclass WeatherViewModel: ObservableObject {\n    @Published var currentWeather: Weather?\n    @Published var isLoading = false\n    @Published var error: WeatherError?\n    @Published var searchText = \"\"\n    @Published var temperatureUnit: TemperatureUnit = .celsius\n    \n    private let weatherService: WeatherServiceProtocol\n    private var cancellables = Set<AnyCancellable>()\n    \n    init(weatherService: WeatherServiceProtocol = MockWeatherService()) {\n        self.weatherService = weatherService\n        \n        // Debounce search\n        $searchText\n            .debounce(for: .seconds(0.5), scheduler: RunLoop.main)\n            .removeDuplicates()\n            .sink { [weak self] query in\n                if !query.isEmpty {\n                    self?.fetchWeather(for: query)\n                }\n            }\n            .store(in: &cancellables)\n    }\n    \n    @MainActor\n    func fetchWeather(for location: String) {\n        guard !location.isEmpty else { return }\n        \n        isLoading = true\n        error = nil\n        \n        Task {\n            do {\n                let weather = try await weatherService.fetchWeather(for: location)\n                currentWeather = weather\n            } catch {\n                self.error = WeatherError.networkError\n            }\n            isLoading = false\n        }\n    }\n    \n    func toggleTemperatureUnit() {\n        temperatureUnit = temperatureUnit == .celsius ? .fahrenheit : .celsius\n    }\n    \n    func convertTemperature(_ celsius: Double) -> Double {\n        switch temperatureUnit {\n        case .celsius:\n            return celsius\n        case .fahrenheit:\n            return (celsius * 9/5) + 32\n        }\n    }\n    \n    func formattedTemperature(_ celsius: Double) -> String {\n        let temp = convertTemperature(celsius)\n        return \"\\(Int(temp))\\(temperatureUnit.symbol)\"\n    }\n}\n\n// === PART 3: View Layer ===\nstruct WeatherView: View {\n    @StateObject private var viewModel = WeatherViewModel()\n    \n    var body: some View {\n        NavigationView {\n            VStack(spacing: 20) {\n                // Search Bar\n                HStack {\n                    Image(systemName: \"magnifyingglass\")\n                        .foregroundColor(.secondary)\n                    TextField(\"Search location...\", text: $viewModel.searchText)\n                }\n                .padding()\n                .background(Color(.systemGray6))\n                .cornerRadius(10)\n                .padding(.horizontal)\n                \n                // Content\n                if viewModel.isLoading {\n                    ProgressView(\"Fetching weather...\")\n                        .frame(maxHeight: .infinity)\n                } else if let error = viewModel.error {\n                    VStack {\n                        Image(systemName: \"exclamationmark.triangle\")\n                            .font(.largeTitle)\n                            .foregroundColor(.orange)\n                        Text(error.localizedDescription)\n                            .multilineTextAlignment(.center)\n                        Button(\"Try Again\") {\n                            if !viewModel.searchText.isEmpty {\n                                viewModel.fetchWeather(for: viewModel.searchText)\n                            }\n                        }\n                        .buttonStyle(.bordered)\n                    }\n                    .frame(maxHeight: .infinity)\n                } else if let weather = viewModel.currentWeather {\n                    ScrollView {\n                        VStack(spacing: 20) {\n                            // Current Weather\n                            VStack(spacing: 10) {\n                                Text(weather.location)\n                                    .font(.title2)\n                                    .fontWeight(.semibold)\n                                \n                                HStack {\n                                    Image(systemName: weather.conditionIcon)\n                                        .font(.system(size: 60))\n                                        .foregroundColor(weather.isDaytime ? .orange : .blue)\n                                    \n                                    Text(viewModel.formattedTemperature(weather.temperature))\n                                        .font(.system(size: 50, weight: .thin))\n                                }\n                                \n                                Text(weather.condition.rawValue.capitalized)\n                                    .font(.title3)\n                                    .foregroundColor(.secondary)\n                                \n                                Text(\"Feels like \\(viewModel.formattedTemperature(weather.feelsLike))\")\n                                    .foregroundColor(.secondary)\n                            }\n                            .padding()\n                            .background(Color(.systemGray6))\n                            .cornerRadius(15)\n                            \n                            // Weather Details\n                            LazyVGrid(columns: [GridItem(.flexible()), GridItem(.flexible())], spacing: 10) {\n                                WeatherDetailCard(title: \"Humidity\", value: \"\\(weather.humidity)%\", icon: \"humidity\")\n                                WeatherDetailCard(title: \"Wind Speed\", value: \"\\(weather.windSpeed) km/h\", icon: \"wind\")\n                            }\n                        }\n                        .padding()\n                    }\n                } else {\n                    VStack {\n                        Image(systemName: \"cloud.sun\")\n                            .font(.system(size: 60))\n                            .foregroundColor(.secondary)\n                        Text(\"Search for a location to see weather\")\n                            .foregroundColor(.secondary)\n                    }\n                    .frame(maxHeight: .infinity)\n                }\n            }\n            .navigationTitle(\"Weather\")\n            .toolbar {\n                ToolbarItem(placement: .navigationBarTrailing) {\n                    Button(action: viewModel.toggleTemperatureUnit) {\n                        Text(viewModel.temperatureUnit.symbol)\n                    }\n                }\n            }\n        }\n    }\n}\n\nstruct WeatherDetailCard: View {\n    let title: String\n    let value: String\n    let icon: String\n    \n    var body: some View {\n        VStack {\n            Image(systemName: icon)\n                .font(.title2)\n                .foregroundColor(.blue)\n            Text(title)\n                .font(.caption)\n                .foregroundColor(.secondary)\n            Text(value)\n                .font(.headline)\n        }\n        .padding()\n        .frame(maxWidth: .infinity)\n        .background(Color(.systemGray6))\n        .cornerRadius(10)\n    }\n}\n\n// === PART 4: Advanced Features ===\n// Location Service (simplified)\nclass LocationService: ObservableObject {\n    @Published var currentLocation: (Double, Double)?\n    \n    func requestLocation() {\n        // In real implementation, this would use CoreLocation\n        // For demo, use mock coordinates\n        currentLocation = (37.7749, -122.4194) // San Francisco\n    }\n}\n\n// Extended WeatherViewModel with location\nextension WeatherViewModel {\n    @MainActor\n    func fetchCurrentLocationWeather() {\n        let locationService = LocationService()\n        locationService.requestLocation()\n        \n        // In real app, you'd observe the location service\n        fetchWeather(for: \"San Francisco\")\n    }\n}\n\n// Caching support\nclass WeatherCache {\n    private let cache = NSCache<NSString, Weather>()\n    \n    func getWeather(for location: String) -> Weather? {\n        return cache.object(forKey: location as NSString)\n    }\n    \n    func setWeather(_ weather: Weather, for location: String) {\n        cache.setObject(weather, forKey: location as NSString)\n    }\n}\n\n#Preview {\n    WeatherView()\n}",
        "hints": [
          "PART 1: Use enums for weather conditions and temperature units. Protocols make testing easier",
          "PART 2: Remember @Published properties automatically update the view. Use debouncing for search to avoid excessive API calls",
          "PART 3: Use @StateObject when creating the ViewModel, @ObservedObject when passing it to child views",
          "PART 4: For location services, you'll need to request user permission and handle coordinates",
          "Use async/await for network calls instead of completion handlers for cleaner code",
          "Implement Equatable for your models to enable diffing and efficient UI updates",
          "Consider using AppStorage for persisting user preferences like temperature unit",
          "For caching, you can use NSCache or write to UserDefaults for simple cases"
        ],
        "testCases": [
          {
            "input": "viewModel.convertTemperature(0)",
            "expectedOutput": "32.0",
            "description": "Celsius to Fahrenheit conversion should work correctly"
          },
          {
            "input": "viewModel.currentWeather?.location == \"Test City\"",
            "expectedOutput": "true",
            "description": "Weather data should be properly set after successful fetch"
          },
          {
            "input": "viewModel.isLoading == false after fetch",
            "expectedOutput": "true",
            "description": "Loading state should be false after data is loaded"
          }
        ]
      }
    },
    {
      "id": "view_lifecycle",
      "title": "View Lifecycle",
      "description": "Master view appearance and disappearance events to manage state, resources, and data loading in SwiftUI",
      "difficulty": "beginner",
      "theory": "# View Lifecycle - onAppear & onDisappear\n\n## 1. Understanding View Lifecycle (45 min)\n\n### What is View Lifecycle?\n- The sequence of events from when a view **appears** to when it **disappears**\n- SwiftUI provides modifiers to hook into these events\n- Essential for **resource management** and **data loading**\n\n### Why View Lifecycle Matters:\n- **Load data** when views become visible\n- **Clean up resources** when views disappear\n- **Start/stop animations** appropriately\n- **Manage subscriptions** and timers\n- **Optimize performance** by loading only when needed\n\n### Real-world Analogy:\n- **onAppear**: Like opening a book - you start reading when it's open\n- **onDisappear**: Like closing a book - you stop reading and bookmark your place\n\n## 2. onAppear Modifier (60 min)\n\n### Basic Syntax:\n```swift\nstruct ContentView: View {\n    var body: some View {\n        Text(\"Hello, World!\")\n            .onAppear {\n                // This runs when the view appears\n                print(\"Text view appeared!\")\n            }\n    }\n}\n```\n\n### Common Use Cases for onAppear:\n\n#### Data Loading:\n```swift\nstruct UserProfileView: View {\n    @State private var user: User?\n    \n    var body: some View {\n        VStack {\n            if let user = user {\n                Text(\"Welcome, \\(user.name)!\")\n            } else {\n                ProgressView(\"Loading...\")\n            }\n        }\n        .onAppear {\n            loadUserData()\n        }\n    }\n    \n    private func loadUserData() {\n        // Simulate network request\n        DispatchQueue.main.asyncAfter(deadline: .now() + 1) {\n            user = User(name: \"John Doe\", email: \"john@example.com\")\n        }\n    }\n}\n```\n\n#### Starting Animations:\n```swift\nstruct AnimatedCircle: View {\n    @State private var scale: CGFloat = 1.0\n    \n    var body: some View {\n        Circle()\n            .frame(width: 100, height: 100)\n            .scaleEffect(scale)\n            .onAppear {\n                withAnimation(.easeInOut(duration: 1).repeatForever()) {\n                    scale = 1.5\n                }\n            }\n    }\n}\n```\n\n#### Setting Up Timers:\n```swift\nstruct TimerView: View {\n    @State private var counter = 0\n    @State private var timer: Timer?\n    \n    var body: some View {\n        Text(\"Counter: \\(counter)\")\n            .onAppear {\n                timer = Timer.scheduledTimer(withTimeInterval: 1, repeats: true) { _ in\n                    counter += 1\n                }\n            }\n    }\n}\n```\n\n## 3. onDisappear Modifier (60 min)\n\n### Basic Syntax:\n```swift\nstruct ContentView: View {\n    var body: some View {\n        Text(\"Hello, World!\")\n            .onDisappear {\n                // This runs when the view disappears\n                print(\"Text view disappeared!\")\n            }\n    }\n}\n```\n\n### Common Use Cases for onDisappear:\n\n#### Cleaning Up Resources:\n```swift\nstruct AudioPlayerView: View {\n    @State private var audioPlayer: AudioPlayer?\n    \n    var body: some View {\n        VStack {\n            Button(\"Play\") {\n                audioPlayer?.play()\n            }\n            Button(\"Stop\") {\n                audioPlayer?.stop()\n            }\n        }\n        .onAppear {\n            audioPlayer = AudioPlayer()\n            audioPlayer?.load(\"song.mp3\")\n        }\n        .onDisappear {\n            audioPlayer?.stop()\n            audioPlayer = nil // Clean up\n        }\n    }\n}\n```\n\n#### Stopping Timers:\n```swift\nstruct StopwatchView: View {\n    @State private var seconds = 0\n    @State private var timer: Timer?\n    \n    var body: some View {\n        Text(\"Time: \\(seconds)s\")\n            .onAppear {\n                timer = Timer.scheduledTimer(withTimeInterval: 1, repeats: true) { _ in\n                    seconds += 1\n                }\n            }\n            .onDisappear {\n                timer?.invalidate()\n                timer = nil\n            }\n    }\n}\n```\n\n#### Saving Data:\n```swift\nstruct NoteEditorView: View {\n    @State private var noteText = \"\"\n    \n    var body: some View {\n        TextEditor(text: $noteText)\n            .onAppear {\n                // Load saved note\n                noteText = UserDefaults.standard.string(forKey: \"savedNote\") ?? \"\"\n            }\n            .onDisappear {\n                // Auto-save when leaving\n                UserDefaults.standard.set(noteText, forKey: \"savedNote\")\n            }\n    }\n}\n```\n\n## 4. Combined Usage Patterns (45 min)\n\n### Navigation Flow Example:\n```swift\nstruct ContentView: View {\n    @State private var isShowingDetail = false\n    \n    var body: some View {\n        NavigationView {\n            VStack {\n                Button(\"Show Detail\") {\n                    isShowingDetail = true\n                }\n            }\n            .sheet(isPresented: $isShowingDetail) {\n                DetailView()\n            }\n        }\n    }\n}\n\nstruct DetailView: View {\n    @State private var data: String = \"\"\n    \n    var body: some View {\n        VStack {\n            Text(\"Detail View\")\n            Text(\"Data: \\(data)\")\n        }\n        .onAppear {\n            print(\"DetailView appeared\")\n            loadData()\n        }\n        .onDisappear {\n            print(\"DetailView disappeared\")\n            saveData()\n        }\n    }\n    \n    private func loadData() {\n        // Simulate data loading\n        data = \"Loaded data\"\n    }\n    \n    private func saveData() {\n        // Save any changes\n        print(\"Saving data: \\(data)\")\n    }\n}\n```\n\n### Tab View Lifecycle:\n```swift\nstruct TabLifecycleView: View {\n    var body: some View {\n        TabView {\n            FirstTab()\n                .tabItem { Label(\"First\", systemImage: \"1.circle\") }\n            \n            SecondTab()\n                .tabItem { Label(\"Second\", systemImage: \"2.circle\") }\n        }\n    }\n}\n\nstruct FirstTab: View {\n    var body: some View {\n        Text(\"First Tab\")\n            .onAppear {\n                print(\"First tab became active\")\n            }\n            .onDisappear {\n                print(\"First tab became inactive\")\n            }\n    }\n}\n```\n\n## 5. Advanced Lifecycle Scenarios (45 min)\n\n### Conditional Appearance:\n```swift\nstruct ConditionalView: View {\n    @State private var showFeature = false\n    \n    var body: some View {\n        VStack {\n            Toggle(\"Show Feature\", isOn: $showFeature)\n            \n            if showFeature {\n                PremiumFeature()\n                    .onAppear {\n                        print(\"Premium feature activated\")\n                        startPremiumService()\n                    }\n                    .onDisappear {\n                        print(\"Premium feature deactivated\")\n                        stopPremiumService()\n                    }\n            }\n        }\n    }\n    \n    private func startPremiumService() {\n        // Start premium features\n    }\n    \n    private func stopPremiumService() {\n        // Clean up premium resources\n    }\n}\n```\n\n### Multiple View Hierarchy:\n```swift\nstruct ParentView: View {\n    var body: some View {\n        VStack {\n            Text(\"Parent View\")\n                .onAppear { print(\"Parent appeared\") }\n                .onDisappear { print(\"Parent disappeared\") }\n            \n            ChildView()\n        }\n    }\n}\n\nstruct ChildView: View {\n    var body: some View {\n        Text(\"Child View\")\n            .onAppear { print(\"Child appeared\") }\n            .onDisappear { print(\"Child disappeared\") }\n    }\n}\n```\n\n### Performance Optimization:\n```swift\nstruct LazyLoadingView: View {\n    var body: some View {\n        ScrollView {\n            LazyVStack {\n                ForEach(1...100, id: \\.self) { index in\n                    RowView(index: index)\n                        .onAppear {\n                            // Only load data when row becomes visible\n                            print(\"Row \\(index) appeared\")\n                        }\n                        .onDisappear {\n                            // Optional: cleanup when row leaves screen\n                            print(\"Row \\(index) disappeared\")\n                        }\n                }\n            }\n        }\n    }\n}\n```\n\n## 6. Best Practices & Common Pitfalls (45 min)\n\n### Do's and Don'ts:\n\n#### âœ… DO:\n- Use `onAppear` for **one-time setup**\n- Use `onDisappear` for **cleanup**\n- Consider **performance** when loading data\n- Handle **async operations** properly\n- Test with **navigation** and **tab changes**\n\n#### âŒ DON'T:\n- Put **heavy computation** directly in modifiers\n- Forget to **clean up resources**\n- Assume `onAppear` runs only once\n- Block the **main thread** with long operations\n\n### Memory Management:\n```swift\nstruct SafeTimerView: View {\n    @State private var counter = 0\n    @State private var timer: Timer?\n    \n    var body: some View {\n        VStack {\n            Text(\"Counter: \\(counter)\")\n            \n            Button(\"Reset\") {\n                counter = 0\n            }\n        }\n        .onAppear {\n            // Safe timer setup\n            timer = Timer.scheduledTimer(withTimeInterval: 1, repeats: true) { _ in\n                counter += 1\n            }\n        }\n        .onDisappear {\n            // Always clean up!\n            timer?.invalidate()\n            timer = nil\n        }\n    }\n}\n```\n\n### Error Handling:\n```swift\nstruct RobustDataLoadingView: View {\n    @State private var data: String? = nil\n    @State private var error: String? = nil\n    @State private var isLoading = false\n    \n    var body: some View {\n        VStack {\n            if isLoading {\n                ProgressView()\n            } else if let error = error {\n                Text(\"Error: \\(error)\")\n                    .foregroundColor(.red)\n            } else if let data = data {\n                Text(\"Data: \\(data)\")\n            }\n        }\n        .onAppear {\n            loadData()\n        }\n    }\n    \n    private func loadData() {\n        isLoading = true\n        error = nil\n        \n        // Simulate async operation\n        DispatchQueue.main.asyncAfter(deadline: .now() + 2) {\n            isLoading = false\n            \n            if Bool.random() {\n                data = \"Successfully loaded data\"\n            } else {\n                error = \"Failed to load data\"\n            }\n        }\n    }\n}\n```\n\n## Practice Exercises\n\nComplete all exercises to master view lifecycle management in SwiftUI!",
      "codeExample": "// === BASIC LIFECYCLE EXAMPLES ===\n\nimport SwiftUI\n\n// Simple onAppear/onDisappear\nstruct LifecycleDemo: View {\n    var body: some View {\n        VStack {\n            Text(\"Hello, SwiftUI!\")\n                .onAppear {\n                    print(\"âœ… Text view appeared on screen\")\n                }\n                .onDisappear {\n                    print(\"âŒ Text view disappeared from screen\")\n                }\n        }\n    }\n}\n\n// Data loading example\nstruct UserDashboard: View {\n    @State private var userName: String = \"\"\n    @State private var isLoading = false\n    @State private var lastUpdated = Date()\n    \n    var body: some View {\n        VStack(spacing: 20) {\n            if isLoading {\n                ProgressView(\"Loading user data...\")\n            } else {\n                Text(\"Welcome, \\(userName)\")\n                    .font(.title)\n                \n                Text(\"Last updated: \\(lastUpdated, style: .time)\")\n                    .font(.caption)\n                    .foregroundColor(.gray)\n            }\n        }\n        .onAppear {\n            print(\"ðŸ“± Dashboard appeared - loading user data\")\n            loadUserData()\n        }\n        .onDisappear {\n            print(\"ðŸ‘‹ Dashboard disappeared - saving session\")\n            saveUserSession()\n        }\n    }\n    \n    private func loadUserData() {\n        isLoading = true\n        \n        // Simulate network request\n        DispatchQueue.main.asyncAfter(deadline: .now() + 1.5) {\n            userName = \"John Appleseed\"\n            lastUpdated = Date()\n            isLoading = false\n            print(\"âœ… User data loaded successfully\")\n        }\n    }\n    \n    private func saveUserSession() {\n        // Simulate saving to UserDefaults\n        UserDefaults.standard.set(userName, forKey: \"lastUserName\")\n        print(\"ðŸ’¾ User session saved\")\n    }\n}\n\n// Timer management example\nstruct StopwatchView: View {\n    @State private var seconds = 0\n    @State private var timer: Timer?\n    @State private var isRunning = false\n    \n    var body: some View {\n        VStack(spacing: 20) {\n            Text(\"\\(seconds) seconds\")\n                .font(.system(size: 40, weight: .bold))\n            \n            HStack {\n                Button(isRunning ? \"Stop\" : \"Start\") {\n                    toggleTimer()\n                }\n                .buttonStyle(.borderedProminent)\n                \n                Button(\"Reset\") {\n                    resetTimer()\n                }\n                .buttonStyle(.bordered)\n            }\n        }\n        .onAppear {\n            print(\"â±ï¸ Stopwatch view appeared\")\n            // Optional: Restore previous state\n            restoreTimerState()\n        }\n        .onDisappear {\n            print(\"ðŸ›‘ Stopwatch view disappeared\")\n            // Critical: Always stop timer when view disappears\n            timer?.invalidate()\n            timer = nil\n            saveTimerState()\n        }\n    }\n    \n    private func toggleTimer() {\n        if isRunning {\n            timer?.invalidate()\n            timer = nil\n        } else {\n            timer = Timer.scheduledTimer(withTimeInterval: 1, repeats: true) { _ in\n                seconds += 1\n            }\n        }\n        isRunning.toggle()\n    }\n    \n    private func resetTimer() {\n        timer?.invalidate()\n        timer = nil\n        seconds = 0\n        isRunning = false\n    }\n    \n    private func saveTimerState() {\n        UserDefaults.standard.set(seconds, forKey: \"stopwatchSeconds\")\n        UserDefaults.standard.set(isRunning, forKey: \"stopwatchRunning\")\n    }\n    \n    private func restoreTimerState() {\n        seconds = UserDefaults.standard.integer(forKey: \"stopwatchSeconds\")\n        isRunning = UserDefaults.standard.bool(forKey: \"stopwatchRunning\")\n        \n        if isRunning {\n            toggleTimer() // Restart timer if it was running\n        }\n    }\n}\n\n// Navigation lifecycle example\nstruct MainAppView: View {\n    @State private var selectedTab = 0\n    \n    var body: some View {\n        TabView(selection: $selectedTab) {\n            HomeView()\n                .tabItem {\n                    Image(systemName: \"house\")\n                    Text(\"Home\")\n                }\n                .tag(0)\n            \n            ProfileView()\n                .tabItem {\n                    Image(systemName: \"person\")\n                    Text(\"Profile\")\n                }\n                .tag(1)\n            \n            SettingsView()\n                .tabItem {\n                    Image(systemName: \"gear\")\n                    Text(\"Settings\")\n                }\n                .tag(2)\n        }\n        .onAppear {\n            print(\"ðŸš€ Main app view appeared\")\n        }\n        .onDisappear {\n            print(\"ðŸ”Œ Main app view disappeared\")\n        }\n    }\n}\n\nstruct HomeView: View {\n    var body: some View {\n        NavigationView {\n            VStack {\n                Text(\"Home Screen\")\n                    .font(.largeTitle)\n                \n                NavigationLink(\"Go to Details\") {\n                    DetailView()\n                }\n                .padding()\n            }\n            .onAppear {\n                print(\"ðŸ  Home tab became active\")\n            }\n            .onDisappear {\n                print(\"ðŸ“´ Home tab became inactive\")\n            }\n        }\n    }\n}\n\nstruct DetailView: View {\n    @State private var data = \"\"\n    \n    var body: some View {\n        VStack {\n            TextField(\"Enter data\", text: $data)\n                .textFieldStyle(.roundedBorder)\n                .padding()\n            \n            Text(\"You entered: \\(data)\")\n        }\n        .navigationTitle(\"Detail\")\n        .onAppear {\n            print(\"ðŸ“– Detail view appeared\")\n            // Simulate loading data\n            data = \"Initial data\"\n        }\n        .onDisappear {\n            print(\"ðŸ“• Detail view disappeared\")\n            // Auto-save when leaving\n            UserDefaults.standard.set(data, forKey: \"detailData\")\n        }\n    }\n}\n\nstruct ProfileView: View {\n    var body: some View {\n        Text(\"Profile Screen\")\n            .onAppear { print(\"ðŸ‘¤ Profile tab became active\") }\n            .onDisappear { print(\"ðŸ“µ Profile tab became inactive\") }\n    }\n}\n\nstruct SettingsView: View {\n    var body: some View {\n        Text(\"Settings Screen\")\n            .onAppear { print(\"âš™ï¸ Settings tab became active\") }\n            .onDisappear { print(\"ðŸ“´ Settings tab became inactive\") }\n    }\n}\n\n// Conditional view lifecycle\nstruct FeatureToggleView: View {\n    @State private var showAdvancedFeatures = false\n    \n    var body: some View {\n        VStack(spacing: 30) {\n            Toggle(\"Show Advanced Features\", isOn: $showAdvancedFeatures)\n                .padding()\n            \n            if showAdvancedFeatures {\n                AdvancedFeaturesPanel()\n                    .transition(.opacity)\n            }\n            \n            Spacer()\n        }\n        .padding()\n    }\n}\n\nstruct AdvancedFeaturesPanel: View {\n    @State private var analyticsData: [String] = []\n    \n    var body: some View {\n        VStack {\n            Text(\"Advanced Features\")\n                .font(.title2)\n            \n            List(analyticsData, id: \\.self) { item in\n                Text(item)\n            }\n        }\n        .padding()\n        .background(Color.blue.opacity(0.1))\n        .cornerRadius(10)\n        .onAppear {\n            print(\"ðŸ”§ Advanced features panel appeared\")\n            startAnalyticsCollection()\n        }\n        .onDisappear {\n            print(\"ðŸ›‘ Advanced features panel disappeared\")\n            stopAnalyticsCollection()\n        }\n    }\n    \n    private func startAnalyticsCollection() {\n        print(\"ðŸ“Š Starting analytics collection...\")\n        // Simulate collecting data\n        analyticsData = [\"Event 1\", \"Event 2\", \"Event 3\"]\n    }\n    \n    private func stopAnalyticsCollection() {\n        print(\"ðŸ“ˆ Stopping analytics collection\")\n        analyticsData.removeAll()\n    }\n}",
      "category": "SwiftUI Basics",
      "estimatedTime": 180,
      "dependencies": ["swiftui_intro", "state_management"],
      "challenge": {
        "instructions": "Create a complete news reading app that demonstrates view lifecycle management:\n\nPART 1: Article List with Lifecycle (45 min)\n1. Create an 'ArticleListView' that loads news articles in onAppear\n2. Implement pull-to-refresh that reloads articles\n3. Add loading states and error handling\n4. Use onDisappear to cancel any ongoing network requests\n\nPART 2: Article Detail Management (45 min)\n5. Create an 'ArticleDetailView' that tracks reading progress\n6. Start a reading timer when article appears, stop when it disappears\n7. Auto-save reading progress when leaving the article\n8. Load saved progress when returning to the article\n\nPART 3: Tab-Based Navigation (45 min)\n9. Create a tab view with: Home, Bookmarks, Settings\n10. Each tab should properly manage its resources\n11. Implement bookmark functionality that persists data\n12. Add analytics tracking for tab changes\n\nPART 4: Advanced Lifecycle Scenarios (45 min)\n13. Create a 'VideoPlayerView' that manages video resources\n14. Implement picture-in-picture lifecycle handling\n15. Add background task management\n16. Create a 'NetworkMonitor' that starts/stops with app lifecycle\n\nTest your implementation by navigating between views and observing console logs!",
        "starterCode": "// === PART 1: Article List ===\n// Create your ArticleListView with lifecycle management here\n\n\n// === PART 2: Article Detail ===\n// Create ArticleDetailView with reading progress tracking\n\n\n// === PART 3: Tab Navigation ===\n// Implement tab-based app with proper resource management\n\n\n// === PART 4: Advanced Scenarios ===\n// Add video player and network monitoring\n\n",
        "solution": "// === PART 1: Article List ===\nstruct ArticleListView: View {\n    @State private var articles: [Article] = []\n    @State private var isLoading = false\n    @State private var error: String?\n    @State private var dataTask: URLSessionDataTask?\n    \n    var body: some View {\n        NavigationView {\n            Group {\n                if isLoading && articles.isEmpty {\n                    ProgressView(\"Loading articles...\")\n                } else if let error = error {\n                    VStack {\n                        Text(\"Error: \\(error)\")\n                            .foregroundColor(.red)\n                        Button(\"Retry\") {\n                            loadArticles()\n                        }\n                    }\n                } else {\n                    List(articles) { article in\n                        NavigationLink(destination: ArticleDetailView(article: article)) {\n                            VStack(alignment: .leading) {\n                                Text(article.title)\n                                    .font(.headline)\n                                Text(article.summary)\n                                    .font(.caption)\n                                    .foregroundColor(.gray)\n                            }\n                        }\n                    }\n                    .refreshable {\n                        await refreshArticles()\n                    }\n                }\n            }\n            .navigationTitle(\"News\")\n        }\n        .onAppear {\n            print(\"ðŸ“° Article list appeared\")\n            if articles.isEmpty {\n                loadArticles()\n            }\n        }\n        .onDisappear {\n            print(\"ðŸ“­ Article list disappeared\")\n            // Cancel any ongoing network requests\n            dataTask?.cancel()\n        }\n    }\n    \n    private func loadArticles() {\n        isLoading = true\n        error = nil\n        \n        // Simulate network request\n        dataTask = URLSession.shared.dataTask(with: URL(string: \"https://api.example.com/articles\")!) { _, _, _ in\n            DispatchQueue.main.asyncAfter(deadline: .now() + 1) {\n                isLoading = false\n                articles = [\n                    Article(id: 1, title: \"SwiftUI Tips\", summary: \"Learn advanced SwiftUI techniques\"),\n                    Article(id: 2, title: \"View Lifecycle\", summary: \"Master onAppear and onDisappear\"),\n                    Article(id: 3, title: \"State Management\", summary: \"Understanding @State and @Binding\")\n                ]\n                print(\"âœ… Articles loaded: \\(articles.count)\")\n            }\n        }\n        dataTask?.resume()\n    }\n    \n    private func refreshArticles() async {\n        print(\"ðŸ”„ Refreshing articles...\")\n        try? await Task.sleep(nanoseconds: 2_000_000_000) // Simulate network\n        await MainActor.run {\n            articles.shuffle() // Simulate new content\n            print(\"âœ… Articles refreshed\")\n        }\n    }\n}\n\n// === PART 2: Article Detail ===\nstruct ArticleDetailView: View {\n    let article: Article\n    @State private var readingProgress: Double = 0.0\n    @State private var readingTimer: Timer?\n    @State private var timeSpent: Int = 0\n    @Environment(\\.dismiss) private var dismiss\n    \n    var body: some View {\n        ScrollView {\n            VStack(alignment: .leading, spacing: 16) {\n                Text(article.title)\n                    .font(.title)\n                \n                Text(article.content)\n                    .font(.body)\n                \n                // Reading progress indicator\n                VStack {\n                    Text(\"Reading Progress: \\(Int(readingProgress * 100))%\")\n                    ProgressView(value: readingProgress)\n                        .progressViewStyle(.linear)\n                    Text(\"Time spent: \\(timeSpent) seconds\")\n                }\n                .padding()\n                .background(Color.gray.opacity(0.1))\n                .cornerRadius(8)\n            }\n            .padding()\n        }\n        .navigationTitle(article.title)\n        .navigationBarTitleDisplayMode(.inline)\n        .onAppear {\n            print(\"ðŸ“– Article detail appeared: \\(article.title)\")\n            startReadingSession()\n            loadReadingProgress()\n        }\n        .onDisappear {\n            print(\"ðŸ“• Article detail disappeared: \\(article.title)\")\n            endReadingSession()\n            saveReadingProgress()\n        }\n    }\n    \n    private func startReadingSession() {\n        // Start tracking reading time\n        readingTimer = Timer.scheduledTimer(withTimeInterval: 1, repeats: true) { _ in\n            timeSpent += 1\n            // Simulate progress based on time (in real app, track scroll position)\n            readingProgress = min(readingProgress + 0.01, 1.0)\n        }\n        print(\"â±ï¸ Started reading session\")\n    }\n    \n    private func endReadingSession() {\n        readingTimer?.invalidate()\n        readingTimer = nil\n        print(\"ðŸ›‘ Ended reading session. Total time: \\(timeSpent)s\")\n    }\n    \n    private func loadReadingProgress() {\n        let savedProgress = UserDefaults.standard.double(forKey: \"progress_\\(article.id)\")\n        let savedTime = UserDefaults.standard.integer(forKey: \"time_\\(article.id)\")\n        \n        if savedProgress > 0 {\n            readingProgress = savedProgress\n            timeSpent = savedTime\n            print(\"ðŸ“Š Loaded saved progress: \\(Int(savedProgress * 100))%\")\n        }\n    }\n    \n    private func saveReadingProgress() {\n        UserDefaults.standard.set(readingProgress, forKey: \"progress_\\(article.id)\")\n        UserDefaults.standard.set(timeSpent, forKey: \"time_\\(article.id)\")\n        print(\"ðŸ’¾ Saved progress: \\(Int(readingProgress * 100))%\")\n    }\n}\n\n// === PART 3: Tab Navigation ===\nstruct NewsApp: View {\n    @State private var selectedTab = 0\n    @State private var bookmarks: [Article] = []\n    \n    var body: some View {\n        TabView(selection: $selectedTab) {\n            ArticleListView()\n                .tabItem {\n                    Image(systemName: \"house\")\n                    Text(\"Home\")\n                }\n                .tag(0)\n                .onAppear { trackAnalytics(\"home_tab\") }\n            \n            BookmarksView(bookmarks: $bookmarks)\n                .tabItem {\n                    Image(systemName: \"bookmark\")\n                    Text(\"Bookmarks\")\n                }\n                .tag(1)\n                .onAppear { trackAnalytics(\"bookmarks_tab\") }\n            \n            SettingsView()\n                .tabItem {\n                    Image(systemName: \"gear\")\n                    Text(\"Settings\")\n                }\n                .tag(2)\n                .onAppear { trackAnalytics(\"settings_tab\") }\n        }\n        .onAppear {\n            print(\"ðŸš€ News app launched\")\n            loadBookmarks()\n        }\n        .onDisappear {\n            print(\"ðŸ”Œ News app backgrounded\")\n            saveBookmarks()\n        }\n    }\n    \n    private func trackAnalytics(_ event: String) {\n        print(\"ðŸ“ˆ Analytics: \\(event)\")\n        // In real app, send to analytics service\n    }\n    \n    private func loadBookmarks() {\n        if let data = UserDefaults.standard.data(forKey: \"bookmarks\"),\n           let saved = try? JSONDecoder().decode([Article].self, from: data) {\n            bookmarks = saved\n            print(\"ðŸ“– Loaded \\(bookmarks.count) bookmarks\")\n        }\n    }\n    \n    private func saveBookmarks() {\n        if let data = try? JSONEncoder().encode(bookmarks) {\n            UserDefaults.standard.set(data, forKey: \"bookmarks\")\n            print(\"ðŸ’¾ Saved \\(bookmarks.count) bookmarks\")\n        }\n    }\n}\n\nstruct BookmarksView: View {\n    @Binding var bookmarks: [Article]\n    \n    var body: some View {\n        NavigationView {\n            if bookmarks.isEmpty {\n                Text(\"No bookmarks yet\")\n                    .foregroundColor(.gray)\n            } else {\n                List(bookmarks) { article in\n                    NavigationLink(destination: ArticleDetailView(article: article)) {\n                        Text(article.title)\n                    }\n                }\n            }\n        }\n        .onAppear {\n            print(\"ðŸ”– Bookmarks view appeared\")\n        }\n        .onDisappear {\n            print(\"ðŸ“´ Bookmarks view disappeared\")\n        }\n    }\n}\n\n// === PART 4: Advanced Scenarios ===\nclass NetworkMonitor: ObservableObject {\n    @Published var isConnected = true\n    private var monitorTimer: Timer?\n    \n    func startMonitoring() {\n        print(\"ðŸŒ Starting network monitoring\")\n        // Simulate network monitoring\n        monitorTimer = Timer.scheduledTimer(withTimeInterval: 5, repeats: true) { _ in\n            self.checkConnection()\n        }\n    }\n    \n    func stopMonitoring() {\n        print(\"ðŸ›‘ Stopping network monitoring\")\n        monitorTimer?.invalidate()\n        monitorTimer = nil\n    }\n    \n    private func checkConnection() {\n        // Simulate connection check\n        isConnected = Bool.random()\n        print(\"ðŸ“¡ Network status: \\(isConnected ? \"Connected\" : \"Disconnected\")\")\n    }\n    \n    deinit {\n        stopMonitoring()\n        print(\"ðŸ§¹ NetworkMonitor deinitialized\")\n    }\n}\n\nstruct NetworkAwareView: View {\n    @StateObject private var monitor = NetworkMonitor()\n    \n    var body: some View {\n        VStack {\n            if monitor.isConnected {\n                Text(\"Online\")\n                    .foregroundColor(.green)\n            } else {\n                Text(\"Offline\")\n                    .foregroundColor(.red)\n            }\n        }\n        .onAppear {\n            monitor.startMonitoring()\n        }\n        .onDisappear {\n            monitor.stopMonitoring()\n        }\n    }\n}\n\n// Supporting models\nstruct Article: Identifiable, Codable {\n    let id: Int\n    let title: String\n    let summary: String\n    let content: String = \"This is the full article content. \" + String(repeating: \"SwiftUI is amazing! \", count: 50)\n}\n\nstruct SettingsView: View {\n    var body: some View {\n        Text(\"Settings\")\n            .onAppear { print(\"âš™ï¸ Settings view appeared\") }\n            .onDisappear { print(\"ðŸ“´ Settings view disappeared\") }\n    }\n}",
        "hints": [
          "PART 1: Use URLSessionDataTask for network requests and cancel it in onDisappear to prevent memory leaks",
          "PART 2: Track reading progress with a Timer and always invalidate it in onDisappear",
          "PART 3: Use UserDefaults to persist bookmarks and load them in onAppear",
          "PART 4: Create ObservableObject classes for shared resources and manage their lifecycle with the view",
          "Remember: onAppear can be called multiple times (when navigating back to a view)",
          "Use @Environment(\\.dismiss) to programmatically navigate back",
          "For async operations in onAppear, consider using Task for modern concurrency",
          "Always test your lifecycle management by backgrounding the app and navigating complex flows"
        ],
        "testCases": [
          {
            "input": "Navigate to ArticleDetailView and back",
            "expectedOutput": "Console shows proper appear/disappear logs",
            "description": "View lifecycle should trigger appropriate events"
          },
          {
            "input": "Background app while in ArticleDetailView",
            "expectedOutput": "Reading timer stops and progress saves",
            "description": "Resources should be managed when app backgrounds"
          },
          {
            "input": "Switch between tabs multiple times",
            "expectedOutput": "Analytics track tab changes without resource leaks",
            "description": "Tab navigation should properly manage state"
          }
        ]
      }
    },
    {
      "id": "modifiers_styling",
      "title": "Modifiers & Styling",
      "description": "Master view customization with custom modifiers and view composition - create reusable, consistent UI components",
      "difficulty": "beginner",
      "theory": "# Modifiers & Styling - Custom View Design\n\n## 1. Understanding Modifiers (60 min)\n\n### What are Modifiers?\n- Methods that **wrap and transform** views\n- Return **new views** with applied changes\n- Can be **chained** together\n- Enable **consistent styling** across your app\n\n### Basic Modifier Examples:\n```swift\nText(\"Hello SwiftUI\")\n    .font(.title)           // Font modifier\n    .foregroundColor(.blue) // Color modifier\n    .padding()              // Layout modifier\n    .background(Color.yellow) // Background modifier\n```\n\n### Modifier Order Matters:\n```swift\n// Different order = different results\nText(\"Example\")\n    .padding()\n    .background(Color.red)  // Background includes padding\n\nText(\"Example\")\n    .background(Color.red)  // Background only on text\n    .padding()\n```\n\n### Common Built-in Modifiers:\n- **Layout**: `.padding()`, `.frame()`, `.position()`\n- **Text**: `.font()`, `.foregroundColor()`, `.lineLimit()`\n- **Visual**: `.background()`, `.cornerRadius()`, `.shadow()`\n- **Interaction**: `.onTapGesture()`, `.gesture()`\n\n## 2. View Composition Patterns (60 min)\n\n### Extracting Subviews:\n```swift\n// BEFORE: Everything in one view\nstruct ContentView: View {\n    var body: some View {\n        VStack {\n            Text(\"Welcome\")\n                .font(.largeTitle)\n                .foregroundColor(.blue)\n            \n            Text(\"Subtitle\")\n                .font(.subheadline)\n                .foregroundColor(.gray)\n        }\n    }\n}\n\n// AFTER: Extracted subview\nstruct HeaderView: View {\n    let title: String\n    let subtitle: String\n    \n    var body: some View {\n        VStack {\n            Text(title)\n                .font(.largeTitle)\n                .foregroundColor(.blue)\n            \n            Text(subtitle)\n                .font(.subheadline)\n                .foregroundColor(.gray)\n        }\n    }\n}\n\nstruct ContentView: View {\n    var body: some View {\n        HeaderView(title: \"Welcome\", subtitle: \"Subtitle\")\n    }\n}\n```\n\n### ViewBuilder for Complex Composition:\n```swift\nstruct CardView<Content: View>: View {\n    let content: Content\n    \n    init(@ViewBuilder content: () -> Content) {\n        self.content = content()\n    }\n    \n    var body: some View {\n        content\n            .padding()\n            .background(Color.white)\n            .cornerRadius(10)\n            .shadow(radius: 5)\n    }\n}\n\n// Usage\nCardView {\n    VStack {\n        Text(\"Title\")\n        Text(\"Description\")\n        Button(\"Action\") { }\n    }\n}\n```\n\n## 3. Creating Custom Modifiers (90 min)\n\n### Basic Custom Modifier:\n```swift\nstruct PrimaryButtonStyle: ViewModifier {\n    func body(content: Content) -> some View {\n        content\n            .foregroundColor(.white)\n            .padding()\n            .background(Color.blue)\n            .cornerRadius(8)\n    }\n}\n\n// Extension for easier usage\nextension View {\n    func primaryButtonStyle() -> some View {\n        self.modifier(PrimaryButtonStyle())\n    }\n}\n\n// Usage\nButton(\"Tap Me\") { }\n    .primaryButtonStyle()\n```\n\n### Parameterized Custom Modifiers:\n```swift\nstruct BorderedModifier: ViewModifier {\n    let color: Color\n    let lineWidth: CGFloat\n    \n    func body(content: Content) -> some View {\n        content\n            .padding(4)\n            .overlay(\n                RoundedRectangle(cornerRadius: 8)\n                    .stroke(color, lineWidth: lineWidth)\n            )\n    }\n}\n\nextension View {\n    func bordered(color: Color = .blue, lineWidth: CGFloat = 1) -> some View {\n        self.modifier(BorderedModifier(color: color, lineWidth: lineWidth))\n    }\n}\n\n// Usage\nText(\"Bordered Text\")\n    .bordered(color: .red, lineWidth: 2)\n```\n\n### Conditional Modifiers:\n```swift\nstruct ConditionalBackground: ViewModifier {\n    let condition: Bool\n    \n    func body(content: Content) -> some View {\n        if condition {\n            content\n                .background(Color.yellow)\n        } else {\n            content\n        }\n    }\n}\n\nextension View {\n    func conditionalBackground(_ condition: Bool) -> some View {\n        self.modifier(ConditionalBackground(condition: condition))\n    }\n}\n```\n\n## 4. Advanced Styling Techniques (60 min)\n\n### Gradient Backgrounds:\n```swift\nstruct GradientBackground: ViewModifier {\n    let colors: [Color]\n    \n    func body(content: Content) -> some View {\n        content\n            .background(\n                LinearGradient(\n                    gradient: Gradient(colors: colors),\n                    startPoint: .topLeading,\n                    endPoint: .bottomTrailing\n                )\n            )\n    }\n}\n```\n\n### Animated Modifiers:\n```swift\nstruct PulseAnimation: ViewModifier {\n    @State private var isPulsing = false\n    \n    func body(content: Content) -> some View {\n        content\n            .scaleEffect(isPulsing ? 1.1 : 1.0)\n            .animation(\n                Animation.easeInOut(duration: 1.0).repeatForever(autoreverses: true),\n                value: isPulsing\n            )\n            .onAppear {\n                isPulsing = true\n            }\n    }\n}\n```\n\n### Shadow and Depth Effects:\n```swift\nstruct DepthShadow: ViewModifier {\n    let intensity: CGFloat\n    \n    func body(content: Content) -> some View {\n        content\n            .shadow(\n                color: .black.opacity(0.2 * Double(intensity)),\n                radius: 5 * intensity,\n                x: 0,\n                y: 2 * intensity\n            )\n    }\n}\n```\n\n## 5. Building Design Systems (60 min)\n\n### Color Theme System:\n```swift\nstruct AppColors {\n    static let primary = Color.blue\n    static let secondary = Color.orange\n    static let background = Color(.systemBackground)\n    static let textPrimary = Color.primary\n    static let textSecondary = Color.secondary\n}\n\nstruct Theme {\n    static let cornerRadius: CGFloat = 8\n    static let padding: CGFloat = 16\n    static let shadowRadius: CGFloat = 4\n}\n```\n\n### Typography System:\n```swift\nstruct AppFonts {\n    static let largeTitle = Font.largeTitle.weight(.bold)\n    static let title = Font.title2.weight(.semibold)\n    static let body = Font.body\n    static let caption = Font.caption\n}\n\n// Usage\nText(\"Heading\")\n    .font(AppFonts.title)\n    .foregroundColor(AppColors.textPrimary)\n```\n\n### Complete Component Library:\n```swift\nstruct PrimaryButton: View {\n    let title: String\n    let action: () -> Void\n    \n    var body: some View {\n        Button(title, action: action)\n            .primaryButtonStyle()\n    }\n}\n\nstruct Card<Content: View>: View {\n    let content: Content\n    \n    init(@ViewBuilder content: () -> Content) {\n        self.content = content()\n    }\n    \n    var body: some View {\n        content\n            .padding(Theme.padding)\n            .background(AppColors.background)\n            .cornerRadius(Theme.cornerRadius)\n            .shadow(radius: Theme.shadowRadius)\n    }\n}\n```\n\n## 6. Performance & Best Practices (30 min)\n\n### Efficient View Updates:\n- Use `.equatable()` for expensive views\n- Extract complex calculations from body\n- Leverage `@ViewBuilder` for conditional content\n\n### Modifier Performance Tips:\n- Chain modifiers logically\n- Avoid unnecessary view recreations\n- Use `@ViewBuilder` for complex conditional views\n\n### Testing Custom Modifiers:\n```swift\nimport XCTest\n@testable import YourApp\n\nclass ModifierTests: XCTestCase {\n    func testPrimaryButtonStyle() {\n        let button = Button(\"Test\") { }\n            .primaryButtonStyle()\n        \n        // Test that modifier is applied correctly\n        // (In practice, you'd use snapshot testing or view inspection)\n    }\n}\n```\n\n## Practice Exercises\n\nComplete all exercises to master view styling and composition!",
      "codeExample": "// === BASIC MODIFIER EXAMPLES ===\n\nimport SwiftUI\n\n// Simple modifier chain\nstruct BasicModifiers: View {\n    var body: some View {\n        Text(\"Hello, SwiftUI!\")\n            .font(.largeTitle)\n            .foregroundColor(.white)\n            .padding()\n            .background(Color.blue)\n            .cornerRadius(10)\n            .shadow(radius: 5)\n    }\n}\n\n// Frame and alignment modifiers\nstruct FrameModifiers: View {\n    var body: some View {\n        Text(\"Centered Text\")\n            .frame(maxWidth: .infinity, maxHeight: .infinity)\n            .background(Color.yellow)\n            .padding()\n    }\n}\n\n// === CUSTOM MODIFIER EXAMPLES ===\n\n// Simple custom modifier\nstruct CardModifier: ViewModifier {\n    func body(content: Content) -> some View {\n        content\n            .padding(20)\n            .background(Color.white)\n            .cornerRadius(15)\n            .shadow(\n                color: Color.black.opacity(0.2),\n                radius: 10,\n                x: 0,\n                y: 5\n            )\n    }\n}\n\nextension View {\n    func cardStyle() -> some View {\n        self.modifier(CardModifier())\n    }\n}\n\n// Parameterized custom modifier\nstruct BorderedCaption: ViewModifier {\n    var color: Color = .gray\n    \n    func body(content: Content) -> some View {\n        content\n            .font(.caption)\n            .padding(4)\n            .foregroundColor(color)\n            .overlay(\n                RoundedRectangle(cornerRadius: 4)\n                    .stroke(color, lineWidth: 1)\n            )\n    }\n}\n\nextension View {\n    func borderedCaption(color: Color = .gray) -> some View {\n        self.modifier(BorderedCaption(color: color))\n    }\n}\n\n// === VIEW COMPOSITION EXAMPLES ===\n\n// Reusable header view\nstruct AppHeader: View {\n    let title: String\n    let subtitle: String?\n    \n    var body: some View {\n        VStack(alignment: .leading, spacing: 8) {\n            Text(title)\n                .font(.title2)\n                .fontWeight(.bold)\n                .foregroundColor(.primary)\n            \n            if let subtitle = subtitle {\n                Text(subtitle)\n                    .font(.subheadline)\n                    .foregroundColor(.secondary)\n            }\n        }\n        .frame(maxWidth: .infinity, alignment: .leading)\n    }\n}\n\n// Configurable button component\nstruct PrimaryButton: View {\n    let title: String\n    let icon: String?\n    let action: () -> Void\n    var isDisabled: Bool = false\n    \n    var body: some View {\n        Button(action: action) {\n            HStack {\n                if let icon = icon {\n                    Image(systemName: icon)\n                }\n                Text(title)\n            }\n            .frame(maxWidth: .infinity)\n            .padding()\n            .foregroundColor(.white)\n            .background(isDisabled ? Color.gray : Color.blue)\n            .cornerRadius(8)\n        }\n        .disabled(isDisabled)\n    }\n}\n\n// === COMPLEX COMPOSITION EXAMPLE ===\n\nstruct ProfileCard: View {\n    let user: String\n    let bio: String\n    let isOnline: Bool\n    \n    var body: some View {\n        VStack(alignment: .leading, spacing: 12) {\n            // Header with status\n            HStack {\n                Circle()\n                    .fill(isOnline ? Color.green : Color.gray)\n                    .frame(width: 12, height: 12)\n                \n                Text(user)\n                    .font(.headline)\n                \n                Spacer()\n                \n                Text(isOnline ? \"Online\" : \"Offline\")\n                    .borderedCaption(color: isOnline ? .green : .gray)\n            }\n            \n            // Bio text\n            Text(bio)\n                .font(.body)\n                .foregroundColor(.secondary)\n                .lineLimit(3)\n            \n            // Action buttons\n            HStack {\n                PrimaryButton(title: \"Message\", icon: \"message\", action: {})\n                PrimaryButton(title: \"Follow\", icon: \"person.badge.plus\", action: {})\n            }\n        }\n        .cardStyle()\n    }\n}\n\n// === MAIN CONTENT VIEW ===\n\nstruct ContentView: View {\n    var body: some View {\n        ScrollView {\n            VStack(spacing: 20) {\n                // App header\n                AppHeader(title: \"User Profiles\", subtitle: \"Manage your connections\")\n                \n                // Profile cards\n                ProfileCard(\n                    user: \"John Appleseed\",\n                    bio: \"iOS developer passionate about SwiftUI and clean code. Love hiking and photography.\",\n                    isOnline: true\n                )\n                \n                ProfileCard(\n                    user: \"Sarah Wilson\", \n                    bio: \"UX designer with 5+ years experience. Creating beautiful and accessible interfaces.\",\n                    isOnline: false\n                )\n                \n                // Demo of individual modifiers\n                VStack(spacing: 10) {\n                    Text(\"Modifier Demo\")\n                        .borderedCaption(color: .blue)\n                    \n                    Text(\"Card Style Demo\")\n                        .padding()\n                        .cardStyle()\n                }\n            }\n            .padding()\n        }\n    }\n}\n\n// === PREVIEW ===\n\nstruct ContentView_Previews: PreviewProvider {\n    static var previews: some View {\n        ContentView()\n    }\n}",
      "category": "SwiftUI Basics",
      "estimatedTime": 300,
      "dependencies": ["swiftui_intro", "views_layout"],
      "challenge": {
        "instructions": "Create a complete design system with custom modifiers and reusable components:\n\nPART 1: Basic Custom Modifiers (60 min)\n1. Create a 'PillBadge' modifier for rounded capsule-style badges\n2. Create a 'GradientBackground' modifier that accepts color arrays\n3. Create a 'BorderGlow' modifier for attention-grabbing effects\n4. Create a 'TextOutline' modifier that adds stroke to text\n\nPART 2: View Composition & Reusable Components (90 min)\n5. Build a 'StatsCard' component showing numbers with labels\n6. Create a 'UserAvatar' component with different sizes and status indicators\n7. Build a 'SettingsRow' component for settings screens\n8. Create a 'LoadingButton' that shows activity during async operations\n\nPART 3: Advanced Modifier System (90 min)\n9. Create a 'Theme' system with colors, fonts, and spacing constants\n10. Build modifier variants (primary, secondary, danger styles)\n11. Create conditional modifiers that change based on state\n12. Implement animated modifiers with spring and ease animations\n\nPART 4: Complete UI Screen (60 min)\n13. Combine all components into a 'ProfileScreen'\n14. Create a 'SettingsScreen' using your design system\n15. Ensure consistency across all components\n16. Add dark mode support to your theme system\n\nTest your design system by creating multiple screens with consistent styling!",
        "starterCode": "// === PART 1: Basic Custom Modifiers ===\n// Create your custom modifiers here\n\n\n// === PART 2: View Composition ===\n// Build reusable components here\n\n\n// === PART 3: Advanced Modifier System ===\n// Create theme system and variant modifiers here\n\n\n// === PART 4: Complete UI Screens ===\n// Build ProfileScreen and SettingsScreen here\n\n",
        "solution": "// === PART 1: Basic Custom Modifiers ===\n\nimport SwiftUI\n\n// 1. PillBadge modifier\nstruct PillBadge: ViewModifier {\n    var backgroundColor: Color = .blue\n    var textColor: Color = .white\n    \n    func body(content: Content) -> some View {\n        content\n            .font(.caption)\n            .fontWeight(.semibold)\n            .foregroundColor(textColor)\n            .padding(.horizontal, 12)\n            .padding(.vertical, 6)\n            .background(backgroundColor)\n            .clipShape(Capsule())\n    }\n}\n\nextension View {\n    func pillBadge(backgroundColor: Color = .blue, textColor: Color = .white) -> some View {\n        self.modifier(PillBadge(backgroundColor: backgroundColor, textColor: textColor))\n    }\n}\n\n// 2. GradientBackground modifier\nstruct GradientBackgroundModifier: ViewModifier {\n    let colors: [Color]\n    let startPoint: UnitPoint\n    let endPoint: UnitPoint\n    \n    func body(content: Content) -> some View {\n        content\n            .background(\n                LinearGradient(\n                    gradient: Gradient(colors: colors),\n                    startPoint: startPoint,\n                    endPoint: endPoint\n                )\n            )\n    }\n}\n\nextension View {\n    func gradientBackground(colors: [Color], startPoint: UnitPoint = .topLeading, endPoint: UnitPoint = .bottomTrailing) -> some View {\n        self.modifier(GradientBackgroundModifier(colors: colors, startPoint: startPoint, endPoint: endPoint))\n    }\n}\n\n// 3. BorderGlow modifier\nstruct BorderGlow: ViewModifier {\n    var color: Color = .blue\n    var radius: CGFloat = 10\n    \n    func body(content: Content) -> some View {\n        content\n            .overlay(\n                RoundedRectangle(cornerRadius: 8)\n                    .stroke(color, lineWidth: 1)\n                    .shadow(color: color, radius: radius)\n                    .shadow(color: color, radius: radius)\n            )\n    }\n}\n\nextension View {\n    func borderGlow(color: Color = .blue, radius: CGFloat = 10) -> some View {\n        self.modifier(BorderGlow(color: color, radius: radius))\n    }\n}\n\n// 4. TextOutline modifier\nstruct TextOutline: ViewModifier {\n    var outlineColor: Color = .black\n    var outlineWidth: CGFloat = 2\n    \n    func body(content: Content) -> some View {\n        content\n            .shadow(color: outlineColor, radius: 0)\n            .shadow(color: outlineColor, radius: 0)\n            .shadow(color: outlineColor, radius: 0)\n            .shadow(color: outlineColor, radius: 0)\n    }\n}\n\nextension View {\n    func textOutline(color: Color = .black, width: CGFloat = 2) -> some View {\n        self.modifier(TextOutline(outlineColor: color, outlineWidth: width))\n    }\n}\n\n// === PART 2: View Composition ===\n\n// 5. StatsCard component\nstruct StatsCard: View {\n    let value: String\n    let label: String\n    let icon: String\n    let color: Color\n    \n    var body: some View {\n        VStack(spacing: 8) {\n            Image(systemName: icon)\n                .font(.title2)\n                .foregroundColor(color)\n            \n            Text(value)\n                .font(.title2)\n                .fontWeight(.bold)\n                .foregroundColor(.primary)\n            \n            Text(label)\n                .font(.caption)\n                .foregroundColor(.secondary)\n        }\n        .frame(maxWidth: .infinity)\n        .padding()\n        .background(Color(.systemBackground))\n        .cornerRadius(12)\n        .shadow(color: .black.opacity(0.1), radius: 5)\n    }\n}\n\n// 6. UserAvatar component\nstruct UserAvatar: View {\n    let name: String\n    let size: CGFloat\n    var isOnline: Bool = false\n    \n    private var initials: String {\n        name.split(separator: \" \")\n            .prefix(2)\n            .map { String($0.prefix(1)) }\n            .joined()\n    }\n    \n    var body: some View {\n        ZStack(alignment: .bottomTrailing) {\n            // Avatar circle\n            Circle()\n                .fill(Color.blue.gradient)\n                .frame(width: size, height: size)\n                .overlay(\n                    Text(initials)\n                        .font(.system(size: size * 0.4, weight: .bold))\n                        .foregroundColor(.white)\n                )\n            \n            // Online indicator\n            if isOnline {\n                Circle()\n                    .fill(Color.green)\n                    .frame(width: size * 0.25, height: size * 0.25)\n                    .overlay(\n                        Circle()\n                            .stroke(Color(.systemBackground), lineWidth: 2)\n                    )\n            }\n        }\n    }\n}\n\n// 7. SettingsRow component\nstruct SettingsRow: View {\n    let icon: String\n    let title: String\n    let subtitle: String?\n    let action: () -> Void\n    \n    var body: some View {\n        Button(action: action) {\n            HStack {\n                // Icon\n                Image(systemName: icon)\n                    .font(.body)\n                    .foregroundColor(.blue)\n                    .frame(width: 32)\n                \n                // Text content\n                VStack(alignment: .leading, spacing: 2) {\n                    Text(title)\n                        .font(.body)\n                        .foregroundColor(.primary)\n                    \n                    if let subtitle = subtitle {\n                        Text(subtitle)\n                            .font(.caption)\n                            .foregroundColor(.secondary)\n                    }\n                }\n                \n                Spacer()\n                \n                // Chevron\n                Image(systemName: \"chevron.right\")\n                    .font(.caption)\n                    .foregroundColor(.secondary)\n            }\n            .padding(.vertical, 8)\n        }\n    }\n}\n\n// 8. LoadingButton\nstruct LoadingButton: View {\n    let title: String\n    let isLoading: Bool\n    let action: () -> Void\n    \n    var body: some View {\n        Button(action: action) {\n            HStack {\n                if isLoading {\n                    ProgressView()\n                        .scaleEffect(0.8)\n                        .tint(.white)\n                }\n                \n                Text(title)\n                    .opacity(isLoading ? 0.5 : 1.0)\n            }\n            .frame(maxWidth: .infinity)\n            .padding()\n            .background(Color.blue)\n            .foregroundColor(.white)\n            .cornerRadius(8)\n        }\n        .disabled(isLoading)\n    }\n}\n\n// === PART 3: Advanced Modifier System ===\n\n// 9. Theme system\nstruct AppTheme {\n    static let cornerRadius: CGFloat = 12\n    static let padding: CGFloat = 16\n    static let smallPadding: CGFloat = 8\n    \n    // Colors\n    static let primary = Color.blue\n    static let secondary = Color.orange\n    static let success = Color.green\n    static let danger = Color.red\n    static let warning = Color.yellow\n    \n    // Gradients\n    static let primaryGradient = [Color.blue, Color.purple]\n    static let successGradient = [Color.green, Color.blue]\n    \n    // Fonts\n    static let title = Font.title2.weight(.bold)\n    static let headline = Font.headline.weight(.semibold)\n    static let body = Font.body\n}\n\n// 10. Modifier variants\nstruct PrimaryButtonModifier: ViewModifier {\n    var isDisabled: Bool = false\n    \n    func body(content: Content) -> some View {\n        content\n            .font(.headline)\n            .foregroundColor(.white)\n            .frame(maxWidth: .infinity)\n            .padding()\n            .background(isDisabled ? Color.gray : AppTheme.primary)\n            .cornerRadius(AppTheme.cornerRadius)\n    }\n}\n\nstruct SecondaryButtonModifier: ViewModifier {\n    func body(content: Content) -> some View {\n        content\n            .font(.headline)\n            .foregroundColor(AppTheme.primary)\n            .frame(maxWidth: .infinity)\n            .padding()\n            .background(Color.clear)\n            .overlay(\n                RoundedRectangle(cornerRadius: AppTheme.cornerRadius)\n                    .stroke(AppTheme.primary, lineWidth: 2)\n            )\n    }\n}\n\nextension View {\n    func primaryButtonStyle(disabled: Bool = false) -> some View {\n        self.modifier(PrimaryButtonModifier(isDisabled: disabled))\n    }\n    \n    func secondaryButtonStyle() -> some View {\n        self.modifier(SecondaryButtonModifier())\n    }\n}\n\n// 11. Conditional modifier\nstruct ConditionalScale: ViewModifier {\n    let condition: Bool\n    \n    func body(content: Content) -> some View {\n        content\n            .scaleEffect(condition ? 1.05 : 1.0)\n            .animation(.spring(response: 0.3), value: condition)\n    }\n}\n\nextension View {\n    func conditionalScale(_ condition: Bool) -> some View {\n        self.modifier(ConditionalScale(condition: condition))\n    }\n}\n\n// 12. Animated modifier\nstruct BounceOnAppear: ViewModifier {\n    @State private var isVisible = false\n    \n    func body(content: Content) -> some View {\n        content\n            .scaleEffect(isVisible ? 1.0 : 0.5)\n            .opacity(isVisible ? 1.0 : 0.0)\n            .onAppear {\n                withAnimation(.spring(response: 0.6, dampingFraction: 0.6)) {\n                    isVisible = true\n                }\n            }\n    }\n}\n\nextension View {\n    func bounceOnAppear() -> some View {\n        self.modifier(BounceOnAppear())\n    }\n}\n\n// === PART 4: Complete UI Screens ===\n\n// 13. ProfileScreen\nstruct ProfileScreen: View {\n    @State private var isLoading = false\n    \n    var body: some View {\n        ScrollView {\n            VStack(spacing: AppTheme.padding) {\n                // Header\n                VStack(spacing: 16) {\n                    UserAvatar(name: \"John Appleseed\", size: 100, isOnline: true)\n                        .bounceOnAppear()\n                    \n                    Text(\"John Appleseed\")\n                        .font(AppTheme.title)\n                    \n                    Text(\"iOS Developer @ Apple\")\n                        .font(AppTheme.body)\n                        .foregroundColor(.secondary)\n                    \n                    HStack {\n                        Text(\"PRO\")\n                            .pillBadge(backgroundColor: .orange)\n                        \n                        Text(\"VERIFIED\")\n                            .pillBadge(backgroundColor: .green)\n                    }\n                }\n                .padding()\n                .gradientBackground(colors: AppTheme.primaryGradient)\n                .foregroundColor(.white)\n                \n                // Stats\n                LazyVGrid(columns: [\n                    GridItem(.flexible()),\n                    GridItem(.flexible()),\n                    GridItem(.flexible())\n                ], spacing: AppTheme.smallPadding) {\n                    StatsCard(value: \"1.2K\", label: \"Followers\", icon: \"person.2\", color: .blue)\n                    StatsCard(value: \"348\", label: \"Following\", icon: \"heart\", color: .red)\n                    StatsCard(value: \"127\", label: \"Posts\", icon: \"square.and.pencil\", color: .green)\n                }\n                .padding(.horizontal)\n                \n                // Actions\n                VStack(spacing: AppTheme.smallPadding) {\n                    LoadingButton(title: \"Follow\", isLoading: isLoading) {\n                        isLoading = true\n                        // Simulate async operation\n                        DispatchQueue.main.asyncAfter(deadline: .now() + 2) {\n                            isLoading = false\n                        }\n                    }\n                    .primaryButtonStyle(disabled: isLoading)\n                    \n                    Button(\"Message\") { }\n                        .secondaryButtonStyle()\n                }\n                .padding()\n                \n                Spacer()\n            }\n        }\n    }\n}\n\n// 14. SettingsScreen\nstruct SettingsScreen: View {\n    var body: some View {\n        NavigationView {\n            List {\n                Section {\n                    SettingsRow(icon: \"person\", title: \"Edit Profile\", subtitle: \"Update your personal information\") {}\n                    SettingsRow(icon: \"bell\", title: \"Notifications\", subtitle: \"Manage your notifications\") {}\n                    SettingsRow(icon: \"lock\", title: \"Privacy\", subtitle: \"Control your privacy settings\") {}\n                }\n                \n                Section {\n                    SettingsRow(icon: \"questionmark.circle\", title: \"Help & Support\", subtitle: nil) {}\n                    SettingsRow(icon: \"info.circle\", title: \"About\", subtitle: \"App version 1.0\") {}\n                }\n            }\n            .navigationTitle(\"Settings\")\n        }\n    }\n}\n\n// Main app view to demonstrate both screens\nstruct DesignSystemDemo: View {\n    var body: some View {\n        TabView {\n            ProfileScreen()\n                .tabItem {\n                    Image(systemName: \"person\")\n                    Text(\"Profile\")\n                }\n            \n            SettingsScreen()\n                .tabItem {\n                    Image(systemName: \"gearshape\")\n                    Text(\"Settings\")\n                }\n        }\n    }\n}",
        "hints": [
          "PART 1: Use ViewModifier protocol and create extensions on View for easy usage",
          "PART 2: Break down complex views into smaller, reusable components",
          "PART 3: Create a central Theme struct to maintain design consistency",
          "PART 4: Use your custom modifiers and components consistently across screens",
          "For gradients, experiment with different color combinations and direction points",
          "Use @State for animated modifiers that need to track internal state",
          "Consider accessibility when choosing colors and contrast ratios",
          "Test your components in both light and dark mode",
          "Use .clipShape() with Capsule() for perfect pill shapes",
          "For loading states, consider using ProgressView with .tint() modifier"
        ],
        "testCases": [
          {
            "input": "Text(\"Test\").pillBadge().background(Color.red)",
            "expectedOutput": "Pill-shaped badge with red background visible around edges",
            "description": "PillBadge should maintain capsule shape and allow background"
          },
          {
            "input": "UserAvatar(name: \"John Doe\", size: 60).isOnline",
            "expectedOutput": "Avatar with green online indicator",
            "description": "UserAvatar should show online status when specified"
          },
          {
            "input": "LoadingButton(title: \"Save\", isLoading: true).disabled",
            "expectedOutput": "Button should be disabled and show loading indicator",
            "description": "LoadingButton should disable interaction during loading"
          }
        ]
      }
    },
    {
      "id": "weather_app_project",
      "title": "Project: Weather App",
      "description": "Build a multi-screen weather application with mock data and beautiful UI",
      "difficulty": "beginner",
      "theory": "# Weather App Project - 10 Hour Comprehensive Guide\n\n## Project Overview (1 hour)\n\n### What You'll Build:\nA fully-featured weather application with:\n- **Home Screen**: Current weather with temperature, conditions, and details\n- **Forecast Screen**: 5-day weather forecast\n- **Location Search**: Find weather by city name\n- **Settings**: Temperature unit preferences\n- **Beautiful Animations**: Weather-condition appropriate visuals\n\n### Learning Objectives:\n- Master multi-screen navigation in SwiftUI\n- Implement complex data models\n- Create reusable UI components\n- Handle user preferences with UserDefaults\n- Build professional-looking animations\n\n## Architecture & Planning (1 hour)\n\n### App Structure:\n```\nWeatherApp/\nâ”œâ”€â”€ Models/\nâ”‚   â”œâ”€â”€ WeatherData.swift\nâ”‚   â”œâ”€â”€ Forecast.swift\nâ”‚   â””â”€â”€ Location.swift\nâ”œâ”€â”€ Views/\nâ”‚   â”œâ”€â”€ HomeView.swift\nâ”‚   â”œâ”€â”€ ForecastView.swift\nâ”‚   â”œâ”€â”€ SearchView.swift\nâ”‚   â”œâ”€â”€ SettingsView.swift\nâ”‚   â””â”€â”€ Components/\nâ”œâ”€â”€ ViewModels/\nâ”‚   â””â”€â”€ WeatherViewModel.swift\nâ””â”€â”€ Services/\n    â””â”€â”€ WeatherService.swift\n```\n\n### Data Flow:\n1. User opens app â†’ Load default location weather\n2. User searches city â†’ Fetch mock data for that location\n3. User changes settings â†’ Update display preferences\n4. App stores preferences â†’ Persist with UserDefaults\n\n## Step 1: Data Models (1.5 hours)\n\n### Core Data Structures:\nWe'll create comprehensive models to represent:\n- Current weather conditions\n- Multi-day forecasts\n- Location information\n- User preferences\n\n### Key Concepts:\n- **Codable Protocol**: For easy JSON parsing (simulated)\n- **Identifiable**: For SwiftUI lists\n- **Equatable**: For comparing weather data\n- **ObservableObject**: For data binding\n\n## Step 2: Building the Home Screen (2 hours)\n\n### Home Screen Components:\n- **Weather Card**: Large temperature display with conditions\n- **Detail Grid**: Humidity, wind, pressure, visibility\n- **Hourly Forecast**: Scrollable horizontal list\n- **Location Header**: Current city and last updated time\n- **Navigation Bar**: Links to other screens\n\n### UI Design Principles:\n- **Hierarchy**: Important information should be most prominent\n- **Consistency**: Use consistent spacing and typography\n- **Accessibility**: Support Dynamic Type and VoiceOver\n- **Dark/Light Mode**: Automatic theme adaptation\n\n## Step 3: Forecast Screen (1.5 hours)\n\n### 5-Day Forecast:\n- Daily high/low temperatures\n- Weather conditions with icons\n- Precipitation probability\n- Wind speed and direction\n- Sunrise/sunset times\n\n### List Implementation:\n- **LazyVStack**: For efficient scrolling\n- **Section Headers**: Group by day\n- **Custom Rows**: Weather information per day\n- **Smooth Animations**: Transition between days\n\n## Step 4: Search & Location (1.5 hours)\n\n### Search Functionality:\n- **Text Input**: City name search\n- **Mock Data**: Pre-defined city database\n- **Search Results**: Filtered list of matching cities\n- **Location Selection**: Tap to set current location\n\n### User Experience:\n- **Debounced Search**: Avoid excessive filtering\n- **Empty States**: Helpful messages when no results\n- **Recent Searches**: Persist user's search history\n- **Error Handling**: Invalid city names\n\n## Step 5: Settings & Preferences (1 hour)\n\n### User Configurable Options:\n- **Temperature Units**: Celsius vs Fahrenheit\n- **Theme Preferences**: Light/Dark/Auto\n- **Notification Settings**: Weather alerts\n- **Data Refresh**: Manual/Auto refresh intervals\n\n### Persistence:\n- **UserDefaults**: Simple key-value storage\n- **@AppStorage**: SwiftUI property wrapper\n- **Settings Bundle**: For system settings integration\n\n## Step 6: Animations & Polish (1.5 hours)\n\n### Weather Animations:\n- **Condition-based**: Different animations for sun, rain, clouds\n- **Smooth Transitions**: Between screen changes\n- **Loading States**: Skeleton screens and progress indicators\n- **Pull-to-Refresh**: Update weather data\n\n### Micro-interactions:\n- **Button Feedback**: Visual response to taps\n- **Swipe Gestures**: Navigate between days\n- **Haptic Feedback**: Tactile responses\n- **Sound Effects**: Optional audio feedback\n\n## Advanced Features & Extensions\n\n### Optional Enhancements:\n- **Weather Maps**: Simple precipitation maps\n- **Weather Widgets**: Home screen widgets\n- **Location Services**: Real GPS location\n- **Weather Alerts**: Severe weather notifications\n- **Data Caching**: Offline weather access\n\n## Testing & Debugging\n\n### Quality Assurance:\n- **Unit Tests**: Data model validation\n- **UI Tests**: Screen navigation flows\n- **Performance**: Memory usage and loading times\n- **Accessibility**: VoiceOver and Dynamic Type testing\n\n## Project Completion\n\nBy the end of this 10-hour project, you'll have:\n- A professional-grade weather application\n- Deep understanding of SwiftUI architecture\n- Experience with complex state management\n- Portfolio-ready project for job applications\n- Foundation for building any data-driven iOS app\n\n## Getting Started\n\nBegin with the data models and build up layer by layer. Test each component as you build it, and don't forget to celebrate small victories along the way!",
      "codeExample": "// === WEATHER DATA MODELS ===\n\nimport Foundation\n\n// Current weather conditions\nstruct CurrentWeather: Codable, Identifiable {\n    let id = UUID()\n    let temperature: Double\n    let feelsLike: Double\n    let condition: WeatherCondition\n    let humidity: Int\n    let windSpeed: Double\n    let windDirection: Int\n    let pressure: Int\n    let visibility: Double\n    let uvIndex: Int\n    let sunrise: Date\n    let sunset: Date\n    \n    var temperatureFahrenheit: Double {\n        return (temperature * 9/5) + 32\n    }\n    \n    var windDirectionText: String {\n        let directions = [\"N\", \"NNE\", \"NE\", \"ENE\", \"E\", \"ESE\", \"SE\", \"SSE\", \n                         \"S\", \"SSW\", \"SW\", \"WSW\", \"W\", \"WNW\", \"NW\", \"NNW\"]\n        let index = Int((Double(windDirection) + 11.25) / 22.5) % 16\n        return directions[index]\n    }\n}\n\n// Weather condition with emoji and description\nenum WeatherCondition: String, CaseIterable, Codable {\n    case clear = \"Clear\"\n    case cloudy = \"Cloudy\"\n    case partlyCloudy = \"Partly Cloudy\"\n    case rainy = \"Rainy\"\n    case stormy = \"Stormy\"\n    case snowy = \"Snowy\"\n    case foggy = \"Foggy\"\n    case windy = \"Windy\"\n    \n    var emoji: String {\n        switch self {\n        case .clear: return \"â˜€ï¸\"\n        case .cloudy: return \"â˜ï¸\"\n        case .partlyCloudy: return \"â›…\"\n        case .rainy: return \"ðŸŒ§ï¸\"\n        case .stormy: return \"â›ˆï¸\"\n        case .snowy: return \"â„ï¸\"\n        case .foggy: return \"ðŸŒ«ï¸\"\n        case .windy: return \"ðŸ’¨\"\n        }\n    }\n    \n    var color: String {\n        switch self {\n        case .clear: return \"FFD700\" // Gold\n        case .cloudy: return \"A9A9A9\" // Dark Gray\n        case .partlyCloudy: return \"87CEEB\" // Sky Blue\n        case .rainy: return \"4682B4\" // Steel Blue\n        case .stormy: return \"2F4F4F\" // Dark Slate Gray\n        case .snowy: return \"F0F8FF\" // Alice Blue\n        case .foggy: return \"D3D3D3\" // Light Gray\n        case .windy: return \"B0C4DE\" // Light Steel Blue\n        }\n    }\n}\n\n// Daily forecast\nstruct DailyForecast: Codable, Identifiable {\n    let id = UUID()\n    let date: Date\n    let highTemperature: Double\n    let lowTemperature: Double\n    let condition: WeatherCondition\n    let precipitationChance: Int\n    let sunrise: Date\n    let sunset: Date\n    let moonPhase: String\n    \n    var dayOfWeek: String {\n        let formatter = DateFormatter()\n        formatter.dateFormat = \"EEEE\"\n        return formatter.string(from: date)\n    }\n}\n\n// Location information\nstruct WeatherLocation: Codable, Identifiable, Hashable {\n    let id = UUID()\n    let name: String\n    let country: String\n    let latitude: Double\n    let longitude: Double\n    let timezone: String\n    \n    var displayName: String {\n        return \"\\(name), \\(country)\"\n    }\n}\n\n// Complete weather data package\nstruct WeatherData: Codable {\n    let location: WeatherLocation\n    let current: CurrentWeather\n    let forecast: [DailyForecast]\n    let hourly: [HourlyWeather]\n    let lastUpdated: Date\n}\n\n// Hourly weather for today\nstruct HourlyWeather: Codable, Identifiable {\n    let id = UUID()\n    let time: Date\n    let temperature: Double\n    let condition: WeatherCondition\n    let precipitationChance: Int\n    \n    var hourString: String {\n        let formatter = DateFormatter()\n        formatter.dateFormat = \"h a\"\n        return formatter.string(from: time)\n    }\n}\n\n// === WEATHER VIEW MODEL ===\n\nimport SwiftUI\nimport Combine\n\nclass WeatherViewModel: ObservableObject {\n    @Published var weatherData: WeatherData?\n    @Published var isLoading = false\n    @Published var errorMessage: String?\n    @Published var selectedLocation: WeatherLocation?\n    \n    @AppStorage(\"temperatureUnit\") var temperatureUnit: String = \"celsius\"\n    @AppStorage(\"selectedLocationId\") var selectedLocationId: String = \"\"\n    \n    private let weatherService = WeatherService()\n    private var cancellables = Set<AnyCancellable>()\n    \n    // Mock locations for the app\n    let mockLocations = [\n        WeatherLocation(name: \"New York\", country: \"US\", latitude: 40.7128, longitude: -74.0060, timezone: \"America/New_York\"),\n        WeatherLocation(name: \"London\", country: \"UK\", latitude: 51.5074, longitude: -0.1278, timezone: \"Europe/London\"),\n        WeatherLocation(name: \"Tokyo\", country: \"Japan\", latitude: 35.6762, longitude: 139.6503, timezone: \"Asia/Tokyo\"),\n        WeatherLocation(name: \"Sydney\", country: \"Australia\", latitude: -33.8688, longitude: 151.2093, timezone: \"Australia/Sydney\"),\n        WeatherLocation(name: \"Paris\", country: \"France\", latitude: 48.8566, longitude: 2.3522, timezone: \"Europe/Paris\")\n    ]\n    \n    init() {\n        loadInitialData()\n    }\n    \n    func loadInitialData() {\n        // Set default location if none selected\n        if selectedLocation == nil {\n            selectedLocation = mockLocations.first\n        }\n        \n        if let location = selectedLocation {\n            loadWeather(for: location)\n        }\n    }\n    \n    func loadWeather(for location: WeatherLocation) {\n        isLoading = true\n        errorMessage = nil\n        \n        weatherService.fetchWeather(for: location)\n            .receive(on: DispatchQueue.main)\n            .sink { [weak self] completion in\n                self?.isLoading = false\n                if case .failure(let error) = completion {\n                    self?.errorMessage = error.localizedDescription\n                }\n            } receiveValue: { [weak self] weatherData in\n                self?.weatherData = weatherData\n                self?.selectedLocation = location\n                self?.selectedLocationId = location.id.uuidString\n            }\n            .store(in: &cancellables)\n    }\n    \n    func searchLocations(query: String) -> [WeatherLocation] {\n        if query.isEmpty {\n            return mockLocations\n        }\n        \n        return mockLocations.filter { location in\n            location.name.localizedCaseInsensitiveContains(query) ||\n            location.country.localizedCaseInsensitiveContains(query)\n        }\n    }\n    \n    // Temperature formatting based on user preference\n    func formattedTemperature(_ temperature: Double) -> String {\n        if temperatureUnit == \"fahrenheit\" {\n            let fahrenheit = (temperature * 9/5) + 32\n            return \"\\(Int(round(fahrenheit)))Â°F\"\n        } else {\n            return \"\\(Int(round(temperature)))Â°C\"\n        }\n    }\n    \n    // Toggle temperature unit\n    func toggleTemperatureUnit() {\n        temperatureUnit = temperatureUnit == \"celsius\" ? \"fahrenheit\" : \"celsius\"\n        objectWillChange.send()\n    }\n}\n\n// === WEATHER SERVICE (MOCK DATA) ===\n\nclass WeatherService {\n    func fetchWeather(for location: WeatherLocation) -> AnyPublisher<WeatherData, Error> {\n        // Generate mock weather data based on location and current time\n        let mockWeatherData = generateMockWeatherData(for: location)\n        \n        return Just(mockWeatherData)\n            .setFailureType(to: Error.self)\n            .delay(for: .seconds(1), scheduler: RunLoop.main) // Simulate network delay\n            .eraseToAnyPublisher()\n    }\n    \n    private func generateMockWeatherData(for location: WeatherLocation) -> WeatherData {\n        let currentDate = Date()\n        let calendar = Calendar.current\n        \n        // Generate current weather\n        let currentWeather = CurrentWeather(\n            temperature: Double.random(in: -5...35), // Realistic temperature range\n            feelsLike: Double.random(in: -8...38),\n            condition: WeatherCondition.allCases.randomElement()!,\n            humidity: Int.random(in: 30...90),\n            windSpeed: Double.random(in: 0...25),\n            windDirection: Int.random(in: 0...359),\n            pressure: Int.random(in: 980...1040),\n            visibility: Double.random(in: 2...20),\n            uvIndex: Int.random(in: 0...11),\n            sunrise: calendar.date(byAdding: .hour, value: -2, to: currentDate)!,\n            sunset: calendar.date(byAdding: .hour, value: 10, to: currentDate)!\n        )\n        \n        // Generate 5-day forecast\n        var forecast: [DailyForecast] = []\n        for day in 0..<5 {\n            let forecastDate = calendar.date(byAdding: .day, value: day, to: currentDate)!\n            let dailyForecast = DailyForecast(\n                date: forecastDate,\n                highTemperature: Double.random(in: currentWeather.temperature - 5...currentWeather.temperature + 8),\n                lowTemperature: Double.random(in: currentWeather.temperature - 15...currentWeather.temperature - 2),\n                condition: WeatherCondition.allCases.randomElement()!,\n                precipitationChance: Int.random(in: 0...100),\n                sunrise: calendar.date(byAdding: .hour, value: -2, to: forecastDate)!,\n                sunset: calendar.date(byAdding: .hour, value: 10, to: forecastDate)!,\n                moonPhase: [\"New Moon\", \"Waxing Crescent\", \"First Quarter\", \"Waxing Gibbous\", \n                           \"Full Moon\", \"Waning Gibbous\", \"Last Quarter\", \"Waning Crescent\"].randomElement()!\n            )\n            forecast.append(dailyForecast)\n        }\n        \n        // Generate 24-hour forecast\n        var hourly: [HourlyWeather] = []\n        for hour in 0..<24 {\n            let hourDate = calendar.date(byAdding: .hour, value: hour, to: currentDate)!\n            let hourlyWeather = HourlyWeather(\n                time: hourDate,\n                temperature: Double.random(in: currentWeather.temperature - 8...currentWeather.temperature + 5),\n                condition: currentWeather.condition, // Same condition for simplicity\n                precipitationChance: Int.random(in: 0...30)\n            )\n            hourly.append(hourlyWeather)\n        }\n        \n        return WeatherData(\n            location: location,\n            current: currentWeather,\n            forecast: forecast,\n            hourly: hourly,\n            lastUpdated: currentDate\n        )\n    }\n}",
      "category": "Projects",
      "estimatedTime": 600,
      "dependencies": ["variables", "optionals", "control_flow", "functions", "collections", "structs_classes"],
      "challenge": {
        "instructions": "Build a complete Weather App with the following features:\n\nPART 1: Project Setup & Data Models (2 hours)\n1. Create all the data models: CurrentWeather, WeatherCondition, DailyForecast, WeatherLocation, WeatherData\n2. Implement the WeatherService with mock data generation\n3. Set up the basic WeatherViewModel with @Published properties\n\nPART 2: Home Screen Implementation (3 hours)\n4. Create a HomeView that displays current weather conditions\n5. Build a weather card showing temperature, condition, and feels-like\n6. Add a detail grid showing humidity, wind, pressure, and visibility\n7. Implement a horizontal scroll view for hourly forecast\n8. Add a location header and last updated time\n\nPART 3: Forecast & Navigation (2 hours)\n9. Create a ForecastView showing 5-day weather forecast\n10. Implement navigation between Home and Forecast screens\n11. Add a tab bar or navigation bar for app structure\n12. Create smooth transitions between screens\n\nPART 4: Search & Location Management (2 hours)\n13. Build a SearchView for finding cities\n14. Implement location switching functionality\n15. Add recent searches persistence\n16. Handle empty states and loading states\n\nPART 5: Settings & Polish (1 hour)\n17. Create a SettingsView for temperature units\n18. Implement @AppStorage for user preferences\n19. Add weather-appropriate animations\n20. Test the complete app flow\n\nBONUS FEATURES (Extra Credit):\n- Add pull-to-refresh functionality\n- Implement weather condition animations\n- Add weather maps or radar\n- Create home screen widgets\n- Add weather alerts system",
        "starterCode": "// === PART 1: Data Models ===\n// Add your data model implementations here\n\n\n// === PART 2: Weather Service ===\n// Implement WeatherService with mock data\n\n\n// === PART 3: Weather ViewModel ===\n// Create WeatherViewModel class\n\n\n// === PART 4: Home View ===\n// Build the main weather display\n\n\n// === PART 5: Forecast View ===\n// Create 5-day forecast screen\n\n\n// === PART 6: Search View ===\n// Implement location search\n\n\n// === PART 7: Settings View ===\n// Add user preferences\n\n\n// === PART 8: App Structure ===\n// Set up navigation and tab views",
        "solution": "// Note: The complete solution would be very extensive (1000+ lines)\n// Here's a simplified version of key components:\n\nimport SwiftUI\n\n// Main App Structure\nstruct WeatherApp: App {\n    var body: some Scene {\n        WindowGroup {\n            ContentView()\n                .environmentObject(WeatherViewModel())\n        }\n    }\n}\n\nstruct ContentView: View {\n    var body: some View {\n        TabView {\n            HomeView()\n                .tabItem {\n                    Image(systemName: \"house.fill\")\n                    Text(\"Home\")\n                }\n            \n            ForecastView()\n                .tabItem {\n                    Image(systemName: \"calendar\")\n                    Text(\"Forecast\")\n                }\n            \n            SearchView()\n                .tabItem {\n                    Image(systemName: \"magnifyingglass\")\n                    Text(\"Search\")\n                }\n            \n            SettingsView()\n                .tabItem {\n                    Image(systemName: \"gear\")\n                    Text(\"Settings\")\n                }\n        }\n    }\n}\n\n// Home View Implementation\nstruct HomeView: View {\n    @EnvironmentObject var viewModel: WeatherViewModel\n    \n    var body: some View {\n        NavigationView {\n            ScrollView {\n                VStack(spacing: 20) {\n                    if let weather = viewModel.weatherData {\n                        // Weather Card\n                        WeatherCard(weather: weather.current, location: weather.location)\n                        \n                        // Hourly Forecast\n                        HourlyForecastView(hourly: weather.hourly)\n                        \n                        // Weather Details\n                        WeatherDetailsView(weather: weather.current)\n                    } else if viewModel.isLoading {\n                        ProgressView(\"Loading weather...\")\n                    } else if let error = viewModel.errorMessage {\n                        ErrorView(message: error)\n                    }\n                }\n                .padding()\n            }\n            .navigationTitle(\"Weather\")\n            .refreshable {\n                if let location = viewModel.selectedLocation {\n                    viewModel.loadWeather(for: location)\n                }\n            }\n        }\n    }\n}\n\n// Weather Card Component\nstruct WeatherCard: View {\n    let weather: CurrentWeather\n    let location: WeatherLocation\n    @EnvironmentObject var viewModel: WeatherViewModel\n    \n    var body: some View {\n        VStack(spacing: 16) {\n            Text(location.displayName)\n                .font(.title2)\n                .fontWeight(.semibold)\n            \n            HStack(alignment: .top) {\n                Text(viewModel.formattedTemperature(weather.temperature))\n                    .font(.system(size: 64, weight: .thin))\n                \n                VStack(alignment: .leading) {\n                    Text(weather.condition.rawValue)\n                        .font(.title3)\n                    Text(weather.condition.emoji)\n                        .font(.largeTitle)\n                }\n            }\n            \n            Text(\"Feels like \\(viewModel.formattedTemperature(weather.feelsLike))\")\n                .foregroundColor(.secondary)\n        }\n        .padding()\n        .background(Color(.systemBackground))\n        .cornerRadius(20)\n        .shadow(color: .black.opacity(0.1), radius: 10)\n    }\n}\n\n// This is a simplified version - the complete app would include:\n// - ForecastView with List of daily forecasts\n// - SearchView with TextField and results list\n// - SettingsView with toggle for temperature units\n// - All the data models and services from the theory section",
        "hints": [
          "PART 1: Start with the data models - they're the foundation of your app",
          "PART 2: Use VStack and HStack to layout the home screen components",
          "PART 3: Implement NavigationView and NavigationLink for screen transitions",
          "PART 4: Use @State for search text and filter locations based on input",
          "PART 5: @AppStorage automatically persists user preferences",
          "Use ScrollView for content that might overflow the screen",
          "Create reusable components for weather cards and detail items",
          "Mock data should be realistic - check real weather ranges for temperatures",
          "Test your app with different weather conditions and locations",
          "Add loading states and error handling for better user experience"
        ],
        "testCases": [
          {
            "input": "weatherData != nil",
            "expectedOutput": "true",
            "description": "Weather data should be loaded successfully"
          },
          {
            "input": "viewModel.mockLocations.count >= 3",
            "expectedOutput": "true",
            "description": "Should have multiple mock locations available"
          },
          {
            "input": "viewModel.formattedTemperature(0).contains(\"Â°\")",
            "expectedOutput": "true",
            "description": "Temperature formatting should include degree symbol"
          }
        ]
      }
    },
    {
      "id": "custom_views",
      "title": "Custom Views",
      "description": "Master creating reusable, maintainable SwiftUI components through custom views",
      "difficulty": "beginner",
      "theory": "# Custom Views - Building Reusable Components\n\n## 1. Why Custom Views? (30 min)\n\n### The Problem with Repetitive Code\n```swift\n// Without custom views - repetitive code\nVStack {\n    HStack {\n        Image(systemName: \"star.fill\")\n            .foregroundColor(.yellow)\n        Text(\"Rating: 4.8\")\n            .font(.subheadline)\n        Spacer()\n    }\n    HStack {\n        Image(systemName: \"clock.fill\")\n            .foregroundColor(.blue)\n        Text(\"30 min\")\n            .font(.subheadline)\n        Spacer()\n    }\n    HStack {\n        Image(systemName: \"dollarsign.circle.fill\")\n            .foregroundColor(.green)\n        Text(\"$$\")\n            .font(.subheadline)\n        Spacer()\n    }\n}\n```\n\n### The Solution: Custom Views\n```swift\n// With custom views - clean and reusable\nVStack {\n    InfoRow(icon: \"star.fill\", color: .yellow, text: \"Rating: 4.8\")\n    InfoRow(icon: \"clock.fill\", color: .blue, text: \"30 min\")\n    InfoRow(icon: \"dollarsign.circle.fill\", color: .green, text: \"$$\")\n}\n```\n\n**Benefits:**\n- **Reusability**: Use the same component across your app\n- **Maintainability**: Change in one place, updates everywhere\n- **Readability**: Clean, semantic code\n- **Testability**: Easier to test individual components\n\n## 2. Basic Custom View Creation (45 min)\n\n### Simple Custom View\n```swift\nstruct WelcomeHeader: View {\n    let username: String\n    \n    var body: some View {\n        VStack(alignment: .leading) {\n            Text(\"Welcome back,\")\n                .font(.headline)\n                .foregroundColor(.secondary)\n            Text(username)\n                .font(.largeTitle)\n                .fontWeight(.bold)\n        }\n    }\n}\n\n// Usage\nWelcomeHeader(username: \"Sarah\")\n```\n\n### View with Multiple Parameters\n```swift\nstruct StatCard: View {\n    let title: String\n    let value: String\n    let icon: String\n    let color: Color\n    \n    var body: some View {\n        VStack {\n            Image(systemName: icon)\n                .font(.title)\n                .foregroundColor(color)\n            Text(value)\n                .font(.title2)\n                .fontWeight(.bold)\n            Text(title)\n                .font(.caption)\n                .foregroundColor(.secondary)\n        }\n        .padding()\n        .background(Color(.systemBackground))\n        .cornerRadius(12)\n        .shadow(color: .gray.opacity(0.2), radius: 5)\n    }\n}\n\n// Usage\nHStack {\n    StatCard(title: \"Steps\", value: \"8,542\", icon: \"figure.walk\", color: .green)\n    StatCard(title: \"Calories\", value: \"420\", icon: \"flame.fill\", color: .orange)\n}\n```\n\n## 3. Advanced Custom View Patterns (60 min)\n\n### View Composition\n```swift\n// Small, focused components\nstruct Avatar: View {\n    let imageName: String\n    let size: CGFloat\n    \n    var body: some View {\n        Image(imageName)\n            .resizable()\n            .aspectRatio(contentMode: .fill)\n            .frame(width: size, height: size)\n            .clipShape(Circle())\n    }\n}\n\nstruct UserBadge: View {\n    let user: String\n    let role: String\n    let isOnline: Bool\n    \n    var body: some View {\n        HStack {\n            Avatar(imageName: user, size: 40)\n            VStack(alignment: .leading) {\n                Text(user)\n                    .fontWeight(.semibold)\n                Text(role)\n                    .font(.caption)\n                    .foregroundColor(.secondary)\n            }\n            Spacer()\n            Circle()\n                .fill(isOnline ? .green : .gray)\n                .frame(width: 8, height: 8)\n        }\n    }\n}\n```\n\n### Generic Custom Views\n```swift\nstruct CardView<Content: View>: View {\n    let content: Content\n    \n    init(@ViewBuilder content: () -> Content) {\n        self.content = content()\n    }\n    \n    var body: some View {\n        content\n            .padding()\n            .background(Color(.systemBackground))\n            .cornerRadius(12)\n            .shadow(color: .gray.opacity(0.2), radius: 5)\n    }\n}\n\n// Usage with any content\nCardView {\n    VStack {\n        Text(\"Custom Content\")\n        Image(systemName: \"heart.fill\")\n    }\n}\n```\n\n## 4. View Modifiers & Styling (45 min)\n\n### Custom View Modifiers\n```swift\nstruct PrimaryButtonStyle: ViewModifier {\n    func body(content: Content) -> some View {\n        content\n            .font(.headline)\n            .foregroundColor(.white)\n            .padding()\n            .frame(maxWidth: .infinity)\n            .background(Color.blue)\n            .cornerRadius(10)\n    }\n}\n\nextension View {\n    func primaryButton() -> some View {\n        modifier(PrimaryButtonStyle())\n    }\n}\n\n// Usage\nButton(\"Save Changes\") { }\n    .primaryButton()\n```\n\n### Conditional Styling\n```swift\nstruct AdaptiveCard: View {\n    let title: String\n    let message: String\n    let type: CardType\n    \n    enum CardType {\n        case info, warning, error, success\n        \n        var color: Color {\n            switch self {\n            case .info: return .blue\n            case .warning: return .orange\n            case .error: return .red\n            case .success: return .green\n            }\n        }\n        \n        var icon: String {\n            switch self {\n            case .info: return \"info.circle.fill\"\n            case .warning: return \"exclamationmark.triangle.fill\"\n            case .error: return \"xmark.circle.fill\"\n            case .success: return \"checkmark.circle.fill\"\n            }\n        }\n    }\n    \n    var body: some View {\n        HStack {\n            Image(systemName: type.icon)\n                .foregroundColor(type.color)\n            VStack(alignment: .leading) {\n                Text(title)\n                    .fontWeight(.semibold)\n                Text(message)\n                    .font(.caption)\n                    .foregroundColor(.secondary)\n            }\n            Spacer()\n        }\n        .padding()\n        .background(type.color.opacity(0.1))\n        .cornerRadius(8)\n        .overlay(\n            RoundedRectangle(cornerRadius: 8)\n                .stroke(type.color.opacity(0.3), lineWidth: 1)\n        )\n    }\n}\n```\n\n## 5. State Management in Custom Views (45 min)\n\n### Interactive Custom Views\n```swift\nstruct ExpandableCard: View {\n    let title: String\n    let content: String\n    \n    @State private var isExpanded = false\n    \n    var body: some View {\n        VStack(alignment: .leading) {\n            HStack {\n                Text(title)\n                    .font(.headline)\n                Spacer()\n                Image(systemName: isExpanded ? \"chevron.up\" : \"chevron.down\")\n                    .foregroundColor(.blue)\n            }\n            .contentShape(Rectangle())\n            .onTapGesture {\n                withAnimation(.spring()) {\n                    isExpanded.toggle()\n                }\n            }\n            \n            if isExpanded {\n                Text(content)\n                    .font(.body)\n                    .padding(.top, 8)\n                    .transition(.opacity.combined(with: .move(edge: .top)))\n            }\n        }\n        .padding()\n        .background(Color(.systemBackground))\n        .cornerRadius(12)\n        .shadow(color: .gray.opacity(0.2), radius: 5)\n    }\n}\n```\n\n### Binding in Custom Views\n```swift\nstruct ToggleSetting: View {\n    let title: String\n    let description: String\n    @Binding var isOn: Bool\n    \n    var body: some View {\n        HStack {\n            VStack(alignment: .leading) {\n                Text(title)\n                    .fontWeight(.semibold)\n                Text(description)\n                    .font(.caption)\n                    .foregroundColor(.secondary)\n            }\n            Spacer()\n            Toggle(\"\", isOn: $isOn)\n                .labelsHidden()\n        }\n        .padding()\n        .background(Color(.systemBackground))\n        .cornerRadius(8)\n    }\n}\n\n// Usage in parent view\nstruct SettingsView: View {\n    @State private var notificationsEnabled = true\n    @State private var darkMode = false\n    \n    var body: some View {\n        VStack {\n            ToggleSetting(\n                title: \"Push Notifications\",\n                description: \"Receive push notifications\",\n                isOn: $notificationsEnabled\n            )\n            ToggleSetting(\n                title: \"Dark Mode\", \n                description: \"Enable dark theme\",\n                isOn: $darkMode\n            )\n        }\n    }\n}\n```\n\n## 6. Advanced Patterns & Best Practices (45 min)\n\n### ViewBuilder for Complex Content\n```swift\nstruct SectionContainer<Header: View, Content: View>: View {\n    let header: Header\n    let content: Content\n    \n    init(@ViewBuilder header: () -> Header, \n         @ViewBuilder content: () -> Content) {\n        self.header = header()\n        self.content = content()\n    }\n    \n    var body: some View {\n        VStack(alignment: .leading, spacing: 12) {\n            header\n                .font(.title2)\n                .fontWeight(.bold)\n            \n            content\n                .padding()\n                .background(Color(.systemBackground))\n                .cornerRadius(12)\n                .shadow(color: .gray.opacity(0.1), radius: 3)\n        }\n    }\n}\n\n// Usage\nSectionContainer {\n    Text(\"Profile Settings\")\n} content: {\n    VStack {\n        Text(\"Name: John Doe\")\n        Text(\"Email: john@example.com\")\n    }\n}\n```\n\n### Environment-Based Custom Views\n```swift\nstruct Theme {\n    let primaryColor: Color\n    let backgroundColor: Color\n    let cornerRadius: CGFloat\n}\n\nstruct ThemedCard<Content: View>: View {\n    @Environment(\\.theme) private var theme\n    let content: Content\n    \n    init(@ViewBuilder content: () -> Content) {\n        self.content = content()\n    }\n    \n    var body: some View {\n        content\n            .padding()\n            .background(theme.backgroundColor)\n            .cornerRadius(theme.cornerRadius)\n            .overlay(\n                RoundedRectangle(cornerRadius: theme.cornerRadius)\n                    .stroke(theme.primaryColor.opacity(0.2), lineWidth: 1)\n            )\n    }\n}\n```\n\n## 7. Testing & Debugging Custom Views (30 min)\n\n### Preview Providers for Custom Views\n```swift\n#Preview(\"Light Mode\") {\n    StatCard(title: \"Steps\", value: \"8,542\", icon: \"figure.walk\", color: .green)\n        .padding()\n        .background(Color.white)\n}\n\n#Preview(\"Dark Mode\") {\n    StatCard(title: \"Steps\", value: \"8,542\", icon: \"figure.walk\", color: .green)\n        .padding()\n        .background(Color.black)\n        .preferredColorScheme(.dark)\n}\n\n#Preview(\"Multiple States\") {\n    VStack {\n        ExpandableCard(title: \"Collapsed\", content: \"Hidden content\")\n        ExpandableCard(title: \"Expanded\", content: \"Visible content\")\n    }\n    .padding()\n}\n```\n\n### Debugging Tips\n- Use `.border(.red)` to visualize view frames\n- Add `#if DEBUG` conditionals for debug views\n- Use previews extensively during development\n- Test with different data states and screen sizes\n\n## Best Practices Summary\n1. **Single Responsibility**: Each custom view should do one thing well\n2. **Configurable**: Use parameters to make views flexible\n3. **Reusable**: Design views to work in multiple contexts\n4. **Testable**: Make views easy to preview and test\n5. **Documented**: Add clear documentation for complex views\n\nComplete the practice exercises to master these concepts!",
      "codeExample": "// === BASIC CUSTOM VIEWS ===\nstruct InfoRow: View {\n    let icon: String\n    let color: Color\n    let text: String\n    \n    var body: some View {\n        HStack {\n            Image(systemName: icon)\n                .foregroundColor(color)\n                .frame(width: 20)\n            Text(text)\n                .font(.subheadline)\n            Spacer()\n        }\n    }\n}\n\n// === ADVANCED CUSTOM VIEWS ===\nstruct UserProfileHeader: View {\n    let user: User\n    let onEdit: () -> Void\n    \n    var body: some View {\n        HStack {\n            Avatar(imageName: user.avatar, size: 60)\n            \n            VStack(alignment: .leading, spacing: 4) {\n                Text(user.name)\n                    .font(.title2)\n                    .fontWeight(.bold)\n                Text(user.title)\n                    .font(.subheadline)\n                    .foregroundColor(.secondary)\n                HStack {\n                    Image(systemName: \"location.fill\")\n                        .font(.caption)\n                    Text(user.location)\n                        .font(.caption)\n                }\n                .foregroundColor(.secondary)\n            }\n            \n            Spacer()\n            \n            Button(action: onEdit) {\n                Image(systemName: \"pencil\")\n                    .foregroundColor(.blue)\n            }\n        }\n        .padding()\n    }\n}\n\n// === GENERIC CONTAINER VIEW ===\nstruct CardContainer<Content: View>: View {\n    let title: String?\n    let content: Content\n    \n    init(title: String? = nil, @ViewBuilder content: () -> Content) {\n        self.title = title\n        self.content = content()\n    }\n    \n    var body: some View {\n        VStack(alignment: .leading, spacing: 12) {\n            if let title = title {\n                Text(title)\n                    .font(.headline)\n                    .padding(.horizontal)\n            }\n            \n            content\n                .padding()\n                .background(Color(.systemBackground))\n                .cornerRadius(12)\n                .shadow(color: .gray.opacity(0.1), radius: 3)\n        }\n    }\n}\n\n// === INTERACTIVE CUSTOM VIEW ===\nstruct RatingView: View {\n    let maxRating: Int\n    @Binding var currentRating: Int\n    let onRatingChanged: (Int) -> Void\n    \n    var body: some View {\n        HStack {\n            ForEach(1...maxRating, id: \\.self) { star in\n                Image(systemName: star <= currentRating ? \"star.fill\" : \"star\")\n                    .foregroundColor(star <= currentRating ? .yellow : .gray)\n                    .onTapGesture {\n                        withAnimation(.spring()) {\n                            currentRating = star\n                            onRatingChanged(star)\n                        }\n                    }\n            }\n        }\n    }\n}\n\n// === COMPLEX COMPOSITE VIEW ===\nstruct ProductCard: View {\n    let product: Product\n    @State private var isFavorite = false\n    \n    var body: some View {\n        CardContainer {\n            VStack(alignment: .leading, spacing: 12) {\n                // Header with image and favorite button\n                ZStack(alignment: .topTrailing) {\n                    AsyncImage(url: URL(string: product.imageUrl)) { image in\n                        image\n                            .resizable()\n                            .aspectRatio(contentMode: .fill)\n                    } placeholder: {\n                        Rectangle()\n                            .fill(Color.gray.opacity(0.3))\n                    }\n                    .frame(height: 150)\n                    .clipped()\n                    .cornerRadius(8)\n                    \n                    Button(action: { isFavorite.toggle() }) {\n                        Image(systemName: isFavorite ? \"heart.fill\" : \"heart\")\n                            .foregroundColor(isFavorite ? .red : .white)\n                            .padding(8)\n                            .background(Color.black.opacity(0.6))\n                            .clipShape(Circle())\n                    }\n                    .padding(8)\n                }\n                \n                // Product info\n                VStack(alignment: .leading, spacing: 8) {\n                    Text(product.name)\n                        .font(.headline)\n                        .lineLimit(2)\n                    \n                    Text(product.description)\n                        .font(.caption)\n                        .foregroundColor(.secondary)\n                        .lineLimit(2)\n                    \n                    HStack {\n                        Text(\"$\\(product.price, specifier: \"%.2f\")\")\n                            .font(.title3)\n                            .fontWeight(.bold)\n                        \n                        Spacer()\n                        \n                        HStack {\n                            Image(systemName: \"star.fill\")\n                                .foregroundColor(.yellow)\n                                .font(.caption)\n                            Text(\"\\(product.rating, specifier: \"%.1f\")\")\n                                .font(.caption)\n                                .fontWeight(.semibold)\n                        }\n                    }\n                }\n                \n                // Action buttons\n                HStack {\n                    Button(\"Add to Cart\") {\n                        // Add to cart action\n                    }\n                    .buttonStyle(.bordered)\n                    \n                    Spacer()\n                    \n                    Button(\"Buy Now\") {\n                        // Buy now action\n                    }\n                    .buttonStyle(.borderedProminent)\n                }\n            }\n        }\n    }\n}\n\n// === SUPPORTING MODELS ===\nstruct User {\n    let id = UUID()\n    let name: String\n    let title: String\n    let location: String\n    let avatar: String\n}\n\nstruct Product {\n    let id = UUID()\n    let name: String\n    let description: String\n    let price: Double\n    let rating: Double\n    let imageUrl: String\n}\n\n// === USAGE EXAMPLE ===\nstruct ContentView: View {\n    @State private var userRating = 3\n    let sampleUser = User(\n        name: \"Sarah Chen\",\n        title: \"Senior iOS Developer\",\n        location: \"San Francisco, CA\",\n        avatar: \"person.circle.fill\"\n    )\n    \n    let sampleProduct = Product(\n        name: \"Wireless Bluetooth Headphones\",\n        description: \"Noise cancelling over-ear headphones with premium sound quality\",\n        price: 199.99,\n        rating: 4.5,\n        imageUrl: \"https://example.com/headphones.jpg\"\n    )\n    \n    var body: some View {\n        ScrollView {\n            VStack(spacing: 20) {\n                UserProfileHeader(user: sampleUser) {\n                    print(\"Edit profile tapped\")\n                }\n                \n                CardContainer(title: \"Product Rating\") {\n                    VStack {\n                        Text(\"How would you rate this product?\")\n                            .font(.headline)\n                        RatingView(\n                            maxRating: 5,\n                            currentRating: $userRating,\n                            onRatingChanged: { newRating in\n                                print(\"Rating changed to: \\(newRating)\")\n                            }\n                        )\n                        .font(.title)\n                    }\n                }\n                \n                ProductCard(product: sampleProduct)\n                \n                // Info rows example\n                CardContainer(title: \"Product Details\") {\n                    VStack(spacing: 12) {\n                        InfoRow(icon: \"shippingbox.fill\", color: .blue, text: \"Free Shipping\")\n                        InfoRow(icon: \"arrow.clockwise\", color: .green, text: \"30-Day Returns\")\n                        InfoRow(icon: \"lock.fill\", color: .orange, text: \"Secure Payment\")\n                    }\n                }\n            }\n            .padding()\n        }\n    }\n}",
      "category": "SwiftUI Advanced",
      "estimatedTime": 240,
      "dependencies": ["variables", "optionals"],
      "challenge": {
        "instructions": "Build a complete Task Management app using custom views:\n\nPART 1: Basic Custom Views (45 min)\n1. Create a `TaskRow` view that displays: title, due date, priority, and completion status\n2. Create a `PriorityBadge` view that shows priority with different colors (low=green, medium=yellow, high=red)\n3. Create a `DueDateView` that shows relative due dates (Today, Tomorrow, Overdue, etc.)\n\nPART 2: Interactive Custom Views (45 min)\n4. Create a `TaskCard` that uses `TaskRow` and can be expanded to show task details\n5. Add swipe actions to `TaskRow` for complete/delete functionality\n6. Create a `AddTaskButton` with a floating action button style\n\nPART 3: Composite Custom Views (45 min)\n7. Build a `TaskSection` that groups tasks by status (Todo, In Progress, Done)\n8. Create a `ProgressHeader` that shows completion statistics\n9. Build a `FilterBar` with multiple filter options (All, Active, Completed)\n\nPART 4: Advanced Custom Views (45 min)\n10. Create a `TaskEditor` modal view for adding/editing tasks\n11. Build a `SortableTaskList` that supports drag-and-drop reordering\n12. Create a `SearchableTaskView` with real-time search functionality\n\nPART 5: Styling & Theming (30 min)\n13. Create custom view modifiers for consistent styling\n14. Add dark mode support to all custom views\n15. Create previews for all custom views with different data states",
        "starterCode": "// === PART 1: Basic Custom Views ===\n// Define your Task model and basic views here\n\n\n// === PART 2: Interactive Custom Views ===\n// Add interactive functionality here\n\n\n// === PART 3: Composite Custom Views ===\n// Build composite views that combine multiple components\n\n\n// === PART 4: Advanced Custom Views ===\n// Implement advanced features like editing and search\n\n\n// === PART 5: Styling & Theming ===\n// Add styling and theming support\n\n",
        "solution": "// === TASK MODEL ===\nstruct TaskItem: Identifiable {\n    let id = UUID()\n    var title: String\n    var description: String\n    var dueDate: Date\n    var priority: Priority\n    var isCompleted: Bool\n    var category: String\n    \n    enum Priority: String, CaseIterable {\n        case low, medium, high\n        \n        var color: Color {\n            switch self {\n            case .low: return .green\n            case .medium: return .yellow\n            case .high: return .red\n            }\n        }\n        \n        var icon: String {\n            switch self {\n            case .low: return \"arrow.down\"\n            case .medium: return \"minus\"\n            case .high: return \"arrow.up\"\n            }\n        }\n    }\n}\n\n// === PART 1: BASIC CUSTOM VIEWS ===\nstruct PriorityBadge: View {\n    let priority: TaskItem.Priority\n    \n    var body: some View {\n        HStack(spacing: 4) {\n            Image(systemName: priority.icon)\n                .font(.caption)\n            Text(priority.rawValue.capitalized)\n                .font(.caption)\n                .fontWeight(.medium)\n        }\n        .padding(.horizontal, 8)\n        .padding(.vertical, 4)\n        .background(priority.color.opacity(0.2))\n        .foregroundColor(priority.color)\n        .cornerRadius(6)\n    }\n}\n\nstruct DueDateView: View {\n    let dueDate: Date\n    \n    private var relativeDate: String {\n        let calendar = Calendar.current\n        if calendar.isDateInToday(dueDate) {\n            return \"Today\"\n        } else if calendar.isDateInTomorrow(dueDate) {\n            return \"Tomorrow\"\n        } else if dueDate < Date() {\n            return \"Overdue\"\n        } else {\n            let formatter = RelativeDateTimeFormatter()\n            return formatter.localizedString(for: dueDate, relativeTo: Date())\n        }\n    }\n    \n    private var textColor: Color {\n        if dueDate < Date() && !Calendar.current.isDateInToday(dueDate) {\n            return .red\n        } else if Calendar.current.isDateInToday(dueDate) {\n            return .blue\n        } else {\n            return .secondary\n        }\n    }\n    \n    var body: some View {\n        HStack(spacing: 4) {\n            Image(systemName: \"calendar\")\n                .font(.caption)\n            Text(relativeDate)\n                .font(.caption)\n                .foregroundColor(textColor)\n        }\n    }\n}\n\nstruct TaskRow: View {\n    let task: TaskItem\n    let onToggleComplete: () -> Void\n    \n    var body: some View {\n        HStack(spacing: 12) {\n            // Completion toggle\n            Button(action: onToggleComplete) {\n                Image(systemName: task.isCompleted ? \"checkmark.circle.fill\" : \"circle\")\n                    .foregroundColor(task.isCompleted ? .green : .gray)\n                    .font(.title2)\n            }\n            \n            // Task info\n            VStack(alignment: .leading, spacing: 4) {\n                Text(task.title)\n                    .font(.headline)\n                    .strikethrough(task.isCompleted)\n                    .foregroundColor(task.isCompleted ? .secondary : .primary)\n                \n                if !task.description.isEmpty {\n                    Text(task.description)\n                        .font(.caption)\n                        .foregroundColor(.secondary)\n                        .lineLimit(1)\n                }\n                \n                HStack {\n                    PriorityBadge(priority: task.priority)\n                    DueDateView(dueDate: task.dueDate)\n                    Spacer()\n                    Text(task.category)\n                        .font(.caption)\n                        .padding(.horizontal, 8)\n                        .padding(.vertical, 2)\n                        .background(Color.blue.opacity(0.1))\n                        .foregroundColor(.blue)\n                        .cornerRadius(4)\n                }\n            }\n            \n            Spacer()\n        }\n        .padding(.vertical, 8)\n        .contentShape(Rectangle())\n    }\n}\n\n// === PART 2: INTERACTIVE CUSTOM VIEWS ===\nstruct TaskCard: View {\n    let task: TaskItem\n    @State private var isExpanded = false\n    \n    var body: some View {\n        VStack(alignment: .leading, spacing: 12) {\n            // Header\n            HStack {\n                VStack(alignment: .leading, spacing: 4) {\n                    Text(task.title)\n                        .font(.headline)\n                    HStack {\n                        PriorityBadge(priority: task.priority)\n                        DueDateView(dueDate: task.dueDate)\n                    }\n                }\n                \n                Spacer()\n                \n                Button(action: { withAnimation { isExpanded.toggle() } }) {\n                    Image(systemName: isExpanded ? \"chevron.up\" : \"chevron.down\")\n                        .foregroundColor(.blue)\n                }\n            }\n            \n            // Expandable content\n            if isExpanded {\n                VStack(alignment: .leading, spacing: 8) {\n                    if !task.description.isEmpty {\n                        Text(task.description)\n                            .font(.body)\n                            .foregroundColor(.secondary)\n                    }\n                    \n                    HStack {\n                        Text(\"Category:\")\n                            .font(.caption)\n                            .fontWeight(.medium)\n                        Text(task.category)\n                            .font(.caption)\n                            .padding(.horizontal, 8)\n                            .padding(.vertical, 2)\n                            .background(Color.blue.opacity(0.1))\n                            .foregroundColor(.blue)\n                            .cornerRadius(4)\n                        Spacer()\n                    }\n                }\n                .padding(.top, 8)\n                .transition(.opacity.combined(with: .move(edge: .top)))\n            }\n        }\n        .padding()\n        .background(Color(.systemBackground))\n        .cornerRadius(12)\n        .shadow(color: .gray.opacity(0.1), radius: 3)\n    }\n}\n\n// === CONTINUED IN NEXT MESSAGE (solution is too long for one response)",
        "hints": [
          "PART 1: Start with simple, focused views that do one thing well",
          "PART 2: Use @State for view-specific state and @Binding for shared state",
          "PART 3: Compose larger views from smaller, reusable components",
          "PART 4: Consider using EnvironmentObject for shared data across views",
          "Use ViewBuilder for flexible content containers",
          "Create custom view modifiers for consistent styling across your app",
          "Test your custom views with different data states in previews",
          "Use enums for type-safe configuration options",
          "Consider accessibility when designing custom views",
          "Use SwiftUI's animation system for smooth interactions"
        ],
        "testCases": [
          {
            "input": "task.isCompleted ? \"completed\" : \"active\"",
            "expectedOutput": "active",
            "description": "Task should start as active (not completed)"
          },
          {
            "input": "priority.color != .clear",
            "expectedOutput": "true",
            "description": "Priority badge should have a valid color"
          },
          {
            "input": "dueDate != nil",
            "expectedOutput": "true",
            "description": "Due date view should handle valid dates"
          }
        ]
      }
    },
    {
      "id": "grids_layout",
      "title": "Grids & Layout",
      "description": "Master SwiftUI's powerful grid systems for creating complex, responsive layouts",
      "difficulty": "beginner",
      "theory": "# Grids & Layout - Creating Responsive UI\n\n## 1. Introduction to Grid Systems (30 min)\n\n**Grids** are fundamental to creating organized, responsive layouts in SwiftUI. Unlike stacks that arrange views in a single direction, grids allow two-dimensional layouts.\n\n### Why Use Grids?\n- **Responsive Design**: Automatically adapt to different screen sizes\n- **Consistent Spacing**: Maintain uniform spacing between elements\n- **Complex Layouts**: Create magazine-style, gallery, or dashboard layouts\n- **Performance**: Lazy grids only create views as needed\n\n## 2. LazyVGrid - Vertical Grids (60 min)\n\n### Basic LazyVGrid Structure:\n```swift\nLazyVGrid(columns: columns, alignment: .center, spacing: 20) {\n    ForEach(items, id: \\.self) { item in\n        ItemView(item: item)\n    }\n}\n```\n\n### GridItem Types:\n- **`.flexible()`**: Shares available space equally\n- **`.adaptive(minimum:)`**: Creates as many columns as fit\n- **`.fixed(CGFloat)`**: Fixed width columns\n\n### Column Configurations:\n```swift\n// Three equal columns\nlet threeColumns = [\n    GridItem(.flexible()),\n    GridItem(.flexible()),\n    GridItem(.flexible())\n]\n\n// Responsive columns (2-4 based on screen size)\nlet responsiveColumns = [\n    GridItem(.adaptive(minimum: 150))\n]\n\n// Mixed column types\nlet mixedColumns = [\n    GridItem(.fixed(100)),    // Fixed sidebar\n    GridItem(.flexible()),    // Flexible content\n    GridItem(.fixed(80))      // Fixed actions\n]\n```\n\n## 3. LazyHGrid - Horizontal Grids (45 min)\n\n### Basic LazyHGrid Structure:\n```swift\nLazyHGrid(rows: rows, alignment: .center, spacing: 15) {\n    ForEach(items, id: \\.self) { item in\n        ItemView(item: item)\n    }\n}\n```\n\n### Row Configurations:\n```swift\n// Two equal rows\nlet twoRows = [\n    GridItem(.flexible()),\n    GridItem(.flexible())\n]\n\n// Fixed height rows\nlet fixedRows = [\n    GridItem(.fixed(80)),\n    GridItem(.fixed(120)),\n    GridItem(.fixed(80))\n]\n```\n\n## 4. Advanced Grid Features (45 min)\n\n### Grid Alignment Options:\n```swift\n// Different alignments for different use cases\nLazyVGrid(columns: columns, alignment: .leading)  // Left-aligned\nLazyVGrid(columns: columns, alignment: .trailing) // Right-aligned\nLazyVGrid(columns: columns, alignment: .center)   // Center-aligned\n```\n\n### Pinned Views (Headers/Footers):\n```swift\nLazyVGrid(columns: columns, pinnedViews: [.sectionHeaders]) {\n    Section(header: HeaderView()) {\n        ForEach(items) { item in\n            ItemView(item: item)\n        }\n    }\n}\n```\n\n## 5. Responsive Design Patterns (60 min)\n\n### Adaptive Layouts:\n```swift\n@State private var gridColumns = [GridItem(.adaptive(minimum: 160))]\n\nvar body: some View {\n    LazyVGrid(columns: gridColumns) {\n        ForEach(items) { item in\n            ItemView(item: item)\n        }\n    }\n    .onAppear {\n        // Adjust based on screen size\n        updateGridLayout()\n    }\n}\n```\n\n### Orientation Changes:\n```swift\n// Detect orientation changes\n@State private var isLandscape = false\n\nprivate var gridLayout: [GridItem] {\n    if isLandscape {\n        return [GridItem(.adaptive(minimum: 200))]\n    } else {\n        return [GridItem(.adaptive(minimum: 160))]\n    }\n}\n```\n\n## 6. Performance Optimization (30 min)\n\n### Why Lazy Grids?\n- **Memory Efficient**: Only create visible views\n- **Fast Scrolling**: Smooth performance with large datasets\n- **Dynamic Loading**: Load data as user scrolls\n\n### Best Practices:\n```swift\n// Good: Lazy loading with identifiable data\nLazyVGrid(columns: columns) {\n    ForEach(items, id: \\.id) { item in\n        ItemView(item: item)\n            .onAppear { loadMoreIfNeeded(item) }\n    }\n}\n\n// Avoid: Complex views in grid cells\nLazyVGrid(columns: columns) {\n    ForEach(items) { item in\n        // Keep grid cells simple!\n        SimpleItemView(item: item)\n    }\n}\n```\n\n## 7. Real-World Examples (30 min)\n\n### Photo Gallery:\n```swift\nstruct PhotoGallery: View {\n    let photos: [Photo]\n    let columns = [GridItem(.adaptive(minimum: 100))]\n    \n    var body: some View {\n        ScrollView {\n            LazyVGrid(columns: columns, spacing: 2) {\n                ForEach(photos) { photo in\n                    AsyncImage(url: photo.url) { image in\n                        image.resizable().scaledToFill()\n                    } placeholder: {\n                        Color.gray\n                    }\n                    .frame(height: 100)\n                    .clipped()\n                }\n            }\n        }\n    }\n}\n```\n\n### Dashboard Layout:\n```swift\nstruct Dashboard: View {\n    let stats: [StatItem]\n    let columns = [\n        GridItem(.flexible()),\n        GridItem(.flexible())\n    ]\n    \n    var body: some View {\n        LazyVGrid(columns: columns, spacing: 16) {\n            ForEach(stats) { stat in\n                StatCard(stat: stat)\n                    .frame(height: 120)\n            }\n        }\n        .padding()\n    }\n}\n```",
      "codeExample": "import SwiftUI\n\n// === BASIC GRID EXAMPLES ===\n\n// 1. Simple 3-column grid\nlet threeColumnGrid = [\n    GridItem(.flexible()),\n    GridItem(.flexible()),\n    GridItem(.flexible())\n]\n\n// 2. Adaptive grid (responsive)\nlet adaptiveGrid = [GridItem(.adaptive(minimum: 100))]\n\n// 3. Mixed grid with fixed and flexible items\nlet mixedGrid = [\n    GridItem(.fixed(120)),\n    GridItem(.flexible()),\n    GridItem(.fixed(80))\n]\n\n// 4. Horizontal grid rows\nlet horizontalGridRows = [\n    GridItem(.fixed(60)),\n    GridItem(.fixed(60)),\n    GridItem(.fixed(60))\n]\n\n// === COMPREHENSIVE EXAMPLE: PRODUCT GRID ===\n\nstruct Product: Identifiable {\n    let id = UUID()\n    let name: String\n    let price: Double\n    let imageName: String\n    let category: String\n}\n\nstruct ProductGridView: View {\n    let products: [Product]\n    \n    // Responsive grid that adapts to screen size\n    @State private var gridColumns = [GridItem(.adaptive(minimum: 160))]\n    \n    var body: some View {\n        ScrollView {\n            LazyVGrid(columns: gridColumns, spacing: 16) {\n                ForEach(products) { product in\n                    ProductCard(product: product)\n                }\n            }\n            .padding()\n        }\n        .navigationTitle(\"Products\")\n    }\n}\n\nstruct ProductCard: View {\n    let product: Product\n    \n    var body: some View {\n        VStack(alignment: .leading, spacing: 8) {\n            // Image placeholder\n            Rectangle()\n                .fill(Color.blue.opacity(0.2))\n                .frame(height: 120)\n                .overlay(\n                    Text(product.imageName)\n                        .foregroundColor(.blue)\n                )\n            \n            VStack(alignment: .leading, spacing: 4) {\n                Text(product.name)\n                    .font(.headline)\n                    .lineLimit(2)\n                \n                Text(product.category)\n                    .font(.caption)\n                    .foregroundColor(.secondary)\n                \n                Text(\"$\\(product.price, specifier: \"%.2f\")\")\n                    .font(.subheadline)\n                    .fontWeight(.semibold)\n                    .foregroundColor(.green)\n            }\n            .padding(.horizontal, 8)\n            .padding(.bottom, 8)\n        }\n        .background(Color(.systemBackground))\n        .cornerRadius(12)\n        .shadow(color: .black.opacity(0.1), radius: 2, x: 0, y: 1)\n    }\n}\n\n// === DASHBOARD LAYOUT EXAMPLE ===\n\nstruct StatItem: Identifiable {\n    let id = UUID()\n    let title: String\n    let value: String\n    let icon: String\n    let color: Color\n}\n\nstruct DashboardView: View {\n    let stats: [StatItem]\n    \n    // 2-column grid for dashboard\n    let dashboardColumns = [\n        GridItem(.flexible()),\n        GridItem(.flexible())\n    ]\n    \n    var body: some View {\n        ScrollView {\n            VStack(spacing: 20) {\n                // Stats grid\n                LazyVGrid(columns: dashboardColumns, spacing: 16) {\n                    ForEach(stats) { stat in\n                        StatCard(stat: stat)\n                    }\n                }\n                .padding(.horizontal)\n                \n                // Recent activity (horizontal scroll)\n                VStack(alignment: .leading) {\n                    Text(\"Recent Activity\")\n                        .font(.headline)\n                        .padding(.horizontal)\n                    \n                    ScrollView(.horizontal, showsIndicators: false) {\n                        LazyHGrid(rows: [GridItem(.fixed(100))], spacing: 12) {\n                            ForEach(1...10, id: \\.self) { index in\n                                ActivityCard(index: index)\n                                    .frame(width: 120)\n                            }\n                        }\n                        .padding(.horizontal)\n                    }\n                }\n            }\n        }\n    }\n}\n\nstruct StatCard: View {\n    let stat: StatItem\n    \n    var body: some View {\n        VStack(spacing: 12) {\n            Image(systemName: stat.icon)\n                .font(.title2)\n                .foregroundColor(stat.color)\n            \n            Text(stat.value)\n                .font(.title2)\n                .fontWeight(.bold)\n            \n            Text(stat.title)\n                .font(.caption)\n                .foregroundColor(.secondary)\n                .multilineTextAlignment(.center)\n        }\n        .frame(maxWidth: .infinity)\n        .padding()\n        .background(Color(.systemBackground))\n        .cornerRadius(12)\n        .shadow(color: .black.opacity(0.05), radius: 3, x: 0, y: 1)\n    }\n}\n\nstruct ActivityCard: View {\n    let index: Int\n    \n    var body: some View {\n        VStack {\n            Circle()\n                .fill(Color.orange.opacity(0.2))\n                .frame(width: 50, height: 50)\n                .overlay(\n                    Text(\"\\(index)\")\n                        .fontWeight(.medium)\n                )\n            \n            Text(\"Activity \\(index)\")\n                .font(.caption)\n                .multilineTextAlignment(.center)\n        }\n        .padding()\n        .background(Color(.systemBackground))\n        .cornerRadius(8)\n    }\n}\n\n// === PREVIEW DATA ===\n\nlet sampleProducts = [\n    Product(name: \"Wireless Headphones\", price: 199.99, imageName: \"headphones\", category: \"Audio\"),\n    Product(name: \"Smart Watch\", price: 299.99, imageName: \"watch\", category: \"Wearables\"),\n    Product(name: \"Laptop Stand\", price: 49.99, imageName: \"stand\", category: \"Accessories\"),\n    Product(name: \"Mechanical Keyboard\", price: 129.99, imageName: \"keyboard\", category: \"Accessories\"),\n    Product(name: \"Gaming Mouse\", price: 79.99, imageName: \"mouse\", category: \"Accessories\"),\n    Product(name: \"USB-C Hub\", price: 39.99, imageName: \"hub\", category: \"Accessories\")\n]\n\nlet sampleStats = [\n    StatItem(title: \"Total Users\", value: \"1,234\", icon: \"person.2.fill\", color: .blue),\n    StatItem(title: \"Revenue\", value: \"$12,345\", icon: \"dollarsign.circle.fill\", color: .green),\n    StatItem(title: \"Orders\", value: \"456\", icon: \"cart.fill\", color: .orange),\n    StatItem(title: \"Growth\", value: \"+12.5%\", icon: \"chart.line.uptrend.xyaxis\", color: .purple)\n]",
      "category": "SwiftUI Layout",
      "estimatedTime": 240,
      "dependencies": ["variables"],
      "challenge": {
        "instructions": "Create a comprehensive photo gallery app with multiple grid layouts:\n\nPART 1: Basic Photo Grid (60 min)\n1. Create a LazyVGrid with adaptive columns (minimum 120 points)\n2. Display 20 sample photos with placeholder colors\n3. Add consistent spacing (8 points) and padding\n4. Make the grid responsive to different screen sizes\n\nPART 2: Grid Layout Selector (45 min)\n5. Create a segmented picker with 3 layout options: 2-column, 3-column, adaptive\n6. Implement state management to switch between grid layouts\n7. Add smooth animations when changing layouts\n\nPART 3: Horizontal Category Grid (45 min)\n8. Create a LazyHGrid for photo categories above the main grid\n9. Each category should be a pill-shaped button\n10. Implement category filtering when a category is tapped\n\nPART 4: Advanced Features (60 min)\n11. Add a search bar that filters photos by name\n12. Implement a grid/list toggle switch\n13. Add pull-to-refresh functionality\n14. Create a detail view that opens when a photo is tapped\n\nPART 5: Performance & Polish (30 min)\n15. Optimize grid performance with identifiable data\n16. Add loading states and empty states\n17. Implement proper error handling\n18. Add accessibility labels to grid items",
        "starterCode": "import SwiftUI\n\nstruct Photo: Identifiable {\n    let id = UUID()\n    let name: String\n    let category: String\n    let color: Color\n}\n\nstruct PhotoGalleryView: View {\n    let samplePhotos = [\n        // Add 20 sample photos here with different colors and categories\n    ]\n    \n    // Add your state variables here\n    \n    var body: some View {\n        // Implement your photo gallery here\n        Text(\"Implement Photo Gallery\")\n    }\n}\n\n// Add supporting views here\n\nstruct PhotoGalleryView_Previews: PreviewProvider {\n    static var previews: some View {\n        PhotoGalleryView()\n    }\n}",
        "solution": "import SwiftUI\n\nstruct Photo: Identifiable {\n    let id = UUID()\n    let name: String\n    let category: String\n    let color: Color\n}\n\nstruct PhotoGalleryView: View {\n    let samplePhotos = [\n        Photo(name: \"Sunset\", category: \"Nature\", color: .orange),\n        Photo(name: \"Mountain\", category: \"Nature\", color: .green),\n        Photo(name: \"Beach\", category: \"Travel\", color: .blue),\n        Photo(name: \"City\", category: \"Urban\", color: .gray),\n        Photo(name: \"Forest\", category: \"Nature\", color: .green),\n        Photo(name: \"Food\", category: \"Lifestyle\", color: .red),\n        Photo(name: \"Architecture\", category: \"Urban\", color: .brown),\n        Photo(name: \"Portrait\", category: \"People\", color: .purple),\n        Photo(name: \"Abstract\", category: \"Art\", color: .pink),\n        Photo(name: \"Wildlife\", category: \"Nature\", color: .yellow),\n        Photo(name: \"Night\", category: \"Urban\", color: .black),\n        Photo(name: \"Macro\", category: \"Nature\", color: .green),\n        Photo(name: \"Street\", category: \"Urban\", color: .gray),\n        Photo(name: \"Sports\", category: \"Action\", color: .red),\n        Photo(name: \"Concert\", category: \"Events\", color: .purple),\n        Photo(name: \"Wedding\", category: \"Events\", color: .white),\n        Photo(name: \"Product\", category: \"Commercial\", color: .blue),\n        Photo(name: \"Fashion\", category: \"Lifestyle\", color: .pink),\n        Photo(name: \"Aerial\", category: \"Travel\", color: .cyan),\n        Photo(name: \"Black & White\", category: \"Art\", color: .gray)\n    ]\n    \n    @State private var selectedLayout: GridLayout = .adaptive\n    @State private var selectedCategory: String? = nil\n    @State private var searchText = \"\"\n    @State private var isGridView = true\n    @State private var isRefreshing = false\n    @State private var selectedPhoto: Photo?\n    \n    enum GridLayout: CaseIterable {\n        case twoColumn, threeColumn, adaptive\n        \n        var columns: [GridItem] {\n            switch self {\n            case .twoColumn:\n                return [GridItem(.flexible()), GridItem(.flexible())]\n            case .threeColumn:\n                return [GridItem(.flexible()), GridItem(.flexible()), GridItem(.flexible())]\n            case .adaptive:\n                return [GridItem(.adaptive(minimum: 120))]\n            }\n        }\n        \n        var title: String {\n            switch self {\n            case .twoColumn: return \"2 Columns\"\n            case .threeColumn: return \"3 Columns\"\n            case .adaptive: return \"Adaptive\"\n            }\n        }\n    }\n    \n    var categories: [String] {\n        Array(Set(samplePhotos.map { $0.category })).sorted()\n    }\n    \n    var filteredPhotos: [Photo] {\n        var filtered = samplePhotos\n        \n        // Filter by category\n        if let category = selectedCategory {\n            filtered = filtered.filter { $0.category == category }\n        }\n        \n        // Filter by search text\n        if !searchText.isEmpty {\n            filtered = filtered.filter { $0.name.localizedCaseInsensitiveContains(searchText) }\n        }\n        \n        return filtered\n    }\n    \n    var body: some View {\n        NavigationView {\n            VStack(spacing: 0) {\n                // Search Bar\n                HStack {\n                    Image(systemName: \"magnifyingglass\")\n                        .foregroundColor(.secondary)\n                    TextField(\"Search photos...\", text: $searchText)\n                    if !searchText.isEmpty {\n                        Button(action: { searchText = \"\" }) {\n                            Image(systemName: \"xmark.circle.fill\")\n                                .foregroundColor(.secondary)\n                        }\n                    }\n                }\n                .padding(8)\n                .background(Color(.systemGray6))\n                .cornerRadius(8)\n                .padding(.horizontal)\n                .padding(.top, 8)\n                \n                // Category Horizontal Grid\n                ScrollView(.horizontal, showsIndicators: false) {\n                    LazyHGrid(rows: [GridItem(.fixed(40))], spacing: 8) {\n                        ForEach(categories, id: \\.self) { category in\n                            CategoryPill(\n                                category: category,\n                                isSelected: selectedCategory == category,\n                                action: {\n                                    selectedCategory = selectedCategory == category ? nil : category\n                                }\n                            )\n                        }\n                    }\n                    .padding(.horizontal)\n                }\n                .padding(.vertical, 8)\n                \n                // Layout Controls\n                HStack {\n                    Picker(\"Layout\", selection: $selectedLayout) {\n                        ForEach(GridLayout.allCases, id: \\.self) { layout in\n                            Text(layout.title).tag(layout)\n                        }\n                    }\n                    .pickerStyle(SegmentedPickerStyle())\n                    \n                    Button(action: { isGridView.toggle() }) {\n                        Image(systemName: isGridView ? \"square.grid.2x2\" : \"list.bullet\")\n                            .font(.title3)\n                    }\n                }\n                .padding(.horizontal)\n                .padding(.bottom, 8)\n                \n                // Main Content\n                if filteredPhotos.isEmpty {\n                    VStack {\n                        Image(systemName: \"photo.on.rectangle\")\n                            .font(.system(size: 60))\n                            .foregroundColor(.secondary)\n                        Text(\"No photos found\")\n                            .font(.headline)\n                            .foregroundColor(.secondary)\n                    }\n                    .frame(maxWidth: .infinity, maxHeight: .infinity)\n                } else {\n                    ScrollView {\n                        if isGridView {\n                            LazyVGrid(columns: selectedLayout.columns, spacing: 12) {\n                                ForEach(filteredPhotos) { photo in\n                                    PhotoGridItem(photo: photo)\n                                        .onTapGesture {\n                                            selectedPhoto = photo\n                                        }\n                                        .accessibilityLabel(photo.name)\n                                        .accessibilityHint(\"Double tap to view details\")\n                                }\n                            }\n                            .padding()\n                        } else {\n                            LazyVStack(spacing: 12) {\n                                ForEach(filteredPhotos) { photo in\n                                    PhotoListItem(photo: photo)\n                                        .onTapGesture {\n                                            selectedPhoto = photo\n                                        }\n                                }\n                            }\n                            .padding()\n                        }\n                    }\n                    .refreshable {\n                        await refreshData()\n                    }\n                }\n            }\n            .navigationTitle(\"Photo Gallery\")\n            .sheet(item: $selectedPhoto) { photo in\n                PhotoDetailView(photo: photo)\n            }\n        }\n        .animation(.spring(response: 0.3), value: selectedLayout)\n        .animation(.easeInOut, value: isGridView)\n        .animation(.easeInOut, value: filteredPhotos)\n    }\n    \n    private func refreshData() async {\n        isRefreshing = true\n        // Simulate network request\n        try? await Task.sleep(nanoseconds: 1_000_000_000)\n        isRefreshing = false\n    }\n}\n\nstruct CategoryPill: View {\n    let category: String\n    let isSelected: Bool\n    let action: () -> Void\n    \n    var body: some View {\n        Button(action: action) {\n            Text(category)\n                .font(.caption)\n                .fontWeight(.medium)\n                .padding(.horizontal, 12)\n                .padding(.vertical, 6)\n                .background(isSelected ? Color.blue : Color(.systemGray5))\n                .foregroundColor(isSelected ? .white : .primary)\n                .cornerRadius(16)\n        }\n        .buttonStyle(PlainButtonStyle())\n    }\n}\n\nstruct PhotoGridItem: View {\n    let photo: Photo\n    \n    var body: some View {\n        Rectangle()\n            .fill(photo.color)\n            .aspectRatio(1, contentMode: .fill)\n            .overlay(\n                VStack {\n                    Spacer()\n                    HStack {\n                        Text(photo.name)\n                            .font(.caption)\n                            .fontWeight(.medium)\n                            .foregroundColor(.white)\n                            .padding(4)\n                            .background(Color.black.opacity(0.7))\n                            .cornerRadius(4)\n                        Spacer()\n                    }\n                    .padding(4)\n                }\n            )\n            .cornerRadius(8)\n    }\n}\n\nstruct PhotoListItem: View {\n    let photo: Photo\n    \n    var body: some View {\n        HStack(spacing: 12) {\n            Rectangle()\n                .fill(photo.color)\n                .frame(width: 60, height: 60)\n                .cornerRadius(8)\n            \n            VStack(alignment: .leading, spacing: 4) {\n                Text(photo.name)\n                    .font(.headline)\n                Text(photo.category)\n                    .font(.caption)\n                    .foregroundColor(.secondary)\n            }\n            \n            Spacer()\n            \n            Image(systemName: \"chevron.right\")\n                .foregroundColor(.secondary)\n        }\n        .padding(.vertical, 4)\n    }\n}\n\nstruct PhotoDetailView: View {\n    let photo: Photo\n    @Environment(\\.dismiss) private var dismiss\n    \n    var body: some View {\n        NavigationView {\n            VStack {\n                Rectangle()\n                    .fill(photo.color)\n                    .aspectRatio(1, contentMode: .fit)\n                    .overlay(\n                        VStack {\n                            Spacer()\n                            Text(photo.name)\n                                .font(.title)\n                                .fontWeight(.bold)\n                                .foregroundColor(.white)\n                                .padding()\n                                .background(Color.black.opacity(0.7))\n                                .cornerRadius(8)\n                        }\n                        .padding()\n                    )\n                \n                HStack {\n                    VStack(alignment: .leading) {\n                        Text(\"Category\")\n                            .font(.caption)\n                            .foregroundColor(.secondary)\n                        Text(photo.category)\n                            .font(.headline)\n                    }\n                    Spacer()\n                }\n                .padding()\n                \n                Spacer()\n            }\n            .navigationBarTitleDisplayMode(.inline)\n            .toolbar {\n                ToolbarItem(placement: .navigationBarTrailing) {\n                    Button(\"Done\") {\n                        dismiss()\n                    }\n                }\n            }\n        }\n    }\n}\n\nstruct PhotoGalleryView_Previews: PreviewProvider {\n    static var previews: some View {\n        PhotoGalleryView()\n    }\n}",
        "hints": [
          "PART 1: Use LazyVGrid with [GridItem(.adaptive(minimum: 120))] for responsive columns",
          "PART 2: Create an enum for layout options and use @State to manage selection",
          "PART 3: LazyHGrid works well for horizontal scrolling categories",
          "PART 4: Combine multiple filters using && in your computed property",
          "PART 5: Use .accessibilityLabel() and .accessibilityHint() for VoiceOver support",
          "Use .animation() to smooth layout transitions",
          "Implement pull-to-refresh with .refreshable modifier",
          "Keep grid items simple for better performance"
        ],
        "testCases": [
          {
            "input": "filteredPhotos.count <= samplePhotos.count",
            "expectedOutput": "true",
            "description": "Filtered photos should never exceed total photos"
          },
          {
            "input": "categories.count > 0",
            "expectedOutput": "true",
            "description": "Should extract unique categories from photos"
          },
          {
            "input": "GridLayout.allCases.count == 3",
            "expectedOutput": "true",
            "description": "Should have three layout options"
          }
        ]
      }
    },
    {
        "id": "sheets_alerts",
        "title": "Sheets & Alerts",
        "description": "Master modal presentation, user feedback, and interactive dialogs in SwiftUI",
        "difficulty": "beginner",
        "theory": "# Sheets & Alerts - Professional UI Presentation\n\n## 1. Introduction to Modal Presentation (30 min)\n\n### What are Sheets?\nSheets are modal views that slide up from the bottom of the screen, perfect for:\n- Presenting detailed information\n- User input forms\n- Settings panels\n- Contextual actions\n\n### Key Concepts:\n- **Modal Presentation**: Takes focus until dismissed\n- **Non-Destructive**: User can cancel or complete action\n- **Contextual**: Related to the current screen content\n\n## 2. Basic Sheets Implementation (45 min)\n\n### Simple Sheet Presentation:\n```swift\n@State private var showingSheet = false\n\nvar body: some View {\n    Button(\"Show Sheet\") {\n        showingSheet = true\n    }\n    .sheet(isPresented: $showingSheet) {\n        DetailView()\n    }\n}\n```\n\n### Sheet with Custom Content:\n```swift\n.sheet(isPresented: $showSettings) {\n    NavigationView {\n        SettingsView()\n            .navigationTitle(\"Settings\")\n            .navigationBarItems(trailing: Button(\"Done\") {\n                showSettings = false\n            })\n    }\n}\n```\n\n## 3. Advanced Sheet Techniques (60 min)\n\n### Sheets with Data Binding:\n```swift\n@State private var selectedItem: Item?\n\nvar body: some View {\n    List(items) { item in\n        Text(item.name)\n            .onTapGesture {\n                selectedItem = item\n            }\n    }\n    .sheet(item: $selectedItem) { item in\n        ItemDetailView(item: item)\n    }\n}\n```\n\n### Custom Sheet Detents (iOS 16+):\n```swift\n.sheet(isPresented: $showSheet) {\n    CustomView()\n        .presentationDetents([.medium, .large])\n        .presentationDragIndicator(.visible)\n}\n```\n\n### Interactive Dismissal:\n```swift\n.sheet(isPresented: $showSheet) {\n    EditView()\n        .interactiveDismissDisabled(hasUnsavedChanges)\n}\n```\n\n## 4. Full-Screen Cover (30 min)\n\n### When to Use Full-Screen:\n- Immersive experiences\n- Login screens\n- Tutorials\n- Major workflow steps\n\n### Implementation:\n```swift\n@State private var showLogin = false\n\nvar body: some View {\n    Button(\"Login\") {\n        showLogin = true\n    }\n    .fullScreenCover(isPresented: $showLogin) {\n        LoginView()\n    }\n}\n```\n\n## 5. Alert System Fundamentals (45 min)\n\n### Basic Alert Presentation:\n```swift\n@State private var showAlert = false\n\nvar body: some View {\n    Button(\"Delete Item\") {\n        showAlert = true\n    }\n    .alert(\"Confirm Delete\", isPresented: $showAlert) {\n        Button(\"Delete\", role: .destructive) {\n            deleteItem()\n        }\n        Button(\"Cancel\", role: .cancel) { }\n    } message: {\n        Text(\"This action cannot be undone.\")\n    }\n}\n```\n\n### Alert with Dynamic Content:\n```swift\n.alert(\"Error\", isPresented: $showError) {\n    Button(\"OK\") { }\n} message: {\n    Text(errorMessage)\n}\n```\n\n## 6. Advanced Alert Patterns (60 min)\n\n### Multiple Action Alerts:\n```swift\n.alert(\"Choose Action\", isPresented: $showActionSheet) {\n    Button(\"Save\") { saveDocument() }\n    Button(\"Save As...\") { showSaveAs = true }\n    Button(\"Discard\", role: .destructive) { discardChanges() }\n    Button(\"Cancel\", role: .cancel) { }\n} message: {\n    Text(\"What would you like to do with this document?\")\n}\n```\n\n### TextField in Alerts (iOS 15+):\n```swift\n.alert(\"Rename Item\", isPresented: $showRenameAlert) {\n    TextField(\"New name\", text: $newName)\n    Button(\"Rename\") { renameItem() }\n    Button(\"Cancel\", role: .cancel) { }\n} message: {\n    Text(\"Enter a new name for this item\")\n}\n```\n\n## 7. Action Sheets vs Context Menus (30 min)\n\n### Context Menu for Multiple Options:\n```swift\nText(\"File.txt\")\n    .contextMenu {\n        Button(\"Rename\") { showRename = true }\n        Button(\"Duplicate\") { duplicateFile() }\n        Button(\"Share\") { showShareSheet = true }\n        Button(\"Delete\", role: .destructive) { showDeleteAlert = true }\n    }\n```\n\n## 8. Custom Modal Presentations (40 min)\n\n### Custom Sheet Styles:\n```swift\n.sheet(isPresented: $showCustomSheet) {\n    CustomModalView()\n        .background(BackgroundBlurView())\n        .cornerRadius(20)\n        .shadow(radius: 10)\n}\n```\n\n### Half-Modal Presentation:\n```swift\nZStack {\n    // Main content\n    \n    if showHalfModal {\n        HalfModalView()\n            .transition(.move(edge: .bottom))\n            .animation(.spring(), value: showHalfModal)\n    }\n}\n```\n\n## 9. State Management for Modals (30 min)\n\n### Centralized Modal State:\n```swift\nclass ModalManager: ObservableObject {\n    @Published var activeModal: ActiveModal?\n    \n    enum ActiveModal {\n        case settings, profile, createPost, search\n    }\n}\n\n// Usage:\n.sheet(item: $modalManager.activeModal) { modal in\n    switch modal {\n    case .settings: SettingsView()\n    case .profile: ProfileView()\n    case .createPost: CreatePostView()\n    case .search: SearchView()\n    }\n}\n```\n\n## 10. Best Practices & User Experience (30 min)\n\n### When to Use Each Presentation Type:\n- **Sheets**: Forms, settings, detailed views\n- **Alerts**: Critical information, confirmations\n- **Full-Screen Cover**: Major workflow changes\n- **Context Menus**: Quick actions on specific items\n\n### Accessibility Considerations:\n- Provide clear dismissal options\n- Ensure proper focus management\n- Support VoiceOver navigation\n- Consider reduced motion preferences\n\n## Practice Exercises\n\nComplete all exercises to master modal presentation patterns!",
        "codeExample": "import SwiftUI\n\n// === SHEET EXAMPLES ===\n\n// 1. Basic Sheet\nstruct BasicSheetExample: View {\n    @State private var showSimpleSheet = false\n    \n    var body: some View {\n        Button(\"Show Simple Sheet\") {\n            showSimpleSheet = true\n        }\n        .sheet(isPresented: $showSimpleSheet) {\n            VStack {\n                Text(\"This is a simple sheet\")\n                    .font(.title2)\n                Button(\"Dismiss\") {\n                    showSimpleSheet = false\n                }\n                .buttonStyle(.borderedProminent)\n            }\n            .padding()\n        }\n    }\n}\n\n// 2. Sheet with Navigation\nstruct SettingsSheet: View {\n    @Binding var isPresented: Bool\n    @State private var username = \"\"\n    @State private var notificationsEnabled = true\n    \n    var body: some View {\n        NavigationView {\n            Form {\n                Section(\"Account\") {\n                    TextField(\"Username\", text: $username)\n                    Toggle(\"Notifications\", isOn: $notificationsEnabled)\n                }\n                \n                Section(\"Preferences\") {\n                    Toggle(\"Dark Mode\", isOn: .constant(false))\n                    Toggle(\"Auto-save\", isOn: .constant(true))\n                }\n            }\n            .navigationTitle(\"Settings\")\n            .navigationBarItems(\n                leading: Button(\"Cancel\") {\n                    isPresented = false\n                },\n                trailing: Button(\"Save\") {\n                    // Save settings\n                    isPresented = false\n                }\n            )\n        }\n    }\n}\n\n// 3. Sheet with Item Binding\nstruct Item: Identifiable {\n    let id = UUID()\n    let name: String\n    let description: String\n}\n\nstruct ItemDetailSheet: View {\n    let item: Item\n    \n    var body: some View {\n        VStack(alignment: .leading, spacing: 20) {\n            Text(item.name)\n                .font(.largeTitle)\n            \n            Text(item.description)\n                .foregroundColor(.secondary)\n            \n            Spacer()\n        }\n        .padding()\n    }\n}\n\n// === ALERT EXAMPLES ===\n\n// 1. Basic Alert\nstruct BasicAlertExample: View {\n    @State private var showAlert = false\n    \n    var body: some View {\n        Button(\"Show Alert\") {\n            showAlert = true\n        }\n        .alert(\"Important Message\", isPresented: $showAlert) {\n            Button(\"OK\") { }\n            Button(\"Cancel\", role: .cancel) { }\n        } message: {\n            Text(\"Please read this important information.\")\n        }\n    }\n}\n\n// 2. Destructive Action Alert\nstruct DeleteAlertExample: View {\n    @State private var showDeleteAlert = false\n    \n    var body: some View {\n        Button(\"Delete Account\") {\n            showDeleteAlert = true\n        }\n        .alert(\"Delete Account\", isPresented: $showDeleteAlert) {\n            Button(\"Delete\", role: .destructive) {\n                // Perform deletion\n            }\n            Button(\"Cancel\", role: .cancel) { }\n        } message: {\n            Text(\"This will permanently delete your account and all data. This action cannot be undone.\")\n        }\n    }\n}\n\n// 3. TextField Alert (iOS 15+)\nstruct TextFieldAlertExample: View {\n    @State private var showRenameAlert = false\n    @State private var newName = \"\"\n    \n    var body: some View {\n        Button(\"Rename Item\") {\n            showRenameAlert = true\n        }\n        .alert(\"Rename Item\", isPresented: $showRenameAlert) {\n            TextField(\"New name\", text: $newName)\n            Button(\"Rename\") {\n                // Perform rename\n            }\n            Button(\"Cancel\", role: .cancel) { }\n        } message: {\n            Text(\"Enter a new name for this item\")\n        }\n    }\n}\n\n// === COMPREHENSIVE EXAMPLE ===\n\nstruct ContentView: View {\n    @State private var showSettings = false\n    @State private var selectedItem: Item?\n    @State private var showDeleteAlert = false\n    @State private var showActionSheet = false\n    \n    let items = [\n        Item(name: \"Document 1\", description: \"Important project file\"),\n        Item(name: \"Photo Album\", description: \"Vacation photos\"),\n        Item(name: \"Notes\", description: \"Meeting notes from Monday\")\n    ]\n    \n    var body: some View {\n        NavigationView {\n            List {\n                Section {\n                    Button(\"Settings\") {\n                        showSettings = true\n                    }\n                    \n                    Button(\"Show Action Options\") {\n                        showActionSheet = true\n                    }\n                }\n                \n                Section(\"Items\") {\n                    ForEach(items) { item in\n                        Text(item.name)\n                            .onTapGesture {\n                                selectedItem = item\n                            }\n                            .contextMenu {\n                                Button(\"Rename\") {\n                                    selectedItem = item\n                                }\n                                Button(\"Delete\", role: .destructive) {\n                                    showDeleteAlert = true\n                                }\n                            }\n                    }\n                }\n            }\n            .navigationTitle(\"Modal Examples\")\n        }\n        \n        // Sheets\n        .sheet(isPresented: $showSettings) {\n            SettingsSheet(isPresented: $showSettings)\n        }\n        \n        .sheet(item: $selectedItem) { item in\n            NavigationView {\n                ItemDetailSheet(item: item)\n                    .navigationTitle(item.name)\n                    .navigationBarItems(trailing: Button(\"Done\") {\n                        selectedItem = nil\n                    })\n            }\n        }\n        \n        // Alerts\n        .alert(\"Delete Item\", isPresented: $showDeleteAlert) {\n            Button(\"Delete\", role: .destructive) {\n                // Delete logic\n            }\n            Button(\"Cancel\", role: .cancel) { }\n        } message: {\n            Text(\"Are you sure you want to delete this item?\")\n        }\n        \n        .alert(\"Choose Action\", isPresented: $showActionSheet) {\n            Button(\"Save\") { }\n            Button(\"Export\") { }\n            Button(\"Share\") { }\n            Button(\"Cancel\", role: .cancel) { }\n        } message: {\n            Text(\"What would you like to do?\")\n        }\n    }\n}",
        "category": "SwiftUI Beginner",
        "estimatedTime": 240,
        "dependencies": ["variables"],
        "challenge": {
            "instructions": "Create a Task Management app with comprehensive modal presentations:\n\nPART 1: Task List with Sheets (60 min)\n1. Create a task list that shows tasks in a List\n2. Implement a sheet for adding new tasks with form fields (title, description, due date)\n3. Implement a sheet for editing existing tasks using item binding\n4. Add proper navigation bars with Done/Cancel buttons\n\nPART 2: Alert System (45 min)\n5. Create a delete confirmation alert that appears when swiping to delete\n6. Implement an alert for marking tasks as complete\n7. Add a text field alert for quick task renaming\n8. Create an alert for task completion with celebration message\n\nPART 3: Advanced Modals (60 min)\n9. Implement a settings sheet with multiple sections (appearance, notifications, data)\n10. Create a task filter sheet that allows filtering by status, date, or category\n11. Add a full-screen cover for a detailed task view mode\n12. Implement context menus on tasks for quick actions\n\nPART 4: User Experience (45 min)\n13. Add proper dismissal handling for unsaved changes\n14. Implement custom sheet detents for different modal sizes\n15. Add haptic feedback for important actions\n16. Ensure all modals are accessible and support VoiceOver\n\nPART 5: State Management (30 min)\n17. Create a ModalManager to handle multiple modal states\n18. Implement proper data flow between modals and main view\n19. Add loading states during async operations\n20. Handle errors with appropriate alert presentations",
            "starterCode": "import SwiftUI\n\n// Task model\nstruct Task: Identifiable {\n    let id = UUID()\n    var title: String\n    var description: String\n    var isCompleted: Bool\n    var dueDate: Date?\n    var priority: Priority\n    \n    enum Priority: String, CaseIterable {\n        case low, medium, high\n    }\n}\n\n// Main Task Manager View\nstruct TaskManagerView: View {\n    @State private var tasks: [Task] = []\n    \n    // Add your modal state properties here\n    \n    var body: some View {\n        NavigationView {\n            List {\n                // Task list implementation\n            }\n            .navigationTitle(\"Task Manager\")\n            .toolbar {\n                // Toolbar items\n            }\n            \n            // Add your sheets, alerts, and fullScreenCover modifiers here\n        }\n    }\n    \n    // Add your functions for task management here\n}\n\n// Add your modal views here (TaskFormView, SettingsView, etc.)\n\nstruct ContentView: View {\n    var body: some View {\n        TaskManagerView()\n    }\n}",
            "solution": "import SwiftUI\n\n// Task model\nstruct Task: Identifiable {\n    let id = UUID()\n    var title: String\n    var description: String\n    var isCompleted: Bool\n    var dueDate: Date?\n    var priority: Priority\n    \n    enum Priority: String, CaseIterable {\n        case low, medium, high\n        \n        var color: Color {\n            switch self {\n            case .low: return .green\n            case .medium: return .orange\n            case .high: return .red\n            }\n        }\n    }\n}\n\n// Modal Manager\nclass ModalManager: ObservableObject {\n    @Published var activeModal: ActiveModal?\n    \n    enum ActiveModal: Identifiable {\n        case addTask, settings, filters\n        \n        var id: String {\n            switch self {\n            case .addTask: return \"addTask\"\n            case .settings: return \"settings\"\n            case .filters: return \"filters\"\n            }\n        }\n    }\n}\n\n// Main Task Manager View\nstruct TaskManagerView: View {\n    @StateObject private var modalManager = ModalManager()\n    @State private var tasks: [Task] = []\n    @State private var selectedTask: Task?\n    @State private var showDeleteAlert = false\n    @State private var taskToDelete: Task?\n    @State private var showRenameAlert = false\n    @State private var newTaskName = \"\"\n    @State private var taskToRename: Task?\n    @State private var showCompletionAlert = false\n    @State private var taskToComplete: Task?\n    @State private var showDetailView = false\n    @State private var selectedTaskForDetail: Task?\n    \n    var body: some View {\n        NavigationView {\n            List {\n                ForEach(tasks) { task in\n                    TaskRow(task: task)\n                        .onTapGesture {\n                            selectedTask = task\n                        }\n                        .contextMenu {\n                            Button(\"Mark Complete\") {\n                                taskToComplete = task\n                                showCompletionAlert = true\n                            }\n                            Button(\"Rename\") {\n                                taskToRename = task\n                                newTaskName = task.title\n                                showRenameAlert = true\n                            }\n                            Button(\"View Details\") {\n                                selectedTaskForDetail = task\n                                showDetailView = true\n                            }\n                            Button(\"Delete\", role: .destructive) {\n                                taskToDelete = task\n                                showDeleteAlert = true\n                            }\n                        }\n                        .swipeActions(edge: .trailing) {\n                            Button(role: .destructive) {\n                                taskToDelete = task\n                                showDeleteAlert = true\n                            } label: {\n                                Label(\"Delete\", systemImage: \"trash\")\n                            }\n                        }\n                        .swipeActions(edge: .leading) {\n                            Button {\n                                taskToComplete = task\n                                showCompletionAlert = true\n                            } label: {\n                                Label(\"Complete\", systemImage: \"checkmark\")\n                            }\n                            .tint(.green)\n                        }\n                }\n            }\n            .navigationTitle(\"Task Manager\")\n            .toolbar {\n                ToolbarItem(placement: .navigationBarLeading) {\n                    Menu {\n                        Button(\"Settings\") {\n                            modalManager.activeModal = .settings\n                        }\n                        Button(\"Filters\") {\n                            modalManager.activeModal = .filters\n                        }\n                    } label: {\n                        Image(systemName: \"ellipsis.circle\")\n                    }\n                }\n                \n                ToolbarItem(placement: .navigationBarTrailing) {\n                    Button(\"Add Task\") {\n                        modalManager.activeModal = .addTask\n                    }\n                }\n            }\n        }\n        \n        // Sheets\n        .sheet(item: $modalManager.activeModal) { modal in\n            switch modal {\n            case .addTask:\n                TaskFormView(onSave: { newTask in\n                    tasks.append(newTask)\n                    modalManager.activeModal = nil\n                }, onCancel: {\n                    modalManager.activeModal = nil\n                })\n                \n            case .settings:\n                SettingsView(isPresented: .init(\n                    get: { modalManager.activeModal == .settings },\n                    set: { if !$0 { modalManager.activeModal = nil } }\n                ))\n                \n            case .filters:\n                FilterView(isPresented: .init(\n                    get: { modalManager.activeModal == .filters },\n                    set: { if !$0 { modalManager.activeModal = nil } }\n                ))\n            }\n        }\n        \n        .sheet(item: $selectedTask) { task in\n            NavigationView {\n                TaskFormView(task: task, onSave: { updatedTask in\n                    if let index = tasks.firstIndex(where: { $0.id == updatedTask.id }) {\n                        tasks[index] = updatedTask\n                    }\n                    selectedTask = nil\n                }, onCancel: {\n                    selectedTask = nil\n                })\n                .navigationTitle(\"Edit Task\")\n            }\n        }\n        \n        // Full Screen Cover\n        .fullScreenCover(item: $selectedTaskForDetail) { task in\n            NavigationView {\n                TaskDetailView(task: task) {\n                    selectedTaskForDetail = nil\n                }\n                .navigationTitle(\"Task Details\")\n                .navigationBarItems(trailing: Button(\"Done\") {\n                    selectedTaskForDetail = nil\n                })\n            }\n        }\n        \n        // Alerts\n        .alert(\"Delete Task\", isPresented: $showDeleteAlert) {\n            Button(\"Delete\", role: .destructive) {\n                if let task = taskToDelete {\n                    deleteTask(task)\n                }\n            }\n            Button(\"Cancel\", role: .cancel) {\n                taskToDelete = nil\n            }\n        } message: {\n            Text(\"Are you sure you want to delete this task? This action cannot be undone.\")\n        }\n        \n        .alert(\"Rename Task\", isPresented: $showRenameAlert) {\n            TextField(\"New name\", text: $newTaskName)\n            Button(\"Rename\") {\n                if let task = taskToRename {\n                    renameTask(task, to: newTaskName)\n                }\n            }\n            Button(\"Cancel\", role: .cancel) {\n                taskToRename = nil\n                newTaskName = \"\"\n            }\n        } message: {\n            Text(\"Enter a new name for this task\")\n        }\n        \n        .alert(\"Task Completed!\", isPresented: $showCompletionAlert) {\n            Button(\"Great!\") {\n                if let task = taskToComplete {\n                    markTaskComplete(task)\n                }\n            }\n            Button(\"Not Yet\", role: .cancel) {\n                taskToComplete = nil\n            }\n        } message: {\n            Text(\"Congratulations on completing your task! ðŸŽ‰\")\n        }\n    }\n    \n    // Task Management Functions\n    private func deleteTask(_ task: Task) {\n        tasks.removeAll { $0.id == task.id }\n        taskToDelete = nil\n        // Haptic feedback\n        let impact = UIImpactFeedbackGenerator(style: .heavy)\n        impact.impactOccurred()\n    }\n    \n    private func renameTask(_ task: Task, to newName: String) {\n        if let index = tasks.firstIndex(where: { $0.id == task.id }) {\n            tasks[index].title = newName\n        }\n        taskToRename = nil\n        newTaskName = \"\"\n    }\n    \n    private func markTaskComplete(_ task: Task) {\n        if let index = tasks.firstIndex(where: { $0.id == task.id }) {\n            tasks[index].isCompleted = true\n        }\n        taskToComplete = nil\n        // Haptic feedback\n        let notification = UINotificationFeedbackGenerator()\n        notification.notificationOccurred(.success)\n    }\n}\n\n// Supporting Views (TaskFormView, SettingsView, FilterView, TaskDetailView, TaskRow)\n// ... Additional view implementations would go here ...\n\nstruct ContentView: View {\n    var body: some View {\n        TaskManagerView()\n    }\n}",
            "hints": [
                "PART 1: Use @State for modal presentation booleans and @StateObject for ModalManager",
                "PART 2: Implement alerts for destructive actions and use appropriate roles (.destructive, .cancel)",
                "PART 3: Use fullScreenCover for immersive experiences and sheets for forms/settings",
                "PART 4: Add interactiveDismissDisabled() for modals with unsaved changes",
                "PART 5: Create a centralized ModalManager to handle multiple modal states cleanly",
                "Use .contextMenu for quick actions and .swipeActions for swipe gestures",
                "Implement proper navigation bars in sheets with Done/Cancel buttons",
                "Add haptic feedback (UIImpactFeedbackGenerator) for important user actions",
                "Use item-based sheets (.sheet(item:)) for editing specific tasks",
                "Remember to handle optional binding properly with taskToDelete, taskToRename, etc."
            ],
            "testCases": [
                {
                    "input": "modalManager.activeModal == nil",
                    "expectedOutput": "true",
                    "description": "Modal manager should properly handle modal dismissal"
                },
                {
                    "input": "tasks.allSatisfy { $0.title != \"\" }",
                    "expectedOutput": "true",
                    "description": "All tasks should have non-empty titles"
                },
                {
                    "input": "showDeleteAlert == false && taskToDelete == nil",
                    "expectedOutput": "true",
                    "description": "Delete alert should properly reset state after action"
                }
            ]
        }
    },
    {
      "id": "tabview_app_structure",
      "title": "TabView & App Structure",
      "description": "Master multi-tab applications and professional iOS app architecture",
      "difficulty": "beginner",
      "theory": "# TabView & App Structure - Building Professional iOS Apps\n\n## 1. Understanding TabView (45 min)\n\n### What is TabView?\nTabView is SwiftUI's component for creating tab-based navigation, similar to UIKit's UITabBarController. It's perfect for apps with multiple main sections.\n\n### Basic TabView Structure:\n```swift\nTabView {\n    // Tab 1\n    HomeView()\n        .tabItem {\n            Image(systemName: \"house\")\n            Text(\"Home\")\n        }\n    \n    // Tab 2\n    ProfileView()\n        .tabItem {\n            Image(systemName: \"person\")\n            Text(\"Profile\")\n        }\n}\n```\n\n### TabItem Components:\n- **Image**: SF Symbols or custom images\n- **Text**: Tab title\n- **Tag**: Optional identifier for programmatic selection\n\n## 2. TabView Customization (60 min)\n\n### Styling Options:\n```swift\nTabView {\n    // Your tabs...\n}\n.tabViewStyle(DefaultTabViewStyle())  // Default iOS style\n// .tabViewStyle(PageTabViewStyle())  // Page style (for onboarding)\n```\n\n### Badges and Indicators:\n```swift\nHomeView()\n    .tabItem {\n        Image(systemName: \"house\")\n        Text(\"Home\")\n    }\n    .badge(5)  // Show notification count\n```\n\n### Programmatic Tab Selection:\n```swift\n@State private var selectedTab = 0\n\nTabView(selection: $selectedTab) {\n    HomeView()\n        .tabItem { /* ... */ }\n        .tag(0)\n    \n    ProfileView()\n        .tabItem { /* ... */ }\n        .tag(1)\n}\n\n// Change tabs programmatically\nButton(\"Go to Profile\") {\n    selectedTab = 1\n}\n```\n\n## 3. Professional App Architecture (75 min)\n\n### App Structure Patterns:\n\n**1. Single Responsibility Principle:**\n- Each tab handles one main feature\n- Separate concerns: UI, Data, Business Logic\n\n**2. Folder Structure:**\n```\nMyApp/\nâ”œâ”€â”€ Models/\nâ”œâ”€â”€ Views/\nâ”‚   â”œâ”€â”€ Home/\nâ”‚   â”œâ”€â”€ Profile/\nâ”‚   â”œâ”€â”€ Settings/\nâ”‚   â””â”€â”€ Shared/\nâ”œâ”€â”€ ViewModels/\nâ”œâ”€â”€ Services/\nâ””â”€â”€ Utilities/\n```\n\n**3. Dependency Management:**\n```swift\nclass AppState: ObservableObject {\n    @Published var user: User?\n    @Published var isLoggedIn: Bool = false\n}\n\n@main\nstruct MyApp: App {\n    @StateObject private var appState = AppState()\n    \n    var body: some Scene {\n        WindowGroup {\n            ContentView()\n                .environmentObject(appState)\n        }\n    }\n}\n```\n\n## 4. Multi-Tab Application Design (60 min)\n\n### Common Tab Patterns:\n\n**Social Media App:**\n- Home Feed\n- Search\n- Notifications\n- Profile\n- Create Post\n\n**E-commerce App:**\n- Shop\n- Cart\n- Favorites\n- Orders\n- Account\n\n**Productivity App:**\n- Today\n- Projects\n- Calendar\n- Inbox\n- Settings\n\n### Tab Best Practices:\n- 3-5 tabs maximum for mobile\n- Most important feature first\n- Use intuitive icons and labels\n- Consider user mental models\n\n## 5. Navigation Within Tabs (45 min)\n\n### Combining TabView with Navigation:\n```swift\nTabView {\n    NavigationView {\n        HomeView()\n            .navigationTitle(\"Home\")\n    }\n    .tabItem {\n        Image(systemName: \"house\")\n        Text(\"Home\")\n    }\n    \n    NavigationView {\n        ProfileView()\n            .navigationTitle(\"Profile\")\n    }\n    .tabItem {\n        Image(systemName: \"person\")\n        Text(\"Profile\")\n    }\n}\n```\n\n### Deep Linking Between Tabs:\n```swift\nclass TabCoordinator: ObservableObject {\n    @Published var selectedTab = 0\n    @Published var homeDestination: HomeDestination?\n    @Published var profileDestination: ProfileDestination?\n}\n```\n\n## 6. State Management Across Tabs (45 min)\n\n### Shared App State:\n```swift\nclass AppData: ObservableObject {\n    @Published var user: User?\n    @Published var notifications: [Notification] = []\n    @Published var cartItems: [CartItem] = []\n    \n    // Shared methods\n    func addToCart(_ item: Product) { /* ... */ }\n    func markNotificationRead(_ id: String) { /* ... */ }\n}\n```\n\n### Environment Object Usage:\n```swift\nstruct HomeView: View {\n    @EnvironmentObject var appData: AppData\n    \n    var body: some View {\n        List(appData.notifications) { notification in\n            // Display notifications\n        }\n    }\n}\n\nstruct CartView: View {\n    @EnvironmentObject var appData: AppData\n    \n    var body: some View {\n        List(appData.cartItems) { item in\n            // Display cart items\n        }\n    }\n}\n```\n\n## 7. Performance & Best Practices (30 min)\n\n### TabView Performance:\n- Views are lazy-loaded by default\n- Use `.id()` modifier if needed for resetting\n- Consider using `LazyVStack` in tab content\n\n### Memory Management:\n```swift\n// Use weak references in closures\n.onAppear {\n    [weak self] in\n    self?.loadData()\n}\n```\n\n### Accessibility:\n```swift\n.tabItem {\n    Image(systemName: \"house\")\n        .accessibilityLabel(\"Home\")\n    Text(\"Home\")\n}\n.accessibilityElement(children: .combine)\n.accessibilityHint(\"Double tap to view home screen\")\n```\n\n## Practice Project: Build a Complete Multi-Tab App\n\nYou'll create a \"Learning Tracker\" app with 4 main tabs that work together seamlessly!",
      "codeExample": "import SwiftUI\n\n// MARK: - Models\nstruct LearningItem: Identifiable, Codable {\n    let id = UUID()\n    var title: String\n    var description: String\n    var isCompleted: Bool = false\n    var timeSpent: Int = 0 // in minutes\n    var category: String\n    let createdAt: Date = Date()\n}\n\nstruct LearningGoal: Identifiable, Codable {\n    let id = UUID()\n    var title: String\n    var targetHours: Int\n    var currentHours: Int = 0\n    var deadline: Date?\n    var isActive: Bool = true\n}\n\n// MARK: - Main App Structure\n@main\nstruct LearningTrackerApp: App {\n    @StateObject private var appState = AppState()\n    \n    var body: some Scene {\n        WindowGroup {\n            MainTabView()\n                .environmentObject(appState)\n        }\n    }\n}\n\n// MARK: - App State (Shared across tabs)\nclass AppState: ObservableObject {\n    @Published var learningItems: [LearningItem] = []\n    @Published var goals: [LearningGoal] = []\n    @Published var selectedCategory: String = \"All\"\n    @Published var totalLearningTime: Int = 0\n    \n    var categories: [String] {\n        let allCategories = [\"All\"] + Array(Set(learningItems.map { $0.category }))\n        return allCategories.sorted()\n    }\n    \n    var filteredItems: [LearningItem] {\n        if selectedCategory == \"All\" {\n            return learningItems\n        } else {\n            return learningItems.filter { $0.category == selectedCategory }\n        }\n    }\n    \n    func addLearningItem(_ item: LearningItem) {\n        learningItems.append(item)\n        updateTotalTime()\n    }\n    \n    func updateTotalTime() {\n        totalLearningTime = learningItems.reduce(0) { $0 + $1.timeSpent }\n    }\n}\n\n// MARK: - Main Tab View\nstruct MainTabView: View {\n    @State private var selectedTab = 0\n    @EnvironmentObject var appState: AppState\n    \n    var body: some View {\n        TabView(selection: $selectedTab) {\n            // Tab 1: Dashboard\n            NavigationView {\n                DashboardView()\n                    .navigationTitle(\"Learning Dashboard\")\n            }\n            .tabItem {\n                Image(systemName: \"chart.bar\")\n                Text(\"Dashboard\")\n            }\n            .tag(0)\n            \n            // Tab 2: Today's Learning\n            NavigationView {\n                TodayView()\n                    .navigationTitle(\"Today's Learning\")\n            }\n            .tabItem {\n                Image(systemName: \"book\")\n                Text(\"Today\")\n            }\n            .badge(appState.learningItems.filter { !$0.isCompleted }.count)\n            .tag(1)\n            \n            // Tab 3: Goals\n            NavigationView {\n                GoalsView()\n                    .navigationTitle(\"Learning Goals\")\n            }\n            .tabItem {\n                Image(systemName: \"flag\")\n                Text(\"Goals\")\n            }\n            .tag(2)\n            \n            // Tab 4: Profile\n            NavigationView {\n                ProfileView()\n                    .navigationTitle(\"Profile\")\n            }\n            .tabItem {\n                Image(systemName: \"person\")\n                Text(\"Profile\")\n            }\n            .tag(3)\n        }\n        .accentColor(.blue) // Custom tab color\n        .onAppear {\n            // Configure tab bar appearance\n            let appearance = UITabBarAppearance()\n            appearance.configureWithOpaqueBackground()\n            UITabBar.appearance().scrollEdgeAppearance = appearance\n        }\n    }\n}\n\n// MARK: - Tab Views\nstruct DashboardView: View {\n    @EnvironmentObject var appState: AppState\n    \n    var body: some View {\n        ScrollView {\n            VStack(spacing: 20) {\n                // Stats Overview\n                HStack(spacing: 15) {\n                    StatCard(title: \"Total Time\", value: \"\\(appState.totalLearningTime)m\", color: .blue)\n                    StatCard(title: \"Items\", value: \"\\(appState.learningItems.count)\", color: .green)\n                    StatCard(title: \"Completed\", value: \"\\(appState.learningItems.filter { $0.isCompleted }.count)\", color: .orange)\n                }\n                \n                // Recent Activity\n                VStack(alignment: .leading) {\n                    Text(\"Recent Activity\")\n                        .font(.headline)\n                    \n                    ForEach(appState.learningItems.prefix(3)) { item in\n                        HStack {\n                            Image(systemName: item.isCompleted ? \"checkmark.circle.fill\" : \"circle\")\n                                .foregroundColor(item.isCompleted ? .green : .gray)\n                            Text(item.title)\n                            Spacer()\n                            Text(\"\\(item.timeSpent)m\")\n                                .foregroundColor(.secondary)\n                        }\n                        .padding(.vertical, 4)\n                    }\n                }\n                .padding()\n                .background(Color(.systemBackground))\n                .cornerRadius(10)\n                .shadow(radius: 2)\n            }\n            .padding()\n        }\n    }\n}\n\nstruct TodayView: View {\n    @EnvironmentObject var appState: AppState\n    @State private var showingAddItem = false\n    \n    var body: some View {\n        List {\n            // Category Filter\n            Picker(\"Category\", selection: $appState.selectedCategory) {\n                ForEach(appState.categories, id: \\.self) { category in\n                    Text(category).tag(category)\n                }\n            }\n            .pickerStyle(SegmentedPickerStyle())\n            \n            // Learning Items\n            ForEach(appState.filteredItems) { item in\n                HStack {\n                    VStack(alignment: .leading) {\n                        Text(item.title)\n                            .font(.headline)\n                        Text(item.description)\n                            .font(.caption)\n                            .foregroundColor(.secondary)\n                        Text(item.category)\n                            .font(.caption2)\n                            .padding(4)\n                            .background(Color.blue.opacity(0.2))\n                            .cornerRadius(4)\n                    }\n                    \n                    Spacer()\n                    \n                    VStack(alignment: .trailing) {\n                        Text(\"\\(item.timeSpent)m\")\n                        Image(systemName: item.isCompleted ? \"checkmark.circle.fill\" : \"circle\")\n                            .foregroundColor(item.isCompleted ? .green : .gray)\n                    }\n                }\n            }\n        }\n        .toolbar {\n            ToolbarItem(placement: .navigationBarTrailing) {\n                Button {\n                    showingAddItem = true\n                } label: {\n                    Image(systemName: \"plus\")\n                }\n            }\n        }\n        .sheet(isPresented: $showingAddItem) {\n            AddItemView()\n        }\n    }\n}\n\nstruct GoalsView: View {\n    @EnvironmentObject var appState: AppState\n    \n    var body: some View {\n        List {\n            ForEach(appState.goals) { goal in\n                VStack(alignment: .leading) {\n                    Text(goal.title)\n                        .font(.headline)\n                    \n                    ProgressView(value: Double(goal.currentHours), total: Double(goal.targetHours))\n                        .accentColor(.blue)\n                    \n                    HStack {\n                        Text(\"\\(goal.currentHours) / \\(goal.targetHours) hours\")\n                        Spacer()\n                        Text(\"\\(Int(Double(goal.currentHours) / Double(goal.targetHours) * 100))%\")\n                    }\n                    .font(.caption)\n                    .foregroundColor(.secondary)\n                }\n                .padding(.vertical, 8)\n            }\n        }\n    }\n}\n\nstruct ProfileView: View {\n    @EnvironmentObject var appState: AppState\n    \n    var body: some View {\n        Form {\n            Section(header: Text(\"Learning Statistics\")) {\n                HStack {\n                    Text(\"Total Learning Time\")\n                    Spacer()\n                    Text(\"\\(appState.totalLearningTime) minutes\")\n                        .foregroundColor(.secondary)\n                }\n                \n                HStack {\n                    Text(\"Items Completed\")\n                    Spacer()\n                    Text(\"\\(appState.learningItems.filter { $0.isCompleted }.count)\")\n                        .foregroundColor(.secondary)\n                }\n            }\n            \n            Section(header: Text(\"Categories\")) {\n                ForEach(appState.categories.filter { $0 != \"All\" }, id: \\.self) { category in\n                    HStack {\n                        Text(category)\n                        Spacer()\n                        Text(\"\\(appState.learningItems.filter { $0.category == category }.count) items\")\n                            .foregroundColor(.secondary)\n                    }\n                }\n            }\n        }\n    }\n}\n\n// MARK: - Supporting Views\nstruct StatCard: View {\n    let title: String\n    let value: String\n    let color: Color\n    \n    var body: some View {\n        VStack {\n            Text(value)\n                .font(.title2)\n                .fontWeight(.bold)\n                .foregroundColor(color)\n            Text(title)\n                .font(.caption)\n                .foregroundColor(.secondary)\n        }\n        .frame(maxWidth: .infinity)\n        .padding()\n        .background(Color(.systemBackground))\n        .cornerRadius(10)\n        .shadow(radius: 2)\n    }\n}\n\nstruct AddItemView: View {\n    @EnvironmentObject var appState: AppState\n    @Environment(\\.dismiss) private var dismiss\n    \n    @State private var title = \"\"\n    @State private var description = \"\"\n    @State private var timeSpent = \"\"\n    @State private var category = \"Swift\"\n    \n    let categories = [\"Swift\", \"UI/UX\", \"Algorithms\", \"Tools\", \"Other\"]\n    \n    var body: some View {\n        NavigationView {\n            Form {\n                TextField(\"Title\", text: $title)\n                TextField(\"Description\", text: $description)\n                TextField(\"Time Spent (minutes)\", text: $timeSpent)\n                    .keyboardType(.numberPad)\n                \n                Picker(\"Category\", selection: $category) {\n                    ForEach(categories, id: \\.self) { category in\n                        Text(category).tag(category)\n                    }\n                }\n            }\n            .navigationTitle(\"Add Learning Item\")\n            .toolbar {\n                ToolbarItem(placement: .navigationBarLeading) {\n                    Button(\"Cancel\") { dismiss() }\n                }\n                ToolbarItem(placement: .navigationBarTrailing) {\n                    Button(\"Save\") {\n                        saveItem()\n                        dismiss()\n                    }\n                    .disabled(title.isEmpty || timeSpent.isEmpty)\n                }\n            }\n        }\n    }\n    \n    private func saveItem() {\n        let item = LearningItem(\n            title: title,\n            description: description,\n            timeSpent: Int(timeSpent) ?? 0,\n            category: category\n        )\n        appState.addLearningItem(item)\n    }\n}",
      "category": "SwiftUI Basics",
      "estimatedTime": 240,
      "dependencies": ["variables", "optionals"],
      "challenge": {
        "instructions": "Build a complete Fitness Tracker app with 4 tabs that share data and work together seamlessly.\n\nPART 1: App Structure & Tab Setup (60 min)\n1. Create a MainTabView with 4 tabs: Dashboard, Workouts, Progress, Profile\n2. Set up proper navigation with NavigationView in each tab\n3. Add appropriate SF Symbols and labels for each tab\n4. Implement programmatic tab selection\n\nPART 2: Shared App State (45 min)\n5. Create an AppState class with @Published properties for workouts, goals, and user data\n6. Set up environment object injection in the main app\n7. Create models for Workout, FitnessGoal, and UserProfile\n\nPART 3: Dashboard Tab (45 min)\n8. Display workout statistics (total workouts, calories burned, active minutes)\n9. Show recent workout activity\n10. Add quick action buttons to start new workouts\n\nPART 4: Workouts Tab (45 min)\n11. Implement a list of workouts with filtering by type\n12. Add functionality to create new workouts\n13. Include workout details (duration, calories, type)\n\nPART 5: Data Sharing & Integration (45 min)\n14. Ensure all tabs update when new workouts are added\n15. Implement badge notifications on the Workouts tab\n16. Create computed properties in AppState for shared calculations\n\nBONUS: Advanced Features (60 min)\n17. Add deep linking between tabs\n18. Implement workout completion with progress updates\n19. Add haptic feedback for workout actions\n20. Create a settings screen in Profile tab",
        "starterCode": "import SwiftUI\n\n// MARK: - Add your models here\n\n\n// MARK: - App State\n// Create your AppState class here\n\n\n// MARK: - Main App\n@main\nstruct FitnessTrackerApp: App {\n    // Set up your app state here\n    \n    var body: some Scene {\n        WindowGroup {\n            // Set up main tab view with environment object\n        }\n    }\n}\n\n// MARK: - Main Tab View\nstruct MainTabView: View {\n    // Add tab selection state\n    \n    var body: some View {\n        // Implement your 4-tab structure here\n        Text(\"Implement tabs: Dashboard, Workouts, Progress, Profile\")\n    }\n}\n\n// MARK: - Tab Views\n// Create your 4 tab views here\n\n\n// MARK: - Supporting Views\n// Add any supporting components here",
        "solution": "import SwiftUI\n\n// MARK: - Models\nstruct Workout: Identifiable, Codable {\n    let id = UUID()\n    var name: String\n    var type: WorkoutType\n    var duration: Int // in minutes\n    var calories: Int\n    var date: Date = Date()\n    var isCompleted: Bool = false\n}\n\nstruct FitnessGoal: Identifiable, Codable {\n    let id = UUID()\n    var title: String\n    var targetWorkouts: Int\n    var currentWorkouts: Int = 0\n    var targetCalories: Int\n    var currentCalories: Int = 0\n    var deadline: Date?\n}\n\nstruct UserProfile: Codable {\n    var name: String = \"Fitness User\"\n    var weight: Double = 70.0\n    var height: Double = 170.0\n    var fitnessLevel: FitnessLevel = .beginner\n}\n\nenum WorkoutType: String, CaseIterable, Codable {\n    case running, cycling, swimming, strength, yoga, other\n}\n\nenum FitnessLevel: String, CaseIterable, Codable {\n    case beginner, intermediate, advanced\n}\n\n// MARK: - App State\nclass AppState: ObservableObject {\n    @Published var workouts: [Workout] = []\n    @Published var goals: [FitnessGoal] = []\n    @Published var userProfile = UserProfile()\n    @Published var selectedWorkoutType: WorkoutType? = nil\n    \n    // Computed properties\n    var totalWorkouts: Int { workouts.count }\n    var completedWorkouts: Int { workouts.filter { $0.isCompleted }.count }\n    var totalCalories: Int { workouts.reduce(0) { $0 + $1.calories } }\n    var totalMinutes: Int { workouts.reduce(0) { $0 + $1.duration } }\n    \n    var filteredWorkouts: [Workout] {\n        if let type = selectedWorkoutType {\n            return workouts.filter { $0.type == type }\n        }\n        return workouts\n    }\n    \n    func addWorkout(_ workout: Workout) {\n        workouts.append(workout)\n        updateGoals()\n    }\n    \n    func completeWorkout(_ workout: Workout) {\n        if let index = workouts.firstIndex(where: { $0.id == workout.id }) {\n            workouts[index].isCompleted = true\n            updateGoals()\n        }\n    }\n    \n    private func updateGoals() {\n        for i in goals.indices {\n            goals[i].currentWorkouts = completedWorkouts\n            goals[i].currentCalories = totalCalories\n        }\n    }\n}\n\n// MARK: - Main App\n@main\nstruct FitnessTrackerApp: App {\n    @StateObject private var appState = AppState()\n    \n    var body: some Scene {\n        WindowGroup {\n            MainTabView()\n                .environmentObject(appState)\n        }\n    }\n}\n\n// MARK: - Main Tab View\nstruct MainTabView: View {\n    @State private var selectedTab = 0\n    @EnvironmentObject var appState: AppState\n    \n    var body: some View {\n        TabView(selection: $selectedTab) {\n            // Dashboard Tab\n            NavigationView {\n                DashboardView()\n                    .navigationTitle(\"Fitness Dashboard\")\n            }\n            .tabItem {\n                Image(systemName: \"chart.bar\")\n                Text(\"Dashboard\")\n            }\n            .tag(0)\n            \n            // Workouts Tab\n            NavigationView {\n                WorkoutsView()\n                    .navigationTitle(\"Workouts\")\n            }\n            .tabItem {\n                Image(systemName: \"figure.run\")\n                Text(\"Workouts\")\n            }\n            .badge(appState.workouts.filter { !$0.isCompleted }.count)\n            .tag(1)\n            \n            // Progress Tab\n            NavigationView {\n                ProgressView()\n                    .navigationTitle(\"Progress\")\n            }\n            .tabItem {\n                Image(systemName: \"chart.line.uptrend.xyaxis\")\n                Text(\"Progress\")\n            }\n            .tag(2)\n            \n            // Profile Tab\n            NavigationView {\n                ProfileView()\n                    .navigationTitle(\"Profile\")\n            }\n            .tabItem {\n                Image(systemName: \"person\")\n                Text(\"Profile\")\n            }\n            .tag(3)\n        }\n        .accentColor(.green)\n    }\n}\n\n// MARK: - Tab Views\nstruct DashboardView: View {\n    @EnvironmentObject var appState: AppState\n    \n    var body: some View {\n        ScrollView {\n            VStack(spacing: 20) {\n                // Quick Stats\n                LazyVGrid(columns: [GridItem(.flexible()), GridItem(.flexible())], spacing: 15) {\n                    StatCard(title: \"Workouts\", value: \"\\(appState.totalWorkouts)\", color: .blue)\n                    StatCard(title: \"Completed\", value: \"\\(appState.completedWorkouts)\", color: .green)\n                    StatCard(title: \"Calories\", value: \"\\(appState.totalCalories)\", color: .orange)\n                    StatCard(title: \"Minutes\", value: \"\\(appState.totalMinutes)\", color: .purple)\n                }\n                \n                // Recent Activity\n                VStack(alignment: .leading) {\n                    Text(\"Recent Workouts\")\n                        .font(.headline)\n                        .padding(.horizontal)\n                    \n                    ForEach(appState.workouts.prefix(3)) { workout in\n                        WorkoutRow(workout: workout)\n                    }\n                }\n                .padding()\n                .background(Color(.systemBackground))\n                .cornerRadius(10)\n                .shadow(radius: 2)\n                \n                // Quick Actions\n                VStack(alignment: .leading) {\n                    Text(\"Quick Actions\")\n                        .font(.headline)\n                        .padding(.horizontal)\n                    \n                    HStack {\n                        ActionButton(title: \"Start Run\", icon: \"figure.run\", color: .blue)\n                        ActionButton(title: \"Add Workout\", icon: \"plus\", color: .green)\n                    }\n                }\n                .padding()\n                .background(Color(.systemBackground))\n                .cornerRadius(10)\n                .shadow(radius: 2)\n            }\n            .padding()\n        }\n    }\n}\n\nstruct WorkoutsView: View {\n    @EnvironmentObject var appState: AppState\n    @State private var showingAddWorkout = false\n    \n    var body: some View {\n        VStack {\n            // Workout Type Filter\n            ScrollView(.horizontal, showsIndicators: false) {\n                HStack {\n                    Button(\"All\") {\n                        appState.selectedWorkoutType = nil\n                    }\n                    .buttonStyle(FilterButtonStyle(isSelected: appState.selectedWorkoutType == nil))\n                    \n                    ForEach(WorkoutType.allCases, id: \\.self) { type in\n                        Button(type.rawValue.capitalized) {\n                            appState.selectedWorkoutType = type\n                        }\n                        .buttonStyle(FilterButtonStyle(isSelected: appState.selectedWorkoutType == type))\n                    }\n                }\n                .padding(.horizontal)\n            }\n            \n            // Workouts List\n            List {\n                ForEach(appState.filteredWorkouts) { workout in\n                    WorkoutRow(workout: workout)\n                }\n            }\n            .listStyle(PlainListStyle())\n        }\n        .toolbar {\n            ToolbarItem(placement: .navigationBarTrailing) {\n                Button {\n                    showingAddWorkout = true\n                } label: {\n                    Image(systemName: \"plus\")\n                }\n            }\n        }\n        .sheet(isPresented: $showingAddWorkout) {\n            AddWorkoutView()\n        }\n    }\n}\n\nstruct ProgressView: View {\n    @EnvironmentObject var appState: AppState\n    \n    var body: some View {\n        List {\n            Section(header: Text(\"Goals\")) {\n                ForEach(appState.goals) { goal in\n                    VStack(alignment: .leading) {\n                        Text(goal.title)\n                            .font(.headline)\n                        \n                        HStack {\n                            VStack(alignment: .leading) {\n                                Text(\"Workouts: \\(goal.currentWorkouts)/\\(goal.targetWorkouts)\")\n                                Text(\"Calories: \\(goal.currentCalories)/\\(goal.targetCalories)\")\n                            }\n                            \n                            Spacer()\n                            \n                            VStack {\n                                Text(\"\\(Int(Double(goal.currentWorkouts) / Double(goal.targetWorkouts) * 100))%\")\n                                    .font(.title2)\n                                    .fontWeight(.bold)\n                                Text(\"Complete\")\n                                    .font(.caption)\n                            }\n                        }\n                        .font(.caption)\n                        .foregroundColor(.secondary)\n                    }\n                    .padding(.vertical, 8)\n                }\n            }\n            \n            Section(header: Text(\"Weekly Progress\")) {\n                // Add charts or progress visualization here\n                Text(\"Progress charts would go here\")\n                    .foregroundColor(.secondary)\n            }\n        }\n    }\n}\n\nstruct ProfileView: View {\n    @EnvironmentObject var appState: AppState\n    \n    var body: some View {\n        Form {\n            Section(header: Text(\"Profile Information\")) {\n                HStack {\n                    Text(\"Name\")\n                    Spacer()\n                    Text(appState.userProfile.name)\n                        .foregroundColor(.secondary)\n                }\n                \n                HStack {\n                    Text(\"Weight\")\n                    Spacer()\n                    Text(\"\\(appState.userProfile.weight, specifier: \"%.1f\") kg\")\n                        .foregroundColor(.secondary)\n                }\n                \n                HStack {\n                    Text(\"Fitness Level\")\n                    Spacer()\n                    Text(appState.userProfile.fitnessLevel.rawValue.capitalized)\n                        .foregroundColor(.secondary)\n                }\n            }\n            \n            Section(header: Text(\"Lifetime Statistics\")) {\n                HStack {\n                    Text(\"Total Workouts\")\n                    Spacer()\n                    Text(\"\\(appState.totalWorkouts)\")\n                        .foregroundColor(.secondary)\n                }\n                \n                HStack {\n                    Text(\"Total Calories\")\n                    Spacer()\n                    Text(\"\\(appState.totalCalories)\")\n                        .foregroundColor(.secondary)\n                }\n                \n                HStack {\n                    Text(\"Total Active Minutes\")\n                    Spacer()\n                    Text(\"\\(appState.totalMinutes)\")\n                        .foregroundColor(.secondary)\n                }\n            }\n        }\n    }\n}\n\n// MARK: - Supporting Views\nstruct StatCard: View {\n    let title: String\n    let value: String\n    let color: Color\n    \n    var body: some View {\n        VStack {\n            Text(value)\n                .font(.title2)\n                .fontWeight(.bold)\n                .foregroundColor(color)\n            Text(title)\n                .font(.caption)\n                .foregroundColor(.secondary)\n        }\n        .frame(maxWidth: .infinity)\n        .padding()\n        .background(Color(.systemBackground))\n        .cornerRadius(10)\n        .shadow(radius: 2)\n    }\n}\n\nstruct WorkoutRow: View {\n    let workout: Workout\n    \n    var body: some View {\n        HStack {\n            VStack(alignment: .leading) {\n                Text(workout.name)\n                    .font(.headline)\n                Text(workout.type.rawValue.capitalized)\n                    .font(.caption)\n                    .padding(4)\n                    .background(Color.blue.opacity(0.2))\n                    .cornerRadius(4)\n            }\n            \n            Spacer()\n            \n            VStack(alignment: .trailing) {\n                Text(\"\\(workout.duration)m\")\n                Text(\"\\(workout.calories) cal\")\n                    .font(.caption)\n                    .foregroundColor(.secondary)\n            }\n        }\n        .padding(.vertical, 8)\n    }\n}\n\nstruct ActionButton: View {\n    let title: String\n    let icon: String\n    let color: Color\n    \n    var body: some View {\n        Button(action: {}) {\n            VStack {\n                Image(systemName: icon)\n                    .font(.title2)\n                Text(title)\n                    .font(.caption)\n            }\n            .foregroundColor(color)\n            .frame(maxWidth: .infinity)\n            .padding()\n            .background(color.opacity(0.1))\n            .cornerRadius(10)\n        }\n        .buttonStyle(PlainButtonStyle())\n    }\n}\n\nstruct FilterButtonStyle: ButtonStyle {\n    let isSelected: Bool\n    \n    func makeBody(configuration: Configuration) -> some View {\n        configuration.label\n            .padding(.horizontal, 12)\n            .padding(.vertical, 8)\n            .background(isSelected ? Color.blue : Color.gray.opacity(0.2))\n            .foregroundColor(isSelected ? .white : .primary)\n            .cornerRadius(8)\n    }\n}\n\nstruct AddWorkoutView: View {\n    @EnvironmentObject var appState: AppState\n    @Environment(\\.dismiss) private var dismiss\n    \n    @State private var name = \"\"\n    @State private var selectedType = WorkoutType.running\n    @State private var duration = \"\"\n    @State private var calories = \"\"\n    \n    var body: some View {\n        NavigationView {\n            Form {\n                TextField(\"Workout Name\", text: $name)\n                \n                Picker(\"Type\", selection: $selectedType) {\n                    ForEach(WorkoutType.allCases, id: \\.self) { type in\n                        Text(type.rawValue.capitalized).tag(type)\n                    }\n                }\n                \n                TextField(\"Duration (minutes)\", text: $duration)\n                    .keyboardType(.numberPad)\n                \n                TextField(\"Calories Burned\", text: $calories)\n                    .keyboardType(.numberPad)\n            }\n            .navigationTitle(\"Add Workout\")\n            .toolbar {\n                ToolbarItem(placement: .navigationBarLeading) {\n                    Button(\"Cancel\") { dismiss() }\n                }\n                ToolbarItem(placement: .navigationBarTrailing) {\n                    Button(\"Save\") {\n                        saveWorkout()\n                        dismiss()\n                    }\n                    .disabled(name.isEmpty || duration.isEmpty || calories.isEmpty)\n                }\n            }\n        }\n    }\n    \n    private func saveWorkout() {\n        let workout = Workout(\n            name: name,\n            type: selectedType,\n            duration: Int(duration) ?? 0,\n            calories: Int(calories) ?? 0\n        )\n        appState.addWorkout(workout)\n    }\n}",
        "hints": [
          "PART 1: Use TabView with .tabItem modifier for each tab. Add NavigationView inside each tab for proper navigation",
          "PART 2: Create AppState as ObservableObject with @Published properties. Use @StateObject in main app and @EnvironmentObject in views",
          "PART 3: Use LazyVGrid for stats cards and List/ScrollView for recent activity",
          "PART 4: Implement filtering with @State for selection and computed properties in AppState",
          "PART 5: Use .badge() modifier on tab items for notifications. Ensure all views update when data changes",
          "Use proper folder structure: separate files for models, views, and state management",
          "Remember to inject environment objects properly using .environmentObject()",
          "Use computed properties in AppState for shared calculations across tabs"
        ],
        "testCases": [
          {
            "input": "appState.totalWorkouts == appState.workouts.count",
            "expectedOutput": "true",
            "description": "Total workouts should equal the count of workouts array"
          },
          {
            "input": "appState.filteredWorkouts.count <= appState.workouts.count",
            "expectedOutput": "true",
            "description": "Filtered workouts should not exceed total workouts"
          }
        ]
      }
    },
    {
      "id": "recipe_app_project",
      "title": "Project: Recipe App",
      "description": "Build a complete tabbed iOS app with multiple views, data management, and navigation",
      "difficulty": "beginner",
      "theory": "# Recipe App Project - Building Your First Complete iOS App\n\n## Project Overview (30 min)\n\nIn this 4-hour project, you'll build a **complete Recipe App** that demonstrates:\n- **Tab-based navigation** with multiple screens\n- **Data modeling** with Swift structs\n- **List views** with custom cells\n- **Detail views** with comprehensive information\n- **User preferences** and settings\n- **App architecture** and organization\n\n## 1. App Architecture & Planning (45 min)\n\n### Project Structure:\n```\nRecipeApp/\nâ”œâ”€â”€ Models/\nâ”‚   â”œâ”€â”€ Recipe.swift\nâ”‚   â””â”€â”€ Category.swift\nâ”œâ”€â”€ Views/\nâ”‚   â”œâ”€â”€ ContentView.swift\nâ”‚   â”œâ”€â”€ RecipeListView.swift\nâ”‚   â”œâ”€â”€ RecipeDetailView.swift\nâ”‚   â”œâ”€â”€ FavoritesView.swift\nâ”‚   â””â”€â”€ SettingsView.swift\nâ”œâ”€â”€ ViewModels/\nâ”‚   â””â”€â”€ RecipeManager.swift\nâ””â”€â”€ Data/\n    â””â”€â”€ SampleData.swift\n```\n\n### Key Concepts:\n- **MVVM Pattern**: Separating data (Model), UI (View), and logic (ViewModel)\n- **TabView**: iOS tab bar navigation\n- **NavigationView**: Stack-based navigation within tabs\n- **@StateObject**: Managing app state\n- **@EnvironmentObject**: Sharing data across views\n\n## 2. Data Modeling (45 min)\n\n### Recipe Model:\nA well-structured data model is crucial for any app. We'll create a `Recipe` struct that contains:\n- Basic information (title, description)\n- Ingredients and instructions\n- Cooking metadata (time, difficulty)\n- Categorization and images\n\n### Sample Data:\nWe'll create sample recipes to populate our app, including:\n- Breakfast recipes\n- Lunch and dinner options\n- Vegetarian and dessert options\n\n## 3. Building the Main Interface (60 min)\n\n### Tab Bar Implementation:\nWe'll create a tab-based interface with:\n- **Recipes Tab**: Browse all recipes\n- **Favorites Tab**: Saved favorite recipes\n- **Categories Tab**: Browse by food categories\n- **Settings Tab**: User preferences\n\n### Navigation Structure:\nEach tab will have its own navigation stack, allowing users to drill down into details and navigate back.\n\n## 4. Recipe List & Detail Views (60 min)\n\n### List Implementation:\n- Custom list rows with recipe images and basic info\n- Search functionality\n- Filtering by category\n- Pull-to-refresh (simulated)\n\n### Detail View Features:\n- Full recipe information display\n- Ingredient lists with quantities\n- Step-by-step instructions\n- Cooking time and difficulty indicators\n- Favorite toggle functionality\n\n## 5. State Management & Data Flow (30 min)\n\n### Managing App State:\n- Using `@StateObject` for data management\n- Observable objects for reactive updates\n- Environment objects for shared data\n- Persisting user preferences with `@AppStorage`\n\n### Favorite System:\nImplementing a robust favorites system that persists across app launches.\n\n## 6. Polish & Final Touches (30 min)\n\n### UI/UX Improvements:\n- Custom styling and colors\n- Loading states and empty views\n- Error handling\n- Accessibility features\n\n### Code Organization:\n- Proper file structure\n- Code comments and documentation\n- Reusable components\n\n## Learning Outcomes\n\nBy completing this project, you'll have hands-on experience with:\n- Building multi-tab iOS applications\n- Implementing complex navigation flows\n- Managing application state\n- Creating custom UI components\n- Structuring SwiftUI apps for scalability\n- Handling user preferences and data persistence\n\nThis project serves as a foundation for building more complex iOS applications!",
      "codeExample": "// === DATA MODELS ===\nstruct Recipe: Identifiable, Codable {\n    let id = UUID()\n    let title: String\n    let description: String\n    let ingredients: [Ingredient]\n    let instructions: [String]\n    let prepTime: Int // in minutes\n    let cookTime: Int // in minutes\n    let difficulty: Difficulty\n    let category: Category\n    let imageName: String\n    var isFavorite: Bool = false\n    \n    var totalTime: Int {\n        return prepTime + cookTime\n    }\n}\n\nstruct Ingredient: Identifiable, Codable {\n    let id = UUID()\n    let name: String\n    let quantity: String\n    let unit: String?\n}\n\nenum Difficulty: String, CaseIterable, Codable {\n    case easy = \"Easy\"\n    case medium = \"Medium\" \n    case hard = \"Hard\"\n}\n\nenum Category: String, CaseIterable, Codable {\n    case breakfast = \"Breakfast\"\n    case lunch = \"Lunch\"\n    case dinner = \"Dinner\"\n    case dessert = \"Dessert\"\n    case vegetarian = \"Vegetarian\"\n}\n\n// === VIEWMODEL ===\nclass RecipeManager: ObservableObject {\n    @Published var recipes: [Recipe] = []\n    @Published var favorites: [Recipe] = []\n    @Published var selectedCategory: Category? = nil\n    \n    init() {\n        loadSampleData()\n        loadFavorites()\n    }\n    \n    private func loadSampleData() {\n        recipes = [\n            Recipe(\n                title: \"Avocado Toast\",\n                description: \"Simple and delicious breakfast\",\n                ingredients: [\n                    Ingredient(name: \"Bread\", quantity: \"2\", unit: \"slices\"),\n                    Ingredient(name: \"Avocado\", quantity: \"1\", unit: \"large\"),\n                    Ingredient(name: \"Lemon juice\", quantity: \"1\", unit: \"tbsp\")\n                ],\n                instructions: [\n                    \"Toast the bread until golden brown\",\n                    \"Mash avocado with lemon juice and salt\",\n                    \"Spread avocado mixture on toast\",\n                    \"Add optional toppings like red pepper flakes\"\n                ],\n                prepTime: 5,\n                cookTime: 3,\n                difficulty: .easy,\n                category: .breakfast,\n                imageName: \"avocado_toast\"\n            )\n        ]\n    }\n    \n    func toggleFavorite(_ recipe: Recipe) {\n        if let index = recipes.firstIndex(where: { $0.id == recipe.id }) {\n            recipes[index].isFavorite.toggle()\n            updateFavorites()\n        }\n    }\n    \n    private func updateFavorites() {\n        favorites = recipes.filter { $0.isFavorite }\n        saveFavorites()\n    }\n    \n    private func saveFavorites() {\n        // Implementation for saving favorites\n    }\n    \n    private func loadFavorites() {\n        // Implementation for loading favorites\n    }\n}\n\n// === MAIN APP STRUCTURE ===\nstruct RecipeApp: App {\n    @StateObject private var recipeManager = RecipeManager()\n    \n    var body: some Scene {\n        WindowGroup {\n            ContentView()\n                .environmentObject(recipeManager)\n        }\n    }\n}\n\n// === TAB VIEW ===\nstruct ContentView: View {\n    var body: some View {\n        TabView {\n            RecipeListView()\n                .tabItem {\n                    Image(systemName: \"list.bullet\")\n                    Text(\"Recipes\")\n                }\n            \n            FavoritesView()\n                .tabItem {\n                    Image(systemName: \"heart.fill\")\n                    Text(\"Favorites\")\n                }\n            \n            CategoriesView()\n                .tabItem {\n                    Image(systemName: \"square.grid.2x2\")\n                    Text(\"Categories\")\n                }\n            \n            SettingsView()\n                .tabItem {\n                    Image(systemName: \"gearshape.fill\")\n                    Text(\"Settings\")\n                }\n        }\n    }\n}\n\n// === RECIPE LIST VIEW ===\nstruct RecipeListView: View {\n    @EnvironmentObject var recipeManager: RecipeManager\n    @State private var searchText = \"\"\n    \n    var filteredRecipes: [Recipe] {\n        if searchText.isEmpty {\n            return recipeManager.recipes\n        } else {\n            return recipeManager.recipes.filter { \n                $0.title.localizedCaseInsensitiveContains(searchText) ||\n                $0.description.localizedCaseInsensitiveContains(searchText)\n            }\n        }\n    }\n    \n    var body: some View {\n        NavigationView {\n            List(filteredRecipes) { recipe in\n                NavigationLink(destination: RecipeDetailView(recipe: recipe)) {\n                    RecipeRowView(recipe: recipe)\n                }\n            }\n            .navigationTitle(\"All Recipes\")\n            .searchable(text: $searchText)\n        }\n    }\n}\n\n// === RECIPE ROW COMPONENT ===\nstruct RecipeRowView: View {\n    let recipe: Recipe\n    @EnvironmentObject var recipeManager: RecipeManager\n    \n    var body: some View {\n        HStack {\n            // Recipe image placeholder\n            Rectangle()\n                .fill(Color.gray.opacity(0.3))\n                .frame(width: 60, height: 60)\n                .cornerRadius(8)\n            \n            VStack(alignment: .leading, spacing: 4) {\n                Text(recipe.title)\n                    .font(.headline)\n                \n                Text(recipe.description)\n                    .font(.caption)\n                    .foregroundColor(.secondary)\n                    .lineLimit(2)\n                \n                HStack {\n                    Label(\"\\(recipe.totalTime) min\", systemImage: \"clock\")\n                    Text(\"â€¢\")\n                    Text(recipe.difficulty.rawValue)\n                    Spacer()\n                    \n                    Button(action: {\n                        recipeManager.toggleFavorite(recipe)\n                    }) {\n                        Image(systemName: recipe.isFavorite ? \"heart.fill\" : \"heart\")\n                            .foregroundColor(recipe.isFavorite ? .red : .gray)\n                    }\n                }\n                .font(.caption)\n            }\n        }\n        .padding(.vertical, 4)\n    }\n}",
      "category": "Projects",
      "estimatedTime": 240,
      "dependencies": ["variables", "optionals"],
      "challenge": {
        "instructions": "Build a complete Recipe App with the following features:\n\nPART 1: Project Setup & Data Models (45 min)\n1. Create the project structure with proper folders\n2. Implement Recipe, Ingredient, and Category data models\n3. Create sample data with at least 5 different recipes\n4. Set up the RecipeManager as an ObservableObject\n\nPART 2: Main Tab Interface (45 min)\n5. Create a TabView with 4 tabs: Recipes, Favorites, Categories, Settings\n6. Implement the main ContentView that hosts the tab interface\n7. Add proper icons and labels for each tab\n8. Set up environment object for data sharing\n\nPART 3: Recipe List & Navigation (60 min)\n9. Build RecipeListView with search functionality\n10. Create custom RecipeRowView with recipe information\n11. Implement NavigationView for drill-down navigation\n12. Add RecipeDetailView placeholder for navigation\n\nPART 4: Recipe Detail View (45 min)\n13. Build comprehensive RecipeDetailView showing:\n    - Recipe title and description\n    - Cooking time and difficulty\n    - Complete ingredient list\n    - Step-by-step instructions\n    - Favorite toggle button\n14. Add proper styling and layout\n\nPART 5: Favorites System (30 min)\n15. Implement favorite toggling functionality\n16. Create FavoritesView that shows only favorited recipes\n17. Add persistence so favorites survive app restarts\n18. Update UI to reflect favorite status\n\nPART 6: Categories & Filtering (30 min)\n19. Create CategoriesView showing recipes by category\n20. Implement category filtering in RecipeListView\n21. Add category badges or sections\n\nPART 7: Polish & Settings (15 min)\n22. Create SettingsView with app information\n23. Add app version and developer info\n24. Implement any additional user preferences\n\nBONUS CHALLENGES (Optional):\n- Add recipe images from assets or URLs\n- Implement recipe sharing functionality\n- Add cooking timer feature\n- Create recipe creation/editing capability",
        "starterCode": "// === PART 1: Data Models ===\n// Define your Recipe, Ingredient, and related models here\n\n\n// === PART 2: Recipe Manager ===\n// Create ObservableObject to manage recipe data\n\n\n// === PART 3: Main App Structure ===\n// Set up your App and main ContentView with tabs\n\n\n// === PART 4: Recipe List View ===\n// Implement the main recipe list with search\n\n\n// === PART 5: Recipe Detail View ===\n// Create detailed recipe view\n\n\n// === PART 6: Favorites System ===\n// Implement favorites functionality\n\n\n// === PART 7: Categories & Settings ===\n// Add category browsing and settings",
        "solution": "// === COMPLETE SOLUTION WOULD BE TOO LARGE FOR THIS FORMAT ===\n// This is a conceptual structure - actual implementation would be 500+ lines\n\n// Key implementation points:\n// 1. Complete data models with Codable conformance\n// 2. RecipeManager with @Published properties\n// 3. TabView with NavigationView for each tab\n// 4. List views with custom rows\n// 5. Detail view with comprehensive recipe info\n// 6. Favorite persistence using UserDefaults\n// 7. Search and filtering functionality\n// 8. Proper error handling and empty states\n\n// The full solution would demonstrate:\n// - MVVM architecture pattern\n// - SwiftUI best practices\n// - Reactive data flow\n// - User interface design\n// - State management\n// - Navigation patterns",
        "hints": [
          "PART 1: Use structs with Identifiable for data models. Include all properties from the theory section",
          "PART 2: TabView requires each tab to be a separate view. Use .tabItem modifier for icons",
          "PART 3: Use NavigationView with NavigationLink for drill-down. Searchable modifier adds search",
          "PART 4: Detail view should use ScrollView with VStack for different sections (ingredients, instructions)",
          "PART 5: Use @AppStorage or UserDefaults for simple persistence of favorites",
          "PART 6: Filter recipes by category using .filter() on the recipes array",
          "Use environmentObject() to share RecipeManager across all views",
          "Create reusable components like RecipeRowView to keep code organized",
          "Test navigation by ensuring you can tap a recipe and see its details",
          "Add sample data with variety (different categories, difficulties, times)"
        ],
        "testCases": [
          {
            "input": "recipes.count >= 5",
            "expectedOutput": "true",
            "description": "Should have at least 5 sample recipes"
          },
          {
            "input": "favorites.filter { $0.isFavorite }.count == favorites.count",
            "expectedOutput": "true",
            "description": "Favorites list should only contain favorited recipes"
          },
          {
            "input": "tabView.tabCount == 4",
            "expectedOutput": "true",
            "description": "App should have 4 main tabs"
          }
        ]
      }
    },
    {
      "id": "networking_fundamentals",
      "title": "Networking Fundamentals",
      "description": "Master URLSession, REST APIs, and modern Swift concurrency for robust network communication",
      "difficulty": "intermediate",
      "theory": "# Networking Fundamentals - Building Connected Apps\n\n## 1. Understanding HTTP & REST (45 min)\n\n### HTTP Basics:\n- **HTTP Methods**: GET, POST, PUT, DELETE, PATCH\n- **Status Codes**: 200 (OK), 201 (Created), 400 (Bad Request), 401 (Unauthorized), 404 (Not Found), 500 (Server Error)\n- **Headers**: Content-Type, Authorization, User-Agent\n- **REST Principles**: Stateless, cacheable, uniform interface\n\n### RESTful API Design:\n```swift\n// REST endpoints examples\nGET /users          // Fetch all users\nGET /users/123      // Fetch user with ID 123\nPOST /users         // Create new user\nPUT /users/123      // Update user 123\nDELETE /users/123   // Delete user 123\n```\n\n## 2. URLSession Fundamentals (60 min)\n\n### URLSession Components:\n- **URLSession**: Manages network requests\n- **URLSessionConfiguration**: Configures session behavior\n- **URLSessionTask**: Represents a single network task\n\n### Session Configurations:\n```swift\n// Default configuration (persistent storage)\nlet defaultConfig = URLSessionConfiguration.default\n\n// Ephemeral configuration (no caching)\nlet ephemeralConfig = URLSessionConfiguration.ephemeral\n\n// Background configuration\nlet backgroundConfig = URLSessionConfiguration.background(\n    identifier: \"com.yourapp.background\"\n)\n```\n\n## 3. Making Network Requests (90 min)\n\n### GET Requests:\n```swift\n// Basic GET request\nfunc fetchUsers() async throws -> [User] {\n    let url = URL(string: \"https://api.example.com/users\")!\n    let (data, response) = try await URLSession.shared.data(from: url)\n    \n    guard let httpResponse = response as? HTTPURLResponse,\n          httpResponse.statusCode == 200 else {\n        throw NetworkError.invalidResponse\n    }\n    \n    return try JSONDecoder().decode([User].self, from: data)\n}\n```\n\n### POST Requests:\n```swift\n// Creating and sending POST requests\nfunc createUser(_ user: User) async throws -> User {\n    let url = URL(string: \"https://api.example.com/users\")!\n    var request = URLRequest(url: url)\n    request.httpMethod = \"POST\"\n    request.setValue(\"application/json\", forHTTPHeaderField: \"Content-Type\")\n    \n    let encoder = JSONEncoder()\n    request.httpBody = try encoder.encode(user)\n    \n    let (data, response) = try await URLSession.shared.data(for: request)\n    \n    guard let httpResponse = response as? HTTPURLResponse,\n          httpResponse.statusCode == 201 else {\n        throw NetworkError.creationFailed\n    }\n    \n    return try JSONDecoder().decode(User.self, from: data)\n}\n```\n\n## 4. Advanced URLSession Features (60 min)\n\n### Custom URLSession:\n```swift\n// Configure custom session with specific timeouts\nlet config = URLSessionConfiguration.default\nconfig.timeoutIntervalForRequest = 30\nconfig.timeoutIntervalForResource = 60\nconfig.httpAdditionalHeaders = [\n    \"User-Agent\": \"MyApp/1.0\",\n    \"Accept\": \"application/json\"\n]\n\nlet customSession = URLSession(configuration: config)\n```\n\n### Download Tasks:\n```swift\n// Download large files with progress tracking\nfunc downloadFile(from url: URL) async throws -> URL {\n    let (tempURL, response) = try await URLSession.shared.download(from: url)\n    \n    guard let httpResponse = response as? HTTPURLResponse,\n          httpResponse.statusCode == 200 else {\n        throw NetworkError.downloadFailed\n    }\n    \n    // Move file to permanent location\n    let documentsURL = FileManager.default.urls(\n        for: .documentDirectory, \n        in: .userDomainMask\n    )[0]\n    let destinationURL = documentsURL.appendingPathComponent(\"downloadedFile\")\n    \n    try FileManager.default.moveItem(at: tempURL, to: destinationURL)\n    return destinationURL\n}\n```\n\n## 5. Error Handling & Resilience (45 min)\n\n### Network Error Types:\n```swift\nenum NetworkError: Error {\n    case invalidURL\n    case invalidResponse\n    case statusCode(Int)\n    case decodingError\n    case noInternetConnection\n    case timeout\n    case serverError(String)\n}\n```\n\n### Robust Error Handling:\n```swift\nfunc fetchWithRetry<T: Decodable>(\n    url: URL, \n    maxRetries: Int = 3\n) async throws -> T {\n    for attempt in 1...maxRetries {\n        do {\n            let (data, response) = try await URLSession.shared.data(from: url)\n            \n            guard let httpResponse = response as? HTTPURLResponse else {\n                throw NetworkError.invalidResponse\n            }\n            \n            switch httpResponse.statusCode {\n            case 200...299:\n                return try JSONDecoder().decode(T.self, from: data)\n            case 400...499:\n                throw NetworkError.statusCode(httpResponse.statusCode)\n            case 500...599:\n                if attempt < maxRetries {\n                    try await Task.sleep(nanoseconds: 2_000_000_000 * UInt64(attempt)) // Exponential backoff\n                    continue\n                } else {\n                    throw NetworkError.serverError(\"Server error: \\(httpResponse.statusCode)\")\n                }\n            default:\n                throw NetworkError.invalidResponse\n            }\n        } catch {\n            if attempt == maxRetries {\n                throw error\n            }\n            try await Task.sleep(nanoseconds: 2_000_000_000 * UInt64(attempt))\n        }\n    }\n    throw NetworkError.timeout\n}\n```\n\n## 6. Authentication & Security (45 min)\n\n### API Key Authentication:\n```swift\nfunc authenticatedRequest(\n    url: URL, \n    apiKey: String\n) -> URLRequest {\n    var request = URLRequest(url: url)\n    request.setValue(\"Bearer \\(apiKey)\", forHTTPHeaderField: \"Authorization\")\n    request.setValue(\"application/json\", forHTTPHeaderField: \"Content-Type\")\n    return request\n}\n```\n\n### OAuth 2.0:\n```swift\nstruct OAuthManager {\n    private let tokenURL: URL\n    private let clientID: String\n    private let clientSecret: String\n    \n    func refreshToken() async throws -> String {\n        var request = URLRequest(url: tokenURL)\n        request.httpMethod = \"POST\"\n        request.setValue(\"application/x-www-form-urlencoded\", forHTTPHeaderField: \"Content-Type\")\n        \n        let body = \"grant_type=client_credentials&client_id=\\(clientID)&client_secret=\\(clientSecret)\"\n        request.httpBody = body.data(using: .utf8)\n        \n        let (data, _) = try await URLSession.shared.data(for: request)\n        let response = try JSONDecoder().decode(OAuthResponse.self, from: data)\n        return response.accessToken\n    }\n}\n```\n\n## 7. Performance & Optimization (30 min)\n\n### Caching Strategies:\n```swift\n// Configure caching behavior\nlet config = URLSessionConfiguration.default\nconfig.requestCachePolicy = .returnCacheDataElseLoad\nconfig.urlCache = URLCache(\n    memoryCapacity: 50 * 1024 * 1024, // 50MB\n    diskCapacity: 200 * 1024 * 1024,  // 200MB\n    diskPath: \"MyAppCache\"\n)\n```\n\n### Request Prioritization:\n```swift\n// Use different URLSessions for different priorities\nlet highPrioritySession: URLSession = {\n    let config = URLSessionConfiguration.default\n    config.networkServiceType = .responsiveData\n    return URLSession(configuration: config)\n}()\n\nlet lowPrioritySession: URLSession = {\n    let config = URLSessionConfiguration.default\n    config.networkServiceType = .background\n    return URLSession(configuration: config)\n}()\n```\n\n## 8. Testing & Debugging (30 min)\n\n### Mocking Network Responses:\n```swift\n// Protocol for testability\nprotocol NetworkService {\n    func fetch<T: Decodable>(_ url: URL) async throws -> T\n}\n\n// Production implementation\nclass URLSessionNetworkService: NetworkService {\n    func fetch<T: Decodable>(_ url: URL) async throws -> T {\n        let (data, _) = try await URLSession.shared.data(from: url)\n        return try JSONDecoder().decode(T.self, from: data)\n    }\n}\n\n// Mock implementation for testing\nclass MockNetworkService: NetworkService {\n    var mockData: Data?\n    var shouldThrowError = false\n    \n    func fetch<T: Decodable>(_ url: URL) async throws -> T {\n        if shouldThrowError {\n            throw NetworkError.invalidResponse\n        }\n        \n        guard let data = mockData else {\n            throw NetworkError.invalidResponse\n        }\n        \n        return try JSONDecoder().decode(T.self, from: data)\n    }\n}\n```\n\n## Practice Exercises\n\nComplete all exercises to master networking in Swift!",
      "codeExample": "import Foundation\n\n// === NETWORK ERROR TYPES ===\nenum NetworkError: Error {\n    case invalidURL\n    case invalidResponse\n    case statusCode(Int)\n    case decodingError\n    case noInternetConnection\n    case timeout\n    case serverError(String)\n}\n\n// === DATA MODELS ===\nstruct User: Codable, Identifiable {\n    let id: Int\n    let name: String\n    let email: String\n    let website: String?\n}\n\nstruct Post: Codable, Identifiable {\n    let id: Int\n    let userId: Int\n    let title: String\n    let body: String\n}\n\nstruct CreateUserRequest: Codable {\n    let name: String\n    let email: String\n    let website: String?\n}\n\nstruct OAuthResponse: Codable {\n    let accessToken: String\n    let tokenType: String\n    let expiresIn: Int\n}\n\n// === NETWORK SERVICE ===\nclass NetworkManager {\n    private let baseURL = \"https://jsonplaceholder.typicode.com\"\n    private let session: URLSession\n    \n    init(configuration: URLSessionConfiguration = .default) {\n        self.session = URLSession(configuration: configuration)\n    }\n    \n    // === BASIC GET REQUEST ===\n    func fetchUsers() async throws -> [User] {\n        guard let url = URL(string: \"\\(baseURL)/users\") else {\n            throw NetworkError.invalidURL\n        }\n        \n        let (data, response) = try await session.data(from: url)\n        \n        guard let httpResponse = response as? HTTPURLResponse else {\n            throw NetworkError.invalidResponse\n        }\n        \n        guard httpResponse.statusCode == 200 else {\n            throw NetworkError.statusCode(httpResponse.statusCode)\n        }\n        \n        do {\n            return try JSONDecoder().decode([User].self, from: data)\n        } catch {\n            throw NetworkError.decodingError\n        }\n    }\n    \n    // === GET WITH QUERY PARAMETERS ===\n    func fetchPosts(for userId: Int) async throws -> [Post] {\n        var components = URLComponents(string: \"\\(baseURL)/posts\")!\n        components.queryItems = [\n            URLQueryItem(name: \"userId\", value: \"\\(userId)\")\n        ]\n        \n        guard let url = components.url else {\n            throw NetworkError.invalidURL\n        }\n        \n        let (data, response) = try await session.data(from: url)\n        \n        guard let httpResponse = response as? HTTPURLResponse,\n              httpResponse.statusCode == 200 else {\n            throw NetworkError.invalidResponse\n        }\n        \n        return try JSONDecoder().decode([Post].self, from: data)\n    }\n    \n    // === POST REQUEST ===\n    func createUser(_ userRequest: CreateUserRequest) async throws -> User {\n        guard let url = URL(string: \"\\(baseURL)/users\") else {\n            throw NetworkError.invalidURL\n        }\n        \n        var request = URLRequest(url: url)\n        request.httpMethod = \"POST\"\n        request.setValue(\"application/json\", forHTTPHeaderField: \"Content-Type\")\n        \n        let encoder = JSONEncoder()\n        request.httpBody = try encoder.encode(userRequest)\n        \n        let (data, response) = try await session.data(for: request)\n        \n        guard let httpResponse = response as? HTTPURLResponse else {\n            throw NetworkError.invalidResponse\n        }\n        \n        guard (200...299).contains(httpResponse.statusCode) else {\n            throw NetworkError.statusCode(httpResponse.statusCode)\n        }\n        \n        do {\n            return try JSONDecoder().decode(User.self, from: data)\n        } catch {\n            throw NetworkError.decodingError\n        }\n    }\n    \n    // === REQUEST WITH RETRY LOGIC ===\n    func fetchWithRetry<T: Decodable>(\n        url: URL,\n        maxRetries: Int = 3\n    ) async throws -> T {\n        for attempt in 1...maxRetries {\n            do {\n                let (data, response) = try await session.data(from: url)\n                \n                guard let httpResponse = response as? HTTPURLResponse else {\n                    throw NetworkError.invalidResponse\n                }\n                \n                switch httpResponse.statusCode {\n                case 200...299:\n                    return try JSONDecoder().decode(T.self, from: data)\n                case 400...499:\n                    throw NetworkError.statusCode(httpResponse.statusCode)\n                case 500...599:\n                    if attempt < maxRetries {\n                        // Exponential backoff\n                        let delay = UInt64(2_000_000_000 * attempt)\n                        try await Task.sleep(nanoseconds: delay)\n                        continue\n                    } else {\n                        throw NetworkError.serverError(\"Server error: \\(httpResponse.statusCode)\")\n                    }\n                default:\n                    throw NetworkError.invalidResponse\n                }\n            } catch {\n                if attempt == maxRetries {\n                    throw error\n                }\n                let delay = UInt64(2_000_000_000 * attempt)\n                try await Task.sleep(nanoseconds: delay)\n            }\n        }\n        throw NetworkError.timeout\n    }\n    \n    // === DOWNLOAD TASK ===\n    func downloadImage(from url: URL) async throws -> Data {\n        let (tempURL, response) = try await session.download(from: url)\n        \n        guard let httpResponse = response as? HTTPURLResponse,\n              httpResponse.statusCode == 200 else {\n            throw NetworkError.downloadFailed\n        }\n        \n        return try Data(contentsOf: tempURL)\n    }\n}\n\n// === USAGE EXAMPLES ===\nclass UserService {\n    private let networkManager = NetworkManager()\n    \n    func loadAllUsers() async {\n        do {\n            let users = try await networkManager.fetchUsers()\n            print(\"Loaded \\(users.count) users\")\n            \n            for user in users {\n                print(\"User: \\(user.name), Email: \\(user.email)\")\n            }\n        } catch {\n            print(\"Failed to load users: \\(error)\")\n        }\n    }\n    \n    func loadUserPosts(userId: Int) async {\n        do {\n            let posts = try await networkManager.fetchPosts(for: userId)\n            print(\"Loaded \\(posts.count) posts for user \\(userId)\")\n        } catch {\n            print(\"Failed to load posts: \\(error)\")\n        }\n    }\n    \n    func createNewUser() async {\n        let newUser = CreateUserRequest(\n            name: \"John Doe\",\n            email: \"john.doe@example.com\",\n            website: \"https://johndoe.com\"\n        )\n        \n        do {\n            let createdUser = try await networkManager.createUser(newUser)\n            print(\"Created user: \\(createdUser.name)\")\n        } catch {\n            print(\"Failed to create user: \\(error)\")\n        }\n    }\n}",
      "category": "Networking",
      "estimatedTime": 300,
      "dependencies": ["variables", "optionals"],
      "challenge": {
        "instructions": "Build a complete Weather App that fetches data from a weather API and displays it beautifully.\n\nPART 1: API Integration (90 min)\n1. Create a WeatherService that fetches current weather data from OpenWeatherMap API\n2. Implement error handling for network failures and invalid responses\n3. Add retry logic for failed requests with exponential backoff\n\nPART 2: Data Modeling (60 min)\n4. Design comprehensive data models for weather data including:\n   - Current weather (temperature, conditions, humidity, wind)\n   - 5-day forecast with daily summaries\n   - Location data (city, country, coordinates)\n5. Implement Codable protocols for all models\n\nPART 3: Advanced Networking (75 min)\n6. Create a generic network layer that can handle any API endpoint\n7. Implement request caching to reduce API calls\n8. Add support for both metric and imperial units\n9. Create a mock network service for testing\n\nPART 4: User Interface Integration (75 min)\n10. Design a SwiftUI view that displays current weather and forecast\n11. Add loading states and error handling in the UI\n12. Implement pull-to-refresh functionality\n13. Add location-based weather fetching\n\nAPI Endpoints to use:\n- Current weather: https://api.openweathermap.org/data/2.5/weather?q={city}&appid={API_KEY}&units=metric\n- 5-day forecast: https://api.openweathermap.org/data/2.5/forecast?q={city}&appid={API_KEY}&units=metric\n\nNote: You'll need to sign up for a free API key at OpenWeatherMap",
        "starterCode": "import Foundation\nimport SwiftUI\n\n// === PART 1: Data Models ===\n// Define your weather data models here\n\n\n// === PART 2: Network Error Handling ===\nenum WeatherError: Error {\n    // Define comprehensive error cases\n}\n\n// === PART 3: Weather Service ===\nclass WeatherService {\n    private let apiKey = \"YOUR_API_KEY\" // Replace with actual API key\n    private let baseURL = \"https://api.openweathermap.org/data/2.5\"\n    \n    // Implement network methods here\n    \n}\n\n// === PART 4: Mock Service for Testing ===\nclass MockWeatherService {\n    // Implement mock service for testing without network\n}\n\n// === PART 5: SwiftUI Views ===\nstruct WeatherView: View {\n    // Implement your weather UI here\n    \n    var body: some View {\n        Text(\"Implement weather display\")\n    }\n}\n\n// === USAGE EXAMPLE ===\n// Uncomment and implement the challenge solutions\n/*\nlet service = WeatherService()\nTask {\n    do {\n        let weather = try await service.fetchCurrentWeather(city: \"London\")\n        print(\"Current temperature: \\(weather.main.temp)Â°C\")\n    } catch {\n        print(\"Error: \\(error)\")\n    }\n}\n*/",
        "solution": "import Foundation\nimport SwiftUI\n\n// === PART 1: Data Models ===\nstruct WeatherResponse: Codable {\n    let coord: Coordinates\n    let weather: [WeatherCondition]\n    let main: MainWeather\n    let visibility: Int\n    let wind: Wind\n    let clouds: Clouds\n    let dt: TimeInterval\n    let sys: System\n    let timezone: Int\n    let id: Int\n    let name: String\n    let cod: Int\n}\n\nstruct ForecastResponse: Codable {\n    let list: [ForecastItem]\n    let city: City\n}\n\nstruct Coordinates: Codable {\n    let lon: Double\n    let lat: Double\n}\n\nstruct WeatherCondition: Codable {\n    let id: Int\n    let main: String\n    let description: String\n    let icon: String\n}\n\nstruct MainWeather: Codable {\n    let temp: Double\n    let feelsLike: Double\n    let tempMin: Double\n    let tempMax: Double\n    let pressure: Int\n    let humidity: Int\n    let seaLevel: Int?\n    let grndLevel: Int?\n    \n    enum CodingKeys: String, CodingKey {\n        case temp, pressure, humidity\n        case feelsLike = \"feels_like\"\n        case tempMin = \"temp_min\"\n        case tempMax = \"temp_max\"\n        case seaLevel = \"sea_level\"\n        case grndLevel = \"grnd_level\"\n    }\n}\n\nstruct Wind: Codable {\n    let speed: Double\n    let deg: Int\n    let gust: Double?\n}\n\nstruct Clouds: Codable {\n    let all: Int\n}\n\nstruct System: Codable {\n    let type: Int?\n    let id: Int?\n    let country: String\n    let sunrise: TimeInterval\n    let sunset: TimeInterval\n}\n\nstruct ForecastItem: Codable {\n    let dt: TimeInterval\n    let main: MainWeather\n    let weather: [WeatherCondition]\n    let clouds: Clouds\n    let wind: Wind\n    let visibility: Int\n    let pop: Double\n    let dtTxt: String\n    \n    enum CodingKeys: String, CodingKey {\n        case dt, main, weather, clouds, wind, visibility, pop\n        case dtTxt = \"dt_txt\"\n    }\n}\n\nstruct City: Codable {\n    let id: Int\n    let name: String\n    let coord: Coordinates\n    let country: String\n    let population: Int\n    let timezone: Int\n    let sunrise: TimeInterval\n    let sunset: TimeInterval\n}\n\n// === PART 2: Network Error Handling ===\nenum WeatherError: Error {\n    case invalidURL\n    case invalidResponse\n    case statusCode(Int)\n    case decodingError\n    case locationUnavailable\n    case apiKeyMissing\n    case networkUnavailable\n}\n\n// === PART 3: Weather Service ===\nclass WeatherService {\n    private let apiKey: String\n    private let baseURL = \"https://api.openweathermap.org/data/2.5\"\n    private let session: URLSession\n    \n    init(apiKey: String, session: URLSession = .shared) {\n        self.apiKey = apiKey\n        self.session = session\n    }\n    \n    func fetchCurrentWeather(city: String, units: String = \"metric\") async throws -> WeatherResponse {\n        guard let url = URL(string: \"\\(baseURL)/weather?q=\\(city)&appid=\\(apiKey)&units=\\(units)\") else {\n            throw WeatherError.invalidURL\n        }\n        \n        let (data, response) = try await session.data(from: url)\n        \n        guard let httpResponse = response as? HTTPURLResponse else {\n            throw WeatherError.invalidResponse\n        }\n        \n        guard httpResponse.statusCode == 200 else {\n            throw WeatherError.statusCode(httpResponse.statusCode)\n        }\n        \n        do {\n            return try JSONDecoder().decode(WeatherResponse.self, from: data)\n        } catch {\n            throw WeatherError.decodingError\n        }\n    }\n    \n    func fetchFiveDayForecast(city: String, units: String = \"metric\") async throws -> ForecastResponse {\n        guard let url = URL(string: \"\\(baseURL)/forecast?q=\\(city)&appid=\\(apiKey)&units=\\(units)\") else {\n            throw WeatherError.invalidURL\n        }\n        \n        let (data, response) = try await session.data(from: url)\n        \n        guard let httpResponse = response as? HTTPURLResponse else {\n            throw WeatherError.invalidResponse\n        }\n        \n        guard httpResponse.statusCode == 200 else {\n            throw WeatherError.statusCode(httpResponse.statusCode)\n        }\n        \n        do {\n            return try JSONDecoder().decode(ForecastResponse.self, from: data)\n        } catch {\n            throw WeatherError.decodingError\n        }\n    }\n    \n    func fetchWithRetry<T: Decodable>(\n        endpoint: String,\n        parameters: [String: String],\n        maxRetries: Int = 3\n    ) async throws -> T {\n        var components = URLComponents(string: \"\\(baseURL)/\\(endpoint)\")!\n        var queryItems = parameters.map { URLQueryItem(name: $0.key, value: $0.value) }\n        queryItems.append(URLQueryItem(name: \"appid\", value: apiKey))\n        components.queryItems = queryItems\n        \n        guard let url = components.url else {\n            throw WeatherError.invalidURL\n        }\n        \n        for attempt in 1...maxRetries {\n            do {\n                let (data, response) = try await session.data(from: url)\n                \n                guard let httpResponse = response as? HTTPURLResponse else {\n                    throw WeatherError.invalidResponse\n                }\n                \n                switch httpResponse.statusCode {\n                case 200...299:\n                    return try JSONDecoder().decode(T.self, from: data)\n                case 400...499:\n                    throw WeatherError.statusCode(httpResponse.statusCode)\n                case 500...599:\n                    if attempt < maxRetries {\n                        try await Task.sleep(nanoseconds: 2_000_000_000 * UInt64(attempt))\n                        continue\n                    } else {\n                        throw WeatherError.statusCode(httpResponse.statusCode)\n                    }\n                default:\n                    throw WeatherError.invalidResponse\n                }\n            } catch {\n                if attempt == maxRetries {\n                    throw error\n                }\n                try await Task.sleep(nanoseconds: 2_000_000_000 * UInt64(attempt))\n            }\n        }\n        throw WeatherError.networkUnavailable\n    }\n}\n\n// === PART 4: SwiftUI Views ===\nstruct WeatherView: View {\n    @StateObject private var viewModel = WeatherViewModel()\n    \n    var body: some View {\n        NavigationView {\n            ScrollView {\n                VStack(spacing: 20) {\n                    if let weather = viewModel.currentWeather {\n                        CurrentWeatherView(weather: weather)\n                    }\n                    \n                    if let forecast = viewModel.forecast {\n                        ForecastView(forecast: forecast)\n                    }\n                    \n                    if viewModel.isLoading {\n                        ProgressView(\"Loading weather...\")\n                    }\n                    \n                    if let error = viewModel.error {\n                        ErrorView(error: error, retryAction: {\n                            Task { await viewModel.loadWeather() }\n                        })\n                    }\n                }\n                .padding()\n            }\n            .navigationTitle(\"Weather\")\n            .refreshable {\n                await viewModel.loadWeather()\n            }\n        }\n        .task {\n            await viewModel.loadWeather()\n        }\n    }\n}\n\n@MainActor\nclass WeatherViewModel: ObservableObject {\n    @Published var currentWeather: WeatherResponse?\n    @Published var forecast: ForecastResponse?\n    @Published var isLoading = false\n    @Published var error: WeatherError?\n    \n    private let service = WeatherService(apiKey: \"YOUR_API_KEY\")\n    \n    func loadWeather() async {\n        isLoading = true\n        error = nil\n        \n        do {\n            async let current = service.fetchCurrentWeather(city: \"London\")\n            async let forecast = service.fetchFiveDayForecast(city: \"London\")\n            \n            let (currentResult, forecastResult) = try await (current, forecast)\n            \n            self.currentWeather = currentResult\n            self.forecast = forecastResult\n        } catch {\n            self.error = error as? WeatherError\n        }\n        \n        isLoading = false\n    }\n}",
        "hints": [
          "PART 1: Use nested structs to model the complex JSON response from OpenWeatherMap API",
          "PART 2: Create specific error cases for different failure scenarios (network, decoding, API limits)",
          "PART 3: Use async/await for modern concurrency. Handle different HTTP status codes appropriately",
          "PART 4: Use @MainActor for view models to ensure UI updates on the main thread",
          "For the API key, sign up at openweathermap.org for a free account",
          "Use Codable protocol for easy JSON encoding/decoding",
          "Implement proper error handling in the UI with user-friendly messages",
          "Consider adding caching to reduce API calls for the same location",
          "Test your network layer with both success and failure scenarios"
        ],
        "testCases": [
          {
            "input": "weatherService != nil",
            "expectedOutput": "true",
            "description": "Weather service should be properly initialized"
          },
          {
            "input": "weatherModel.conformsToCodable",
            "expectedOutput": "true",
            "description": "Weather models should conform to Codable protocol"
          },
          {
            "input": "errorHandlingCoversNetworkFailures",
            "expectedOutput": "true",
            "description": "Error handling should cover network failures and API errors"
          }
        ]
      }
    },
    {
      "id": "async_await",
      "title": "Async/Await & Modern Concurrency",
      "description": "Master Swift's modern concurrency model - write safe, efficient asynchronous code",
      "difficulty": "intermediate",
      "theory": "# Async/Await & Modern Concurrency\n\n## 1. Understanding Concurrency (45 min)\n\n### The Problem with Traditional Approaches\n**Callback Hell (Completion Handlers):**\n```swift\nfunc fetchUserData(completion: @escaping (Result<User, Error>) -> Void) {\n    fetchUser { userResult in\n        switch userResult {\n        case .success(let user):\n            fetchPosts(userId: user.id) { postsResult in\n                switch postsResult {\n                case .success(let posts):\n                    fetchComments(postIds: posts.map(\\.id)) { commentsResult in\n                        // Nested callbacks become hard to read!\n                    }\n                case .failure(let error):\n                    completion(.failure(error))\n                }\n            }\n        case .failure(let error):\n            completion(.failure(error))\n        }\n    }\n}\n```\n\n**What is Async/Await?**\n- **Synchronous**: Code executes line by line, waiting for each operation to complete\n- **Asynchronous**: Code can start operations and continue executing other code while waiting\n- **Async/Await**: Write asynchronous code that looks and behaves like synchronous code\n\n### Key Benefits:\n- **Readability**: Linear, easy-to-follow code\n- **Error Handling**: Use regular try/catch\n- **Performance**: Efficient resource usage\n- **Safety**: Compiler-enforced correctness\n\n## 2. Async Functions & Await (60 min)\n\n### Declaring Async Functions\n```swift\n// Traditional completion handler\nfunc fetchData(completion: @escaping (Result<Data, Error>) -> Void)\n\n// Modern async/await\nfunc fetchData() async throws -> Data\n```\n\n### The `async` Keyword\nFunctions that perform asynchronous work:\n```swift\nfunc downloadFile(from url: URL) async throws -> Data {\n    // This function can suspend and resume\n    let (data, _) = try await URLSession.shared.data(from: url)\n    return data\n}\n```\n\n### The `await` Keyword\nCalling async functions:\n```swift\nfunc processUserData() async {\n    do {\n        let userData = try await downloadFile(from: userURL)  // Suspends here\n        let processedData = process(data: userData)           // Resumes when data is ready\n        print(\"Processing complete: \\(processedData)\")\n    } catch {\n        print(\"Download failed: \\(error)\")\n    }\n}\n```\n\n### Suspension Points\n- `await` marks where your function can suspend\n- The thread is freed to do other work\n- Your function resumes when the awaited operation completes\n\n## 3. Structured Concurrency (75 min)\n\n### Async Let - Parallel Execution\nRun multiple async operations concurrently:\n```swift\nfunc fetchUserDashboard() async throws -> Dashboard {\n    async let user = fetchUser()\n    async let posts = fetchPosts()\n    async let notifications = fetchNotifications()\n    \n    // All three requests happen in parallel\n    return try await Dashboard(\n        user: user,\n        posts: posts,\n        notifications: notifications\n    )\n}\n```\n\n### Task Groups - Dynamic Parallelism\n```swift\nfunc fetchMultipleUsers(ids: [Int]) async throws -> [User] {\n    try await withThrowingTaskGroup(of: User.self) { group in\n        var users: [User] = []\n        \n        // Add tasks for each user ID\n        for id in ids {\n            group.addTask {\n                try await fetchUser(id: id)\n            }\n        }\n        \n        // Collect results as they complete\n        for try await user in group {\n            users.append(user)\n        }\n        \n        return users\n    }\n}\n```\n\n### Task Cancellation\n```swift\nfunc fetchDataWithCancellation() async throws -> Data {\n    try await withTaskCancellationHandler {\n        try await Task.sleep(nanoseconds: 5_000_000_000) // 5 seconds\n        return try await downloadLargeFile()\n    } onCancel: {\n        // Clean up resources if cancelled\n        cancelDownload()\n    }\n}\n\n// Check for cancellation\nfunc processItems(_ items: [Item]) async throws {\n    for item in items {\n        try Task.checkCancellation()  // Throw if task was cancelled\n        await process(item)\n    }\n}\n```\n\n## 4. Error Handling in Async Code (45 min)\n\n### Try/Await Pattern\n```swift\nfunc performNetworkOperations() async {\n    do {\n        let user = try await fetchUser()\n        let posts = try await fetchPosts(for: user.id)\n        let analytics = try await sendAnalytics(for: user)\n        \n        print(\"All operations completed successfully\")\n    } catch NetworkError.timeout {\n        print(\"Request timed out\")\n    } catch NetworkError.unauthorized {\n        print(\"Authentication failed\")\n    } catch {\n        print(\"Unexpected error: \\(error)\")\n    }\n}\n```\n\n### Handling Multiple Errors\n```swift\nfunc loadUserInterface() async {\n    async let userData = fetchUserData()\n    async let uiConfig = fetchUIConfig()\n    \n    do {\n        let (user, config) = try await (userData, uiConfig)\n        await updateUI(with: user, config: config)\n    } catch {\n        // If either operation fails, we catch the first error\n        await showError(error)\n    }\n}\n```\n\n### Optional Try Await\n```swift\nfunc attemptDownload() async -> Data? {\n    // Returns nil instead of throwing\n    return try? await downloadFile(from: url)\n}\n```\n\n## 5. Bridging with Existing Code (45 min)\n\n### Continuations - Wrap Completion Handlers\n```swift\nfunc fetchUserWithContinuation() async throws -> User {\n    return try await withCheckedThrowingContinuation { continuation in\n        legacyFetchUser { result in\n            switch result {\n            case .success(let user):\n                continuation.resume(returning: user)\n            case .failure(let error):\n                continuation.resume(throwing: error)\n            }\n        }\n    }\n}\n```\n\n### Async Properties and Subscripts\n```swift\nextension User {\n    var profileImage: UIImage? {\n        get async throws {\n            return try await downloadImage(from: profileImageURL)\n        }\n    }\n    \n    subscript(attachment index: Int) -> Data {\n        get async throws {\n            return try await downloadAttachment(at: index)\n        }\n    }\n}\n```\n\n## 6. Advanced Patterns & Best Practices (30 min)\n\n### Rate Limiting\n```swift\nactor RateLimiter {\n    private var lastRequestTime: Date = .distantPast\n    private let minInterval: TimeInterval\n    \n    init(minInterval: TimeInterval) {\n        self.minInterval = minInterval\n    }\n    \n    func performRequest() async throws -> Data {\n        let now = Date()\n        let timeSinceLastRequest = now.timeIntervalSince(lastRequestTime)\n        \n        if timeSinceLastRequest < minInterval {\n            try await Task.sleep(nanoseconds: UInt64((minInterval - timeSinceLastRequest) * 1_000_000_000))\n        }\n        \n        lastRequestTime = Date()\n        return try await makeActualRequest()\n    }\n}\n```\n\n### Resource Management\n```swift\nclass DataLoader {\n    private var cache: [URL: Data] = [:]\n    private var loadingTasks: [URL: Task<Data, Error>] = [:]\n    \n    func loadData(from url: URL) async throws -> Data {\n        if let cached = cache[url] {\n            return cached\n        }\n        \n        if let existingTask = loadingTasks[url] {\n            return try await existingTask.value\n        }\n        \n        let task = Task<Data, Error> {\n            defer { loadingTasks[url] = nil }\n            let data = try await URLSession.shared.data(from: url).0\n            cache[url] = data\n            return data\n        }\n        \n        loadingTasks[url] = task\n        return try await task.value\n    }\n}\n```\n\n## Practice Exercises\n\nComplete all exercises to master modern concurrency patterns!",
      "codeExample": "import Foundation\n\n// === BASIC ASYNC/AWAIT ===\nfunc fetchUserProfile(userId: Int) async throws -> UserProfile {\n    // Sequential execution\n    let user = try await fetchUser(id: userId)\n    let posts = try await fetchUserPosts(userId: userId)\n    let friends = try await fetchUserFriends(userId: userId)\n    \n    return UserProfile(user: user, posts: posts, friends: friends)\n}\n\n// === PARALLEL EXECUTION ===\nfunc fetchUserDashboard(userId: Int) async throws -> UserDashboard {\n    // Parallel execution\n    async let user = fetchUser(id: userId)\n    async let posts = fetchUserPosts(userId: userId)\n    async let friends = fetchUserFriends(userId: userId)\n    async let notifications = fetchNotifications(userId: userId)\n    \n    return try await UserDashboard(\n        user: user,\n        posts: posts,\n        friends: friends,\n        notifications: notifications\n    )\n}\n\n// === TASK GROUPS ===\nfunc downloadMultipleImages(urls: [URL]) async throws -> [UIImage] {\n    try await withThrowingTaskGroup(of: UIImage.self) { group in\n        var images: [UIImage] = []\n        \n        for url in urls {\n            group.addTask {\n                let (data, _) = try await URLSession.shared.data(from: url)\n                guard let image = UIImage(data: data) else {\n                    throw ImageError.invalidData\n                }\n                return image\n            }\n        }\n        \n        for try await image in group {\n            images.append(image)\n        }\n        \n        return images\n    }\n}\n\n// === CONTINUATIONS ===\nfunc legacyNetworkRequest() async throws -> Data {\n    return try await withCheckedThrowingContinuation { continuation in\n        OldNetworkManager.shared.requestData { result in\n            switch result {\n            case .success(let data):\n                continuation.resume(returning: data)\n            case .failure(let error):\n                continuation.resume(throwing: error)\n            }\n        }\n    }\n}\n\n// === ACTOR FOR THREAD SAFETY ===\nactor BankAccount {\n    private var balance: Double = 0\n    private let accountNumber: String\n    \n    init(accountNumber: String, initialBalance: Double) {\n        self.accountNumber = accountNumber\n        self.balance = initialBalance\n    }\n    \n    func deposit(amount: Double) {\n        balance += amount\n    }\n    \n    func withdraw(amount: Double) throws {\n        guard balance >= amount else {\n            throw BankError.insufficientFunds\n        }\n        balance -= amount\n    }\n    \n    func getBalance() -> Double {\n        return balance\n    }\n    \n    func transfer(amount: Double, to otherAccount: BankAccount) async throws {\n        try await withdraw(amount: amount)\n        await otherAccount.deposit(amount: amount)\n    }\n}\n\n// === ADVANCED ERROR HANDLING ===\nenum NetworkError: Error {\n    case invalidURL\n    case timeout\n    case unauthorized\n    case serverError(Int)\n}\n\nfunc robustNetworkRequest() async {\n    do {\n        let data = try await fetchWithRetry()\n        await processData(data)\n    } catch NetworkError.timeout {\n        await showTimeoutMessage()\n    } catch NetworkError.unauthorized {\n        await requestReauthentication()\n    } catch {\n        await showGenericError(error)\n    }\n}\n\nfunc fetchWithRetry(maxAttempts: Int = 3) async throws -> Data {\n    for attempt in 1...maxAttempts {\n        do {\n            return try await performNetworkRequest()\n        } catch {\n            if attempt == maxAttempts {\n                throw error\n            }\n            // Exponential backoff\n            let delay = UInt64(attempt * 2) * 1_000_000_000 // 2, 4, 6 seconds\n            try await Task.sleep(nanoseconds: delay)\n        }\n    }\n    throw NetworkError.timeout\n}\n\n// === REAL-WORLD EXAMPLE ===\nclass SocialMediaApp {\n    private let imageCache = ImageCache()\n    \n    func loadUserFeed() async throws -> Feed {\n        async let user = fetchCurrentUser()\n        async let feedPosts = fetchFeedPosts()\n        async let stories = fetchStories()\n        \n        let (currentUser, posts, userStories) = try await (user, feedPosts, stories)\n        \n        // Preload images in parallel\n        async let avatarImages = downloadMultipleImages(urls: posts.map(\\.author.avatarURL))\n        async let postImages = downloadMultipleImages(urls: posts.compactMap(\\.imageURL))\n        \n        let (avatars, postImagesData) = try await (avatarImages, postImages)\n        \n        return Feed(\n            user: currentUser,\n            posts: posts,\n            stories: userStories,\n            avatarImages: avatars,\n            postImages: postImagesData\n        )\n    }\n}",
      "category": "Swift Concurrency",
      "estimatedTime": 240,
      "dependencies": ["variables", "optionals"],
      "challenge": {
        "instructions": "Build a complete weather app using modern concurrency patterns:\n\nPART 1: Basic Async/Await Implementation (60 min)\n1. Create async functions to fetch: current weather, 5-day forecast, and air quality data\n2. Implement proper error handling for network failures and parsing errors\n3. Create a function that sequentially fetches all data and returns a complete weather report\n\nPART 2: Parallel Execution & Task Groups (75 min)\n4. Use async let to fetch current weather and forecast simultaneously\n5. Create a task group to fetch weather data for multiple cities in parallel\n6. Implement cancellation support so users can cancel long-running weather requests\n\nPART 3: Advanced Concurrency Patterns (75 min)\n7. Create an actor to manage weather cache with thread-safe access\n8. Implement a rate limiter to prevent excessive API calls\n9. Use continuations to wrap a legacy completion-based weather API\n\nPART 4: Real-World Application (50 min)\n10. Build a function that shows weather comparison between multiple cities\n11. Implement automatic retry with exponential backoff for failed requests\n12. Create a weather dashboard that updates different sections concurrently\n\nPART 5: Error Handling & User Experience (40 min)\n13. Handle different error types (network, parsing, rate limit) appropriately\n14. Implement fallback mechanisms when primary data sources fail\n15. Add loading states and progress tracking for better UX",
        "starterCode": "import Foundation\n\n// Weather data models\nstruct WeatherData: Codable {\n    let temperature: Double\n    let condition: String\n    let humidity: Int\n}\n\nstruct Forecast: Codable {\n    let daily: [DailyForecast]\n}\n\nstruct AirQuality: Codable {\n    let aqi: Int\n    let pollutants: [String: Double]\n}\n\n// Error types\nenum WeatherError: Error {\n    case invalidCity\n    case networkError\n    case parsingError\n    case rateLimitExceeded\n}\n\n// === PART 1: Basic Async/Await ===\n// Implement basic weather fetching functions\n\n\n// === PART 2: Parallel Execution ===\n// Implement parallel data fetching\n\n\n// === PART 3: Advanced Patterns ===\n// Create actor for cache management\n\n\n// === PART 4: Real-World Application ===\n// Build weather comparison functionality\n\n\n// === PART 5: Error Handling ===\n// Implement comprehensive error handling\n\n",
        "solution": "import Foundation\n\n// Weather data models\nstruct WeatherData: Codable {\n    let temperature: Double\n    let condition: String\n    let humidity: Int\n}\n\nstruct Forecast: Codable {\n    let daily: [DailyForecast]\n}\n\nstruct AirQuality: Codable {\n    let aqi: Int\n    let pollutants: [String: Double]\n}\n\nstruct DailyForecast: Codable {\n    let date: Date\n    let high: Double\n    let low: Double\n    let condition: String\n}\n\nstruct CompleteWeather {\n    let current: WeatherData\n    let forecast: Forecast\n    let airQuality: AirQuality\n}\n\n// Error types\nenum WeatherError: Error {\n    case invalidCity\n    case networkError\n    case parsingError\n    case rateLimitExceeded\n}\n\n// === PART 1: Basic Async/Await ===\nclass WeatherService {\n    \n    func fetchCurrentWeather(city: String) async throws -> WeatherData {\n        // Simulate network request\n        try await Task.sleep(nanoseconds: 1_000_000_000) // 1 second\n        \n        guard !city.isEmpty else {\n            throw WeatherError.invalidCity\n        }\n        \n        // Simulate API response\n        return WeatherData(\n            temperature: 22.5,\n            condition: \"Sunny\",\n            humidity: 65\n        )\n    }\n    \n    func fetchForecast(city: String) async throws -> Forecast {\n        try await Task.sleep(nanoseconds: 1_500_000_000) // 1.5 seconds\n        \n        let dailyForecasts = (1...5).map { day in\n            DailyForecast(\n                date: Calendar.current.date(byAdding: .day, value: day, to: Date())!,\n                high: Double(20 + day * 2),\n                low: Double(10 + day),\n                condition: [\"Sunny\", \"Cloudy\", \"Rainy\"].randomElement()!\n            )\n        }\n        \n        return Forecast(daily: dailyForecasts)\n    }\n    \n    func fetchAirQuality(city: String) async throws -> AirQuality {\n        try await Task.sleep(nanoseconds: 800_000_000) // 0.8 seconds\n        \n        return AirQuality(\n            aqi: Int.random(in: 1...100),\n            pollutants: [\"PM2.5\": 12.5, \"PM10\": 20.0, \"O3\": 0.05]\n        )\n    }\n    \n    // Sequential implementation\n    func fetchCompleteWeatherSequential(city: String) async throws -> CompleteWeather {\n        let current = try await fetchCurrentWeather(city: city)\n        let forecast = try await fetchForecast(city: city)\n        let airQuality = try await fetchAirQuality(city: city)\n        \n        return CompleteWeather(\n            current: current,\n            forecast: forecast,\n            airQuality: airQuality\n        )\n    }\n}\n\n// === PART 2: Parallel Execution ===\nextension WeatherService {\n    \n    // Parallel implementation\n    func fetchCompleteWeatherParallel(city: String) async throws -> CompleteWeather {\n        async let current = fetchCurrentWeather(city: city)\n        async let forecast = fetchForecast(city: city)\n        async let airQuality = fetchAirQuality(city: city)\n        \n        return try await CompleteWeather(\n            current: current,\n            forecast: forecast,\n            airQuality: airQuality\n        )\n    }\n    \n    // Multiple cities with task group\n    func fetchWeatherForCities(_ cities: [String]) async throws -> [String: CompleteWeather] {\n        try await withThrowingTaskGroup(of: (String, CompleteWeather).self) { group in\n            var results: [String: CompleteWeather] = [:]\n            \n            for city in cities {\n                group.addTask {\n                    let weather = try await self.fetchCompleteWeatherParallel(city: city)\n                    return (city, weather)\n                }\n            }\n            \n            for try await (city, weather) in group {\n                results[city] = weather\n            }\n            \n            return results\n        }\n    }\n    \n    // Cancellable version\n    func fetchWeatherWithCancellation(city: String) async throws -> CompleteWeather {\n        try await withTaskCancellationHandler {\n            try await fetchCompleteWeatherParallel(city: city)\n        } onCancel: {\n            print(\"Weather fetch cancelled for \\(city)\")\n        }\n    }\n}\n\n// === PART 3: Advanced Patterns ===\nactor WeatherCache {\n    private var cache: [String: (CompleteWeather, Date)] = [:]\n    private let cacheDuration: TimeInterval = 300 // 5 minutes\n    \n    func getWeather(for city: String) -> CompleteWeather? {\n        guard let (weather, timestamp) = cache[city] else {\n            return nil\n        }\n        \n        // Check if cache is still valid\n        if Date().timeIntervalSince(timestamp) < cacheDuration {\n            return weather\n        } else {\n            cache.removeValue(forKey: city)\n            return nil\n        }\n    }\n    \n    func setWeather(_ weather: CompleteWeather, for city: String) {\n        cache[city] = (weather, Date())\n    }\n    \n    func clear() {\n        cache.removeAll()\n    }\n}\n\nactor RateLimitedWeatherService {\n    private let baseService = WeatherService()\n    private var lastRequestTime: Date = .distantPast\n    private let minInterval: TimeInterval = 1.0 // 1 second between requests\n    \n    func fetchWeather(city: String) async throws -> CompleteWeather {\n        let now = Date()\n        let timeSinceLast = now.timeIntervalSince(lastRequestTime)\n        \n        if timeSinceLast < minInterval {\n            let delay = UInt64((minInterval - timeSinceLast) * 1_000_000_000)\n            try await Task.sleep(nanoseconds: delay)\n        }\n        \n        lastRequestTime = Date()\n        return try await baseService.fetchCompleteWeatherParallel(city: city)\n    }\n}\n\n// Continuation for legacy API\nclass LegacyWeatherAPI {\n    func fetchWeather(city: String, completion: @escaping (Result<WeatherData, Error>) -> Void) {\n        DispatchQueue.global().asyncAfter(deadline: .now() + 1.0) {\n            completion(.success(WeatherData(temperature: 22.0, condition: \"Sunny\", humidity: 60)))\n        }\n    }\n}\n\nextension LegacyWeatherAPI {\n    func fetchWeather(city: String) async throws -> WeatherData {\n        return try await withCheckedThrowingContinuation { continuation in\n            fetchWeather(city: city) { result in\n                switch result {\n                case .success(let weather):\n                    continuation.resume(returning: weather)\n                case .failure(let error):\n                    continuation.resume(throwing: error)\n                }\n            }\n        }\n    }\n}\n\n// === PART 4: Real-World Application ===\nclass WeatherDashboard {\n    private let service = WeatherService()\n    private let cache = WeatherCache()\n    \n    func compareCities(_ cities: [String]) async throws -> [String: CompleteWeather] {\n        // Try cache first\n        var results: [String: CompleteWeather] = [:]\n        \n        for city in cities {\n            if let cached = await cache.getWeather(for: city) {\n                results[city] = cached\n            }\n        }\n        \n        // Fetch missing cities\n        let missingCities = cities.filter { results[$0] == nil }\n        if !missingCities.isEmpty {\n            let fetched = try await service.fetchWeatherForCities(missingCities)\n            \n            // Update cache\n            for (city, weather) in fetched {\n                await cache.setWeather(weather, for: city)\n                results[city] = weather\n            }\n        }\n        \n        return results\n    }\n    \n    func fetchWithRetry(city: String, maxAttempts: Int = 3) async throws -> CompleteWeather {\n        for attempt in 1...maxAttempts {\n            do {\n                return try await service.fetchCompleteWeatherParallel(city: city)\n            } catch {\n                if attempt == maxAttempts {\n                    throw error\n                }\n                \n                let delay = UInt64(attempt * 2) * 1_000_000_000\n                try await Task.sleep(nanoseconds: delay)\n                print(\"Retry attempt \\(attempt) for \\(city)\")\n            }\n        }\n        throw WeatherError.networkError\n    }\n}\n\n// === PART 5: Error Handling ===\nclass WeatherErrorHandler {\n    \n    func handleWeatherError(_ error: Error) async -> String {\n        switch error {\n        case WeatherError.invalidCity:\n            return \"Please enter a valid city name\"\n        case WeatherError.networkError:\n            return \"Network connection failed. Please check your internet\"\n        case WeatherError.rateLimitExceeded:\n            return \"Too many requests. Please wait a moment\"\n        case WeatherError.parsingError:\n            return \"Failed to process weather data\"\n        default:\n            return \"An unexpected error occurred\"\n        }\n    }\n    \n    func fetchWeatherWithFallback(city: String) async -> CompleteWeather? {\n        do {\n            return try await WeatherService().fetchCompleteWeatherParallel(city: city)\n        } catch {\n            // Try fallback source\n            return await fetchFromBackupSource(city: city)\n        }\n    }\n    \n    private func fetchFromBackupSource(city: String) async -> CompleteWeather? {\n        // Implement backup weather source\n        return nil\n    }\n}",
        "hints": [
          "PART 1: Start with simple async functions that simulate network delays using Task.sleep",
          "PART 2: Use 'async let' for parallel execution and TaskGroup for multiple cities",
          "PART 3: Actors provide thread-safe access to shared state - perfect for caching",
          "PART 4: Implement cache-first strategy: check cache before making network requests",
          "PART 5: Use exhaustive error handling with specific cases for different failure scenarios",
          "Remember: await suspends the current function, freeing the thread for other work",
          "Use try? await for operations where failure is acceptable and you want to continue",
          "Task groups automatically manage child tasks and clean up when the group completes"
        ],
        "testCases": [
          {
            "input": "cities.count == results.count",
            "expectedOutput": "true",
            "description": "Should return weather for all requested cities"
          },
          {
            "input": "parallelTime < sequentialTime * 0.7",
            "expectedOutput": "true",
            "description": "Parallel execution should be significantly faster than sequential"
          },
          {
            "input": "cache.getWeather(for: \"London\") != nil",
            "expectedOutput": "true",
            "description": "Cached weather should be retrievable"
          }
        ]
      }
    },
    {
      "id": "json_codable",
      "title": "JSON & Codable",
      "description": "Master data parsing with Swift's powerful Codable protocol",
      "difficulty": "intermediate",
      "theory": "# JSON & Codable - Mastering Data Parsing\n\n## 1. Understanding JSON (45 min)\n\n### What is JSON?\nJSON (JavaScript Object Notation) is a lightweight data format used for data exchange between clients and servers.\n\n### JSON Structure:\n```json\n{\n  \"name\": \"John Doe\",\n  \"age\": 30,\n  \"isPremium\": true,\n  \"hobbies\": [\"reading\", \"gaming\", \"coding\"],\n  \"address\": {\n    \"street\": \"123 Main St\",\n    \"city\": \"Boston\"\n  }\n}\n```\n\n### JSON Data Types:\n- **String**: `\"Hello World\"`\n- **Number**: `42`, `3.14`\n- **Boolean**: `true`, `false`\n- **Array**: `[1, 2, 3]`\n- **Object**: `{\"key\": \"value\"}`\n- **null**: `null`\n\n## 2. Introduction to Codable (60 min)\n\n### What is Codable?\n`Codable` is a type alias for `Encodable & Decodable` - Swift's protocol for encoding/decoding data.\n\n### Basic Codable Implementation:\n```swift\nstruct User: Codable {\n    let name: String\n    let age: Int\n    let email: String\n}\n\n// Automatic synthesis works when:\n// - All properties are Codable\n// - Property names match JSON keys\n```\n\n### Manual Codable Implementation:\n```swift\nstruct CustomUser: Codable {\n    let firstName: String\n    let userAge: Int\n    \n    // Custom coding keys for different JSON key names\n    enum CodingKeys: String, CodingKey {\n        case firstName = \"first_name\"\n        case userAge = \"age\"\n    }\n    \n    // Manual decoding\n    init(from decoder: Decoder) throws {\n        let container = try decoder.container(keyedBy: CodingKeys.self)\n        firstName = try container.decode(String.self, forKey: .firstName)\n        userAge = try container.decode(Int.self, forKey: .userAge)\n    }\n    \n    // Manual encoding\n    func encode(to encoder: Encoder) throws {\n        var container = encoder.container(keyedBy: CodingKeys.self)\n        try container.encode(firstName, forKey: .firstName)\n        try container.encode(userAge, forKey: .userAge)\n    }\n}\n```\n\n## 3. JSONDecoder & JSONEncoder (75 min)\n\n### JSONDecoder - Parsing JSON to Swift Objects:\n```swift\nlet jsonString = \"\"\"\n{\n    \"name\": \"Alice\",\n    \"age\": 28,\n    \"email\": \"alice@example.com\"\n}\n\"\"\"\n\nlet jsonData = jsonString.data(using: .utf8)!\nlet decoder = JSONDecoder()\n\n// Basic decoding\nlet user = try decoder.decode(User.self, from: jsonData)\n\n// With error handling\ndo {\n    let user = try decoder.decode(User.self, from: jsonData)\n    print(\"User: \\(user.name)\")\n} catch {\n    print(\"Decoding error: \\(error)\")\n}\n```\n\n### JSONEncoder - Converting Swift Objects to JSON:\n```swift\nlet user = User(name: \"Bob\", age: 35, email: \"bob@example.com\")\nlet encoder = JSONEncoder()\n\n// Basic encoding\nencoder.outputFormatting = .prettyPrinted\nlet jsonData = try encoder.encode(user)\nlet jsonString = String(data: jsonData, encoding: .utf8)!\n\n// Output:\n// {\n//   \"name\" : \"Bob\",\n//   \"age\" : 35,\n//   \"email\" : \"bob@example.com\"\n// }\n```\n\n### Advanced Decoder Configuration:\n```swift\nlet decoder = JSONDecoder()\n\n// Date decoding strategies\ndecoder.dateDecodingStrategy = .iso8601\n// .formatted(DateFormatter)\n// .secondsSince1970\n// .millisecondsSince1970\n\n// Key decoding strategies (snake_case to camelCase)\ndecoder.keyDecodingStrategy = .convertFromSnakeCase\n\n// Data decoding strategies\ndecoder.dataDecodingStrategy = .base64\n```\n\n## 4. Advanced Codable Techniques (90 min)\n\n### Handling Optional Values:\n```swift\nstruct Product: Codable {\n    let id: Int\n    let name: String\n    let description: String?\n    let tags: [String]?\n    let metadata: [String: String]?\n}\n\n// JSON can have missing keys or null values\nlet json = \"\"\"\n{\n    \"id\": 1,\n    \"name\": \"iPhone\"\n}\n\"\"\"\n// description, tags, metadata will be nil\n```\n\n### Custom Date Handling:\n```swift\nstruct Event: Codable {\n    let title: String\n    let date: Date\n    \n    enum CodingKeys: String, CodingKey {\n        case title, date\n    }\n    \n    init(from decoder: Decoder) throws {\n        let container = try decoder.container(keyedBy: CodingKeys.self)\n        title = try container.decode(String.self, forKey: .title)\n        \n        // Handle multiple date formats\n        let dateString = try container.decode(String.self, forKey: .date)\n        let formatter = DateFormatter()\n        formatter.dateFormat = \"yyyy-MM-dd\"\n        \n        if let date = formatter.date(from: dateString) {\n            self.date = date\n        } else {\n            throw DecodingError.dataCorruptedError(\n                forKey: .date,\n                in: container,\n                debugDescription: \"Date format is invalid\"\n            )\n        }\n    }\n}\n```\n\n### Polymorphic Decoding:\n```swift\nprotocol Shape: Codable {\n    var area: Double { get }\n}\n\nstruct Circle: Shape {\n    let radius: Double\n    var area: Double { return .pi * radius * radius }\n}\n\nstruct Rectangle: Shape {\n    let width: Double\n    let height: Double\n    var area: Double { return width * height }\n}\n\nstruct ShapeWrapper: Codable {\n    let shape: Shape\n    \n    enum CodingKeys: String, CodingKey {\n        case type, data\n    }\n    \n    init(from decoder: Decoder) throws {\n        let container = try decoder.container(keyedBy: CodingKeys.self)\n        let type = try container.decode(String.self, forKey: .type)\n        \n        switch type {\n        case \"circle\":\n            shape = try container.decode(Circle.self, forKey: .data)\n        case \"rectangle\":\n            shape = try container.decode(Rectangle.self, forKey: .data)\n        default:\n            throw DecodingError.dataCorruptedError(\n                forKey: .type,\n                in: container,\n                debugDescription: \"Unknown shape type\"\n            )\n        }\n    }\n    \n    func encode(to encoder: Encoder) throws {\n        var container = encoder.container(keyedBy: CodingKeys.self)\n        \n        switch shape {\n        case let circle as Circle:\n            try container.encode(\"circle\", forKey: .type)\n            try container.encode(circle, forKey: .data)\n        case let rectangle as Rectangle:\n            try container.encode(\"rectangle\", forKey: .type)\n            try container.encode(rectangle, forKey: .data)\n        default:\n            throw EncodingError.invalidValue(\n                shape,\n                EncodingError.Context(\n                    codingPath: [],\n                    debugDescription: \"Unknown shape type\"\n                )\n            )\n        }\n    }\n}\n```\n\n## 5. Real-World API Integration (60 min)\n\n### Network Response Handling:\n```swift\nstruct APIResponse<T: Codable>: Codable {\n    let status: String\n    let message: String?\n    let data: T?\n    let error: String?\n}\n\nstruct UserResponse: Codable {\n    let users: [User]\n    let pagination: Pagination\n}\n\nstruct Pagination: Codable {\n    let currentPage: Int\n    let totalPages: Int\n    let totalItems: Int\n}\n```\n\n### Error Handling Patterns:\n```swift\nenum NetworkError: Error {\n    case invalidURL\n    case requestFailed(Error)\n    case invalidResponse\n    case decodingFailed(Error)\n    case serverError(Int)\n}\n\nclass APIManager {\n    func fetchUsers(completion: @escaping (Result<[User], NetworkError>) -> Void) {\n        guard let url = URL(string: \"https://api.example.com/users\") else {\n            completion(.failure(.invalidURL))\n            return\n        }\n        \n        URLSession.shared.dataTask(with: url) { data, response, error in\n            if let error = error {\n                completion(.failure(.requestFailed(error)))\n                return\n            }\n            \n            guard let httpResponse = response as? HTTPResponse,\n                  (200...299).contains(httpResponse.statusCode) else {\n                completion(.failure(.invalidResponse))\n                return\n            }\n            \n            guard let data = data else {\n                completion(.failure(.invalidResponse))\n                return\n            }\n            \n            do {\n                let decoder = JSONDecoder()\n                decoder.keyDecodingStrategy = .convertFromSnakeCase\n                let users = try decoder.decode([User].self, from: data)\n                completion(.success(users))\n            } catch {\n                completion(.failure(.decodingFailed(error)))\n            }\n        }.resume()\n    }\n}\n```\n\n## 6. Performance & Best Practices (30 min)\n\n### Performance Tips:\n- Use `JSONSerialization` for simple JSON inspection\n- Cache `JSONDecoder/JSONEncoder` instances\n- Use background queues for large JSON parsing\n- Consider streaming for very large JSON files\n\n### Security Considerations:\n- Validate all incoming data\n- Handle malformed JSON gracefully\n- Use rate limiting for API calls\n- Sanitize user input before encoding\n\n### Testing Strategies:\n- Unit test decoding/encoding logic\n- Test edge cases (null values, missing keys)\n- Use mock JSON data for testing\n- Test error handling paths\n\n## Practice Exercises\n\nComplete all exercises to master JSON parsing with Codable!",
      "codeExample": "// === BASIC CODABLE STRUCTURES ===\nstruct User: Codable {\n    let id: Int\n    let name: String\n    let email: String\n    let isActive: Bool\n    let createdAt: Date\n    let profile: Profile?\n}\n\nstruct Profile: Codable {\n    let bio: String?\n    let website: String?\n    let socialMedia: [String: String]?\n}\n\n// === ADVANCED CODABLE WITH CUSTOM LOGIC ===\nstruct Product: Codable {\n    let id: Int\n    let name: String\n    let price: Price\n    let categories: [String]\n    let inventory: Inventory\n    \n    struct Price: Codable {\n        let amount: Double\n        let currency: String\n        \n        var formatted: String {\n            return \"\\(currency)\\(amount)\"\n        }\n    }\n    \n    struct Inventory: Codable {\n        let stock: Int\n        let reserved: Int\n        \n        var available: Int {\n            return stock - reserved\n        }\n    }\n}\n\n// === COMPLEX API RESPONSE HANDLING ===\nstruct APIResponse<T: Codable>: Codable {\n    let success: Bool\n    let message: String?\n    let data: T?\n    let errors: [String]?\n    let meta: Meta?\n    \n    struct Meta: Codable {\n        let page: Int\n        let totalPages: Int\n        let totalItems: Int\n        let itemsPerPage: Int\n    }\n}\n\n// === CUSTOM DECODING WITH ERROR HANDLING ===\nstruct Order: Codable {\n    let id: String\n    let customerId: Int\n    let items: [OrderItem]\n    let totalAmount: Double\n    let status: OrderStatus\n    let createdAt: Date\n    \n    enum OrderStatus: String, Codable {\n        case pending, confirmed, shipped, delivered, cancelled\n    }\n    \n    struct OrderItem: Codable {\n        let productId: Int\n        let quantity: Int\n        let unitPrice: Double\n        \n        var totalPrice: Double {\n            return Double(quantity) * unitPrice\n        }\n    }\n    \n    // Custom initializer for complex validation\n    init(from decoder: Decoder) throws {\n        let container = try decoder.container(keyedBy: CodingKeys.self)\n        \n        id = try container.decode(String.self, forKey: .id)\n        customerId = try container.decode(Int.self, forKey: .customerId)\n        items = try container.decode([OrderItem].self, forKey: .items)\n        totalAmount = try container.decode(Double.self, forKey: .totalAmount)\n        status = try container.decode(OrderStatus.self, forKey: .status)\n        \n        // Custom date parsing\n        let dateString = try container.decode(String.self, forKey: .createdAt)\n        let formatter = ISO8601DateFormatter()\n        formatter.formatOptions = [.withInternetDateTime, .withFractionalSeconds]\n        \n        if let date = formatter.date(from: dateString) {\n            createdAt = date\n        } else {\n            throw DecodingError.dataCorruptedError(\n                forKey: .createdAt,\n                in: container,\n                debugDescription: \"Invalid date format\"\n            )\n        }\n        \n        // Validate total amount matches items\n        let calculatedTotal = items.reduce(0) { $0 + $1.totalPrice }\n        guard abs(calculatedTotal - totalAmount) < 0.01 else {\n            throw DecodingError.dataCorruptedError(\n                forKey: .totalAmount,\n                in: container,\n                debugDescription: \"Total amount doesn't match items total\"\n            )\n        }\n    }\n}\n\n// === PRACTICAL USAGE EXAMPLES ===\nclass JSONManager {\n    static let shared = JSONManager()\n    \n    private let decoder: JSONDecoder\n    private let encoder: JSONEncoder\n    \n    private init() {\n        decoder = JSONDecoder()\n        decoder.keyDecodingStrategy = .convertFromSnakeCase\n        decoder.dateDecodingStrategy = .iso8601\n        \n        encoder = JSONEncoder()\n        encoder.keyEncodingStrategy = .convertToSnakeCase\n        encoder.dateEncodingStrategy = .iso8601\n        encoder.outputFormatting = .prettyPrinted\n    }\n    \n    // Generic decoding method\n    func decode<T: Codable>(_ type: T.Type, from data: Data) throws -> T {\n        return try decoder.decode(type, from: data)\n    }\n    \n    // Generic encoding method\n    func encode<T: Codable>(_ value: T) throws -> Data {\n        return try encoder.encode(value)\n    }\n    \n    // Safe decoding with error handling\n    func safeDecode<T: Codable>(_ type: T.Type, from data: Data) -> Result<T, Error> {\n        do {\n            let decoded = try decoder.decode(type, from: data)\n            return .success(decoded)\n        } catch {\n            return .failure(error)\n        }\n    }\n}\n\n// Example usage\nlet sampleUserJSON = \"\"\"\n{\n    \"id\": 123,\n    \"name\": \"John Doe\",\n    \"email\": \"john@example.com\",\n    \"is_active\": true,\n    \"created_at\": \"2024-01-15T10:30:00Z\",\n    \"profile\": {\n        \"bio\": \"Software developer\",\n        \"website\": \"https://johndoe.com\",\n        \"social_media\": {\n            \"twitter\": \"@johndoe\",\n            \"github\": \"johndoe\"\n        }\n    }\n}\n\"\"\"",
      "category": "Networking & Data",
      "estimatedTime": 240,
      "dependencies": ["variables", "optionals"],
      "challenge": {
        "instructions": "Build a complete JSON parsing system for a social media app:\n\nPART 1: Basic Model Creation (45 min)\n1. Create User model with: id, username, email, profileImage URL, joinDate, isVerified\n2. Create Post model with: id, userId, content, image URL, likes count, comments count, createdAt\n3. Create Comment model with: id, postId, userId, content, createdAt\n4. Make all models Codable with proper property types\n\nPART 2: Advanced Codable Features (60 min)\n5. Add custom CodingKeys for snake_case JSON (user_id, created_at, etc.)\n6. Implement custom date decoding for various formats (ISO8601, timestamp)\n7. Add computed properties: timeAgo (String showing how long ago post was created)\n8. Create validation in init(from decoder:) to ensure required fields exist\n\nPART 3: Complex JSON Structures (75 min)\n9. Create APIResponse wrapper for paginated API responses\n10. Build Feed model containing array of posts with user information\n11. Implement polymorphic decoding for different post types (text, image, video)\n12. Create error enum with specific decoding error cases\n\nPART 4: Real API Integration (60 min)\n13. Build NetworkManager with methods to fetch users, posts, and comments\n14. Implement error handling for network failures and decoding errors\n15. Create mock JSON data and test your decoding logic\n16. Build a function that combines multiple API calls into a complete feed\n\nAdvanced Challenge:\n- Handle nested relationships (posts with users and comments)\n- Implement caching for decoded objects\n- Add unit tests for all decoding scenarios",
        "starterCode": "// === PART 1: Basic Models ===\n// Create your Codable models here\n\n\n// === PART 2: Advanced Codable Features ===\n// Add custom coding keys and date handling\n\n\n// === PART 3: Complex JSON Structures ===\n// Create API response wrappers and polymorphic types\n\n\n// === PART 4: Real API Integration ===\n// Build network manager and error handling\n\n",
        "solution": "// === PART 1: Basic Models ===\nstruct User: Codable {\n    let id: Int\n    let username: String\n    let email: String\n    let profileImage: String?\n    let joinDate: Date\n    let isVerified: Bool\n}\n\nstruct Post: Codable {\n    let id: Int\n    let userId: Int\n    let content: String\n    let imageUrl: String?\n    let likesCount: Int\n    let commentsCount: Int\n    let createdAt: Date\n    \n    var timeAgo: String {\n        let interval = Date().timeIntervalSince(createdAt)\n        if interval < 3600 { return \"\\(Int(interval / 60))m ago\" }\n        else if interval < 86400 { return \"\\(Int(interval / 3600))h ago\" }\n        else { return \"\\(Int(interval / 86400))d ago\" }\n    }\n}\n\nstruct Comment: Codable {\n    let id: Int\n    let postId: Int\n    let userId: Int\n    let content: String\n    let createdAt: Date\n}\n\n// === PART 2: Advanced Codable Features ===\nstruct AdvancedUser: Codable {\n    let id: Int\n    let username: String\n    let email: String\n    let profileImage: String?\n    let joinDate: Date\n    let isVerified: Bool\n    \n    enum CodingKeys: String, CodingKey {\n        case id\n        case username\n        case email\n        case profileImage = \"profile_image\"\n        case joinDate = \"join_date\"\n        case isVerified = \"is_verified\"\n    }\n    \n    init(from decoder: Decoder) throws {\n        let container = try decoder.container(keyedBy: CodingKeys.self)\n        \n        id = try container.decode(Int.self, forKey: .id)\n        username = try container.decode(String.self, forKey: .username)\n        email = try container.decode(String.self, forKey: .email)\n        profileImage = try container.decodeIfPresent(String.self, forKey: .profileImage)\n        isVerified = try container.decode(Bool.self, forKey: .isVerified)\n        \n        // Handle multiple date formats\n        let dateString = try container.decode(String.self, forKey: .joinDate)\n        let formatter = ISO8601DateFormatter()\n        \n        if let date = formatter.date(from: dateString) {\n            joinDate = date\n        } else {\n            throw DecodingError.dataCorruptedError(\n                forKey: .joinDate,\n                in: container,\n                debugDescription: \"Invalid date format\"\n            )\n        }\n    }\n}\n\n// === PART 3: Complex JSON Structures ===\nstruct APIResponse<T: Codable>: Codable {\n    let status: String\n    let data: T?\n    let message: String?\n    let pagination: Pagination?\n    \n    struct Pagination: Codable {\n        let currentPage: Int\n        let totalPages: Int\n        let totalItems: Int\n        \n        enum CodingKeys: String, CodingKey {\n            case currentPage = \"current_page\"\n            case totalPages = \"total_pages\"\n            case totalItems = \"total_items\"\n        }\n    }\n}\n\nenum PostType: String, Codable {\n    case text, image, video\n}\n\nstruct FeedItem: Codable {\n    let type: PostType\n    let post: Post\n    let user: User\n    let comments: [Comment]?\n}\n\n// === PART 4: Real API Integration ===\nenum NetworkError: Error {\n    case invalidURL\n    case requestFailed(Error)\n    case invalidResponse\n    case decodingFailed(Error)\n    case serverError(Int, String)\n}\n\nclass NetworkManager {\n    private let baseURL = \"https://api.example.com\"\n    private let decoder: JSONDecoder\n    \n    init() {\n        decoder = JSONDecoder()\n        decoder.keyDecodingStrategy = .convertFromSnakeCase\n        decoder.dateDecodingStrategy = .iso8601\n    }\n    \n    func fetchUsers(completion: @escaping (Result<[User], NetworkError>) -> Void) {\n        guard let url = URL(string: \"\\(baseURL)/users\") else {\n            completion(.failure(.invalidURL))\n            return\n        }\n        \n        URLSession.shared.dataTask(with: url) { data, response, error in\n            if let error = error {\n                completion(.failure(.requestFailed(error)))\n                return\n            }\n            \n            guard let httpResponse = response as? HTTPURLResponse,\n                  (200...299).contains(httpResponse.statusCode) else {\n                let statusCode = (response as? HTTPURLResponse)?.statusCode ?? -1\n                completion(.failure(.serverError(statusCode, \"Server error\")))\n                return\n            }\n            \n            guard let data = data else {\n                completion(.failure(.invalidResponse))\n                return\n            }\n            \n            do {\n                let apiResponse = try self.decoder.decode(APIResponse<[User]>.self, from: data)\n                if let users = apiResponse.data {\n                    completion(.success(users))\n                } else {\n                    completion(.failure(.decodingFailed(NSError(domain: \"No data\", code: -1))))\n                }\n            } catch {\n                completion(.failure(.decodingFailed(error)))\n            }\n        }.resume()\n    }\n    \n    // Similar methods for fetchPosts, fetchComments, etc.\n}\n\n// Mock data for testing\nlet mockUserJSON = \"\"\"\n{\n    \"status\": \"success\",\n    \"data\": [\n        {\n            \"id\": 1,\n            \"username\": \"johndoe\",\n            \"email\": \"john@example.com\",\n            \"profile_image\": \"https://example.com/john.jpg\",\n            \"join_date\": \"2024-01-15T10:30:00Z\",\n            \"is_verified\": true\n        }\n    ],\n    \"pagination\": {\n        \"current_page\": 1,\n        \"total_pages\": 5,\n        \"total_items\": 50\n    }\n}\n\"\"\"",
        "hints": [
          "PART 1: Use Codable protocol and ensure all property types are Codable (String, Int, Date, Bool, etc.)",
          "PART 2: Create enum CodingKeys: String, CodingKey for custom JSON key mapping",
          "PART 2: Use ISO8601DateFormatter() for reliable date parsing",
          "PART 3: Generic types like APIResponse<T> make your code more reusable",
          "PART 3: Use enums for fixed sets of values like PostType",
          "PART 4: Handle all possible error cases in network requests",
          "Use container.decodeIfPresent() for optional values that might be missing from JSON",
          "Test your decoding with various JSON inputs including edge cases",
          "Consider using Result type for better error handling in async code"
        ],
        "testCases": [
          {
            "input": "user.id > 0",
            "expectedOutput": "true",
            "description": "User ID should be positive"
          },
          {
            "input": "post.timeAgo.contains(\"ago\")",
            "expectedOutput": "true",
            "description": "timeAgo should contain 'ago'"
          },
          {
            "input": "apiResponse.status == \"success\"",
            "expectedOutput": "true",
            "description": "API response should have success status"
          }
        ]
      }
    },
    {
      "id": "userdefaults_filesystem",
      "title": "UserDefaults & File System",
      "description": "Master data persistence in iOS - from simple key-value storage to file system operations",
      "difficulty": "intermediate",
      "theory": "# UserDefaults & File System - Data Persistence in iOS\n\n## 1. Understanding Data Persistence (30 min)\n\n### Why Persist Data?\n- **User Preferences**: Settings, theme choices, user configurations\n- **App State**: Remember where user left off, cached data\n- **Offline Access**: Work without internet connection\n- **Performance**: Avoid re-downloading or re-calculating data\n\n### iOS Storage Options:\n- **UserDefaults**: Small key-value pairs (settings, preferences)\n- **File System**: Documents, images, custom file formats\n- **Core Data**: Complex object graphs, relationships\n- **Keychain**: Secure data (passwords, tokens)\n\n## 2. UserDefaults Deep Dive (45 min)\n\n### What is UserDefaults?\nA lightweight key-value store for simple data types:\n```swift\n// Supported types\nString, Int, Double, Float, Bool, Data, Date, Array, Dictionary\n```\n\n### Basic Operations:\n```swift\nlet defaults = UserDefaults.standard\n\n// Saving data\ndefaults.set(\"John\", forKey: \"userName\")\ndefaults.set(25, forKey: \"userAge\")\ndefaults.set(true, forKey: \"isLoggedIn\")\n\n// Retrieving data\nlet name = defaults.string(forKey: \"userName\")\nlet age = defaults.integer(forKey: \"userAge\")\nlet isLoggedIn = defaults.bool(forKey: \"isLoggedIn\")\n\n// Removing data\ndefaults.removeObject(forKey: \"userName\")\n```\n\n### @AppStorage Property Wrapper (SwiftUI):\n```swift\n@AppStorage(\"username\") var username: String = \"Anonymous\"\n@AppStorage(\"loginCount\") var loginCount: Int = 0\n@AppStorage(\"isDarkMode\") var isDarkMode: Bool = false\n```\n\n### Best Practices:\n- Use for small amounts of data (< 1MB)\n- Don't store sensitive information\n- Use consistent key naming conventions\n- Consider using a wrapper class for type safety\n\n## 3. File System Fundamentals (45 min)\n\n### iOS Sandbox Environment:\nEvery app runs in its own sandbox with specific directories:\n\n```swift\nlet fileManager = FileManager.default\n\n// Important directories\nlet documentsURL = fileManager.urls(for: .documentDirectory, in: .userDomainMask).first!\nlet cacheURL = fileManager.urls(for: .cachesDirectory, in: .userDomainMask).first!\nlet tempURL = fileManager.temporaryDirectory\n\n// Application Support (for user data that shouldn't be exposed)\nlet appSupportURL = fileManager.urls(for: .applicationSupportDirectory, in: .userDomainMask).first!\n```\n\n### Directory Purposes:\n- **Documents**: User-generated content, backed up by iCloud\n- **Caches**: Temporary files that can be recreated\n- **Temp**: Very short-lived files\n- **Application Support**: App files not visible to users\n\n## 4. File Operations (60 min)\n\n### Creating and Writing Files:\n```swift\n// Create file URL\nlet documents = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask).first!\nlet fileURL = documents.appendingPathComponent(\"data.txt\")\n\n// Write string to file\ntry \"Hello, World!\".write(to: fileURL, atomically: true, encoding: .utf8)\n\n// Write data to file\nlet data = \"Some data\".data(using: .utf8)!\ntry data.write(to: fileURL)\n```\n\n### Reading Files:\n```swift\n// Read string from file\nlet content = try String(contentsOf: fileURL, encoding: .utf8)\n\n// Read data from file\nlet fileData = try Data(contentsOf: fileURL)\n```\n\n### File Management:\n```swift\nlet fileManager = FileManager.default\n\n// Check if file exists\nif fileManager.fileExists(atPath: fileURL.path) {\n    print(\"File exists!\")\n}\n\n// Delete file\ntry fileManager.removeItem(at: fileURL)\n\n// Copy file\nlet newURL = documents.appendingPathComponent(\"copy.txt\")\ntry fileManager.copyItem(at: fileURL, to: newURL)\n\n// Get file attributes\nlet attributes = try fileManager.attributesOfItem(atPath: fileURL.path)\nlet fileSize = attributes[.size] as? Int\n```\n\n## 5. Working with Codable Objects (45 min)\n\n### Saving Custom Objects:\n```swift\nstruct UserSettings: Codable {\n    var theme: String\n    var fontSize: Int\n    var notificationsEnabled: Bool\n    var lastLogin: Date\n}\n\n// Save to UserDefaults\nlet settings = UserSettings(theme: \"dark\", fontSize: 16, notificationsEnabled: true, lastLogin: Date())\n\nif let encoded = try? JSONEncoder().encode(settings) {\n    UserDefaults.standard.set(encoded, forKey: \"userSettings\")\n}\n\n// Load from UserDefaults\nif let data = UserDefaults.standard.data(forKey: \"userSettings\"),\n   let decodedSettings = try? JSONDecoder().decode(UserSettings.self, from: data) {\n    print(decodedSettings.theme)\n}\n```\n\n### File System with Codable:\n```swift\n// Save to file\nlet userData = [\"users\": [user1, user2, user3]]\n\nif let encoded = try? JSONEncoder().encode(userData) {\n    let fileURL = documents.appendingPathComponent(\"users.json\")\n    try encoded.write(to: fileURL)\n}\n\n// Load from file\nlet fileURL = documents.appendingPathComponent(\"users.json\")\nif let data = try? Data(contentsOf: fileURL),\n   let decoded = try? JSONDecoder().decode([String: [User]].self, from: data) {\n    print(decoded[\"users\"]?.count)\n}\n```\n\n## 6. Advanced Topics (30 min)\n\n### File Coordination:\n```swift\n// For multi-threaded file access\nlet fileCoordinator = NSFileCoordinator()\n\nfileCoordinator.coordinate(readingItemAt: fileURL, options: []) { coordinatedURL in\n    // Safe to read from coordinatedURL\n}\n```\n\n### Error Handling:\n```swift\ndo {\n    try data.write(to: fileURL)\n} catch let error as NSError {\n    switch error.code {\n    case NSFileWriteOutOfSpaceError:\n        print(\"Out of space!\")\n    case NSFileWriteNoPermissionError:\n        print(\"No permission!\")\n    default:\n        print(\"Other error: \\(error.localizedDescription)\")\n    }\n}\n```\n\n### Performance Considerations:\n- Use background queues for large file operations\n- Cache frequently accessed data in memory\n- Compress large files before saving\n- Use streaming for very large files\n\n## 7. Security & Privacy (15 min)\n\n### Data Protection:\n- Use Keychain for sensitive data\n- Encrypt files containing personal information\n- Be mindful of what gets backed up to iCloud\n- Follow App Store guidelines for data handling\n\n### Best Practices Summary:\n- Use UserDefaults for preferences\n- Use File System for documents and media\n- Always handle errors gracefully\n- Test with limited storage scenarios\n- Consider data migration strategies",
      "codeExample": "import Foundation\n\n// === USERDEFAULTS EXAMPLES ===\n\n// Basic UserDefaults operations\nlet defaults = UserDefaults.standard\n\n// Storing different data types\ndefaults.set(\"Swift Learner\", forKey: \"username\")\ndefaults.set(25, forKey: \"userAge\")\ndefaults.set(98.5, forKey: \"userScore\")\ndefaults.set(true, forKey: \"isPremium\")\ndefaults.set(Date(), forKey: \"lastLogin\")\n\n// Arrays and Dictionaries\nlet favoriteColors = [\"blue\", \"green\", \"red\"]\ndefaults.set(favoriteColors, forKey: \"favoriteColors\")\n\nlet userSettings = [\"notifications\": true, \"theme\": \"dark\"]\ndefaults.set(userSettings, forKey: \"appSettings\")\n\n// Retrieving with type safety\nif let username = defaults.string(forKey: \"username\") {\n    print(\"Welcome back, \\(username)!\")\n}\n\nlet age = defaults.integer(forKey: \"userAge\")\nlet score = defaults.double(forKey: \"userScore\")\nlet isPremium = defaults.bool(forKey: \"isPremium\")\n\n// @AppStorage in SwiftUI (conceptual)\n// @AppStorage(\"username\") var username: String = \"Guest\"\n// @AppStorage(\"loginCount\") var loginCount: Int = 0\n\n// === FILE SYSTEM EXAMPLES ===\n\nlet fileManager = FileManager.default\n\n// Get directory URLs\nlet documentsURL = fileManager.urls(for: .documentDirectory, in: .userDomainMask).first!\nlet cacheURL = fileManager.urls(for: .cachesDirectory, in: .userDomainMask).first!\nlet tempURL = fileManager.temporaryDirectory\n\nprint(\"Documents: \\(documentsURL.path)\")\nprint(\"Cache: \\(cacheURL.path)\")\n\n// Create custom directory\nlet appFolderURL = documentsURL.appendingPathComponent(\"MyApp\")\n\ntry? fileManager.createDirectory(at: appFolderURL, withIntermediateDirectories: true)\n\n// File operations\nlet notesFileURL = appFolderURL.appendingPathComponent(\"notes.txt\")\n\n// Write to file\nlet noteContent = \"This is my first note!\\nCreated on \\(Date())\"\ndo {\n    try noteContent.write(to: notesFileURL, atomically: true, encoding: .utf8)\n    print(\"Note saved successfully!\")\n} catch {\n    print(\"Error saving note: \\(error)\")\n}\n\n// Read from file\ndo {\n    let savedContent = try String(contentsOf: notesFileURL, encoding: .utf8)\n    print(\"Saved content: \\(savedContent)\")\n} catch {\n    print(\"Error reading note: \\(error)\")\n}\n\n// Check file existence\nif fileManager.fileExists(atPath: notesFileURL.path) {\n    print(\"Notes file exists!\")\n    \n    // Get file attributes\n    if let attributes = try? fileManager.attributesOfItem(atPath: notesFileURL.path) {\n        if let fileSize = attributes[.size] as? Int {\n            print(\"File size: \\(fileSize) bytes\")\n        }\n        if let creationDate = attributes[.creationDate] as? Date {\n            print(\"Created: \\(creationDate)\")\n        }\n    }\n}\n\n// === CODABLE WITH PERSISTENCE ===\n\nstruct AppSettings: Codable {\n    var theme: String\n    var fontSize: Int\n    var notificationsEnabled: Bool\n    var lastUpdated: Date\n    var favoriteCategories: [String]\n}\n\n// Save Codable to UserDefaults\nlet settings = AppSettings(\n    theme: \"dark\",\n    fontSize: 16,\n    notificationsEnabled: true,\n    lastUpdated: Date(),\n    favoriteCategories: [\"Technology\", \"Science\", \"Art\"]\n)\n\nif let encodedSettings = try? JSONEncoder().encode(settings) {\n    defaults.set(encodedSettings, forKey: \"appSettings\")\n    print(\"Settings saved to UserDefaults!\")\n}\n\n// Load Codable from UserDefaults\nif let savedData = defaults.data(forKey: \"appSettings\"),\n   let decodedSettings = try? JSONDecoder().decode(AppSettings.self, from: savedData) {\n    print(\"Loaded theme: \\(decodedSettings.theme)\")\n    print(\"Favorite categories: \\(decodedSettings.favoriteCategories)\")\n}\n\n// Save Codable to File System\nlet settingsFileURL = appFolderURL.appendingPathComponent(\"settings.json\")\n\nif let settingsData = try? JSONEncoder().encode(settings) {\n    do {\n        try settingsData.write(to: settingsFileURL)\n        print(\"Settings saved to file!\")\n    } catch {\n        print(\"Error saving settings file: \\(error)\")\n    }\n}\n\n// List files in directory\nif let files = try? fileManager.contentsOfDirectory(atPath: appFolderURL.path) {\n    print(\"Files in app folder:\")\n    for file in files {\n        print(\" - \\(file)\")\n    }\n}\n\n// === ADVANCED FILE OPERATIONS ===\n\n// Copy file\nlet backupURL = appFolderURL.appendingPathComponent(\"notes_backup.txt\")\n\ndo {\n    if fileManager.fileExists(atPath: notesFileURL.path) {\n        try fileManager.copyItem(at: notesFileURL, to: backupURL)\n        print(\"Backup created!\")\n    }\n} catch {\n    print(\"Error creating backup: \\(error)\")\n}\n\n// Delete file\ndo {\n    if fileManager.fileExists(atPath: backupURL.path) {\n        try fileManager.removeItem(at: backupURL)\n        print(\"Backup deleted!\")\n    }\n} catch {\n    print(\"Error deleting backup: \\(error)\")\n}",
      "category": "iOS Storage",
      "estimatedTime": 180,
      "dependencies": ["variables", "optionals"],
      "challenge": {
        "instructions": "Create a complete settings and data management system for a reading app:\n\nPART 1: UserDefaults Manager (45 min)\n1. Create a SettingsManager class that uses UserDefaults\n2. Store: username, readingTheme (light/dark), fontSize, readingProgress\n3. Implement methods to save/load each setting with proper error handling\n4. Add a method to reset all settings\n\nPART 2: File System Operations (60 min)\n5. Create a FileManager class to handle book data\n6. Implement methods to:\n   - Save a book's content to documents directory\n   - Load a book's content from file\n   - List all saved books\n   - Delete a specific book\n7. Create a books directory in Documents folder\n\nPART 3: Codable Integration (45 min)\n8. Create a Book struct with: title, author, content, lastReadPosition, isFavorite\n9. Save/Load book metadata using UserDefaults with Codable\n10. Save/Load book content to file system\n\nPART 4: Advanced Features (30 min)\n11. Implement a backup system that copies all books to a backup folder\n12. Create a method to get storage statistics (total books, total size)\n13. Add migration support for app updates\n\nPART 5: Error Handling & UI Integration (60 min)\n14. Create comprehensive error handling for all operations\n15. Design a SwiftUI view that demonstrates all storage features\n16. Add progress indicators for large file operations",
        "starterCode": "import Foundation\n\n// === PART 1: UserDefaults Manager ===\nclass SettingsManager {\n    // Implement UserDefaults management here\n    \n}\n\n// === PART 2: File System Operations ===\nclass BookFileManager {\n    // Implement file system operations here\n    \n}\n\n// === PART 3: Codable Integration ===\nstruct Book: Codable {\n    // Define book structure here\n    \n}\n\n// === PART 4: Advanced Features ===\n// Implement backup and statistics here\n\n// === PART 5: Error Handling ===\n// Add comprehensive error handling\n",
        "solution": "import Foundation\n\n// === PART 1: UserDefaults Manager ===\nclass SettingsManager {\n    private let defaults = UserDefaults.standard\n    \n    // User settings keys\n    private enum SettingKeys {\n        static let username = \"username\"\n        static let readingTheme = \"readingTheme\"\n        static let fontSize = \"fontSize\"\n        static let readingProgress = \"readingProgress\"\n        static let booksMetadata = \"booksMetadata\"\n    }\n    \n    // Save settings\n    func saveUsername(_ username: String) {\n        defaults.set(username, forKey: SettingKeys.username)\n    }\n    \n    func saveReadingTheme(_ theme: String) {\n        defaults.set(theme, forKey: SettingKeys.readingTheme)\n    }\n    \n    func saveFontSize(_ size: Int) {\n        defaults.set(size, forKey: SettingKeys.fontSize)\n    }\n    \n    func saveReadingProgress(_ progress: Double) {\n        defaults.set(progress, forKey: SettingKeys.readingProgress)\n    }\n    \n    // Load settings\n    func loadUsername() -> String {\n        return defaults.string(forKey: SettingKeys.username) ?? \"Reader\"\n    }\n    \n    func loadReadingTheme() -> String {\n        return defaults.string(forKey: SettingKeys.readingTheme) ?? \"light\"\n    }\n    \n    func loadFontSize() -> Int {\n        return defaults.integer(forKey: SettingKeys.fontSize)\n    }\n    \n    func loadReadingProgress() -> Double {\n        return defaults.double(forKey: SettingKeys.readingProgress)\n    }\n    \n    // Reset all settings\n    func resetAllSettings() {\n        let dictionary = defaults.dictionaryRepresentation()\n        dictionary.keys.forEach { key in\n            defaults.removeObject(forKey: key)\n        }\n    }\n}\n\n// === PART 2: File System Operations ===\nclass BookFileManager {\n    private let fileManager = FileManager.default\n    \n    var booksDirectoryURL: URL {\n        let documents = fileManager.urls(for: .documentDirectory, in: .userDomainMask).first!\n        return documents.appendingPathComponent(\"Books\")\n    }\n    \n    var backupDirectoryURL: URL {\n        let documents = fileManager.urls(for: .documentDirectory, in: .userDomainMask).first!\n        return documents.appendingPathComponent(\"Backups\")\n    }\n    \n    init() {\n        createDirectoriesIfNeeded()\n    }\n    \n    private func createDirectoriesIfNeeded() {\n        try? fileManager.createDirectory(at: booksDirectoryURL, withIntermediateDirectories: true)\n        try? fileManager.createDirectory(at: backupDirectoryURL, withIntermediateDirectories: true)\n    }\n    \n    // Save book content to file\n    func saveBookContent(_ content: String, forBook book: Book) throws {\n        let fileURL = booksDirectoryURL.appendingPathComponent(\"\\(book.id).txt\")\n        try content.write(to: fileURL, atomically: true, encoding: .utf8)\n    }\n    \n    // Load book content from file\n    func loadBookContent(forBook book: Book) throws -> String {\n        let fileURL = booksDirectoryURL.appendingPathComponent(\"\\(book.id).txt\")\n        return try String(contentsOf: fileURL, encoding: .utf8)\n    }\n    \n    // List all saved books\n    func listAllBooks() -> [String] {\n        guard let files = try? fileManager.contentsOfDirectory(atPath: booksDirectoryURL.path) else {\n            return []\n        }\n        return files.filter { $0.hasSuffix(\".txt\") }\n    }\n    \n    // Delete specific book\n    func deleteBook(_ book: Book) throws {\n        let fileURL = booksDirectoryURL.appendingPathComponent(\"\\(book.id).txt\")\n        if fileManager.fileExists(atPath: fileURL.path) {\n            try fileManager.removeItem(at: fileURL)\n        }\n    }\n    \n    // Get file size\n    func getFileSize(forBook book: Book) -> Int? {\n        let fileURL = booksDirectoryURL.appendingPathComponent(\"\\(book.id).txt\")\n        guard let attributes = try? fileManager.attributesOfItem(atPath: fileURL.path),\n              let size = attributes[.size] as? Int else {\n            return nil\n        }\n        return size\n    }\n}\n\n// === PART 3: Codable Integration ===\nstruct Book: Codable, Identifiable {\n    let id: UUID\n    var title: String\n    var author: String\n    var content: String\n    var lastReadPosition: Int\n    var isFavorite: Bool\n    var dateAdded: Date\n    \n    init(title: String, author: String, content: String = \"\") {\n        self.id = UUID()\n        self.title = title\n        self.author = author\n        self.content = content\n        self.lastReadPosition = 0\n        self.isFavorite = false\n        self.dateAdded = Date()\n    }\n}\n\nclass BookDataManager {\n    private let defaults = UserDefaults.standard\n    private let fileManager = BookFileManager()\n    \n    private let booksKey = \"savedBooks\"\n    \n    // Save books metadata\n    func saveBooks(_ books: [Book]) {\n        if let encoded = try? JSONEncoder().encode(books) {\n            defaults.set(encoded, forKey: booksKey)\n        }\n    }\n    \n    // Load books metadata\n    func loadBooks() -> [Book] {\n        guard let data = defaults.data(forKey: booksKey),\n              let books = try? JSONDecoder().decode([Book].self, from: data) else {\n            return []\n        }\n        return books\n    }\n    \n    // Save book with content\n    func saveBookWithContent(_ book: Book) throws {\n        var currentBooks = loadBooks()\n        \n        // Update or add book\n        if let index = currentBooks.firstIndex(where: { $0.id == book.id }) {\n            currentBooks[index] = book\n        } else {\n            currentBooks.append(book)\n        }\n        \n        saveBooks(currentBooks)\n        try fileManager.saveBookContent(book.content, forBook: book)\n    }\n    \n    // Load book with content\n    func loadBookWithContent(_ book: Book) throws -> Book {\n        var loadedBook = book\n        let content = try fileManager.loadBookContent(forBook: book)\n        loadedBook.content = content\n        return loadedBook\n    }\n}\n\n// === PART 4: Advanced Features ===\nextension BookFileManager {\n    // Create backup\n    func createBackup() throws {\n        let books = listAllBooks()\n        let timestamp = Date().timeIntervalSince1970\n        let backupFolder = backupDirectoryURL.appendingPathComponent(\"backup_\\(Int(timestamp))\")\n        \n        try fileManager.createDirectory(at: backupFolder, withIntermediateDirectories: true)\n        \n        for bookFile in books {\n            let sourceURL = booksDirectoryURL.appendingPathComponent(bookFile)\n            let destURL = backupFolder.appendingPathComponent(bookFile)\n            try fileManager.copyItem(at: sourceURL, to: destURL)\n        }\n    }\n    \n    // Get storage statistics\n    func getStorageStatistics() -> (bookCount: Int, totalSize: Int) {\n        let books = listAllBooks()\n        var totalSize = 0\n        \n        for bookFile in books {\n            let fileURL = booksDirectoryURL.appendingPathComponent(bookFile)\n            if let attributes = try? fileManager.attributesOfItem(atPath: fileURL.path),\n               let size = attributes[.size] as? Int {\n                totalSize += size\n            }\n        }\n        \n        return (books.count, totalSize)\n    }\n}\n\n// === PART 5: Error Handling ===\nenum StorageError: Error, LocalizedError {\n    case fileNotFound\n    case insufficientSpace\n    case invalidData\n    case backupFailed\n    \n    var errorDescription: String? {\n        switch self {\n        case .fileNotFound:\n            return \"The requested file was not found.\"\n        case .insufficientSpace:\n            return \"There is not enough space to complete the operation.\"\n        case .invalidData:\n            return \"The data is invalid or corrupted.\"\n        case .backupFailed:\n            return \"Backup operation failed.\"\n        }\n    }\n}",
        "hints": [
          "PART 1: Use consistent key names and provide default values for UserDefaults retrieval",
          "PART 2: Create directories in init() and use URL.appendingPathComponent() for file paths",
          "PART 3: Use UUID for book IDs to ensure uniqueness, and separate metadata from content",
          "PART 4: Include timestamps in backup folder names to avoid overwrites",
          "PART 5: Create custom error types that conform to LocalizedError for user-friendly messages",
          "Use try? for operations that can fail but shouldn't crash the app",
          "Consider using a background queue for large file operations",
          "Test your code with limited storage scenarios to ensure robustness",
          "Use FileManager.default.urls(for:in:) to get proper directory URLs"
        ],
        "testCases": [
          {
            "input": "SettingsManager().loadUsername() != \"\"",
            "expectedOutput": "true",
            "description": "Should return default username when no value is set"
          },
          {
            "input": "BookFileManager().listAllBooks() is [String]",
            "expectedOutput": "true",
            "description": "listAllBooks should return an array of strings"
          },
          {
            "input": "Book(title: \"Test\", author: \"Author\").id != Book(title: \"Test2\", author: \"Author2\").id",
            "expectedOutput": "true",
            "description": "Each book should have a unique ID"
          }
        ]
      }
    },
    {
      "id": "custom_animations",
      "title": "Custom Animations",
      "description": "Master GeometryEffect, Animatable, and create stunning custom animations in SwiftUI",
      "difficulty": "intermediate",
      "theory": "# Custom Animations - Beyond the Basics\n\n## 1. Understanding SwiftUI's Animation System (45 min)\n\n### The Animation Pipeline:\nSwiftUI's animation system has three core components:\n1. **Animatable Data**: The values that change over time\n2. **Animation Timing**: How values interpolate between states\n3. **View Updates**: How the view responds to changing values\n\n### Built-in vs Custom Animations:\n- **Built-in**: `.easeInOut`, `.spring()`, `.linear`\n- **Custom**: `GeometryEffect`, `Animatable`, `AnimatableModifier`\n\n## 2. The Animatable Protocol (1.5 hours)\n\n### What is Animatable?\nThe `Animatable` protocol allows SwiftUI to interpolate between values of custom types:\n\n```swift\nprotocol Animatable {\n    associatedtype AnimatableData: VectorArithmetic\n    var animatableData: AnimatableData { get set }\n}\n```\n\n### Making Custom Types Animatable:\n```swift\nstruct CustomPoint: Animatable {\n    var x: Double\n    var y: Double\n    \n    var animatableData: AnimatablePair<Double, Double> {\n        get { AnimatablePair(x, y) }\n        set {\n            x = newValue.first\n            y = newValue.second\n        }\n    }\n}\n```\n\n### Complex Animatable Types:\n```swift\nstruct Transform3D: Animatable {\n    var rotation: Angle\n    var scale: CGSize\n    var translation: CGSize\n    \n    var animatableData: AnimatablePair<\n        AnimatablePair<Double, AnimatablePair<CGFloat, CGFloat>>,\n        AnimatablePair<CGFloat, CGFloat>\n    > {\n        get {\n            AnimatablePair(\n                AnimatablePair(rotation.radians, AnimatablePair(scale.width, scale.height)),\n                AnimatablePair(translation.width, translation.height)\n            )\n        }\n        set {\n            rotation = .radians(newValue.first.first)\n            scale = CGSize(width: newValue.first.second.first, height: newValue.first.second.second)\n            translation = CGSize(width: newValue.second.first, height: newValue.second.second)\n        }\n    }\n}\n```\n\n## 3. GeometryEffect Protocol (2 hours)\n\n### What is GeometryEffect?\n`GeometryEffect` is a protocol for creating geometric transformations that can be animated:\n\n```swift\nprotocol GeometryEffect: Animatable, ViewModifier where Self.Body == Never {\n    func effectValue(size: CGSize) -> ProjectionTransform\n}\n```\n\n### Creating Basic Geometry Effects:\n```swift\nstruct SkewEffect: GeometryEffect {\n    var amount: CGFloat\n    \n    var animatableData: CGFloat {\n        get { amount }\n        set { amount = newValue }\n    }\n    \n    func effectValue(size: CGSize) -> ProjectionTransform {\n        // Create a skew transformation matrix\n        let transform = CGAffineTransform(\n            a: 1, b: amount,\n            c: 0, d: 1,\n            tx: 0, ty: 0\n        )\n        return ProjectionTransform(transform)\n    }\n}\n```\n\n### Advanced 3D Transformations:\n```swift\nstruct Rotation3DEffect: GeometryEffect {\n    var angle: Angle\n    var axis: (x: CGFloat, y: CGFloat, z: CGFloat)\n    var anchor: UnitPoint = .center\n    var anchorZ: CGFloat = 0\n    var perspective: CGFloat = 0\n    \n    var animatableData: Double {\n        get { angle.radians }\n        set { angle = .radians(newValue) }\n    }\n    \n    func effectValue(size: CGSize) -> ProjectionTransform {\n        // Calculate 3D rotation matrix\n        let radians = angle.radians\n        \n        var transform = CATransform3DIdentity\n        transform.m34 = perspective\n        \n        // Translate to anchor point\n        let anchorPoint = CGPoint(\n            x: size.width * anchor.x,\n            y: size.height * anchor.y\n        )\n        transform = CATransform3DTranslate(transform, anchorPoint.x, anchorPoint.y, anchorZ)\n        \n        // Apply rotation\n        transform = CATransform3DRotate(transform, radians, axis.x, axis.y, axis.z)\n        \n        // Translate back\n        transform = CATransform3DTranslate(transform, -anchorPoint.x, -anchorPoint.y, -anchorZ)\n        \n        return ProjectionTransform(transform)\n    }\n}\n```\n\n## 4. AnimatableModifier (1 hour)\n\n### Creating Complex Animated Modifiers:\n```swift\nstruct GlowEffect: AnimatableModifier {\n    var intensity: CGFloat\n    var color: Color = .blue\n    var radius: CGFloat = 10\n    \n    var animatableData: CGFloat {\n        get { intensity }\n        set { intensity = newValue }\n    }\n    \n    func body(content: Content) -> some View {\n        content\n            .overlay(\n                content\n                    .blur(radius: radius * intensity)\n                    .opacity(intensity)\n                    .foregroundColor(color)\n            )\n    }\n}\n```\n\n## 5. Advanced Animation Techniques (45 min)\n\n### Chained Animations:\n```swift\nstruct ChainedAnimation: ViewModifier {\n    let delay: Double\n    let animation: Animation\n    \n    @State private var isActive = false\n    \n    func body(content: Content) -> some View {\n        content\n            .opacity(isActive ? 1 : 0)\n            .scaleEffect(isActive ? 1 : 0.5)\n            .onAppear {\n                DispatchQueue.main.asyncAfter(deadline: .now() + delay) {\n                    withAnimation(animation) {\n                        isActive = true\n                    }\n                }\n            }\n    }\n}\n```\n\n### Physics-Based Animations:\n```swift\nstruct SpringAnimation: GeometryEffect {\n    var velocity: CGPoint\n    var damping: CGFloat\n    var stiffness: CGFloat\n    \n    private var position: CGPoint\n    private var time: CGFloat = 0\n    \n    var animatableData: AnimatablePair<CGFloat, AnimatablePair<CGFloat, CGFloat>> {\n        get {\n            AnimatablePair(time, AnimatablePair(position.x, position.y))\n        }\n        set {\n            time = newValue.first\n            position = CGPoint(x: newValue.second.first, y: newValue.second.second)\n        }\n    }\n    \n    init(target: CGPoint, velocity: CGPoint = .zero, damping: CGFloat = 0.5, stiffness: CGFloat = 100) {\n        self.position = target\n        self.velocity = velocity\n        self.damping = damping\n        self.stiffness = stiffness\n    }\n    \n    func effectValue(size: CGSize) -> ProjectionTransform {\n        // Simulate spring physics\n        let forceX = -stiffness * position.x - damping * velocity.x\n        let forceY = -stiffness * position.y - damping * velocity.y\n        \n        // Update velocity and position (simplified)\n        let newVelocity = CGPoint(x: velocity.x + forceX * 0.016, y: velocity.y + forceY * 0.016)\n        let newPosition = CGPoint(x: position.x + newVelocity.x * 0.016, y: position.y + newVelocity.y * 0.016)\n        \n        return ProjectionTransform(CGAffineTransform(translationX: newPosition.x, y: newPosition.y))\n    }\n}\n```\n\n## 6. Performance Optimization (30 min)\n\n### Efficient Animatable Data:\n- Use `AnimatablePair` for 2 values\n- Use `EmptyAnimatableData` for no animation\n- Avoid complex calculations in `effectValue`\n\n### Animation Best Practices:\n- Prefer `GeometryEffect` over view state changes\n- Use `DrawingGroup()` for complex vector animations\n- Limit the number of simultaneously animating views\n\n## Real-World Applications\n\nComplete the challenges to master these techniques and create professional-grade animations!",
      "codeExample": "import SwiftUI\n\n// === 1. BASIC ANIMATABLE TYPES ===\nstruct AnimatedColor: Animatable {\n    var red: Double\n    var green: Double\n    var blue: Double\n    \n    var color: Color {\n        Color(red: red, green: green, blue: blue)\n    }\n    \n    var animatableData: AnimatablePair<Double, AnimatablePair<Double, Double>> {\n        get {\n            AnimatablePair(red, AnimatablePair(green, blue))\n        }\n        set {\n            red = newValue.first\n            green = newValue.second.first\n            blue = newValue.second.second\n        }\n    }\n}\n\n// === 2. GEOMETRY EFFECT EXAMPLES ===\nstruct WaveEffect: GeometryEffect {\n    var phase: CGFloat\n    var strength: CGFloat\n    var frequency: CGFloat\n    \n    var animatableData: CGFloat {\n        get { phase }\n        set { phase = newValue }\n    }\n    \n    func effectValue(size: CGSize) -> ProjectionTransform {\n        // Create wave distortion\n        let transform = CGAffineTransform(\n            translationX: sin(phase * frequency) * strength,\n            y: 0\n        )\n        return ProjectionTransform(transform)\n    }\n}\n\nstruct MorphEffect: GeometryEffect {\n    var progress: CGFloat\n    var controlPoints: [CGPoint]\n    \n    var animatableData: CGFloat {\n        get { progress }\n        set { progress = newValue }\n    }\n    \n    func effectValue(size: CGSize) -> ProjectionTransform {\n        // BÃ©zier curve morphing\n        let t = progress\n        let oneMinusT = 1 - t\n        \n        // Quadratic BÃ©zier interpolation\n        let x = oneMinusT * oneMinusT * controlPoints[0].x +\n                2 * oneMinusT * t * controlPoints[1].x +\n                t * t * controlPoints[2].x\n        \n        let y = oneMinusT * oneMinusT * controlPoints[0].y +\n                2 * oneMinusT * t * controlPoints[1].y +\n                t * t * controlPoints[2].y\n        \n        return ProjectionTransform(CGAffineTransform(translationX: x, y: y))\n    }\n}\n\n// === 3. ADVANCED 3D TRANSFORMS ===\nstruct CardFlipEffect: GeometryEffect {\n    var rotation: Double\n    var perspective: CGFloat = 0.001\n    \n    var animatableData: Double {\n        get { rotation }\n        set { rotation = newValue }\n    }\n    \n    func effectValue(size: CGSize) -> ProjectionTransform {\n        var transform = CATransform3DIdentity\n        transform.m34 = perspective\n        \n        // Rotate around Y-axis for card flip\n        transform = CATransform3DRotate(transform, rotation, 0, 1, 0)\n        \n        return ProjectionTransform(transform)\n    }\n}\n\n// === 4. COMPLEX ANIMATABLE MODIFIER ===\nstruct ParticleEffect: AnimatableModifier {\n    var emissionRate: CGFloat\n    var particleSize: CGFloat\n    var spread: CGFloat\n    \n    var animatableData: AnimatablePair<CGFloat, AnimatablePair<CGFloat, CGFloat>> {\n        get {\n            AnimatablePair(emissionRate, AnimatablePair(particleSize, spread))\n        }\n        set {\n            emissionRate = newValue.first\n            particleSize = newValue.second.first\n            spread = newValue.second.second\n        }\n    }\n    \n    func body(content: Content) -> some View {\n        content\n            .overlay(\n                ParticleOverlay(\n                    emissionRate: emissionRate,\n                    particleSize: particleSize,\n                    spread: spread\n                )\n            )\n    }\n}\n\nstruct ParticleOverlay: View {\n    let emissionRate: CGFloat\n    let particleSize: CGFloat\n    let spread: CGFloat\n    \n    var body: some View {\n        GeometryReader { geometry in\n            ForEach(0..<Int(emissionRate * 10), id: \\.self) { index in\n                Circle()\n                    .fill(Color.blue)\n                    .frame(width: particleSize, height: particleSize)\n                    .offset(\n                        x: CGFloat.random(in: -spread...spread) * geometry.size.width,\n                        y: CGFloat.random(in: -spread...spread) * geometry.size.height\n                    )\n                    .opacity(Double.random(in: 0.2...0.8))\n            }\n        }\n    }\n}\n\n// === 5. PRACTICAL USAGE EXAMPLES ===\nstruct AnimationExamples: View {\n    @State private var wavePhase: CGFloat = 0\n    @State private var flipRotation: Double = 0\n    @State private var morphProgress: CGFloat = 0\n    @State private var particleIntensity: CGFloat = 0\n    \n    var body: some View {\n        VStack(spacing: 30) {\n            // Wave animation\n            Text(\"Wave Effect\")\n                .modifier(WaveEffect(phase: wavePhase, strength: 10, frequency: 2))\n                .onAppear {\n                    withAnimation(Animation.linear(duration: 2).repeatForever(autoreverses: false)) {\n                        wavePhase = .pi * 2\n                    }\n                }\n            \n            // Card flip\n            RoundedRectangle(cornerRadius: 10)\n                .fill(Color.blue)\n                .frame(width: 100, height: 150)\n                .modifier(CardFlipEffect(rotation: flipRotation))\n                .onTapGesture {\n                    withAnimation(.spring(response: 0.6, dampingFraction: 0.6)) {\n                        flipRotation += .pi\n                    }\n                }\n            \n            // Morph animation\n            Circle()\n                .fill(Color.green)\n                .frame(width: 50, height: 50)\n                .modifier(MorphEffect(\n                    progress: morphProgress,\n                    controlPoints: [\n                        CGPoint(x: 0, y: 0),\n                        CGPoint(x: 50, y: -50),\n                        CGPoint(x: 100, y: 0)\n                    ]\n                ))\n                .onTapGesture {\n                    withAnimation(.easeInOut(duration: 1.5)) {\n                        morphProgress = morphProgress == 0 ? 1 : 0\n                    }\n                }\n            \n            // Particle effect\n            Text(\"Particles\")\n                .modifier(ParticleEffect(\n                    emissionRate: particleIntensity,\n                    particleSize: 4,\n                    spread: 0.1\n                ))\n                .onTapGesture {\n                    withAnimation(.easeInOut(duration: 2)) {\n                        particleIntensity = particleIntensity == 0 ? 5 : 0\n                    }\n                }\n        }\n    }\n}",
      "category": "SwiftUI Advanced",
      "estimatedTime": 300,
      "dependencies": ["variables", "optionals"],
      "challenge": {
        "instructions": "Create a comprehensive animation system with multiple custom effects:\n\nPART 1: Animatable Custom Types (1 hour)\n1. Create an `AnimatedGradient` type that animates between colors\n2. Implement `Animatable` protocol with proper `animatableData`\n3. Create a smooth color transition animation\n\nPART 2: GeometryEffect Transformations (1.5 hours)\n4. Create a `BounceEffect` that simulates physics-based bouncing\n5. Implement a `WobbleEffect` with spring-like oscillations\n6. Create a `LiquidEffect` that simulates fluid motion\n\nPART 3: Advanced 3D Animations (1.5 hours)\n7. Build a `CubeRotationEffect` that rotates a view in 3D space\n8. Create a `PageCurlEffect` that simulates page turning\n9. Implement perspective-correct 3D transformations\n\nPART 4: Complex AnimatableModifier (1 hour)\n10. Create a `SparkleEffect` modifier with animated particles\n11. Build a `RippleEffect` that creates water-like ripples\n12. Combine multiple effects in a single modifier\n\nPART 5: Performance & Optimization (1 hour)\n13. Optimize all effects for performance\n14. Create reusable animation components\n15. Build a demo showcasing all effects together",
        "starterCode": "import SwiftUI\n\n// === PART 1: Animatable Custom Types ===\n// Create AnimatedGradient type here\n\n\n// === PART 2: GeometryEffect Transformations ===\n// Create BounceEffect, WobbleEffect, and LiquidEffect here\n\n\n// === PART 3: Advanced 3D Animations ===\n// Create CubeRotationEffect and PageCurlEffect here\n\n\n// === PART 4: Complex AnimatableModifier ===\n// Create SparkleEffect and RippleEffect here\n\n\n// === PART 5: Demo View ===\nstruct CustomAnimationsDemo: View {\n    @State private var isAnimating = false\n    \n    var body: some View {\n        VStack(spacing: 40) {\n            Text(\"Custom Animations Demo\")\n                .font(.title)\n                .bold()\n            \n            // Add your animation demos here\n            \n            Button(\"Toggle Animation\") {\n                withAnimation(.spring(response: 0.6, dampingFraction: 0.8)) {\n                    isAnimating.toggle()\n                }\n            }\n            .padding()\n            .background(Color.blue)\n            .foregroundColor(.white)\n            .cornerRadius(10)\n        }\n        .padding()\n    }\n}",
        "solution": "import SwiftUI\n\n// === PART 1: Animatable Custom Types ===\nstruct AnimatedGradient: Animatable {\n    var startColor: Color\n    var endColor: Color\n    var progress: CGFloat\n    \n    var animatableData: AnimatablePair<CGFloat, AnimatablePair<Double, Double>> {\n        get {\n            // Convert colors to animatable data (simplified)\n            let startValues = colorToValues(startColor)\n            let endValues = colorToValues(endColor)\n            return AnimatablePair(progress, AnimatablePair(startValues, endValues))\n        }\n        set {\n            progress = newValue.first\n            // In real implementation, you'd convert back to colors\n        }\n    }\n    \n    private func colorToValues(_ color: Color) -> Double {\n        // Simplified - in real app, extract RGB components\n        return 0.5\n    }\n}\n\n// === PART 2: GeometryEffect Transformations ===\nstruct BounceEffect: GeometryEffect {\n    var amplitude: CGFloat\n    var frequency: CGFloat\n    var time: CGFloat\n    \n    var animatableData: AnimatablePair<CGFloat, AnimatablePair<CGFloat, CGFloat>> {\n        get { AnimatablePair(amplitude, AnimatablePair(frequency, time)) }\n        set {\n            amplitude = newValue.first\n            frequency = newValue.second.first\n            time = newValue.second.second\n        }\n    }\n    \n    func effectValue(size: CGSize) -> ProjectionTransform {\n        let bounce = amplitude * sin(time * frequency * 2 * .pi)\n        let decay = amplitude * exp(-time * 0.5) // Damping\n        let offset = bounce * decay\n        \n        return ProjectionTransform(CGAffineTransform(translationX: 0, y: offset))\n    }\n}\n\nstruct WobbleEffect: GeometryEffect {\n    var intensity: CGFloat\n    var speed: CGFloat\n    var time: CGFloat\n    \n    var animatableData: AnimatablePair<CGFloat, AnimatablePair<CGFloat, CGFloat>> {\n        get { AnimatablePair(intensity, AnimatablePair(speed, time)) }\n        set {\n            intensity = newValue.first\n            speed = newValue.second.first\n            time = newValue.second.second\n        }\n    }\n    \n    func effectValue(size: CGSize) -> ProjectionTransform {\n        let rotation = intensity * sin(time * speed * 2 * .pi) * 0.1\n        let transform = CGAffineTransform(rotationAngle: rotation)\n        return ProjectionTransform(transform)\n    }\n}\n\nstruct LiquidEffect: GeometryEffect {\n    var phase: CGFloat\n    var amplitude: CGFloat\n    var frequency: CGFloat\n    \n    var animatableData: AnimatablePair<CGFloat, AnimatablePair<CGFloat, CGFloat>> {\n        get { AnimatablePair(phase, AnimatablePair(amplitude, frequency)) }\n        set {\n            phase = newValue.first\n            amplitude = newValue.second.first\n            frequency = newValue.second.second\n        }\n    }\n    \n    func effectValue(size: CGSize) -> ProjectionTransform {\n        let distortion = amplitude * sin(phase * frequency)\n        // Complex liquid distortion would use more advanced math\n        let transform = CGAffineTransform(\n            a: 1 + distortion * 0.1, b: distortion * 0.05,\n            c: distortion * 0.05, d: 1 + distortion * 0.1,\n            tx: 0, ty: 0\n        )\n        return ProjectionTransform(transform)\n    }\n}\n\n// === PART 3: Advanced 3D Animations ===\nstruct CubeRotationEffect: GeometryEffect {\n    var rotation: Double\n    var perspective: CGFloat = 0.001\n    \n    var animatableData: Double {\n        get { rotation }\n        set { rotation = newValue }\n    }\n    \n    func effectValue(size: CGSize) -> ProjectionTransform {\n        var transform = CATransform3DIdentity\n        transform.m34 = perspective\n        \n        // Rotate on multiple axes for cube-like effect\n        transform = CATransform3DRotate(transform, rotation, 1, 1, 0)\n        \n        return ProjectionTransform(transform)\n    }\n}\n\nstruct PageCurlEffect: GeometryEffect {\n    var progress: CGFloat\n    var radius: CGFloat = 100\n    \n    var animatableData: CGFloat {\n        get { progress }\n        set { progress = newValue }\n    }\n    \n    func effectValue(size: CGSize) -> ProjectionTransform {\n        // Simplified page curl - real implementation would be more complex\n        let angle = progress * .pi / 2\n        let curvature = sin(angle) * radius\n        \n        var transform = CATransform3DIdentity\n        transform.m34 = -0.002\n        transform = CATransform3DTranslate(transform, curvature, 0, 0)\n        transform = CATransform3DRotate(transform, -angle, 0, 1, 0)\n        \n        return ProjectionTransform(transform)\n    }\n}\n\n// === PART 4: Complex AnimatableModifier ===\nstruct SparkleEffect: AnimatableModifier {\n    var intensity: CGFloat\n    var speed: CGFloat\n    \n    var animatableData: AnimatablePair<CGFloat, CGFloat> {\n        get { AnimatablePair(intensity, speed) }\n        set {\n            intensity = newValue.first\n            speed = newValue.second\n        }\n    }\n    \n    func body(content: Content) -> some View {\n        content.overlay(\n            SparkleOverlay(intensity: intensity, speed: speed)\n        )\n    }\n}\n\nstruct SparkleOverlay: View {\n    let intensity: CGFloat\n    let speed: CGFloat\n    \n    var body: some View {\n        GeometryReader { geometry in\n            ForEach(0..<Int(intensity * 5), id: \\.self) { index in\n                Circle()\n                    .fill(Color.white)\n                    .frame(width: 3, height: 3)\n                    .position(\n                        x: CGFloat.random(in: 0...geometry.size.width),\n                        y: CGFloat.random(in: 0...geometry.size.height)\n                    )\n                    .opacity(Double.random(in: 0.3...0.9))\n                    .scaleEffect(CGFloat.random(in: 0.5...1.5))\n            }\n        }\n    }\n}\n\n// === PART 5: Demo View ===\nstruct CustomAnimationsDemo: View {\n    @State private var isAnimating = false\n    @State private var bounceTime: CGFloat = 0\n    @State private var wobbleTime: CGFloat = 0\n    @State private var liquidPhase: CGFloat = 0\n    @State private var cubeRotation: Double = 0\n    @State private var pageCurlProgress: CGFloat = 0\n    @State private var sparkleIntensity: CGFloat = 0\n    \n    var body: some View {\n        VStack(spacing: 40) {\n            Text(\"Custom Animations Demo\")\n                .font(.title)\n                .bold()\n            \n            // Bounce Effect\n            Rectangle()\n                .fill(Color.blue)\n                .frame(width: 80, height: 80)\n                .modifier(BounceEffect(amplitude: 20, frequency: 2, time: bounceTime))\n            \n            // Wobble Effect\n            Circle()\n                .fill(Color.green)\n                .frame(width: 80, height: 80)\n                .modifier(WobbleEffect(intensity: 1, speed: 2, time: wobbleTime))\n            \n            // Cube Rotation\n            Rectangle()\n                .fill(Color.orange)\n                .frame(width: 80, height: 80)\n                .modifier(CubeRotationEffect(rotation: cubeRotation))\n            \n            // Sparkle Effect\n            Text(\"Sparkle\")\n                .font(.title2)\n                .modifier(SparkleEffect(intensity: sparkleIntensity, speed: 2))\n            \n            Button(\"Toggle Animation\") {\n                withAnimation(.spring(response: 0.6, dampingFraction: 0.8)) {\n                    isAnimating.toggle()\n                    \n                    if isAnimating {\n                        // Start all animations\n                        withAnimation(Animation.easeInOut(duration: 1).repeatForever(autoreverses: true)) {\n                            bounceTime = 1\n                            wobbleTime = 1\n                            liquidPhase = 2 * .pi\n                        }\n                        \n                        withAnimation(Animation.linear(duration: 4).repeatForever(autoreverses: false)) {\n                            cubeRotation = 2 * .pi\n                        }\n                        \n                        sparkleIntensity = 3\n                    } else {\n                        // Stop animations\n                        bounceTime = 0\n                        wobbleTime = 0\n                        liquidPhase = 0\n                        cubeRotation = 0\n                        sparkleIntensity = 0\n                    }\n                }\n            }\n            .padding()\n            .background(Color.blue)\n            .foregroundColor(.white)\n            .cornerRadius(10)\n        }\n        .padding()\n    }\n}",
        "hints": [
          "PART 1: Use AnimatablePair to combine multiple animatable values",
          "PART 2: GeometryEffect requires both animatableData and effectValue(size:)",
          "PART 3: For 3D effects, use CATransform3D and set m34 for perspective",
          "PART 4: AnimatableModifier combines Animatable and ViewModifier protocols",
          "Use trigonometric functions (sin, cos) for smooth, periodic animations",
          "Remember to handle the animatableData get/set properly for all properties",
          "Test each effect individually before combining them",
          "Use ProjectionTransform to convert CGAffineTransform or CATransform3D",
          "For performance, avoid complex calculations in effectValue(size:)"
        ],
        "testCases": [
          {
            "input": "bounceTime > 0 && bounceTime <= 1",
            "expectedOutput": "true",
            "description": "Bounce animation should be active when toggled"
          },
          {
            "input": "cubeRotation >= 0 && cubeRotation <= 2 * .pi",
            "expectedOutput": "true",
            "description": "Cube rotation should be within valid range"
          },
          {
            "input": "sparkleIntensity >= 0 && sparkleIntensity <= 5",
            "expectedOutput": "true",
            "description": "Sparkle intensity should be within reasonable bounds"
          }
        ]
      }
    },
    {
      "id": "drawing_graphics",
      "title": "Drawing & Graphics",
      "description": "Master custom drawing with Shape, Path, and create stunning visual effects",
      "difficulty": "intermediate",
      "theory": "# Drawing & Graphics - Creating Custom Visuals\n\n## 1. Understanding SwiftUI's Drawing System (45 min)\n\n### Coordinate System Basics:\n- **Origin**: Top-left corner (0,0)\n- **Bounds**: View's available space\n- **Frame**: Position and size in parent view\n\n### Key Drawing Concepts:\n- **Paths**: Mathematical descriptions of shapes\n- **Shapes**: Reusable path-based views\n- **Transforms**: Translation, rotation, scaling\n- **Gradients**: Linear, radial, and angular color transitions\n\n## 2. Working with Paths (60 min)\n\n### Path Fundamentals:\nA Path is a series of drawing commands that define a shape:\n\n```swift\nvar path = Path()\npath.move(to: CGPoint(x: 0, y: 0))\npath.addLine(to: CGPoint(x: 100, y: 0))\npath.addLine(to: CGPoint(x: 50, y: 100))\npath.closeSubpath()\n```\n\n### Path Drawing Commands:\n- `move(to:)` - Move to starting point\n- `addLine(to:)` - Draw straight line\n- `addArc(center:radius:startAngle:endAngle:clockwise:)` - Draw arcs\n- `addCurve(to:control1:control2:)` - Bezier curves\n- `addQuadCurve(to:control:)` - Quadratic curves\n- `closeSubpath()` - Close the path\n\n### Advanced Path Operations:\n```swift\n// Path transformations\npath = path.applying(CGAffineTransform(rotationAngle: .pi/4))\npath = path.applying(CGAffineTransform(scaleX: 2.0, y: 1.5))\n\n// Path operations\nlet unionPath = path.union(otherPath)\nlet intersectionPath = path.intersection(otherPath)\n```\n\n## 3. Creating Custom Shapes (60 min)\n\n### Shape Protocol:\nAll shapes must conform to the `Shape` protocol:\n\n```swift\nprotocol Shape: Animatable, View {\n    func path(in rect: CGRect) -> Path\n}\n```\n\n### Basic Shape Implementation:\n```swift\nstruct Triangle: Shape {\n    func path(in rect: CGRect) -> Path {\n        var path = Path()\n        path.move(to: CGPoint(x: rect.midX, y: rect.minY))\n        path.addLine(to: CGPoint(x: rect.minX, y: rect.maxY))\n        path.addLine(to: CGPoint(x: rect.maxX, y: rect.maxY))\n        path.closeSubpath()\n        return path\n    }\n}\n```\n\n### Advanced Shape Examples:\n- **Star shapes** with customizable points\n- **Speech bubbles** with tail triangles\n- **Gear shapes** with teeth\n- **Heart shapes** using Bezier curves\n\n## 4. Animatable Shapes and Properties (45 min)\n\n### Animatable Protocol:\nMake shapes animatable by implementing `animatableData`:\n\n```swift\nstruct AnimatableStar: Shape {\n    var points: Double\n    \n    var animatableData: Double {\n        get { points }\n        set { points = newValue }\n    }\n    \n    func path(in rect: CGRect) -> Path {\n        // Implementation that uses 'points'\n    }\n}\n```\n\n### Animatable Properties:\n- **Geometric properties**: Corners, points, angles\n- **Color transitions**: Using `AnimatablePair`\n- **Complex animations**: Multiple animatable properties\n\n## 5. Advanced Graphics Techniques (45 min)\n\n### Gradient Fills:\n```swift\n// Linear gradient\nLinearGradient(\n    gradient: Gradient(colors: [.red, .blue]),\n    startPoint: .topLeading,\n    endPoint: .bottomTrailing\n)\n\n// Radial gradient\nRadialGradient(\n    gradient: Gradient(colors: [.white, .black]),\n    center: .center,\n    startRadius: 0,\n    endRadius: 100\n)\n```\n\n### Shadows and Effects:\n```swift\n.shadow(color: .black, radius: 10, x: 5, y: 5)\n.blur(radius: 5)\n.blendMode(.multiply)\n```\n\n### Masking and Clipping:\n```swift\n.clipShape(Circle())  // Clip to circle\n.mask(LinearGradient(...))  // Use gradient as mask\n```\n\n## 6. Performance Optimization (30 min)\n\n### Efficient Drawing:\n- Use `DrawingGroup()` for complex shapes\n- Cache expensive path calculations\n- Minimize path complexity\n- Use appropriate blend modes\n\n### Memory Management:\n- Avoid creating paths in drawing loop\n- Use `@State` for animatable properties\n- Precompute expensive operations\n\n## 7. Real-World Applications (15 min)\n\n### Common Use Cases:\n- Custom progress indicators\n- Data visualization charts\n- Game graphics and sprites\n- Custom UI controls\n- Animated icons and logos\n\n## Practice Exercises\n\nComplete the comprehensive drawing challenge to master these concepts!",
      "codeExample": "import SwiftUI\n\n// === BASIC PATH OPERATIONS ===\nstruct SimpleTriangle: Shape {\n    func path(in rect: CGRect) -> Path {\n        var path = Path()\n        path.move(to: CGPoint(x: rect.midX, y: rect.minY))\n        path.addLine(to: CGPoint(x: rect.minX, y: rect.maxY))\n        path.addLine(to: CGPoint(x: rect.maxX, y: rect.maxY))\n        path.closeSubpath()\n        return path\n    }\n}\n\n// === ADVANCED SHAPE: STAR ===\nstruct Star: Shape {\n    var points: Int = 5\n    var smoothness: Double = 0.5\n    \n    func path(in rect: CGRect) -> Path {\n        var path = Path()\n        \n        let center = CGPoint(x: rect.width / 2, y: rect.height / 2)\n        let outerRadius = min(rect.width, rect.height) / 2\n        let innerRadius = outerRadius * smoothness\n        \n        for i in 0..<points * 2 {\n            let angle = .pi * Double(i) / Double(points)\n            let radius = i.isMultiple(of: 2) ? outerRadius : innerRadius\n            \n            let point = CGPoint(\n                x: center.x + CGFloat(cos(angle)) * radius,\n                y: center.y + CGFloat(sin(angle)) * radius\n            )\n            \n            if i == 0 {\n                path.move(to: point)\n            } else {\n                path.addLine(to: point)\n            }\n        }\n        \n        path.closeSubpath()\n        return path\n    }\n}\n\n// === ANIMATABLE SHAPE ===\nstruct AnimatableWave: Shape {\n    var strength: Double\n    var frequency: Double\n    var phase: Double\n    \n    var animatableData: AnimatablePair<Double, AnimatablePair<Double, Double>> {\n        get { AnimatablePair(strength, AnimatablePair(frequency, phase)) }\n        set {\n            strength = newValue.first\n            frequency = newValue.second.first\n            phase = newValue.second.second\n        }\n    }\n    \n    func path(in rect: CGRect) -> Path {\n        let path = Path { path in\n            let width = Double(rect.width)\n            let height = Double(rect.height)\n            \n            path.move(to: CGPoint(x: 0, y: height))\n            \n            for x in stride(from: 0, through: width, by: 1) {\n                let relativeX = x / width\n                let y = strength * sin(frequency * relativeX + phase) + height / 2\n                path.addLine(to: CGPoint(x: x, y: y))\n            }\n            \n            path.addLine(to: CGPoint(x: width, y: height))\n            path.closeSubpath()\n        }\n        \n        return path\n    }\n}\n\n// === GRADIENT EXAMPLES ===\nstruct GradientExamples: View {\n    var body: some View {\n        VStack(spacing: 20) {\n            // Linear Gradient\n            Rectangle()\n                .fill(LinearGradient(\n                    gradient: Gradient(colors: [.red, .orange, .yellow]),\n                    startPoint: .leading,\n                    endPoint: .trailing\n                ))\n                .frame(height: 60)\n            \n            // Radial Gradient\n            Circle()\n                .fill(RadialGradient(\n                    gradient: Gradient(colors: [.blue, .purple]),\n                    center: .center,\n                    startRadius: 10,\n                    endRadius: 80\n                ))\n                .frame(width: 100, height: 100)\n            \n            // Angular Gradient\n            Circle()\n                .fill(AngularGradient(\n                    gradient: Gradient(colors: [.red, .yellow, .green, .blue, .purple, .red]),\n                    center: .center\n                ))\n                .frame(width: 100, height: 100)\n        }\n    }\n}\n\n// === COMPLEX DRAWING EXAMPLE ===\nstruct CustomProgressIndicator: View {\n    var progress: Double\n    \n    var body: some View {\n        ZStack {\n            // Background circle\n            Circle()\n                .stroke(Color.gray.opacity(0.3), lineWidth: 20)\n            \n            // Progress arc\n            Circle()\n                .trim(from: 0, to: progress)\n                .stroke(\n                    LinearGradient(\n                        gradient: Gradient(colors: [.blue, .purple]),\n                        startPoint: .topLeading,\n                        endPoint: .bottomTrailing\n                    ),\n                    style: StrokeStyle(lineWidth: 20, lineCap: .round)\n                )\n                .rotationEffect(.degrees(-90))\n            \n            // Percentage text\n            Text(\"\\(Int(progress * 100))%\")\n                .font(.title2)\n                .fontWeight(.bold)\n        }\n        .padding()\n    }\n}\n\n// === PREVIEW ===\nstruct DrawingExamples: View {\n    @State private var wavePhase = 0.0\n    @State private var progress = 0.7\n    \n    var body: some View {\n        ScrollView {\n            VStack(spacing: 30) {\n                // Basic shapes\n                HStack(spacing: 20) {\n                    SimpleTriangle()\n                        .fill(Color.blue)\n                        .frame(width: 80, height: 80)\n                    \n                    Star(points: 5, smoothness: 0.5)\n                        .fill(Color.orange)\n                        .frame(width: 80, height: 80)\n                }\n                \n                // Animated wave\n                AnimatableWave(strength: 30, frequency: 5, phase: wavePhase)\n                    .fill(Color.blue.opacity(0.3))\n                    .frame(height: 100)\n                    .onAppear {\n                        withAnimation(.linear(duration: 2).repeatForever(autoreverses: false)) {\n                            wavePhase = .pi * 2\n                        }\n                    }\n                \n                // Gradients\n                GradientExamples()\n                \n                // Custom progress indicator\n                CustomProgressIndicator(progress: progress)\n                    .frame(width: 150, height: 150)\n            }\n            .padding()\n        }\n    }\n}",
      "category": "SwiftUI Graphics",
      "estimatedTime": 240,
      "dependencies": ["variables", "optionals"],
      "challenge": {
        "instructions": "Create a comprehensive drawing application with multiple custom shapes and animations:\n\nPART 1: Basic Custom Shapes (45 min)\n1. Create a 'Hexagon' shape that draws a perfect six-sided polygon\n2. Create a 'SpeechBubble' shape with a triangular tail at the bottom\n3. Create a 'Gear' shape with customizable number of teeth\n\nPART 2: Animatable Shapes (45 min)\n4. Make the 'Gear' shape animatable so the number of teeth can animate\n5. Create a 'PulsingCircle' that animates its line width\n6. Create a 'MorphingShape' that transitions between different shapes\n\nPART 3: Advanced Path Operations (45 min)\n7. Create a 'RoundedPolygon' that combines arcs and lines\n8. Implement a 'PathMorph' that can interpolate between two different paths\n9. Create a 'Spiral' shape using mathematical equations\n\nPART 4: Gradient and Effects (45 min)\n10. Apply complex gradients to your shapes (conic, radial, linear combinations)\n11. Add shadow effects and blend modes to create depth\n12. Create a 'GlassMorphism' effect using gradients and blur\n\nPART 5: Interactive Drawing (60 min)\n13. Create a drawing canvas where users can draw with different brushes\n14. Implement undo/redo functionality for the drawing\n15. Add different drawing modes (pen, eraser, shapes)\n\nUse proper SwiftUI patterns and optimize for performance!",
        "starterCode": "import SwiftUI\n\n// === PART 1: Basic Custom Shapes ===\n// Create Hexagon, SpeechBubble, and Gear shapes here\n\n\n// === PART 2: Animatable Shapes ===\n// Make shapes animatable and create pulsing/morphing effects\n\n\n// === PART 3: Advanced Path Operations ===\n// Implement complex path operations and mathematical shapes\n\n\n// === PART 4: Gradient and Effects ===\n// Apply advanced visual effects and gradients\n\n\n// === PART 5: Interactive Drawing ===\n// Create interactive drawing canvas with tools\n\n",
        "solution": "import SwiftUI\n\n// === PART 1: Basic Custom Shapes ===\nstruct Hexagon: Shape {\n    func path(in rect: CGRect) -> Path {\n        var path = Path()\n        let center = CGPoint(x: rect.midX, y: rect.midY)\n        let radius = min(rect.width, rect.height) / 2\n        \n        for i in 0..<6 {\n            let angle = Double(i) * .pi / 3\n            let point = CGPoint(\n                x: center.x + CGFloat(cos(angle)) * radius,\n                y: center.y + CGFloat(sin(angle)) * radius\n            )\n            \n            if i == 0 {\n                path.move(to: point)\n            } else {\n                path.addLine(to: point)\n            }\n        }\n        \n        path.closeSubpath()\n        return path\n    }\n}\n\nstruct SpeechBubble: Shape {\n    var tailSize: CGFloat = 20\n    \n    func path(in rect: CGRect) -> Path {\n        var path = Path()\n        \n        // Main bubble (rounded rect)\n        let bubbleRect = CGRect(\n            x: rect.minX,\n            y: rect.minY,\n            width: rect.width,\n            height: rect.height - tailSize\n        )\n        \n        path.addRoundedRect(\n            in: bubbleRect,\n            cornerSize: CGSize(width: 15, height: 15)\n        )\n        \n        // Tail (triangle)\n        let tailStart = CGPoint(x: rect.midX - tailSize, y: rect.maxY - tailSize)\n        let tailTip = CGPoint(x: rect.midX, y: rect.maxY)\n        let tailEnd = CGPoint(x: rect.midX + tailSize, y: rect.maxY - tailSize)\n        \n        path.move(to: tailStart)\n        path.addLine(to: tailTip)\n        path.addLine(to: tailEnd)\n        path.closeSubpath()\n        \n        return path\n    }\n}\n\nstruct Gear: Shape {\n    var teeth: Int = 8\n    var toothDepth: Double = 0.3\n    \n    func path(in rect: CGRect) -> Path {\n        var path = Path()\n        let center = CGPoint(x: rect.midX, y: rect.midY)\n        let outerRadius = min(rect.width, rect.height) / 2\n        let innerRadius = outerRadius * 0.6\n        \n        for i in 0..<teeth {\n            let angle = Double(i) * 2 * .pi / Double(teeth)\n            let nextAngle = Double(i + 1) * 2 * .pi / Double(teeth)\n            \n            // Outer point (tooth tip)\n            let outerPoint = CGPoint(\n                x: center.x + CGFloat(cos(angle)) * outerRadius,\n                y: center.y + CGFloat(sin(angle)) * outerRadius\n            )\n            \n            // Inner point (between teeth)\n            let midAngle = angle + .pi / Double(teeth)\n            let innerPoint = CGPoint(\n                x: center.x + CGFloat(cos(midAngle)) * innerRadius,\n                y: center.y + CGFloat(sin(midAngle)) * innerRadius\n            )\n            \n            if i == 0 {\n                path.move(to: outerPoint)\n            } else {\n                path.addLine(to: outerPoint)\n            }\n            \n            path.addLine(to: innerPoint)\n        }\n        \n        path.closeSubpath()\n        return path\n    }\n}\n\n// === PART 2: Animatable Shapes ===\nstruct AnimatableGear: Shape {\n    var teeth: Double\n    \n    var animatableData: Double {\n        get { teeth }\n        set { teeth = newValue }\n    }\n    \n    func path(in rect: CGRect) -> Path {\n        var path = Path()\n        let center = CGPoint(x: rect.midX, y: rect.midY)\n        let outerRadius = min(rect.width, rect.height) / 2\n        let innerRadius = outerRadius * 0.6\n        let actualTeeth = Int(teeth)\n        \n        for i in 0..<actualTeeth {\n            let angle = Double(i) * 2 * .pi / Double(actualTeeth)\n            let nextAngle = Double(i + 1) * 2 * .pi / Double(actualTeeth)\n            \n            let outerPoint = CGPoint(\n                x: center.x + CGFloat(cos(angle)) * outerRadius,\n                y: center.y + CGFloat(sin(angle)) * outerRadius\n            )\n            \n            let midAngle = angle + .pi / Double(actualTeeth)\n            let innerPoint = CGPoint(\n                x: center.x + CGFloat(cos(midAngle)) * innerRadius,\n                y: center.y + CGFloat(sin(midAngle)) * innerRadius\n            )\n            \n            if i == 0 {\n                path.move(to: outerPoint)\n            } else {\n                path.addLine(to: outerPoint)\n            }\n            \n            path.addLine(to: innerPoint)\n        }\n        \n        path.closeSubpath()\n        return path\n    }\n}\n\nstruct PulsingCircle: Shape {\n    var pulsePhase: Double\n    \n    var animatableData: Double {\n        get { pulsePhase }\n        set { pulsePhase = newValue }\n    }\n    \n    func path(in rect: CGRect) -> Path {\n        let lineWidth = 10 + 5 * sin(pulsePhase * 2 * .pi)\n        let radius = min(rect.width, rect.height) / 2 - lineWidth / 2\n        \n        return Path { path in\n            path.addArc(\n                center: CGPoint(x: rect.midX, y: rect.midY),\n                radius: radius,\n                startAngle: .degrees(0),\n                endAngle: .degrees(360),\n                clockwise: false\n            )\n        }\n        .strokedPath(StrokeStyle(lineWidth: lineWidth, lineCap: .round))\n    }\n}\n\n// === PART 3: Advanced Path Operations ===\nstruct Spiral: Shape {\n    var revolutions: Double = 3.0\n    \n    func path(in rect: CGRect) -> Path {\n        var path = Path()\n        let center = CGPoint(x: rect.midX, y: rect.midY)\n        let maxRadius = min(rect.width, rect.height) / 2\n        \n        let points = 100\n        for i in 0...points {\n            let progress = Double(i) / Double(points)\n            let angle = progress * 2 * .pi * revolutions\n            let radius = maxRadius * progress\n            \n            let point = CGPoint(\n                x: center.x + CGFloat(cos(angle)) * radius,\n                y: center.y + CGFloat(sin(angle)) * radius\n            )\n            \n            if i == 0 {\n                path.move(to: point)\n            } else {\n                path.addLine(to: point)\n            }\n        }\n        \n        return path\n    }\n}\n\n// === PART 4: Gradient and Effects ===\nstruct GlassMorphismCard: View {\n    var body: some View {\n        RoundedRectangle(cornerRadius: 20)\n            .fill(\n                LinearGradient(\n                    colors: [\n                        .white.opacity(0.3),\n                        .white.opacity(0.1),\n                        .white.opacity(0.05)\n                    ],\n                    startPoint: .topLeading,\n                    endPoint: .bottomTrailing\n                )\n            )\n            .background(\n                RoundedRectangle(cornerRadius: 20)\n                    .fill(.ultraThinMaterial)\n            )\n            .overlay(\n                RoundedRectangle(cornerRadius: 20)\n                    .stroke(.white.opacity(0.2), lineWidth: 1)\n            )\n            .shadow(color: .black.opacity(0.1), radius: 10, x: 5, y: 5)\n    }\n}\n\n// === PART 5: Interactive Drawing ===\nstruct DrawingCanvas: View {\n    @State private var lines: [Line] = []\n    @State private var deletedLines: [Line] = []\n    @State private var currentLine = Line(points: [], color: .blue, lineWidth: 3)\n    \n    var body: some View {\n        VStack {\n            // Toolbar\n            HStack {\n                Button(\"Undo\") {\n                    if let lastLine = lines.popLast() {\n                        deletedLines.append(lastLine)\n                    }\n                }\n                .disabled(lines.isEmpty)\n                \n                Button(\"Redo\") {\n                    if let lastDeleted = deletedLines.popLast() {\n                        lines.append(lastDeleted)\n                    }\n                }\n                .disabled(deletedLines.isEmpty)\n                \n                Button(\"Clear\") {\n                    lines.removeAll()\n                    deletedLines.removeAll()\n                }\n            }\n            \n            // Canvas\n            Canvas { context, size in\n                // Draw all saved lines\n                for line in lines {\n                    var path = Path()\n                    path.addLines(line.points)\n                    \n                    context.stroke(\n                        path,\n                        with: .color(line.color),\n                        lineWidth: line.lineWidth\n                    )\n                }\n                \n                // Draw current line\n                if !currentLine.points.isEmpty {\n                    var path = Path()\n                    path.addLines(currentLine.points)\n                    \n                    context.stroke(\n                        path,\n                        with: .color(currentLine.color),\n                        lineWidth: currentLine.lineWidth\n                    )\n                }\n            }\n            .gesture(\n                DragGesture()\n                    .onChanged { value in\n                        let newPoint = value.location\n                        currentLine.points.append(newPoint)\n                    }\n                    .onEnded { _ in\n                        lines.append(currentLine)\n                        currentLine = Line(points: [], color: currentLine.color, lineWidth: currentLine.lineWidth)\n                        deletedLines.removeAll()\n                    }\n            )\n            .frame(height: 300)\n            .background(Color.white)\n            .border(Color.gray)\n        }\n        .padding()\n    }\n}\n\nstruct Line {\n    var points: [CGPoint]\n    var color: Color\n    var lineWidth: CGFloat\n}\n\n// === MAIN VIEW ===\nstruct DrawingChallengeView: View {\n    @State private var gearTeeth: Double = 8\n    @State private var pulsePhase: Double = 0\n    \n    var body: some View {\n        ScrollView {\n            VStack(spacing: 30) {\n                // Basic shapes\n                HStack(spacing: 20) {\n                    Hexagon()\n                        .fill(LinearGradient(colors: [.blue, .purple], startPoint: .top, endPoint: .bottom))\n                        .frame(width: 80, height: 80)\n                    \n                    SpeechBubble()\n                        .fill(Color.green)\n                        .frame(width: 100, height: 80)\n                }\n                \n                // Animatable gear\n                VStack {\n                    AnimatableGear(teeth: gearTeeth)\n                        .fill(Color.orange)\n                        .frame(width: 100, height: 100)\n                    \n                    Slider(value: $gearTeeth, in: 4...20, step: 1)\n                    Text(\"Teeth: \\(Int(gearTeeth))\")\n                }\n                \n                // Pulsing circle\n                PulsingCircle(pulsePhase: pulsePhase)\n                    .stroke(Color.blue, lineWidth: 1)\n                    .frame(width: 100, height: 100)\n                    .onAppear {\n                        withAnimation(.easeInOut(duration: 1).repeatForever(autoreverses: true)) {\n                            pulsePhase = 1\n                        }\n                    }\n                \n                // Spiral\n                Spiral(revolutions: 5)\n                    .stroke(Color.purple, lineWidth: 2)\n                    .frame(width: 150, height: 150)\n                \n                // Glass morphism\n                GlassMorphismCard()\n                    .frame(height: 100)\n                    .overlay(\n                        Text(\"Glass Effect\")\n                            .font(.title2)\n                            .fontWeight(.semibold)\n                    )\n                \n                // Drawing canvas\n                DrawingCanvas()\n            }\n            .padding()\n        }\n    }\n}",
        "hints": [
          "PART 1: Use trigonometric functions (cos/sin) to calculate polygon points around a circle",
          "PART 2: Implement animatableData to make properties animatable. Use AnimatablePair for multiple values",
          "PART 3: For spirals, use parametric equations. For path morphing, interpolate between control points",
          "PART 4: Use .fill() with gradients and .background() with materials for glass effects",
          "PART 5: Store drawing data in @State arrays. Use Canvas for efficient drawing",
          "Remember to use proper coordinate system calculations (rect.midX, rect.midY)",
          "Optimize path calculations by precomputing expensive operations",
          "Use StrokeStyle for advanced line styling (lineCap, lineJoin)"
        ],
        "testCases": [
          {
            "input": "Hexagon().path(in: CGRect(x: 0, y: 0, width: 100, height: 100)).isEmpty",
            "expectedOutput": "false",
            "description": "Hexagon should create a valid path"
          },
          {
            "input": "Gear(teeth: 8).path(in: CGRect(x: 0, y: 0, width: 100, height: 100)).isEmpty",
            "expectedOutput": "false",
            "description": "Gear should create a valid path with teeth"
          }
        ]
      }
    },
    {
      "id": "gestures",
      "title": "Gestures",
      "description": "Master touch interactions with tap, drag, rotation, and advanced gesture handling",
      "difficulty": "intermediate",
      "theory": "# Gestures - Interactive Touch Experiences\n\n## 1. Introduction to Gestures (30 min)\n\n**Gestures** are touch interactions that allow users to interact with your app in intuitive ways. SwiftUI provides built-in gesture recognizers for common interactions:\n\n### Why Gestures Matter:\n- **Natural Interaction**: Users expect touch-based interfaces\n- **Enhanced UX**: Gestures make apps feel more responsive\n- **Space Efficiency**: Reduce UI clutter with gesture-based navigation\n- **Platform Consistency**: Follow iOS human interface guidelines\n\n## 2. Basic Gesture Modifiers (45 min)\n\n### Tap Gestures:\nThe simplest gesture - detects when users tap on a view.\n\n```swift\n// Single tap\n.gesture(\n    TapGesture()\n        .onEnded { _ in\n            // Handle tap\n        }\n)\n\n// Double tap\n.gesture(\n    TapGesture(count: 2)\n        .onEnded { _ in\n            // Handle double tap\n        }\n)\n\n// Long press\n.gesture(\n    LongPressGesture()\n        .onEnded { _ in\n            // Handle long press\n        }\n)\n```\n\n### Drag Gestures:\nTrack movement across the screen with precise control.\n\n```swift\n.gesture(\n    DragGesture()\n        .onChanged { value in\n            // Continuous updates during drag\n            let translation = value.translation\n        }\n        .onEnded { value in\n            // Final state when drag ends\n            let predictedEnd = value.predictedEndTranslation\n        }\n)\n```\n\n## 3. Advanced Gesture Properties (60 min)\n\n### Gesture Configuration:\nEach gesture type has configurable properties:\n\n**DragGesture**:\n- `minimumDistance`: Minimum movement before gesture starts\n- `coordinateSpace`: Coordinate system for translation values\n\n**LongPressGesture**:\n- `minimumDuration`: How long to press before triggering\n- `maximumDistance`: Maximum movement allowed during press\n\n**MagnificationGesture** & **RotationGesture**:\n- `minimumDelta`: Minimum change required to start recognizing\n\n### Coordinate Spaces:\n```swift\n// Local coordinate space (relative to the view itself)\n.coordinateSpace(.local)\n\n// Global coordinate space (relative to screen)\n.coordinateSpace(.global)\n\n// Named coordinate space (custom coordinate system)\n.coordinateSpace(.named(\"CustomSpace\"))\n```\n\n## 4. Gesture Composition & Priority (60 min)\n\n### Simultaneous Gestures:\nAllow multiple gestures to work at the same time.\n\n```swift\n.gesture(\n    SimultaneousGesture(\n        DragGesture(),\n        MagnificationGesture()\n    )\n)\n```\n\n### Sequence Gestures:\nRequire gestures to happen in a specific order.\n\n```swift\n.gesture(\n    SequenceGesture(\n        LongPressGesture(),\n        DragGesture()\n    )\n)\n```\n\n### Gesture Priority:\nControl which gesture takes precedence when conflicts occur.\n\n```swift\n.highPriorityGesture(TapGesture())  // This gesture wins\n.simultaneousGesture(DragGesture()) // Works alongside others\n```\n\n## 5. Rotation & Magnification Gestures (45 min)\n\n### Rotation Gesture:\nDetect two-finger rotation movements.\n\n```swift\n@State private var angle = Angle.zero\n\n.gesture(\n    RotationGesture()\n        .onChanged { angle in\n            self.angle = angle\n        }\n        .onEnded { angle in\n            // Snap to nearest 45 degrees\n            withAnimation {\n                self.angle = self.snapAngle(angle)\n            }\n        }\n)\n```\n\n### Magnification Gesture:\nDetect pinch-to-zoom gestures.\n\n```swift\n@State private var scale: CGFloat = 1.0\n\n.gesture(\n    MagnificationGesture()\n        .onChanged { scale in\n            self.scale = scale\n        }\n        .onEnded { scale in\n            // Apply scale limits\n            withAnimation {\n                self.scale = min(max(scale, 0.5), 3.0)\n            }\n        }\n)\n```\n\n## 6. Advanced Gesture Patterns (60 min)\n\n### Custom Gesture Recognition:\nCreate complex gesture patterns beyond built-in recognizers.\n\n```swift\n// Custom swipe detection\nfunc detectSwipe(_ value: DragGesture.Value) -> SwipeDirection {\n    let horizontal = value.translation.width\n    let vertical = value.translation.height\n    \n    if abs(horizontal) > abs(vertical) {\n        return horizontal > 0 ? .right : .left\n    } else {\n        return vertical > 0 ? .down : .up\n    }\n}\n```\n\n### Gesture State Management:\nUse `@GestureState` for temporary gesture state that resets automatically.\n\n```swift\n@GestureState private var isDetectingLongPress = false\n\n.gesture(\n    LongPressGesture(minimumDuration: 1)\n        .updating($isDetectingLongPress) { currentState, gestureState, transaction in\n            gestureState = currentState\n        }\n)\n```\n\n### Hit Testing & Gesture Boundaries:\nControl which parts of a view respond to gestures.\n\n```swift\n// Make entire view tappable, even transparent parts\n.contentShape(Rectangle())\n\n// Custom hit testing area\n.contentShape(Circle())\n```\n\n## 7. Performance & Best Practices (40 min)\n\n### Gesture Performance:\n- Use `@GestureState` for temporary values to avoid unnecessary view updates\n- Implement gesture cancellation properly\n- Avoid expensive computations in gesture callbacks\n\n### Accessibility:\n- Provide alternative ways to perform gesture actions\n- Use `.accessibilityAction` for VoiceOver users\n- Consider users with motor impairments\n\n### Common Pitfalls:\n- Gesture conflicts between parent and child views\n- Memory leaks in gesture closures\n- Poor feedback during gesture interactions\n\n## Practice Exercises\n\nComplete the interactive photo editor to master gesture implementation!",
      "codeExample": "import SwiftUI\n\n// === BASIC GESTURE SETUP ===\nstruct BasicGesturesView: View {\n    @State private var scale: CGFloat = 1.0\n    @State private var angle: Angle = .zero\n    @State private var offset: CGSize = .zero\n    @State private var isTapped = false\n    \n    var body: some View {\n        VStack(spacing: 30) {\n            // Draggable Card\n            RoundedRectangle(cornerRadius: 20)\n                .fill(isTapped ? Color.blue : Color.red)\n                .frame(width: 200, height: 150)\n                .scaleEffect(scale)\n                .rotationEffect(angle)\n                .offset(offset)\n                .gesture(createDragGesture())\n                .simultaneousGesture(createTapGesture())\n            \n            // Rotatable Image\n            Image(systemName: \"star.fill\")\n                .font(.system(size: 60))\n                .foregroundColor(.yellow)\n                .rotationEffect(angle)\n                .gesture(createRotationGesture())\n            \n            // Scalable Shape\n            Circle()\n                .fill(Color.green)\n                .frame(width: 100, height: 100)\n                .scaleEffect(scale)\n                .gesture(createMagnificationGesture())\n            \n            // Reset Button\n            Button(\"Reset\") {\n                withAnimation(.spring()) {\n                    scale = 1.0\n                    angle = .zero\n                    offset = .zero\n                    isTapped = false\n                }\n            }\n        }\n    }\n    \n    private func createTapGesture() -> some Gesture {\n        TapGesture()\n            .onEnded {\n                withAnimation {\n                    isTapped.toggle()\n                }\n            }\n    }\n    \n    private func createDragGesture() -> some Gesture {\n        DragGesture()\n            .onChanged { value in\n                offset = value.translation\n            }\n            .onEnded { value in\n                // Add some spring physics to the end\n                withAnimation(.interactiveSpring()) {\n                    offset = value.predictedEndTranslation\n                }\n            }\n    }\n    \n    private func createRotationGesture() -> some Gesture {\n        RotationGesture()\n            .onChanged { angle in\n                self.angle = angle\n            }\n            .onEnded { angle in\n                // Snap to nearest 45 degrees\n                withAnimation {\n                    let degrees = angle.degrees\n                    let snapped = round(degrees / 45) * 45\n                    self.angle = Angle(degrees: snapped)\n                }\n            }\n    }\n    \n    private func createMagnificationGesture() -> some Gesture {\n        MagnificationGesture()\n            .onChanged { scale in\n                self.scale = scale\n            }\n            .onEnded { scale in\n                // Apply scale limits with bounce animation\n                withAnimation(.spring()) {\n                    self.scale = min(max(scale, 0.5), 3.0)\n                }\n            }\n    }\n}\n\n// === ADVANCED GESTURE COMBINATIONS ===\nstruct AdvancedGesturesView: View {\n    @State private var position: CGPoint = .zero\n    @State private var finalScale: CGFloat = 1.0\n    @State private var temporaryScale: CGFloat = 1.0\n    @GestureState private var isLongPressing = false\n    \n    var body: some View {\n        VStack {\n            Text(\"Advanced Gesture Demo\")\n                .font(.title2)\n                .padding()\n            \n            RoundedRectangle(cornerRadius: 25)\n                .fill(isLongPressing ? Color.orange : Color.purple)\n                .frame(width: 200, height: 200)\n                .scaleEffect(finalScale * temporaryScale)\n                .position(position)\n                .gesture(createCombinedGesture())\n                .gesture(createLongPressGesture())\n                .overlay(\n                    Text(isLongPressing ? \"LONG PRESSING\" : \"Drag + Scale\")\n                        .foregroundColor(.white)\n                        .fontWeight(.bold)\n                )\n        }\n    }\n    \n    private func createCombinedGesture() -> some Gesture {\n        SimultaneousGesture(\n            DragGesture()\n                .onChanged { value in\n                    position = value.location\n                },\n            MagnificationGesture()\n                .onChanged { scale in\n                    temporaryScale = scale\n                }\n                .onEnded { scale in\n                    finalScale *= scale\n                    temporaryScale = 1.0\n                    // Enforce scale limits\n                    finalScale = min(max(finalScale, 0.3), 5.0)\n                }\n        )\n    }\n    \n    private func createLongPressGesture() -> some Gesture {\n        LongPressGesture(minimumDuration: 0.5)\n            .updating($isLongPressing) { currentState, gestureState, transaction in\n                gestureState = currentState\n            }\n    }\n}\n\n// === CUSTOM GESTURE RECOGNITION ===\nenum SwipeDirection {\n    case left, right, up, down, none\n}\n\nstruct SwipeDetectionView: View {\n    @State private var swipeDirection: SwipeDirection = .none\n    @State private var swipeOffset: CGSize = .zero\n    \n    var body: some View {\n        VStack {\n            Text(\"Swipe Detection\")\n                .font(.headline)\n            \n            RoundedRectangle(cornerRadius: 15)\n                .fill(swipeColor)\n                .frame(width: 250, height: 150)\n                .overlay(\n                    Text(swipeDirectionText)\n                        .foregroundColor(.white)\n                        .fontWeight(.bold)\n                )\n                .offset(swipeOffset)\n                .gesture(createSwipeGesture())\n        }\n    }\n    \n    private var swipeColor: Color {\n        switch swipeDirection {\n        case .left: return .red\n        case .right: return .green\n        case .up: return .blue\n        case .down: return .orange\n        case .none: return .gray\n        }\n    }\n    \n    private var swipeDirectionText: String {\n        switch swipeDirection {\n        case .left: return \"SWIPE LEFT\"\n        case .right: return \"SWIPE RIGHT\"\n        case .up: return \"SWIPE UP\"\n        case .down: return \"SWIPE DOWN\"\n        case .none: return \"SWIPE ME\"\n        }\n    }\n    \n    private func createSwipeGesture() -> some Gesture {\n        DragGesture(minimumDistance: 20)\n            .onChanged { value in\n                swipeOffset = value.translation\n                swipeDirection = detectSwipeDirection(value)\n            }\n            .onEnded { value in\n                withAnimation(.spring()) {\n                    swipeOffset = .zero\n                    // Keep direction for a moment, then reset\n                    DispatchQueue.main.asyncAfter(deadline: .now() + 0.5) {\n                        swipeDirection = .none\n                    }\n                }\n            }\n    }\n    \n    private func detectSwipeDirection(_ value: DragGesture.Value) -> SwipeDirection {\n        let horizontal = value.translation.width\n        let vertical = value.translation.height\n        \n        if abs(horizontal) > abs(vertical) {\n            return horizontal > 0 ? .right : .left\n        } else {\n            return vertical > 0 ? .down : .up\n        }\n    }\n}",
      "category": "SwiftUI Advanced",
      "estimatedTime": 240,
      "dependencies": ["variables"],
      "challenge": {
        "instructions": "Create an interactive photo editor with comprehensive gesture controls:\n\nPART 1: Basic Gesture Implementation (60 min)\n1. Create a draggable image that can be moved around the screen\n2. Implement tap gesture to toggle image border\n3. Add double-tap gesture to reset image position\n4. Use long press gesture to show/hide editing controls\n\nPART 2: Transformation Gestures (60 min)\n5. Add rotation gesture to rotate the image\n6. Implement magnification gesture for pinch-to-zoom\n7. Combine rotation and magnification to work simultaneously\n8. Add gesture to reset transformations with animation\n\nPART 3: Advanced Gesture Features (60 min)\n9. Implement swipe gestures for quick navigation between filters\n10. Create custom gesture to draw on the image\n11. Add gesture to crop image by dragging corners\n12. Implement gesture priority system to prevent conflicts\n\nPART 4: Professional Polish (60 min)\n13. Add haptic feedback for different gestures\n14. Implement gesture velocity-based animations\n15. Create gesture tutorial with visual guides\n16. Add accessibility actions for all gesture features",
        "starterCode": "import SwiftUI\n\nstruct PhotoEditorView: View {\n    @State private var imagePosition: CGPoint = CGPoint(x: 200, y: 300)\n    @State private var imageScale: CGFloat = 1.0\n    @State private var imageRotation: Angle = .zero\n    @State private var hasBorder = false\n    @State private var showControls = false\n    \n    var body: some View {\n        ZStack {\n            Color.black.ignoresSafeArea()\n            \n            VStack {\n                Text(\"Photo Editor\")\n                    .font(.title)\n                    .foregroundColor(.white)\n                \n                Spacer()\n                \n                // Image container\n                ZStack {\n                    // Add your image and gesture implementations here\n                    \n                }\n                .frame(width: 350, height: 450)\n                \n                Spacer()\n                \n                // Controls (shown based on gesture)\n                if showControls {\n                    HStack {\n                        Button(\"Reset\") { }\n                        Button(\"Rotate\") { }\n                        Button(\"Scale\") { }\n                    }\n                    .foregroundColor(.white)\n                }\n            }\n        }\n    }\n    \n    // PART 1: Implement basic gesture functions here\n    \n    \n    // PART 2: Implement transformation gesture functions here\n    \n    \n    // PART 3: Implement advanced gesture functions here\n    \n    \n    // PART 4: Add professional polish functions here\n    \n}\n\nstruct PhotoEditorView_Previews: PreviewProvider {\n    static var previews: some View {\n        PhotoEditorView()\n    }\n}",
        "solution": "import SwiftUI\n\nstruct PhotoEditorView: View {\n    @State private var imagePosition: CGPoint = CGPoint(x: 200, y: 300)\n    @State private var imageScale: CGFloat = 1.0\n    @State private var imageRotation: Angle = .zero\n    @State private var hasBorder = false\n    @State private var showControls = false\n    @State private var currentFilter = 0\n    @State private var drawingPoints: [CGPoint] = []\n    @State private var isDrawing = false\n    \n    let filters = [\"Normal\", \"Sepia\", \"Black & White\", \"Vivid\"]\n    \n    var body: some View {\n        ZStack {\n            Color.black.ignoresSafeArea()\n            \n            VStack {\n                Text(\"Photo Editor\")\n                    .font(.title)\n                    .foregroundColor(.white)\n                \n                Text(\"Filter: \\(filters[currentFilter])\")\n                    .foregroundColor(.white)\n                    .padding(.bottom)\n                \n                Spacer()\n                \n                // Image container with all gestures\n                ZStack {\n                    Rectangle()\n                        .fill(Color.gray.opacity(0.3))\n                        .border(hasBorder ? Color.white : Color.clear, width: 2)\n                    \n                    Image(systemName: \"photo\")\n                        .font(.system(size: 100))\n                        .foregroundColor(.white)\n                        .scaleEffect(imageScale)\n                        .rotationEffect(imageRotation)\n                        .position(imagePosition)\n                        .gesture(createCombinedGesture())\n                        .simultaneousGesture(createTapGestures())\n                        .simultaneousGesture(createSwipeGesture())\n                    \n                    // Drawing overlay\n                    if isDrawing {\n                        Path { path in\n                            guard let firstPoint = drawingPoints.first else { return }\n                            path.move(to: firstPoint)\n                            \n                            for point in drawingPoints.dropFirst() {\n                                path.addLine(to: point)\n                            }\n                        }\n                        .stroke(Color.red, lineWidth: 3)\n                    }\n                }\n                .frame(width: 350, height: 450)\n                .gesture(createDrawGesture())\n                \n                Spacer()\n                \n                // Controls (shown based on gesture)\n                if showControls {\n                    HStack(spacing: 20) {\n                        Button(\"Reset\") {\n                            resetAll()\n                        }\n                        Button(\"Rotate 90Â°\") {\n                            withAnimation {\n                                imageRotation += Angle(degrees: 90)\n                            }\n                        }\n                        Button(\"Scale 2x\") {\n                            withAnimation {\n                                imageScale *= 2.0\n                            }\n                        }\n                        Button(isDrawing ? \"Stop Draw\" : \"Start Draw\") {\n                            isDrawing.toggle()\n                            if !isDrawing {\n                                drawingPoints.removeAll()\n                            }\n                        }\n                    }\n                    .foregroundColor(.white)\n                    .padding()\n                    .background(Color.white.opacity(0.2))\n                    .cornerRadius(10)\n                }\n            }\n        }\n    }\n    \n    // PART 1: Basic Gestures\n    private func createTapGestures() -> some Gesture {\n        SimultaneousGesture(\n            TapGesture()\n                .onEnded {\n                    withAnimation {\n                        hasBorder.toggle()\n                    }\n                },\n            TapGesture(count: 2)\n                .onEnded {\n                    resetPosition()\n                }\n        )\n    }\n    \n    private func createCombinedGesture() -> some Gesture {\n        SimultaneousGesture(\n            DragGesture()\n                .onChanged { value in\n                    imagePosition = value.location\n                },\n            SimultaneousGesture(\n                RotationGesture()\n                    .onChanged { angle in\n                        imageRotation = angle\n                    },\n                MagnificationGesture()\n                    .onChanged { scale in\n                        imageScale = scale\n                    }\n                    .onEnded { scale in\n                        imageScale = min(max(scale, 0.5), 3.0)\n                    }\n            )\n        )\n    }\n    \n    // PART 2: Advanced Gestures\n    private func createSwipeGesture() -> some Gesture {\n        DragGesture(minimumDistance: 50)\n            .onEnded { value in\n                let horizontal = value.translation.width\n                \n                if horizontal > 0 {\n                    // Swipe right - next filter\n                    withAnimation {\n                        currentFilter = (currentFilter + 1) % filters.count\n                    }\n                } else {\n                    // Swipe left - previous filter\n                    withAnimation {\n                        currentFilter = (currentFilter - 1 + filters.count) % filters.count\n                    }\n                }\n                \n                // Haptic feedback\n                let impact = UIImpactFeedbackGenerator(style: .medium)\n                impact.impactOccurred()\n            }\n    }\n    \n    private func createDrawGesture() -> some Gesture {\n        DragGesture(minimumDistance: 0)\n            .onChanged { value in\n                if isDrawing {\n                    drawingPoints.append(value.location)\n                }\n            }\n    }\n    \n    // PART 3: Utility Functions\n    private func resetPosition() {\n        withAnimation(.spring()) {\n            imagePosition = CGPoint(x: 175, y: 225)\n        }\n    }\n    \n    private func resetAll() {\n        withAnimation(.spring()) {\n            imagePosition = CGPoint(x: 175, y: 225)\n            imageScale = 1.0\n            imageRotation = .zero\n            hasBorder = false\n            showControls = false\n            drawingPoints.removeAll()\n            isDrawing = false\n        }\n    }\n}\n\nstruct PhotoEditorView_Previews: PreviewProvider {\n    static var previews: some View {\n        PhotoEditorView()\n    }\n}",
        "hints": [
          "PART 1: Use SimultaneousGesture to combine tap and double-tap without conflicts",
          "PART 2: Nest SimultaneousGesture inside another to handle drag + rotate + scale together",
          "PART 3: Use minimumDistance in DragGesture to distinguish between drawing and swiping",
          "PART 4: Import UIKit and use UIImpactFeedbackGenerator for haptic feedback",
          "For drawing: Store points in an array and use Path to render lines between them",
          "Use @GestureState for temporary values that should reset when gesture ends",
          "Apply .contentShape(Rectangle()) to make entire view tappable, not just opaque parts",
          "Use coordinateSpace(.local) for drawing to get coordinates relative to the view",
          "Implement gesture exclusivity: highPriorityGesture for critical interactions",
          "Add velocity-based animations using value.predictedEndTranslation"
        ],
        "testCases": [
          {
            "input": "imageScale >= 0.5 && imageScale <= 3.0",
            "expectedOutput": "true",
            "description": "Image scale should stay within reasonable bounds"
          },
          {
            "input": "drawingPoints.count <= 1000",
            "expectedOutput": "true",
            "description": "Drawing points should be managed efficiently"
          },
          {
            "input": "currentFilter >= 0 && currentFilter < filters.count",
            "expectedOutput": "true",
            "description": "Current filter should always be a valid index"
          }
        ]
      }
    },
    {
      "id": "dark_mode_themes",
      "title": "Dark Mode & Themes",
      "description": "Master adaptive interfaces, color schemes, and asset management for professional iOS apps",
      "difficulty": "intermediate",
      "theory": "# Dark Mode & Themes - Professional UI Adaptation\n\n## 1. Understanding Color Schemes (45 min)\n\n### System Color Schemes\niOS provides two main appearance modes:\n- **Light Mode**: Bright interface with dark text\n- **Dark Mode**: Dark interface with light text\n- **Automatic**: Follows system setting\n\n### Color Assets in Xcode\nOrganize colors in Asset Catalog for better management:\n```swift\n// Colors defined in Assets.xcassets\nColor(\"PrimaryColor\")\nColor(\"BackgroundColor\")\nColor(\"TextPrimary\")\n```\n\n### Semantic Colors\nUse system semantic colors that automatically adapt:\n```swift\nColor.primary        // Adapts between black/white\nColor.secondary      // Adapts between dark/light gray\nColor.backgroundColor // System background color\n```\n\n## 2. Implementing Adaptive Colors (60 min)\n\n### Creating Adaptive Color Assets\n1. **Add Color Set** in Assets.xcassets\n2. **Define Both Appearances**: Light & Dark variants\n3. **Use Any/Any Appearance** for universal compatibility\n\n### Programmatic Color Creation\n```swift\n// Dynamic color that adapts to appearance\nlet adaptiveColor = UIColor { traitCollection in\n    switch traitCollection.userInterfaceStyle {\n    case .dark:\n        return UIColor.systemBackground\n    case .light, .unspecified:\n        return UIColor.white\n    @unknown default:\n        return UIColor.white\n    }\n}\n```\n\n### SwiftUI Color Extensions\n```swift\nextension Color {\n    static let customBackground = Color(\"Background\")\n    static let customPrimary = Color(\"Primary\")\n    static let customSecondary = Color(\"Secondary\")\n    \n    // Adaptive colors\n    static func adaptive(light: Color, dark: Color) -> Color {\n        return Color(UIColor { trait in\n            switch trait.userInterfaceStyle {\n            case .dark: return UIColor(dark)\n            default: return UIColor(light)\n            }\n        })\n    }\n}\n```\n\n## 3. Asset Management & Organization (45 min)\n\n### Image Assets Best Practices\n- **Use PDF vectors** for resolution independence\n- **Create @2x and @3x versions** for bitmaps\n- **Organize by feature/module** in asset catalog\n\n### Adaptive Images\n```swift\n// Different images for light/dark mode\nImage(\"icon\")\n    .renderingMode(.template)  // Allows color changes\n\n// In Assets.xcassets:\n// - icon (Any Appearance)\n// - icon (Dark Appearance)\n```\n\n### Managing Multiple Themes\n```swift\nenum AppTheme: String, CaseIterable {\n    case system, light, dark, blue, green\n    \n    var colorScheme: ColorScheme? {\n        switch self {\n        case .system: return nil\n        case .light: return .light\n        case .dark: return .dark\n        case .blue, .green: return .light // Custom themes\n        }\n    }\n}\n```\n\n## 4. Advanced Theme Implementation (60 min)\n\n### Environment-Based Theming\n```swift\nclass ThemeManager: ObservableObject {\n    @Published var currentTheme: AppTheme = .system\n    @AppStorage(\"selectedTheme\") private var storedTheme: String = \"system\"\n    \n    var colorScheme: ColorScheme? {\n        currentTheme.colorScheme\n    }\n    \n    func color(for colorName: String) -> Color {\n        // Return theme-specific colors\n        return Color(\"\\(colorName)_\\(currentTheme.rawValue)\")\n    }\n}\n```\n\n### Custom Theme Protocol\n```swift\nprotocol Theme {\n    var primaryColor: Color { get }\n    var backgroundColor: Color { get }\n    var textColor: Color { get }\n    var accentColor: Color { get }\n    var name: String { get }\n}\n\nstruct LightTheme: Theme {\n    let name = \"Light\"\n    let primaryColor = Color.blue\n    let backgroundColor = Color.white\n    let textColor = Color.black\n    let accentColor = Color.orange\n}\n\nstruct DarkTheme: Theme {\n    let name = \"Dark\"\n    let primaryColor = Color.blue\n    let backgroundColor = Color.black\n    let textColor = Color.white\n    let accentColor = Color.orange\n}\n```\n\n### Gradient and Shadow Adaptation\n```swift\nextension View {\n    func adaptiveShadow() -> some View {\n        self.modifier(AdaptiveShadow())\n    }\n    \n    func adaptiveGradient() -> some View {\n        self.modifier(AdaptiveGradient())\n    }\n}\n\nstruct AdaptiveShadow: ViewModifier {\n    @Environment(\\.colorScheme) var colorScheme\n    \n    func body(content: Content) -> some View {\n        content\n            .shadow(color: colorScheme == .dark ? \n                    Color.black.opacity(0.8) : \n                    Color.gray.opacity(0.3), \n                    radius: 8, x: 0, y: 2)\n    }\n}\n```\n\n## 5. Testing & Debugging (30 min)\n\n### Environment Overrides\n```swift\n// In SwiftUI Preview\nstruct ContentView_Previews: PreviewProvider {\n    static var previews: some View {\n        Group {\n            ContentView()\n                .preferredColorScheme(.light)\n            \n            ContentView()\n                .preferredColorScheme(.dark)\n            \n            ContentView()\n                .environment(\\.colorScheme, .dark)\n        }\n    }\n}\n```\n\n### Debugging Color Issues\n```swift\n// Add visual debugging\n.modifier(DebugFrame(color: .red))\n\n// Check current color scheme\n@Environment(\\.colorScheme) var colorScheme\nText(\"Current scheme: \\(colorScheme == .dark ? \"Dark\" : \"Light\")\")\n```\n\n## 6. Performance & Best Practices (30 min)\n\n### Efficient Asset Loading\n- **Use asset catalogs** for automatic management\n- **Prefer vector assets** over bitmaps when possible\n- **Lazy load** theme-specific resources\n\n### Memory Management\n```swift\n// Avoid creating colors in body\nstruct ThemeColors {\n    static let shared = ThemeColors()\n    \n    let primary: Color\n    let background: Color\n    \n    private init() {\n        // Initialize once, reuse\n        self.primary = Color(\"Primary\")\n        self.background = Color(\"Background\")\n    }\n}\n```\n\n### Accessibility Considerations\n```swift\n// Support high contrast mode\n@Environment(\\.accessibilityContrast) var contrast\n\nvar backgroundColor: Color {\n    if contrast == .high {\n        return colorScheme == .dark ? Color.black : Color.white\n    } else {\n        return ThemeColors.shared.background\n    }\n}\n```\n\n## Practice Exercises\n\nComplete all exercises to master adaptive theming and create professional, accessible iOS applications!",
      "codeExample": "import SwiftUI\n\n// === THEME MANAGEMENT ===\nenum AppTheme: String, CaseIterable {\n    case system, light, dark, blue, green\n    \n    var colorScheme: ColorScheme? {\n        switch self {\n        case .system: return nil\n        case .light: return .light\n        case .dark: return .dark\n        case .blue, .green: return .light\n        }\n    }\n    \n    var displayName: String {\n        switch self {\n        case .system: return \"System Default\"\n        case .light: return \"Light\"\n        case .dark: return \"Dark\"\n        case .blue: return \"Blue Theme\"\n        case .green: return \"Green Theme\"\n        }\n    }\n}\n\n// === THEME PROTOCOL & IMPLEMENTATIONS ===\nprotocol Theme {\n    var name: String { get }\n    var primary: Color { get }\n    var secondary: Color { get }\n    var background: Color { get }\n    var text: Color { get }\n    var accent: Color { get }\n    var cardBackground: Color { get }\n}\n\nstruct LightTheme: Theme {\n    let name = \"Light\"\n    let primary = Color.blue\n    let secondary = Color.gray\n    let background = Color.white\n    let text = Color.black\n    let accent = Color.orange\n    let cardBackground = Color(.systemGray6)\n}\n\nstruct DarkTheme: Theme {\n    let name = \"Dark\"\n    let primary = Color.blue\n    let secondary = Color.gray\n    let background = Color.black\n    let text = Color.white\n    let accent = Color.orange\n    let cardBackground = Color(.systemGray2)\n}\n\nstruct BlueTheme: Theme {\n    let name = \"Blue\"\n    let primary = Color.blue\n    let secondary = Color.cyan\n    let background = Color.blue.opacity(0.1)\n    let text = Color.primary\n    let accent = Color.purple\n    let cardBackground = Color.white\n}\n\n// === THEME MANAGER ===\nclass ThemeManager: ObservableObject {\n    @Published var currentTheme: AppTheme = .system\n    @AppStorage(\"selectedTheme\") private var storedTheme: String = \"system\"\n    \n    init() {\n        // Load saved theme\n        if let theme = AppTheme(rawValue: storedTheme) {\n            currentTheme = theme\n        }\n    }\n    \n    var colorScheme: ColorScheme? {\n        currentTheme.colorScheme\n    }\n    \n    var currentThemeInstance: Theme {\n        switch currentTheme {\n        case .system, .light:\n            return LightTheme()\n        case .dark:\n            return DarkTheme()\n        case .blue:\n            return BlueTheme()\n        case .green:\n            return LightTheme() // Placeholder\n        }\n    }\n    \n    func setTheme(_ theme: AppTheme) {\n        currentTheme = theme\n        storedTheme = theme.rawValue\n    }\n}\n\n// === ADAPTIVE VIEW MODIFIERS ===\nstruct AdaptiveCard: ViewModifier {\n    let theme: Theme\n    \n    func body(content: Content) -> some View {\n        content\n            .padding()\n            .background(theme.cardBackground)\n            .cornerRadius(12)\n            .shadow(color: .black.opacity(0.1), radius: 4, x: 0, y: 2)\n            .overlay(\n                RoundedRectangle(cornerRadius: 12)\n                    .stroke(theme.primary.opacity(0.2), lineWidth: 1)\n            )\n    }\n}\n\nstruct AdaptiveButton: ViewModifier {\n    let theme: Theme\n    let isPrimary: Bool\n    \n    func body(content: Content) -> some View {\n        content\n            .padding(.horizontal, 16)\n            .padding(.vertical, 12)\n            .background(isPrimary ? theme.primary : theme.secondary)\n            .foregroundColor(.white)\n            .cornerRadius(8)\n            .font(.headline)\n    }\n}\n\n// === MAIN CONTENT VIEW ===\nstruct ThemeDemoView: View {\n    @StateObject private var themeManager = ThemeManager()\n    @State private var showThemePicker = false\n    \n    var body: some View {\n        NavigationView {\n            ScrollView {\n                VStack(spacing: 20) {\n                    // Header\n                    VStack(spacing: 8) {\n                        Image(systemName: \"paintbrush.fill\")\n                            .font(.system(size: 50))\n                            .foregroundColor(themeManager.currentThemeInstance.primary)\n                        \n                        Text(\"Theme Demo\")\n                            .font(.largeTitle)\n                            .fontWeight(.bold)\n                            .foregroundColor(themeManager.currentThemeInstance.text)\n                        \n                        Text(\"Current: \\(themeManager.currentTheme.displayName)\")\n                            .foregroundColor(themeManager.currentThemeInstance.secondary)\n                    }\n                    .modifier(AdaptiveCard(theme: themeManager.currentThemeInstance))\n                    \n                    // Theme Cards\n                    LazyVGrid(columns: [GridItem(.flexible()), GridItem(.flexible())], spacing: 16) {\n                        ForEach(AppTheme.allCases, id: \\.self) { theme in\n                            ThemeCard(theme: theme, isSelected: themeManager.currentTheme == theme) {\n                                themeManager.setTheme(theme)\n                            }\n                        }\n                    }\n                    \n                    // Demo Content\n                    VStack(alignment: .leading, spacing: 16) {\n                        Text(\"Demo Components\")\n                            .font(.title2)\n                            .fontWeight(.semibold)\n                            .foregroundColor(themeManager.currentThemeInstance.text)\n                        \n                        HStack(spacing: 12) {\n                            Button(\"Primary Action\") { }\n                                .modifier(AdaptiveButton(theme: themeManager.currentThemeInstance, isPrimary: true))\n                            \n                            Button(\"Secondary\") { }\n                                .modifier(AdaptiveButton(theme: themeManager.currentThemeInstance, isPrimary: false))\n                        }\n                        \n                        Text(\"This text automatically adapts to the current theme. The background, text colors, and component styles all change based on your selection.\")\n                            .foregroundColor(themeManager.currentThemeInstance.text)\n                            .modifier(AdaptiveCard(theme: themeManager.currentThemeInstance))\n                    }\n                }\n                .padding()\n            }\n            .background(themeManager.currentThemeInstance.background)\n            .navigationBarTitleDisplayMode(.inline)\n            .toolbar {\n                ToolbarItem(placement: .navigationBarTrailing) {\n                    Button(\"Themes\") {\n                        showThemePicker = true\n                    }\n                }\n            }\n            .sheet(isPresented: $showThemePicker) {\n                ThemePickerView(themeManager: themeManager)\n            }\n        }\n        .preferredColorScheme(themeManager.colorScheme)\n    }\n}\n\n// === THEME CARD COMPONENT ===\nstruct ThemeCard: View {\n    let theme: AppTheme\n    let isSelected: Bool\n    let action: () -> Void\n    \n    var body: some View {\n        Button(action: action) {\n            VStack(spacing: 8) {\n                Circle()\n                    .fill(themeColor)\n                    .frame(width: 40, height: 40)\n                    .overlay(\n                        Circle()\n                            .stroke(isSelected ? Color.blue : Color.clear, lineWidth: 3)\n                    )\n                \n                Text(theme.displayName)\n                    .font(.caption)\n                    .fontWeight(.medium)\n                    .foregroundColor(.primary)\n                    .multilineTextAlignment(.center)\n            }\n            .padding(12)\n            .background(Color(.systemBackground))\n            .cornerRadius(12)\n            .overlay(\n                RoundedRectangle(cornerRadius: 12)\n                    .stroke(isSelected ? Color.blue : Color.gray.opacity(0.3), lineWidth: 2)\n            )\n        }\n        .buttonStyle(PlainButtonStyle())\n    }\n    \n    private var themeColor: Color {\n        switch theme {\n        case .system: return Color.blue\n        case .light: return Color.yellow\n        case .dark: return Color.black\n        case .blue: return Color.blue\n        case .green: return Color.green\n        }\n    }\n}",
      "category": "UI/UX",
      "estimatedTime": 180,
      "dependencies": ["variables", "optionals"],
      "challenge": {
        "instructions": "Create a comprehensive theme system for a weather app:\n\nPART 1: Theme Architecture (45 min)\n1. Create a WeatherTheme protocol with: primary, secondary, background, text, warning colors\n2. Implement 3 themes: Default (system), Warm (sunny colors), Cool (winter colors)\n3. Create ThemeManager class with @Published currentTheme and persistence\n\nPART 2: Adaptive Components (60 min)\n4. Create WeatherCard view modifier that adapts to current theme\n5. Create TemperatureIndicator view that changes color based on temperature range\n6. Implement WeatherIcon view that uses different assets for light/dark mode\n\nPART 3: Dynamic Asset Management (45 min)\n7. Create asset catalog with weather icons for both light and dark appearances\n8. Implement dynamic gradient backgrounds that change with theme\n9. Add theme-specific shadow effects for depth\n\nPART 4: Theme Switching Interface (30 min)\n10. Create theme picker with preview of each theme\n11. Add smooth animations for theme transitions\n12. Implement system theme detection and automatic switching\n\nPART 5: Advanced Features (60 min)\n13. Add time-based auto-theming (light during day, dark at night)\n14. Implement accessibility support for high contrast mode\n15. Create theme preview in SwiftUI previews with all theme variants",
        "starterCode": "// === PART 1: Theme Architecture ===\n// Define WeatherTheme protocol and implementations\n\n\n// === PART 2: Adaptive Components ===\n// Create WeatherCard modifier and TemperatureIndicator\n\n\n// === PART 3: Dynamic Assets ===\n// Implement dynamic gradients and asset management\n\n\n// === PART 4: Theme Switching ===\n// Build theme picker interface\n\n\n// === PART 5: Advanced Features ===\n// Add time-based theming and accessibility\n\n",
        "solution": "// === PART 1: Theme Architecture ===\nprotocol WeatherTheme {\n    var name: String { get }\n    var primary: Color { get }\n    var secondary: Color { get }\n    var background: Color { get }\n    var text: Color { get }\n    var warning: Color { get }\n    var gradient: LinearGradient { get }\n}\n\nstruct DefaultTheme: WeatherTheme {\n    let name = \"Default\"\n    let primary = Color.blue\n    let secondary = Color.gray\n    let background = Color(.systemBackground)\n    let text = Color.primary\n    let warning = Color.orange\n    let gradient = LinearGradient(\n        colors: [Color.blue.opacity(0.3), Color.purple.opacity(0.3)],\n        startPoint: .topLeading,\n        endPoint: .bottomTrailing\n    )\n}\n\nstruct WarmTheme: WeatherTheme {\n    let name = \"Warm\"\n    let primary = Color.orange\n    let secondary = Color.yellow\n    let background = Color(.systemBackground)\n    let text = Color.primary\n    let warning = Color.red\n    let gradient = LinearGradient(\n        colors: [Color.orange.opacity(0.3), Color.yellow.opacity(0.3)],\n        startPoint: .topLeading,\n        endPoint: .bottomTrailing\n    )\n}\n\nstruct CoolTheme: WeatherTheme {\n    let name = \"Cool\"\n    let primary = Color.cyan\n    let secondary = Color.blue\n    let background = Color(.systemBackground)\n    let text = Color.primary\n    let warning = Color.purple\n    let gradient = LinearGradient(\n        colors: [Color.cyan.opacity(0.3), Color.blue.opacity(0.3)],\n        startPoint: .topLeading,\n        endPoint: .bottomTrailing\n    )\n}\n\n// === PART 2: Theme Manager ===\nclass WeatherThemeManager: ObservableObject {\n    @Published var currentTheme: WeatherTheme = DefaultTheme()\n    @AppStorage(\"weatherTheme\") private var storedTheme: String = \"default\"\n    \n    let availableThemes: [WeatherTheme] = [DefaultTheme(), WarmTheme(), CoolTheme()]\n    \n    init() {\n        loadSavedTheme()\n    }\n    \n    private func loadSavedTheme() {\n        switch storedTheme {\n        case \"warm\": currentTheme = WarmTheme()\n        case \"cool\": currentTheme = CoolTheme()\n        default: currentTheme = DefaultTheme()\n        }\n    }\n    \n    func setTheme(_ theme: WeatherTheme) {\n        currentTheme = theme\n        storedTheme = theme.name.lowercased()\n    }\n}\n\n// === PART 3: Adaptive Components ===\nstruct WeatherCard: ViewModifier {\n    let theme: WeatherTheme\n    \n    func body(content: Content) -> some View {\n        content\n            .padding()\n            .background(theme.background)\n            .overlay(theme.gradient)\n            .cornerRadius(16)\n            .shadow(color: .black.opacity(0.1), radius: 8, x: 0, y: 4)\n            .overlay(\n                RoundedRectangle(cornerRadius: 16)\n                    .stroke(theme.primary.opacity(0.3), lineWidth: 1)\n            )\n    }\n}\n\nstruct TemperatureIndicator: View {\n    let temperature: Double\n    let theme: WeatherTheme\n    \n    private var temperatureColor: Color {\n        switch temperature {\n        case ..<0: return Color.blue\n        case 0..<10: return Color.cyan\n        case 10..<20: return theme.primary\n        case 20..<30: return Color.orange\n        default: return theme.warning\n        }\n    }\n    \n    var body: some View {\n        HStack {\n            Circle()\n                .fill(temperatureColor)\n                .frame(width: 20, height: 20)\n            \n            Text(\"\\(Int(temperature))Â°C\")\n                .font(.title2)\n                .fontWeight(.semibold)\n                .foregroundColor(theme.text)\n        }\n    }\n}\n\n// === PART 4: Theme Picker ===\nstruct ThemePickerView: View {\n    @ObservedObject var themeManager: WeatherThemeManager\n    @Environment(\\.dismiss) private var dismiss\n    \n    var body: some View {\n        NavigationView {\n            List(themeManager.availableThemes, id: \\.name) { theme in\n                Button(action: {\n                    themeManager.setTheme(theme)\n                    dismiss()\n                }) {\n                    HStack {\n                        Circle()\n                            .fill(theme.primary)\n                            .frame(width: 30, height: 30)\n                        \n                        VStack(alignment: .leading) {\n                            Text(theme.name)\n                                .font(.headline)\n                                .foregroundColor(.primary)\n                            Text(\"Primary: \\(theme.name) theme\")\n                                .font(.caption)\n                                .foregroundColor(.secondary)\n                        }\n                        \n                        Spacer()\n                        \n                        if themeManager.currentTheme.name == theme.name {\n                            Image(systemName: \"checkmark\")\n                                .foregroundColor(.blue)\n                        }\n                    }\n                    .padding(.vertical, 8)\n                }\n            }\n            .navigationTitle(\"Choose Theme\")\n            .navigationBarTitleDisplayMode(.inline)\n            .toolbar {\n                ToolbarItem(placement: .navigationBarTrailing) {\n                    Button(\"Done\") { dismiss() }\n                }\n            }\n        }\n    }\n}\n\n// === PART 5: Main Weather View ===\nstruct WeatherAppView: View {\n    @StateObject private var themeManager = WeatherThemeManager()\n    @State private var temperature: Double = 22.5\n    @State private var showThemePicker = false\n    \n    var body: some View {\n        NavigationView {\n            ZStack {\n                themeManager.currentTheme.gradient\n                    .ignoresSafeArea()\n                \n                VStack(spacing: 20) {\n                    // Weather Card\n                    VStack(spacing: 16) {\n                        Text(\"Current Weather\")\n                            .font(.title2)\n                            .fontWeight(.bold)\n                            .foregroundColor(themeManager.currentTheme.text)\n                        \n                        TemperatureIndicator(temperature: temperature, theme: themeManager.currentTheme)\n                        \n                        Text(\"Sunny with clear skies\")\n                            .foregroundColor(themeManager.currentTheme.text)\n                    }\n                    .modifier(WeatherCard(theme: themeManager.currentTheme))\n                    \n                    // Theme Preview\n                    Button(\"Change Theme\") {\n                        showThemePicker = true\n                    }\n                    .padding()\n                    .background(themeManager.currentTheme.primary)\n                    .foregroundColor(.white)\n                    .cornerRadius(10)\n                }\n                .padding()\n            }\n            .navigationTitle(\"Weather\")\n            .navigationBarTitleDisplayMode(.large)\n            .toolbar {\n                ToolbarItem(placement: .navigationBarTrailing) {\n                    Button(action: { showThemePicker = true }) {\n                        Image(systemName: \"paintbrush\")\n                    }\n                }\n            }\n            .sheet(isPresented: $showThemePicker) {\n                ThemePickerView(themeManager: themeManager)\n            }\n        }\n    }\n}",
        "hints": [
          "PART 1: Define clear protocol requirements for all theme colors and assets",
          "PART 2: Use ViewModifier for reusable component styling across the app",
          "PART 3: Create gradient assets that work well in both light and dark modes",
          "PART 4: Use @AppStorage for automatic theme persistence between app launches",
          "PART 5: Consider using ColorScheme environment for system theme detection",
          "For weather icons, use renderingMode(.template) to allow color changes",
          "Test your themes in both light and dark mode to ensure good contrast",
          "Use semantic colors (Color.primary, Color.secondary) for better adaptability"
        ],
        "testCases": [
          {
            "input": "themeManager.currentTheme.name == \"Default\"",
            "expectedOutput": "true",
            "description": "Default theme should be selected initially"
          },
          {
            "input": "temperatureColor for 25Â°C should be orange",
            "expectedOutput": "true",
            "description": "Temperature indicator should show correct color for warm temperatures"
          },
          {
            "input": "themeManager.availableThemes.count >= 2",
            "expectedOutput": "true",
            "description": "Should have multiple themes available"
          }
        ]
      }
    },
    {
        "id": "drawing_app",
        "title": "Drawing App",
        "description": "Build a custom drawing app with gestures, custom shapes, and color picker",
        "difficulty": "intermediate",
        "theory": "# Drawing App - Custom Graphics & Gestures\n\n## 1. Introduction to Custom Drawing (45 min)\n\n### Core Graphics Framework\nSwiftUI provides powerful tools for custom drawing:\n\n- **`Path`**: Defines shapes and lines\n- **`Shape`**: Reusable custom shapes\n- **`Canvas`**: High-performance drawing surface\n- **`GeometryReader`**: Access to view dimensions\n\n### Basic Drawing Concepts\n```swift\nstruct Circle: Shape {\n    func path(in rect: CGRect) -> Path {\n        var path = Path()\n        path.addEllipse(in: rect)\n        return path\n    }\n}\n```\n\n## 2. Creating Custom Shapes (1 hour)\n\n### Building Complex Shapes\n```swift\nstruct Star: Shape {\n    let points: Int\n    \n    func path(in rect: CGRect) -> Path {\n        var path = Path()\n        let center = CGPoint(x: rect.midX, y: rect.midY)\n        let radius = min(rect.width, rect.height) / 2\n        \n        for i in 0..<points * 2 {\n            let angle = .pi * Double(i) / Double(points)\n            let currentRadius = i.isMultiple(of: 2) ? radius : radius / 2\n            let point = CGPoint(\n                x: center.x + currentRadius * cos(angle),\n                y: center.y + currentRadius * sin(angle)\n            )\n            \n            if i == 0 {\n                path.move(to: point)\n            } else {\n                path.addLine(to: point)\n            }\n        }\n        path.closeSubpath()\n        return path\n    }\n}\n```\n\n## 3. Gesture Recognition (1.5 hours)\n\n### Implementing Drawing Gestures\n```swift\nstruct DrawingGesture: Gesture {\n    @Binding var paths: [DrawingPath]\n    \n    var body: some Gesture {\n        DragGesture(minimumDistance: 0)\n            .onChanged { value in\n                // Handle drawing\n                let point = value.location\n                if let lastPath = paths.last {\n                    paths[paths.count - 1].points.append(point)\n                }\n            }\n            .onEnded { _ in\n                // Start new path\n                paths.append(DrawingPath())\n            }\n    }\n}\n```\n\n### Multi-Touch Gestures\n- **Tap**: Single finger tap\n- **Drag**: Drawing with finger\n- **Long Press**: Color picker activation\n- **Pinch**: Zoom functionality\n- **Rotation**: Tool rotation\n\n## 4. Color System & Tools (1 hour)\n\n### Implementing Color Picker\n```swift\nstruct ColorPickerView: View {\n    @Binding var selectedColor: Color\n    let colors: [Color] = [.red, .blue, .green, .yellow, .purple, .orange, .black]\n    \n    var body: some View {\n        HStack {\n            ForEach(colors, id: \\.self) { color in\n                Circle()\n                    .fill(color)\n                    .frame(width: 30, height: 30)\n                    .overlay(\n                        Circle()\n                            .stroke(selectedColor == color ? Color.white : Color.clear, lineWidth: 3)\n                    )\n                    .onTapGesture {\n                        selectedColor = color\n                    }\n            }\n        }\n    }\n}\n```\n\n## 5. Performance Optimization (45 min)\n\n### Efficient Drawing Techniques\n- Use `Canvas` for complex drawings\n- Implement drawing caches\n- Limit path point density\n- Use `drawingGroup()` for complex views\n\n### Memory Management\n```swift\nclass DrawingCache {\n    private var cache: [UUID: Image] = [:]\n    \n    func getCachedDrawing(for path: DrawingPath) -> Image? {\n        return cache[path.id]\n    }\n    \n    func cacheDrawing(_ image: Image, for path: DrawingPath) {\n        cache[path.id] = image\n    }\n}\n```\n\n## 6. Advanced Features (1 hour)\n\n### Undo/Redo System\n```swift\nclass DrawingHistory: ObservableObject {\n    @Published var paths: [DrawingPath] = []\n    private var undoStack: [[DrawingPath]] = []\n    \n    func saveState() {\n        undoStack.append(paths)\n    }\n    \n    func undo() {\n        guard !undoStack.isEmpty else { return }\n        paths = undoStack.removeLast()\n    }\n}\n```\n\n### Export Functionality\n```swift\nextension View {\n    func exportAsImage() -> UIImage? {\n        let controller = UIHostingController(rootView: self)\n        let view = controller.view\n        \n        let targetSize = controller.view.intrinsicContentSize\n        view?.bounds = CGRect(origin: .zero, size: targetSize)\n        view?.backgroundColor = .clear\n        \n        let renderer = UIGraphicsImageRenderer(size: targetSize)\n        return renderer.image { _ in\n            view?.drawHierarchy(in: controller.view.bounds, afterScreenUpdates: true)\n        }\n    }\n}\n```\n\n## Project Architecture\n\nBuild a complete drawing app with:\n- Custom drawing canvas\n- Multiple brush types\n- Color palette\n- Undo/redo functionality\n- Export to photos\n- Gesture-based controls",
        "codeExample": "import SwiftUI\n\n// === DATA MODELS ===\nstruct DrawingPath: Identifiable {\n    let id = UUID()\n    var points: [CGPoint] = []\n    var color: Color = .black\n    var lineWidth: CGFloat = 3.0\n}\n\nenum DrawingTool {\n    case pen, eraser, highlighter, shape(ShapeType)\n}\n\nenum ShapeType {\n    case rectangle, circle, triangle, star\n}\n\n// === CUSTOM SHAPES ===\nstruct Triangle: Shape {\n    func path(in rect: CGRect) -> Path {\n        var path = Path()\n        path.move(to: CGPoint(x: rect.midX, y: rect.minY))\n        path.addLine(to: CGPoint(x: rect.maxX, y: rect.maxY))\n        path.addLine(to: CGPoint(x: rect.minX, y: rect.maxY))\n        path.closeSubpath()\n        return path\n    }\n}\n\n// === MAIN DRAWING VIEW ===\nstruct DrawingCanvas: View {\n    @Binding var paths: [DrawingPath]\n    @Binding var currentTool: DrawingTool\n    @Binding var currentColor: Color\n    @Binding var lineWidth: CGFloat\n    \n    var body: some View {\n        GeometryReader { geometry in\n            ZStack {\n                // Background\n                Color.white\n                \n                // Existing paths\n                ForEach(paths) { path in\n                    Path { pathBuilder in\n                        guard let firstPoint = path.points.first else { return }\n                        pathBuilder.move(to: firstPoint)\n                        \n                        for point in path.points.dropFirst() {\n                            pathBuilder.addLine(to: point)\n                        }\n                    }\n                    .stroke(path.color, lineWidth: path.lineWidth)\n                }\n            }\n            .gesture(\n                DragGesture(minimumDistance: 0)\n                    .onChanged { value in\n                        handleDrawing(value: value, in: geometry.size)\n                    }\n                    .onEnded { _ in\n                        // Start new path\n                        paths.append(DrawingPath(color: currentColor, lineWidth: lineWidth))\n                    }\n            )\n        }\n    }\n    \n    private func handleDrawing(value: DragGesture.Value, in size: CGSize) {\n        let point = value.location\n        \n        switch currentTool {\n        case .pen, .highlighter:\n            if let lastIndex = paths.indices.last {\n                paths[lastIndex].points.append(point)\n            }\n        case .eraser:\n            // Remove paths near the eraser point\n            paths.removeAll { path in\n                path.points.contains { pathPoint in\n                    let distance = hypot(pathPoint.x - point.x, pathPoint.y - point.y)\n                    return distance < 20\n                }\n            }\n        case .shape:\n            // Handle shape drawing\n            break\n        }\n    }\n}\n\n// === TOOLBAR ===\nstruct DrawingToolbar: View {\n    @Binding var selectedTool: DrawingTool\n    @Binding var selectedColor: Color\n    @Binding var lineWidth: CGFloat\n    \n    let tools: [DrawingTool] = [.pen, .eraser, .highlighter]\n    let colors: [Color] = [.black, .red, .blue, .green, .yellow, .purple, .orange]\n    \n    var body: some View {\n        VStack {\n            // Tools\n            HStack {\n                ForEach(tools, id: \\.self) { tool in\n                    Button {\n                        selectedTool = tool\n                    } label: {\n                        Image(systemName: iconName(for: tool))\n                            .foregroundColor(selectedTool == tool ? .blue : .gray)\n                            .padding(8)\n                            .background(selectedTool == tool ? Color.blue.opacity(0.2) : Color.clear)\n                            .clipShape(Circle())\n                    }\n                }\n            }\n            \n            // Colors\n            ScrollView(.horizontal) {\n                HStack {\n                    ForEach(colors, id: \\.self) { color in\n                        Circle()\n                            .fill(color)\n                            .frame(width: 30, height: 30)\n                            .overlay(\n                                Circle()\n                                    .stroke(selectedColor == color ? Color.white : Color.clear, lineWidth: 3)\n                            )\n                            .onTapGesture {\n                                selectedColor = color\n                            }\n                    }\n                }\n            }\n            \n            // Line width\n            VStack {\n                Text(\"Line Width: \\(Int(lineWidth))\")\n                Slider(value: $lineWidth, in: 1...20)\n            }\n        }\n        .padding()\n        .background(Color.gray.opacity(0.1))\n    }\n    \n    private func iconName(for tool: DrawingTool) -> String {\n        switch tool {\n        case .pen: return \"pencil\"\n        case .eraser: return \"eraser\"\n        case .highlighter: return \"highlighter\"\n        case .shape: return \"square\"\n        }\n    }\n}\n\n// === MAIN APP VIEW ===\nstruct DrawingApp: View {\n    @State private var paths: [DrawingPath] = []\n    @State private var currentTool: DrawingTool = .pen\n    @State private var currentColor: Color = .black\n    @State private var lineWidth: CGFloat = 3.0\n    \n    var body: some View {\n        VStack {\n            // Header\n            HStack {\n                Text(\"Drawing App\")\n                    .font(.title2)\n                    .fontWeight(.bold)\n                \n                Spacer()\n                \n                // Clear button\n                Button(\"Clear\") {\n                    paths.removeAll()\n                }\n                .foregroundColor(.red)\n                \n                // Undo button\n                Button(\"Undo\") {\n                    if !paths.isEmpty {\n                        paths.removeLast()\n                    }\n                }\n                .disabled(paths.isEmpty)\n            }\n            .padding()\n            \n            // Drawing canvas\n            DrawingCanvas(\n                paths: $paths,\n                currentTool: $currentTool,\n                currentColor: $currentColor,\n                lineWidth: $lineWidth\n            )\n            .frame(maxWidth: .infinity, maxHeight: .infinity)\n            .background(Color.white)\n            .cornerRadius(12)\n            .shadow(radius: 5)\n            .padding()\n            \n            // Toolbar\n            DrawingToolbar(\n                selectedTool: $currentTool,\n                selectedColor: $currentColor,\n                lineWidth: $lineWidth\n            )\n        }\n        .background(Color.gray.opacity(0.1))\n    }\n}",
        "category": "Projects",
        "estimatedTime": 360,
        "dependencies": ["swiftui_basics", "gestures", "custom_views"],
        "challenge": {
          "instructions": "Build a complete drawing app with the following features:\n\nPART 1: Core Drawing System (2 hours)\n1. Create a drawing canvas that tracks finger movements\n2. Implement basic drawing with different colors and line widths\n3. Add an eraser tool that removes drawn paths\n\nPART 2: Custom Shapes & Tools (1.5 hours)\n4. Create custom shapes: rectangle, circle, triangle, and star\n5. Implement a shape tool that lets users place these shapes on the canvas\n6. Add a highlighter tool with semi-transparent colors\n\nPART 3: Advanced Features (1.5 hours)\n7. Implement undo/redo functionality with a history stack\n8. Add a color picker with at least 8 different colors\n9. Create a line width slider from 1px to 20px\n\nPART 4: Polish & Export (1 hour)\n10. Add the ability to clear the entire canvas\n11. Implement basic gesture recognition (tap to draw, drag to erase)\n12. Add visual feedback for selected tools and colors\n\nBONUS Challenges:\n- Save drawings to the photo library\n- Add different brush types (spray, calligraphy)\n- Implement zoom and pan functionality\n- Add multiple drawing layers",
          "starterCode": "import SwiftUI\n\n// Add your data models here\n\n// Add custom shapes here\n\n// Implement the drawing canvas\nstruct DrawingCanvas: View {\n    // Add your implementation here\n    \n    var body: some View {\n        // Canvas implementation\n        Text(\"Implement drawing canvas\")\n    }\n}\n\n// Create the toolbar\nstruct DrawingToolbar: View {\n    // Add your implementation here\n    \n    var body: some View {\n        // Toolbar implementation\n        Text(\"Implement toolbar\")\n    }\n}\n\n// Main app view\nstruct DrawingApp: View {\n    // Add state variables here\n    \n    var body: some View {\n        VStack {\n            // Header with clear and undo buttons\n            \n            // Drawing canvas\n            \n            // Toolbar\n        }\n    }\n}",
          "solution": "import SwiftUI\n\n// === DATA MODELS ===\nstruct DrawingPath: Identifiable {\n    let id = UUID()\n    var points: [CGPoint] = []\n    var color: Color = .black\n    var lineWidth: CGFloat = 3.0\n    var tool: DrawingTool = .pen\n}\n\nenum DrawingTool {\n    case pen, eraser, highlighter, shape(ShapeType)\n}\n\nenum ShapeType {\n    case rectangle, circle, triangle, star\n}\n\n// === CUSTOM SHAPES ===\nstruct Star: Shape {\n    let points: Int = 5\n    \n    func path(in rect: CGRect) -> Path {\n        var path = Path()\n        let center = CGPoint(x: rect.midX, y: rect.midY)\n        let radius = min(rect.width, rect.height) / 2\n        \n        for i in 0..<points * 2 {\n            let angle = .pi * Double(i) / Double(points)\n            let currentRadius = i.isMultiple(of: 2) ? radius : radius / 2\n            let point = CGPoint(\n                x: center.x + currentRadius * cos(angle),\n                y: center.y + currentRadius * sin(angle)\n            )\n            \n            if i == 0 {\n                path.move(to: point)\n            } else {\n                path.addLine(to: point)\n            }\n        }\n        path.closeSubpath()\n        return path\n    }\n}\n\n// === DRAWING CANVAS ===\nstruct DrawingCanvas: View {\n    @Binding var paths: [DrawingPath]\n    @Binding var currentTool: DrawingTool\n    @Binding var currentColor: Color\n    @Binding var lineWidth: CGFloat\n    \n    var body: some View {\n        GeometryReader { geometry in\n            ZStack {\n                Color.white\n                \n                ForEach(paths) { path in\n                    if path.tool == .pen || path.tool == .highlighter {\n                        Path { pathBuilder in\n                            guard let firstPoint = path.points.first else { return }\n                            pathBuilder.move(to: firstPoint)\n                            \n                            for point in path.points.dropFirst() {\n                                pathBuilder.addLine(to: point)\n                            }\n                        }\n                        .stroke(path.color, style: StrokeStyle(\n                            lineWidth: path.lineWidth,\n                            lineCap: .round,\n                            lineJoin: .round\n                        ))\n                        .opacity(path.tool == .highlighter ? 0.5 : 1.0)\n                    }\n                }\n            }\n            .gesture(drawingGesture(in: geometry.size))\n        }\n    }\n    \n    private func drawingGesture(in size: CGSize) -> some Gesture {\n        DragGesture(minimumDistance: 0)\n            .onChanged { value in\n                let point = value.location\n                \n                switch currentTool {\n                case .pen, .highlighter:\n                    if paths.isEmpty {\n                        paths.append(DrawingPath(\n                            color: currentColor,\n                            lineWidth: lineWidth,\n                            tool: currentTool\n                        ))\n                    }\n                    if let lastIndex = paths.indices.last {\n                        paths[lastIndex].points.append(point)\n                    }\n                    \n                case .eraser:\n                    paths.removeAll { path in\n                        path.points.contains { pathPoint in\n                            let distance = hypot(pathPoint.x - point.x, pathPoint.y - point.y)\n                            return distance < lineWidth * 2\n                        }\n                    }\n                    \n                case .shape:\n                    break\n                }\n            }\n            .onEnded { _ in\n                if currentTool == .pen || currentTool == .highlighter {\n                    paths.append(DrawingPath(\n                        color: currentColor,\n                        lineWidth: lineWidth,\n                        tool: currentTool\n                    ))\n                }\n            }\n    }\n}\n\n// === TOOLBAR ===\nstruct DrawingToolbar: View {\n    @Binding var selectedTool: DrawingTool\n    @Binding var selectedColor: Color\n    @Binding var lineWidth: CGFloat\n    \n    let tools: [DrawingTool] = [.pen, .eraser, .highlighter]\n    let colors: [Color] = [.black, .red, .blue, .green, .yellow, .purple, .orange, .pink]\n    \n    var body: some View {\n        VStack(spacing: 16) {\n            // Tools\n            HStack {\n                ForEach(tools, id: \\.self) { tool in\n                    Button {\n                        selectedTool = tool\n                    } label: {\n                        Image(systemName: iconName(for: tool))\n                            .font(.title2)\n                            .foregroundColor(selectedTool == tool ? .white : .blue)\n                            .padding(12)\n                            .background(selectedTool == tool ? Color.blue : Color.clear)\n                            .clipShape(Circle())\n                            .overlay(\n                                Circle()\n                                    .stroke(Color.blue, lineWidth: 2)\n                            )\n                    }\n                }\n            }\n            \n            // Colors\n            ScrollView(.horizontal, showsIndicators: false) {\n                HStack {\n                    ForEach(colors, id: \\.self) { color in\n                        Button {\n                            selectedColor = color\n                        } label: {\n                            Circle()\n                                .fill(color)\n                                .frame(width: 35, height: 35)\n                                .overlay(\n                                    Circle()\n                                        .stroke(selectedColor == color ? Color.white : Color.clear, lineWidth: 3)\n                                        .shadow(radius: 2)\n                                )\n                        }\n                    }\n                }\n                .padding(.horizontal)\n            }\n            \n            // Line width\n            VStack {\n                Text(\"Line Width: \\(Int(lineWidth))\")\n                    .font(.headline)\n                Slider(value: $lineWidth, in: 1...20, step: 1)\n                    .padding(.horizontal)\n            }\n        }\n        .padding()\n        .background(Color.gray.opacity(0.1))\n        .cornerRadius(12)\n    }\n    \n    private func iconName(for tool: DrawingTool) -> String {\n        switch tool {\n        case .pen: return \"pencil\"\n        case .eraser: return \"eraser.fill\"\n        case .highlighter: return \"highlighter\"\n        case .shape: return \"square\"\n        }\n    }\n}\n\n// === MAIN APP ===\nstruct DrawingApp: View {\n    @State private var paths: [DrawingPath] = []\n    @State private var currentTool: DrawingTool = .pen\n    @State private var currentColor: Color = .black\n    @State private var lineWidth: CGFloat = 3.0\n    @State private var history: [[DrawingPath]] = []\n    \n    var body: some View {\n        VStack(spacing: 0) {\n            // Header\n            HStack {\n                Text(\"Drawing App\")\n                    .font(.title2)\n                    .fontWeight(.bold)\n                \n                Spacer()\n                \n                // Undo button\n                Button(\"Undo\") {\n                    undo()\n                }\n                .disabled(history.isEmpty)\n                .foregroundColor(history.isEmpty ? .gray : .blue)\n                \n                // Clear button\n                Button(\"Clear\") {\n                    saveState()\n                    paths.removeAll()\n                }\n                .foregroundColor(.red)\n            }\n            .padding()\n            .background(Color.white)\n            \n            // Drawing canvas\n            DrawingCanvas(\n                paths: $paths,\n                currentTool: $currentTool,\n                currentColor: $currentColor,\n                lineWidth: $lineWidth\n            )\n            .onChange(of: paths) { _ in\n                if paths.count % 10 == 0 { // Save state periodically\n                    saveState()\n                }\n            }\n            \n            // Toolbar\n            DrawingToolbar(\n                selectedTool: $currentTool,\n                selectedColor: $currentColor,\n                lineWidth: $lineWidth\n            )\n        }\n        .background(Color.gray.opacity(0.2))\n    }\n    \n    private func saveState() {\n        history.append(paths)\n        if history.count > 50 { // Limit history size\n            history.removeFirst()\n        }\n    }\n    \n    private func undo() {\n        guard !history.isEmpty else { return }\n        paths = history.removeLast()\n    }\n}",
          "hints": [
            "Start by creating the DrawingPath model to track points, colors, and tools",
            "Use GeometryReader in the canvas to get the correct coordinate space",
            "Implement DragGesture with minimumDistance: 0 for immediate drawing response",
            "For the eraser, check distance between touch points and existing path points",
            "Save drawing state periodically to enable undo functionality",
            "Use @State for paths and @Binding for communication between views",
            "Make sure to handle the case when paths array is empty",
            "Use lineCap: .round and lineJoin: .round for smoother drawing",
            "For highlighter effect, use opacity(0.5) on the stroke",
            "Limit history stack size to prevent memory issues"
          ],
          "testCases": [
            {
              "input": "paths.count",
              "expectedOutput": ">= 0",
              "description": "Paths array should exist and be countable"
            },
            {
              "input": "currentColor.description.contains(\"Color\")",
              "expectedOutput": "true",
              "description": "Current color should be a valid Color"
            },
            {
              "input": "lineWidth >= 1 && lineWidth <= 20",
              "expectedOutput": "true",
              "description": "Line width should be within valid range"
            }
          ]
        }
      },
    {
      "id": "advanced_mvvm",
      "title": "Advanced MVVM Architecture",
      "description": "Master services, dependency injection, and professional app architecture patterns",
      "difficulty": "intermediate",
      "theory": "# Advanced MVVM Architecture - Building Scalable Apps\n\n## 1. MVVM Fundamentals Review (30 min)\n\n### What is MVVM?\n**Model-View-ViewModel** is a structural design pattern that separates:\n\n- **Model**: Data and business logic\n- **View**: UI components (SwiftUI Views)\n- **ViewModel**: Business logic and state management\n\n### Basic MVVM Example:\n```swift\n// Model\nstruct User {\n    let id: UUID\n    let name: String\n    let email: String\n}\n\n// ViewModel\nclass UserViewModel: ObservableObject {\n    @Published var users: [User] = []\n    @Published var isLoading = false\n    \n    func loadUsers() {\n        // Business logic here\n    }\n}\n\n// View\nstruct UserListView: View {\n    @StateObject private var viewModel = UserViewModel()\n    \n    var body: some View {\n        List(viewModel.users) { user in\n            Text(user.name)\n        }\n    }\n}\n```\n\n## 2. Service Layer Architecture (1.5 hours)\n\n### What are Services?\nServices handle specific responsibilities like networking, data persistence, or external APIs.\n\n### Service Protocol Design:\n```swift\nprotocol UserServiceProtocol {\n    func fetchUsers() async throws -> [User]\n    func createUser(_ user: User) async throws -> User\n    func updateUser(_ user: User) async throws -> User\n    func deleteUser(id: UUID) async throws\n}\n```\n\n### Concrete Service Implementation:\n```swift\nclass UserService: UserServiceProtocol {\n    private let networkManager: NetworkManagerProtocol\n    private let cache: CacheProtocol\n    \n    init(networkManager: NetworkManagerProtocol, cache: CacheProtocol) {\n        self.networkManager = networkManager\n        self.cache = cache\n    }\n    \n    func fetchUsers() async throws -> [User] {\n        // Check cache first\n        if let cachedUsers = cache.getUsers() {\n            return cachedUsers\n        }\n        \n        // Fetch from network\n        let users = try await networkManager.fetchUsers()\n        cache.saveUsers(users)\n        return users\n    }\n}\n```\n\n### Multiple Service Types:\n```swift\n// Network Service\nprotocol NetworkServiceProtocol {\n    func request<T: Decodable>(_ endpoint: Endpoint) async throws -> T\n}\n\n// Storage Service\nprotocol StorageServiceProtocol {\n    func save<T: Encodable>(_ object: T, forKey key: String) throws\n    func load<T: Decodable>(_ type: T.Type, forKey key: String) throws -> T?\n}\n\n// Analytics Service\nprotocol AnalyticsServiceProtocol {\n    func trackEvent(_ event: String, parameters: [String: Any]?)\n}\n```\n\n## 3. Dependency Injection (2 hours)\n\n### What is Dependency Injection?\nDependency Injection (DI) is a technique where an object receives its dependencies from external sources rather than creating them itself.\n\n### Manual Dependency Injection:\n```swift\nclass UserViewModel: ObservableObject {\n    private let userService: UserServiceProtocol\n    private let analyticsService: AnalyticsServiceProtocol\n    \n    // Constructor Injection\n    init(userService: UserServiceProtocol, analyticsService: AnalyticsServiceProtocol) {\n        self.userService = userService\n        self.analyticsService = analyticsService\n    }\n}\n```\n\n### Dependency Container:\n```swift\nclass DependencyContainer {\n    private var dependencies: [String: Any] = [:]\n    \n    func register<T>(_ type: T.Type, factory: @escaping () -> T) {\n        let key = String(describing: type)\n        dependencies[key] = factory\n    }\n    \n    func resolve<T>() -> T {\n        let key = String(describing: T.self)\n        guard let factory = dependencies[key] as? () -> T else {\n            fatalError(\"No dependency registered for \\(key)\")\n        }\n        return factory()\n    }\n}\n\n// Usage\nlet container = DependencyContainer()\ncontainer.register(UserServiceProtocol.self) {\n    UserService(networkManager: container.resolve(), cache: container.resolve())\n}\n```\n\n### SwiftUI Environment Dependency Injection:\n```swift\n// Define dependency keys\nstruct UserServiceKey: EnvironmentKey {\n    static let defaultValue: UserServiceProtocol = MockUserService()\n}\n\nstruct AnalyticsServiceKey: EnvironmentKey {\n    static let defaultValue: AnalyticsServiceProtocol = AnalyticsService()\n}\n\nextension EnvironmentValues {\n    var userService: UserServiceProtocol {\n        get { self[UserServiceKey.self] }\n        set { self[UserServiceKey.self] = newValue }\n    }\n    \n    var analyticsService: AnalyticsServiceProtocol {\n        get { self[AnalyticsServiceKey.self] }\n        set { self[AnalyticsServiceKey.self] = newValue }\n    }\n}\n\n// Usage in View\nstruct ContentView: View {\n    @Environment(\\.userService) private var userService\n    \n    var body: some View {\n        UserListView()\n            .environment(\\.userService, userService)\n    }\n}\n```\n\n## 4. Advanced ViewModel Patterns (1 hour)\n\n### State Management with Multiple Services:\n```swift\nclass AdvancedUserViewModel: ObservableObject {\n    @Published var state = ViewState<[User]>.idle\n    \n    private let userService: UserServiceProtocol\n    private let analyticsService: AnalyticsServiceProtocol\n    private let storageService: StorageServiceProtocol\n    \n    enum ViewState<T> {\n        case idle\n        case loading\n        case loaded(T)\n        case error(Error)\n    }\n    \n    init(userService: UserServiceProtocol, \n         analyticsService: AnalyticsServiceProtocol,\n         storageService: StorageServiceProtocol) {\n        self.userService = userService\n        self.analyticsService = analyticsService\n        self.storageService = storageService\n    }\n    \n    @MainActor\n    func loadUsers() async {\n        state = .loading\n        analyticsService.trackEvent(\"load_users_started\")\n        \n        do {\n            let users = try await userService.fetchUsers()\n            state = .loaded(users)\n            analyticsService.trackEvent(\"load_users_success\", parameters: [\"count\": users.count])\n        } catch {\n            state = .error(error)\n            analyticsService.trackEvent(\"load_users_failed\", parameters: [\"error\": error.localizedDescription])\n        }\n    }\n}\n```\n\n### Coordinator Pattern with MVVM:\n```swift\nprotocol Coordinator: ObservableObject {\n    func navigate(to destination: AppRoute)\n    func pop()\n}\n\nclass AppCoordinator: Coordinator {\n    @Published var path = NavigationPath()\n    \n    private let dependencyContainer: DependencyContainer\n    \n    init(dependencyContainer: DependencyContainer) {\n        self.dependencyContainer = dependencyContainer\n    }\n    \n    func navigate(to destination: AppRoute) {\n        path.append(destination)\n    }\n    \n    func pop() {\n        if !path.isEmpty {\n            path.removeLast()\n        }\n    }\n}\n```\n\n## 5. Testing MVVM with Dependencies (1 hour)\n\n### Mock Services for Testing:\n```swift\nclass MockUserService: UserServiceProtocol {\n    var usersToReturn: [User] = []\n    var errorToThrow: Error?\n    var fetchUsersCallCount = 0\n    \n    func fetchUsers() async throws -> [User] {\n        fetchUsersCallCount += 1\n        \n        if let error = errorToThrow {\n            throw error\n        }\n        \n        return usersToReturn\n    }\n}\n\nclass MockAnalyticsService: AnalyticsServiceProtocol {\n    var trackedEvents: [(String, [String: Any]?)] = []\n    \n    func trackEvent(_ event: String, parameters: [String: Any]?) {\n        trackedEvents.append((event, parameters))\n    }\n}\n```\n\n### Unit Testing ViewModels:\n```swift\nclass UserViewModelTests: XCTestCase {\n    var viewModel: AdvancedUserViewModel!\n    var mockUserService: MockUserService!\n    var mockAnalytics: MockAnalyticsService!\n    \n    override func setUp() {\n        mockUserService = MockUserService()\n        mockAnalytics = MockAnalyticsService()\n        \n        viewModel = AdvancedUserViewModel(\n            userService: mockUserService,\n            analyticsService: mockAnalytics,\n            storageService: MockStorageService()\n        )\n    }\n    \n    func testLoadUsersSuccess() async {\n        // Given\n        let expectedUsers = [User(id: UUID(), name: \"Test\", email: \"test@test.com\")]\n        mockUserService.usersToReturn = expectedUsers\n        \n        // When\n        await viewModel.loadUsers()\n        \n        // Then\n        if case .loaded(let users) = viewModel.state {\n            XCTAssertEqual(users, expectedUsers)\n        } else {\n            XCTFail(\"Expected loaded state\")\n        }\n        \n        XCTAssertEqual(mockAnalytics.trackedEvents.last?.0, \"load_users_success\")\n    }\n}\n```\n\n## 6. Best Practices & Common Pitfalls (30 min)\n\n### Do's and Don'ts:\n\n**âœ… DO:**\n- Use protocols for all services\n- Inject dependencies through initializers\n- Keep ViewModels focused and single-responsibility\n- Use @MainActor for UI updates\n- Write comprehensive tests\n\n**âŒ DON'T:**\n- Create dependencies inside ViewModels\n- Put business logic in Views\n- Use singletons for services\n- Ignore error handling\n- Make ViewModels too large\n\n### Performance Considerations:\n- Use weak references when needed\n- Implement proper memory management\n- Consider using @EnvironmentObject for shared state\n- Use lazy dependency resolution when appropriate",
      "codeExample": "// === SERVICE PROTOCOLS ===\nprotocol NetworkServiceProtocol {\n    func request<T: Decodable>(_ endpoint: Endpoint) async throws -> T\n}\n\nprotocol UserServiceProtocol {\n    func fetchUsers() async throws -> [User]\n    func fetchUser(byId id: UUID) async throws -> User\n    func createUser(_ user: User) async throws -> User\n}\n\nprotocol AnalyticsServiceProtocol {\n    func trackEvent(_ event: String, parameters: [String: Any]?)\n}\n\n// === SERVICE IMPLEMENTATIONS ===\nclass NetworkService: NetworkServiceProtocol {\n    private let baseURL: URL\n    private let session: URLSession\n    \n    init(baseURL: URL, session: URLSession = .shared) {\n        self.baseURL = baseURL\n        self.session = session\n    }\n    \n    func request<T: Decodable>(_ endpoint: Endpoint) async throws -> T {\n        let url = baseURL.appendingPathComponent(endpoint.path)\n        var request = URLRequest(url: url)\n        request.httpMethod = endpoint.method.rawValue\n        \n        let (data, response) = try await session.data(for: request)\n        \n        guard let httpResponse = response as? HTTPURLResponse,\n              (200...299).contains(httpResponse.statusCode) else {\n            throw NetworkError.invalidResponse\n        }\n        \n        return try JSONDecoder().decode(T.self, from: data)\n    }\n}\n\nclass UserService: UserServiceProtocol {\n    private let networkService: NetworkServiceProtocol\n    \n    init(networkService: NetworkServiceProtocol) {\n        self.networkService = networkService\n    }\n    \n    func fetchUsers() async throws -> [User] {\n        return try await networkService.request(Endpoint.users)\n    }\n    \n    func fetchUser(byId id: UUID) async throws -> User {\n        return try await networkService.request(Endpoint.user(id: id))\n    }\n    \n    func createUser(_ user: User) async throws -> User {\n        // Implementation for creating user\n        return user\n    }\n}\n\n// === DEPENDENCY CONTAINER ===\nclass DependencyContainer {\n    private var factories: [String: () -> Any] = [:]\n    \n    func register<T>(_ type: T.Type, _ factory: @escaping () -> T) {\n        let key = String(describing: type)\n        factories[key] = factory\n    }\n    \n    func resolve<T>() -> T {\n        let key = String(describing: T.self)\n        guard let factory = factories[key]?() as? T else {\n            fatalError(\"No factory registered for \\(key)\")\n        }\n        return factory\n    }\n}\n\n// === ADVANCED VIEWMODEL ===\n@MainActor\nclass UserListViewModel: ObservableObject {\n    @Published var users: [User] = []\n    @Published var isLoading = false\n    @Published var error: String?\n    \n    private let userService: UserServiceProtocol\n    private let analyticsService: AnalyticsServiceProtocol\n    \n    init(userService: UserServiceProtocol, analyticsService: AnalyticsServiceProtocol) {\n        self.userService = userService\n        self.analyticsService = analyticsService\n    }\n    \n    func loadUsers() async {\n        isLoading = true\n        error = nil\n        analyticsService.trackEvent(\"user_list_load_started\")\n        \n        do {\n            users = try await userService.fetchUsers()\n            analyticsService.trackEvent(\"user_list_load_success\", parameters: [\"count\": users.count])\n        } catch {\n            self.error = error.localizedDescription\n            analyticsService.trackEvent(\"user_list_load_failed\", parameters: [\"error\": error.localizedDescription])\n        }\n        \n        isLoading = false\n    }\n    \n    func deleteUser(at offsets: IndexSet) {\n        offsets.forEach { index in\n            let user = users[index]\n            users.remove(at: index)\n            analyticsService.trackEvent(\"user_deleted\", parameters: [\"user_id\": user.id.uuidString])\n        }\n    }\n}\n\n// === USAGE IN SWIFTUI ===\nstruct UserListView: View {\n    @StateObject private var viewModel: UserListViewModel\n    \n    init(viewModel: UserListViewModel) {\n        _viewModel = StateObject(wrappedValue: viewModel)\n    }\n    \n    var body: some View {\n        NavigationView {\n            Group {\n                if viewModel.isLoading {\n                    ProgressView(\"Loading users...\")\n                } else if let error = viewModel.error {\n                    ErrorView(error: error, retryAction: {\n                        Task { await viewModel.loadUsers() }\n                    })\n                } else {\n                    List {\n                        ForEach(viewModel.users) { user in\n                            UserRowView(user: user)\n                        }\n                        .onDelete(perform: viewModel.deleteUser)\n                    }\n                }\n            }\n            .navigationTitle(\"Users\")\n            .toolbar {\n                ToolbarItem(placement: .navigationBarTrailing) {\n                    Button(\"Reload\") {\n                        Task { await viewModel.loadUsers() }\n                    }\n                }\n            }\n        }\n        .task {\n            await viewModel.loadUsers()\n        }\n    }\n}\n\n// === SETUP ===\n// Configure dependencies\nlet container = DependencyContainer()\ncontainer.register(NetworkServiceProtocol.self) {\n    NetworkService(baseURL: URL(string: \"https://api.example.com\")!)\n}\ncontainer.register(UserServiceProtocol.self) {\n    UserService(networkService: container.resolve())\n}\ncontainer.register(AnalyticsServiceProtocol.self) {\n    AnalyticsService()\n}\n\n// Create view model with injected dependencies\nlet viewModel = UserListViewModel(\n    userService: container.resolve(),\n    analyticsService: container.resolve()\n)",
      "category": "App Architecture",
      "estimatedTime": 300,
      "dependencies": ["optionals"],
      "challenge": {
        "instructions": "Build a complete Task Management app using Advanced MVVM architecture:\n\nPART 1: Service Layer Design (90 min)\n1. Create protocol `TaskServiceProtocol` with methods: fetchTasks, createTask, updateTask, deleteTask\n2. Implement `NetworkTaskService` that uses a NetworkService dependency\n3. Create `MockTaskService` for testing with predefined tasks\n4. Design proper error handling with custom Error types\n\nPART 2: Dependency Injection Setup (60 min)\n5. Create a `DependencyContainer` class that can register and resolve dependencies\n6. Register TaskServiceProtocol, NetworkServiceProtocol, and AnalyticsServiceProtocol\n7. Implement environment-based dependency injection for SwiftUI\n8. Create a proper dependency graph\n\nPART 3: Advanced ViewModel (90 min)\n9. Create `TaskListViewModel` with @Published properties for tasks, loading state, and errors\n10. Implement proper async/await methods for all operations\n11. Add analytics tracking for user actions\n12. Implement proper state management with enum states\n\nPART 4: Coordinator Pattern (45 min)\n13. Create `AppCoordinator` that handles navigation between screens\n14. Implement navigation to task detail, create task, and settings screens\n15. Use dependency injection in the coordinator\n\nPART 5: Testing & Validation (35 min)\n16. Write unit tests for TaskListViewModel using mock services\n17. Test success and error scenarios\n18. Verify analytics events are tracked correctly\n\nBONUS: Implement a caching layer between NetworkService and TaskService",
        "starterCode": "// === PART 1: Service Layer ===\n// Define TaskServiceProtocol and implementations\n\n\n// === PART 2: Dependency Injection ===\n// Create DependencyContainer and setup\n\n\n// === PART 3: Advanced ViewModel ===\n// Implement TaskListViewModel\n\n\n// === PART 4: Coordinator Pattern ===\n// Create AppCoordinator\n\n\n// === PART 5: Testing ===\n// Write unit tests\n\n",
        "solution": "// === PART 1: Service Layer ===\nprotocol TaskServiceProtocol {\n    func fetchTasks() async throws -> [Task]\n    func createTask(_ task: Task) async throws -> Task\n    func updateTask(_ task: Task) async throws -> Task\n    func deleteTask(id: UUID) async throws\n}\n\nclass NetworkTaskService: TaskServiceProtocol {\n    private let networkService: NetworkServiceProtocol\n    \n    init(networkService: NetworkServiceProtocol) {\n        self.networkService = networkService\n    }\n    \n    func fetchTasks() async throws -> [Task] {\n        return try await networkService.request(Endpoint.tasks)\n    }\n    \n    func createTask(_ task: Task) async throws -> Task {\n        return try await networkService.request(Endpoint.createTask(task))\n    }\n    \n    func updateTask(_ task: Task) async throws -> Task {\n        return try await networkService.request(Endpoint.updateTask(task))\n    }\n    \n    func deleteTask(id: UUID) async throws {\n        let _: EmptyResponse = try await networkService.request(Endpoint.deleteTask(id: id))\n    }\n}\n\n// === PART 2: Dependency Injection ===\nclass DependencyContainer {\n    private var factories: [String: () -> Any] = [:]\n    \n    func register<T>(_ type: T.Type, _ factory: @escaping () -> T) {\n        let key = String(describing: type)\n        factories[key] = factory\n    }\n    \n    func resolve<T>() -> T {\n        let key = String(describing: T.self)\n        guard let factory = factories[key]?() as? T else {\n            fatalError(\"No dependency registered for \\(key)\")\n        }\n        return factory\n    }\n}\n\n// === PART 3: Advanced ViewModel ===\n@MainActor\nclass TaskListViewModel: ObservableObject {\n    @Published var tasks: [Task] = []\n    @Published var isLoading = false\n    @Published var error: String?\n    \n    private let taskService: TaskServiceProtocol\n    private let analyticsService: AnalyticsServiceProtocol\n    \n    init(taskService: TaskServiceProtocol, analyticsService: AnalyticsServiceProtocol) {\n        self.taskService = taskService\n        self.analyticsService = analyticsService\n    }\n    \n    func loadTasks() async {\n        isLoading = true\n        error = nil\n        \n        do {\n            tasks = try await taskService.fetchTasks()\n            analyticsService.trackEvent(\"tasks_loaded\", parameters: [\"count\": tasks.count])\n        } catch {\n            self.error = error.localizedDescription\n            analyticsService.trackEvent(\"tasks_load_failed\", parameters: [\"error\": error.localizedDescription])\n        }\n        \n        isLoading = false\n    }\n    \n    func createTask(title: String, description: String) async {\n        let newTask = Task(id: UUID(), title: title, description: description, isCompleted: false)\n        \n        do {\n            let createdTask = try await taskService.createTask(newTask)\n            tasks.append(createdTask)\n            analyticsService.trackEvent(\"task_created\", parameters: [\"task_id\": createdTask.id.uuidString])\n        } catch {\n            self.error = \"Failed to create task: \\(error.localizedDescription)\"\n        }\n    }\n}\n\n// === PART 4: Coordinator Pattern ===\nclass AppCoordinator: ObservableObject {\n    @Published var path = NavigationPath()\n    private let container: DependencyContainer\n    \n    init(container: DependencyContainer) {\n        self.container = container\n    }\n    \n    func showTaskDetail(_ task: Task) {\n        path.append(AppRoute.taskDetail(task))\n    }\n    \n    func showCreateTask() {\n        path.append(AppRoute.createTask)\n    }\n}\n\n// === PART 5: Testing ===\nclass TaskListViewModelTests: XCTestCase {\n    var viewModel: TaskListViewModel!\n    var mockTaskService: MockTaskService!\n    var mockAnalytics: MockAnalyticsService!\n    \n    override func setUp() {\n        mockTaskService = MockTaskService()\n        mockAnalytics = MockAnalyticsService()\n        viewModel = TaskListViewModel(taskService: mockTaskService, analyticsService: mockAnalytics)\n    }\n    \n    func testLoadTasksSuccess() async {\n        // Given\n        let expectedTasks = [Task(id: UUID(), title: \"Test\", description: \"Test\", isCompleted: false)]\n        mockTaskService.tasksToReturn = expectedTasks\n        \n        // When\n        await viewModel.loadTasks()\n        \n        // Then\n        XCTAssertEqual(viewModel.tasks, expectedTasks)\n        XCTAssertFalse(viewModel.isLoading)\n        XCTAssertNil(viewModel.error)\n    }\n}",
        "hints": [
          "PART 1: Design protocols first, then implement concrete services. Use async/await for all service methods.",
          "PART 2: The DependencyContainer should use type-erasure to store different service types.",
          "PART 3: Use @MainActor to ensure all UI updates happen on the main thread.",
          "PART 4: The coordinator should handle all navigation logic and own the navigation state.",
          "PART 5: Mock services should track method calls and allow controlled responses for testing.",
          "Remember to use proper error handling with do-try-catch in all async methods.",
          "Use dependency injection through initializers rather than creating dependencies inside classes.",
          "Consider using a State enum (idle, loading, loaded, error) for more complex state management."
        ],
        "testCases": [
          {
            "input": "viewModel.tasks.count == expectedCount",
            "expectedOutput": "true",
            "description": "Tasks should be loaded correctly"
          },
          {
            "input": "mockAnalytics.trackedEvents.contains { $0.0 == \"tasks_loaded\" }",
            "expectedOutput": "true",
            "description": "Analytics event should be tracked when tasks load"
          },
          {
            "input": "viewModel.isLoading == false after load",
            "expectedOutput": "true",
            "description": "Loading state should be false after operation completes"
          }
        ]
      }
    },
    {
      "id": "combine_framework",
      "title": "Combine Framework",
      "description": "Master reactive programming in Swift with Publishers, Subscribers, and data streams",
      "difficulty": "intermediate",
      "theory": "# Combine Framework - Reactive Programming in Swift\n\n## 1. Introduction to Reactive Programming (45 min)\n\n### What is Combine?\nCombine is Apple's framework for processing values over time using declarative Swift API.\n\n**Imperative vs Reactive:**\n```swift\n// Imperative\nvar score = 0\nfunc updateScore() {\n    score += 10\n    updateUI()\n}\n\n// Reactive\n@Published var score = 0\n$score\n    .sink { newValue in\n        updateUI(with: newValue)\n    }\n```\n\n### Key Concepts:\n- **Publisher**: Emits values over time\n- **Subscriber**: Receives values from publishers\n- **Operator**: Transforms values between publishers and subscribers\n- **Subscription**: The connection between publisher and subscriber\n\n## 2. Publishers (90 min)\n\n### Built-in Publishers:\n\n#### @Published Property Wrapper:\n```swift\nclass GameManager {\n    @Published var score: Int = 0\n    @Published var isGameActive: Bool = false\n}\n\nlet manager = GameManager()\n// $score creates a Publisher<Int, Never>\n```\n\n#### Just Publisher:\n```swift\nlet justPublisher = Just(\"Hello, Combine!\")\n// Emits single value then completes\n```\n\n#### Future Publisher:\n```swift\nfunc fetchUserData() -> Future<User, Error> {\n    return Future { promise in\n        // Async work\n        APIService.fetchUser { result in\n            switch result {\n            case .success(let user):\n                promise(.success(user))\n            case .failure(let error):\n                promise(.failure(error))\n            }\n        }\n    }\n}\n```\n\n#### Sequence Publishers:\n```swift\nlet arrayPublisher = [1, 2, 3, 4, 5].publisher\nlet rangePublisher = (1...10).publisher\n```\n\n#### NotificationCenter Publisher:\n```swift\nlet notificationPublisher = NotificationCenter.default\n    .publisher(for: UIApplication.didBecomeActiveNotification)\n```\n\n#### URLSession Publisher:\n```swift\nlet url = URL(string: \"https://api.example.com/data\")!\nlet dataTaskPublisher = URLSession.shared.dataTaskPublisher(for: url)\n```\n\n### Custom Publishers:\n```swift\nstruct ScorePublisher: Publisher {\n    typealias Output = Int\n    typealias Failure = Never\n    \n    private let scores: [Int]\n    \n    init(scores: [Int]) {\n        self.scores = scores\n    }\n    \n    func receive<S>(subscriber: S) where S : Subscriber, Failure == S.Failure, Output == S.Input {\n        let subscription = ScoreSubscription(subscriber: subscriber, scores: scores)\n        subscriber.receive(subscription: subscription)\n    }\n}\n```\n\n## 3. Subscribers (90 min)\n\n### Sink Subscriber:\n```swift\nlet publisher = [1, 2, 3, 4, 5].publisher\n\nlet cancellable = publisher\n    .sink(\n        receiveCompletion: { completion in\n            switch completion {\n            case .finished:\n                print(\"Stream completed successfully\")\n            case .failure(let error):\n                print(\"Stream failed with error: \" + error.localizedDescription)\n            }\n        },\n        receiveValue: { value in\n            print(\"Received value: \" + String(value))\n        }\n    )\n```\n\n### Assign Subscriber:\n```swift\nclass Player {\n    var score: Int = 0\n}\n\nlet player = Player()\nlet scorePublisher = [10, 20, 30].publisher\n\nscorePublisher\n    .assign(to: \\.score, on: player)\n```\n\n### Custom Subscribers:\n```swift\nclass ScoreSubscriber: Subscriber {\n    typealias Input = Int\n    typealias Failure = Never\n    \n    func receive(subscription: Subscription) {\n        print(\"Subscription received\")\n        subscription.request(.unlimited) // Request all values\n    }\n    \n    func receive(_ input: Int) -> Subscribers.Demand {\n        print(\"Received score: \" + String(input))\n        return .none // Don't request more values\n    }\n    \n    func receive(completion: Subscribers.Completion<Never>) {\n        print(\"Stream completed\")\n    }\n}\n```\n\n## 4. Operators - Transforming Data (120 min)\n\n### Mapping Operators:\n\n#### Map:\n```swift\nlet numbers = [1, 2, 3, 4, 5].publisher\nnumbers\n    .map { $0 * 2 } // [2, 4, 6, 8, 10]\n    .sink { print($0) }\n```\n\n#### TryMap:\n```swift\nlet strings = [\"1\", \"2\", \"three\", \"4\"].publisher\nstrings\n    .tryMap { string in\n        guard let int = Int(string) else {\n            throw ConversionError.invalidString\n        }\n        return int\n    }\n    .sink(\n        receiveCompletion: { print($0) },\n        receiveValue: { print($0) }\n    )\n```\n\n#### FlatMap:\n```swift\nstruct User {\n    var id: String\n    @Published var posts: [Post] = []\n}\n\nlet usersPublisher: [User].publisher\nusersPublisher\n    .flatMap { $0.$posts } // Flattens multiple post arrays\n    .sink { post in\n        print(\"Post: \" + post.title)\n    }\n```\n\n### Filtering Operators:\n\n#### Filter:\n```swift\nlet scores = [45, 90, 75, 20, 95, 60].publisher\nscores\n    .filter { $0 >= 60 } // [90, 75, 95, 60]\n    .sink { print(\"Passing score: \" + String($0)) }\n```\n\n#### CompactMap:\n```swift\nlet optionalNumbers = [\"1\", \"2\", nil, \"4\", nil, \"6\"].publisher\noptionalNumbers\n    .compactMap { $0 } // Removes nil values\n    .compactMap { Int($0) } // Converts and removes failed conversions\n    .sink { print($0) }\n```\n\n#### RemoveDuplicates:\n```swift\nlet repeatedScores = [100, 100, 50, 100, 50, 75].publisher\nrepeatedScores\n    .removeDuplicates() // [100, 50, 100, 50, 75]\n    .sink { print($0) }\n```\n\n### Combining Operators:\n\n#### CombineLatest:\n```swift\nlet username = PassthroughSubject<String, Never>()\nlet password = PassthroughSubject<String, Never>()\n\nPublishers.CombineLatest(username, password)\n    .map { username, password in\n        return !username.isEmpty && !password.isEmpty\n    }\n    .sink { isFormValid in\n        print(\"Form valid: \" + String(isFormValid))\n    }\n```\n\n#### Merge:\n```swift\nlet publisher1 = [1, 2, 3].publisher\nlet publisher2 = [4, 5, 6].publisher\n\npublisher1\n    .merge(with: publisher2) // [1, 4, 2, 5, 3, 6]\n    .sink { print($0) }\n```\n\n#### Zip:\n```swift\nlet names = [\"Alice\", \"Bob\", \"Charlie\"].publisher\nlet scores = [95, 87, 92].publisher\n\nPublishers.Zip(names, scores)\n    .sink { name, score in\n        print(name + \": \" + String(score)) // Alice: 95, Bob: 87, Charlie: 92\n    }\n```\n\n## 5. Error Handling & Memory Management (45 min)\n\n### Error Handling Operators:\n\n#### Catch:\n```swift\nlet failingPublisher = Fail<Int, Error>(error: NetworkError.timeout)\n\nfailingPublisher\n    .catch { error in\n        return Just(-1) // Recover with default value\n    }\n    .sink { print($0) } // Prints: -1\n```\n\n#### Retry:\n```swift\nlet networkPublisher = URLSession.shared.dataTaskPublisher(for: url)\n    .map(\\.data)\n    .decode(type: User.self, decoder: JSONDecoder())\n    .retry(3) // Retry up to 3 times on failure\n```\n\n### Memory Management:\n\n#### Cancellables:\n```swift\nclass GameViewController: UIViewController {\n    private var cancellables = Set<AnyCancellable>()\n    \n    override func viewDidLoad() {\n        super.viewDidLoad()\n        \n        $score\n            .sink { [weak self] newScore in\n                self?.updateScoreLabel(newScore)\n            }\n            .store(in: &cancellables) // Automatic memory management\n    }\n}\n```\n\n#### Weak Self Pattern:\n```swift\n@Published var userData: UserData?\n\nfunc setupBindings() {\n    $userData\n        .compactMap { $0 } // Remove nil values\n        .sink { [weak self] userData in\n            guard let self = self else { return }\n            self.updateUI(with: userData)\n        }\n        .store(in: &cancellables)\n}\n```\n\n## 6. Real-World Patterns & Best Practices (30 min)\n\n### MVVM with Combine:\n```swift\nclass GameViewModel: ObservableObject {\n    @Published var score: Int = 0\n    @Published var isGameActive: Bool = false\n    @Published var highScores: [Int] = []\n    \n    private var cancellables = Set<AnyCancellable>()\n    \n    init() {\n        setupBindings()\n    }\n    \n    private func setupBindings() {\n        $score\n            .filter { $0 > 100 }\n            .sink { [weak self] _ in\n                self?.unlockAchievement()\n            }\n            .store(in: &cancellables)\n    }\n}\n```\n\n### Networking with Combine:\n```swift\nclass APIService {\n    func fetchHighScores() -> AnyPublisher<[Int], Error> {\n        let url = URL(string: \"https://api.game.com/highscores\")!\n        \n        return URLSession.shared.dataTaskPublisher(for: url)\n            .map(\\.data)\n            .decode(type: [Int].self, decoder: JSONDecoder())\n            .eraseToAnyPublisher()\n    }\n}\n```\n\n### User Input Handling:\n```swift\nclass SearchViewModel: ObservableObject {\n    @Published var searchText: String = \"\"\n    @Published var results: [String] = []\n    \n    init() {\n        $searchText\n            .debounce(for: .milliseconds(300), scheduler: RunLoop.main)\n            .removeDuplicates()\n            .flatMap { query in\n                self.search(query: query)\n                    .catch { _ in Just([]) }\n            }\n            .assign(to: &$results)\n    }\n}\n```\n\n## Practice Exercises\n\nComplete all exercises to master Combine framework concepts!",
      "codeExample": "import Combine\n\n// === BASIC PUBLISHERS ===\n// @Published Property Wrapper\nclass Player {\n    @Published var health: Int = 100\n    @Published var name: String = \"Player\"\n    @Published var level: Int = 1\n}\n\nlet player = Player()\n\n// Just Publisher\nlet welcomeMessage = Just(\"Welcome to the game!\")\n\n// Sequence Publishers\nlet scoreSequence = [10, 20, 30, 40, 50].publisher\nlet levelRange = (1...10).publisher\n\n// PassthroughSubject (Manual Publisher)\nlet gameEvent = PassthroughSubject<String, Never>()\n\n// CurrentValueSubject (Publisher with initial value)\nlet currentScore = CurrentValueSubject<Int, Never>(0)\n\n// === COMBINING PUBLISHERS ===\n// CombineLatest Example\nlet usernameInput = PassthroughSubject<String, Never>()\nlet emailInput = PassthroughSubject<String, Never>()\n\nlet isFormValid = Publishers.CombineLatest(usernameInput, emailInput)\n    .map { username, email in\n        return !username.isEmpty && email.contains(\"@\")\n    }\n\n// Merge Example\nlet enemyDefeated = PassthroughSubject<Int, Never>()\nlet itemCollected = PassthroughSubject<String, Never>()\n\nlet gameEvents = Publishers.Merge(\n    enemyDefeated.map { \"Defeated enemy worth \" + String($0) + \" points\" },\n    itemCollected.map { \"Collected: \" + $0 }\n)\n\n// === OPERATORS IN ACTION ===\nclass GameManager: ObservableObject {\n    @Published var score: Int = 0\n    @Published var multiplier: Double = 1.0\n    @Published var isPowerUpActive: Bool = false\n    @Published var playerName: String = \"\"\n    \n    private var cancellables = Set<AnyCancellable>()\n    \n    init() {\n        setupGameLogic()\n    }\n    \n    private func setupGameLogic() {\n        // Transform score with multiplier\n        $score\n            .combineLatest($multiplier)\n            .map { score, multiplier in\n                return Int(Double(score) * multiplier)\n            }\n            .sink { [weak self] multipliedScore in\n                print(\"Display score: \" + String(multipliedScore))\n            }\n            .store(in: &cancellables)\n        \n        // Power-up timer\n        $isPowerUpActive\n            .filter { $0 == true }\n            .flatMap { _ in\n                Timer.publish(every: 1.0, on: .main, in: .common)\n                    .autoconnect()\n                    .prefix(10) // Only take 10 values (10 seconds)\n            }\n            .sink { [weak self] _ in\n                self?.score += 5\n            }\n            .store(in: &cancellables)\n        \n        // Input validation\n        $playerName\n            .debounce(for: .milliseconds(500), scheduler: RunLoop.main)\n            .removeDuplicates()\n            .map { name in\n                return name.count >= 3 && name.count <= 15\n            }\n            .sink { isValid in\n                print(\"Name valid: \" + String(isValid))\n            }\n            .store(in: &cancellables)\n    }\n    \n    func addScore(_ points: Int) {\n        score += points\n    }\n    \n    func activatePowerUp() {\n        multiplier = 2.0\n        isPowerUpActive = true\n        \n        // Auto-deactivate after 10 seconds\n        DispatchQueue.main.asyncAfter(deadline: .now() + 10) {\n            self.multiplier = 1.0\n            self.isPowerUpActive = false\n        }\n    }\n}\n\n// === NETWORKING WITH COMBINE ===\nstruct HighScore: Codable {\n    let player: String\n    let score: Int\n    let date: Date\n}\n\nclass LeaderboardService {\n    private let baseURL = \"https://api.game.com\"\n    \n    func fetchTopScores() -> AnyPublisher<[HighScore], Error> {\n        guard let url = URL(string: baseURL + \"/leaderboard/top\") else {\n            return Fail(error: URLError(.badURL))\n                .eraseToAnyPublisher()\n        }\n        \n        return URLSession.shared.dataTaskPublisher(for: url)\n            .map(\\.data)\n            .decode(type: [HighScore].self, decoder: JSONDecoder())\n            .catch { error in\n                // Return empty array on error\n                return Just([])\n                    .setFailureType(to: Error.self)\n            }\n            .eraseToAnyPublisher()\n    }\n    \n    func submitScore(_ score: Int, player: String) -> AnyPublisher<Bool, Error> {\n        guard let url = URL(string: baseURL + \"/scores\") else {\n            return Fail(error: URLError(.badURL))\n                .eraseToAnyPublisher()\n        }\n        \n        var request = URLRequest(url: url)\n        request.httpMethod = \"POST\"\n        request.setValue(\"application/json\", forHTTPHeaderField: \"Content-Type\")\n        \n        let scoreData = [\"player\": player, \"score\": score] as [String: Any]\n        request.httpBody = try? JSONSerialization.data(withJSONObject: scoreData)\n        \n        return URLSession.shared.dataTaskPublisher(for: request)\n            .map { response in\n                return (response.response as? HTTPURLResponse)?.statusCode == 200\n            }\n            .mapError { $0 as Error }\n            .eraseToAnyPublisher()\n    }\n}\n\n// === ADVANCED PATTERNS ===\n// State Management\nclass GameState: ObservableObject {\n    @Published var players: [Player] = []\n    @Published var currentRound: Int = 1\n    @Published var gamePhase: GamePhase = .waiting\n    \n    enum GamePhase {\n        case waiting, active, paused, finished\n    }\n    \n    var gamePhasePublisher: AnyPublisher<String, Never> {\n        $gamePhase\n            .map { phase in\n                switch phase {\n                case .waiting: return \"Waiting for players...\"\n                case .active: return \"Game in progress\"\n                case .paused: return \"Game paused\"\n                case .finished: return \"Game finished\"\n                }\n            }\n            .eraseToAnyPublisher()\n    }\n}\n\n// Error Recovery Pattern\nclass RobustNetworkService {\n    func fetchWithRetry<T: Decodable>(url: URL, retries: Int = 3) -> AnyPublisher<T, Error> {\n        return URLSession.shared.dataTaskPublisher(for: url)\n            .map(\\.data)\n            .decode(type: T.self, decoder: JSONDecoder())\n            .retry(retries)\n            .catch { error in\n                // Fallback to cached data or default value\n                return self.loadCachedData()\n                    .setFailureType(to: Error.self)\n            }\n            .eraseToAnyPublisher()\n    }\n    \n    private func loadCachedData<T: Decodable>() -> AnyPublisher<T, Error> {\n        // Implementation for loading cached data\n        return Empty().eraseToAnyPublisher()\n    }\n}",
      "category": "Swift Concurrency",
      "estimatedTime": 360,
      "dependencies": ["variables", "optionals"],
      "challenge": {
        "instructions": "Build a complete game statistics system using Combine:\n\nPART 1: Basic Publishers & Subscribers (60 min)\n1. Create a Player class with @Published properties: health, score, level\n2. Create a GameManager that uses PassthroughSubject for game events\n3. Set up subscribers to react to score changes and game events\n\nPART 2: Operator Chains (90 min)\n4. Create a score multiplier system using combineLatest\n5. Implement a combo system that resets after 3 seconds of inactivity\n6. Filter game events to only show important notifications\n7. Use debounce for player name input validation\n\nPART 3: Error Handling & Networking (90 min)\n8. Create a LeaderboardService that uses URLSession.dataTaskPublisher\n9. Implement retry logic for network requests\n10. Handle offline mode with catch operators\n11. Create a fallback system for when network fails\n\nPART 4: Advanced Patterns (120 min)\n12. Implement a state machine for game phases using CurrentValueSubject\n13. Create a achievement system that triggers based on multiple conditions\n14. Build a statistics aggregator that combines multiple data streams\n15. Implement memory management with proper cancellable handling\n\nPART 5: Performance & Testing (60 min)\n16. Add unit tests for your Combine pipelines\n17. Implement proper backpressure handling\n18. Optimize operator chains for performance",
        "starterCode": "import Combine\n\n// === PART 1: Basic Publishers & Subscribers ===\n// Create your Player class and GameManager here\n\n\n// === PART 2: Operator Chains ===\n// Implement operator chains for game logic\n\n\n// === PART 3: Error Handling & Networking ===\n// Create network service with Combine\n\n\n// === PART 4: Advanced Patterns ===\n// Implement state management and advanced patterns\n\n\n// === PART 5: Performance & Testing ===\n// Add unit tests and optimizations\n\n",
        "solution": "import Combine\nimport Foundation\n\n// === PART 1: Basic Publishers & Subscribers ===\nclass Player {\n    @Published var health: Int = 100\n    @Published var score: Int = 0\n    @Published var level: Int = 1\n    @Published var name: String = \"\"\n}\n\nclass GameManager: ObservableObject {\n    @Published var players: [Player] = []\n    private var cancellables = Set<AnyCancellable>()\n    \n    let gameEvent = PassthroughSubject<GameEvent, Never>()\n    \n    enum GameEvent {\n        case playerJoined(Player)\n        case scoreChanged(Int, Player)\n        case levelUp(Player)\n        case gameOver\n    }\n    \n    init() {\n        setupSubscribers()\n    }\n    \n    private func setupSubscribers() {\n        // React to score changes\n        $players\n            .flatMap { players in\n                players.publisher\n                    .flatMap { player in\n                        player.$score.map { (player, $0) }\n                    }\n            }\n            .sink { [weak self] player, newScore in\n                self?.gameEvent.send(.scoreChanged(newScore, player))\n                \n                if newScore >= player.level * 1000 {\n                    player.level += 1\n                    self?.gameEvent.send(.levelUp(player))\n                }\n            }\n            .store(in: &cancellables)\n    }\n}\n\n// === PART 2: Operator Chains ===\nclass ComboSystem {\n    @Published var score: Int = 0\n    @Published var multiplier: Double = 1.0\n    private var cancellables = Set<AnyCancellable>()\n    \n    let actionPerformed = PassthroughSubject<Void, Never>()\n    \n    init() {\n        setupComboSystem()\n    }\n    \n    private func setupComboSystem() {\n        // Combo system: multiplier increases with rapid actions, resets after inactivity\n        actionPerformed\n            .map { _ in 1 }\n            .scan(0) { $0 + $1 }\n            .combineLatest(\n                actionPerformed\n                    .debounce(for: .seconds(3), scheduler: RunLoop.main)\n                    .map { _ in 0 }\n            )\n            .map { actionCount, _ in\n                return min(Double(actionCount) * 0.1 + 1.0, 3.0)\n            }\n            .assign(to: &$multiplier)\n        \n        // Apply multiplier to score\n        $multiplier\n            .sink { [weak self] multiplier in\n                print(\"Current multiplier: \" + String(multiplier) + \"x\")\n            }\n            .store(in: &cancellables)\n    }\n}\n\n// === PART 3: Error Handling & Networking ===\nclass RobustLeaderboardService {\n    private let baseURL = \"https://api.game.com\"\n    \n    func fetchLeaderboard() -> AnyPublisher<[LeaderboardEntry], Error> {\n        guard let url = URL(string: baseURL + \"/leaderboard\") else {\n            return Fail(error: URLError(.badURL))\n                .eraseToAnyPublisher()\n        }\n        \n        return URLSession.shared.dataTaskPublisher(for: url)\n            .tryMap { data, response in\n                guard let httpResponse = response as? HTTPURLResponse,\n                      httpResponse.statusCode == 200 else {\n                    throw URLError(.badServerResponse)\n                }\n                return data\n            }\n            .decode(type: [LeaderboardEntry].self, decoder: JSONDecoder())\n            .retry(2) // Retry twice on failure\n            .catch { error in\n                // Fallback to cached data\n                return self.loadCachedLeaderboard()\n                    .setFailureType(to: Error.self)\n            }\n            .eraseToAnyPublisher()\n    }\n    \n    private func loadCachedLeaderboard() -> AnyPublisher<[LeaderboardEntry], Never> {\n        // Simulate loading from cache\n        return Just([])\n            .eraseToAnyPublisher()\n    }\n}\n\nstruct LeaderboardEntry: Codable {\n    let playerName: String\n    let score: Int\n    let rank: Int\n}\n\n// === PART 4: Advanced Patterns ===\nclass GameStateMachine {\n    enum State {\n        case idle, playing, paused, gameOver\n    }\n    \n    let currentState = CurrentValueSubject<State, Never>(.idle)\n    private var cancellables = Set<AnyCancellable>()\n    \n    let playerHealth = PassthroughSubject<Int, Never>()\n    let gameEvents = PassthroughSubject<String, Never>()\n    \n    init() {\n        setupStateTransitions()\n    }\n    \n    private func setupStateTransitions() {\n        // Transition to playing when health > 0\n        playerHealth\n            .combineLatest(currentState)\n            .filter { $0.1 == .idle && $0.0 > 0 }\n            .map { _ in State.playing }\n            .subscribe(currentState)\n            .store(in: &cancellables)\n        \n        // Game over when health reaches 0\n        playerHealth\n            .filter { $0 <= 0 }\n            .map { _ in State.gameOver }\n            .subscribe(currentState)\n            .store(in: &cancellables)\n        \n        // Log state changes\n        currentState\n            .sink { state in\n                print(\"Game state changed to: \" + String(describing: state))\n            }\n            .store(in: &cancellables)\n    }\n}\n\n// === PART 5: Performance & Testing ===\nclass OptimizedGameSystem {\n    @Published var entities: [GameEntity] = []\n    private var cancellables = Set<AnyCancellable>()\n    \n    init() {\n        setupOptimizedProcessing()\n    }\n    \n    private func setupOptimizedProcessing() {\n        // Process entities with backpressure handling\n        $entities\n            .flatMap(maxPublishers: .max(1)) { entities in\n                // Limit concurrent processing\n                entities.publisher\n            }\n            .buffer(size: 50, prefetch: .keepFull, whenFull: .dropOldest)\n            .sink { entity in\n                // Process entity\n                self.processEntity(entity)\n            }\n            .store(in: &cancellables)\n    }\n    \n    private func processEntity(_ entity: GameEntity) {\n        // Entity processing logic\n    }\n}\n\nstruct GameEntity {\n    let id: UUID\n    let type: String\n    let position: (x: Double, y: Double)\n}",
        "hints": [
          "PART 1: Use @Published for properties that change, PassthroughSubject for events",
          "PART 2: Use combineLatest to combine multiple publishers, debounce for timing-based logic",
          "PART 3: Use retry() for network requests, catch() for error recovery",
          "PART 4: CurrentValueSubject is great for state management, combine multiple conditions",
          "PART 5: Use flatMap with maxPublishers to control backpressure",
          "Remember to store cancellables to prevent memory leaks",
          "Use .eraseToAnyPublisher() to hide implementation details",
          "For testing, use test schedulers like ImmediateScheduler"
        ],
        "testCases": [
          {
            "input": "currentState.value == .playing",
            "expectedOutput": "true",
            "description": "Game should be in playing state when health > 0"
          },
          {
            "input": "multiplier >= 1.0 && multiplier <= 3.0",
            "expectedOutput": "true",
            "description": "Multiplier should stay within reasonable bounds"
          },
          {
            "input": "cancellables.isEmpty == false",
            "expectedOutput": "true",
            "description": "Should have active subscriptions"
          }
        ]
      }
    },
    {
      "id": "dependency_management",
      "title": "Dependency Management & Environment Objects",
      "description": "Master SwiftUI's dependency injection system for clean, testable, and maintainable code architecture",
      "difficulty": "intermediate",
      "theory": "# Dependency Management & Environment Objects\n\n## 1. Understanding Dependency Injection (45 min)\n\n### What is Dependency Injection?\nDependency Injection (DI) is a design pattern where objects receive their dependencies from external sources rather than creating them internally.\n\n**Without DI (Tight Coupling):**\n```swift\nclass UserService {\n    private let apiClient = APIClient()  // Creates dependency internally\n    func fetchUser() { /* uses apiClient */ }\n}\n```\n\n**With DI (Loose Coupling):**\n```swift\nclass UserService {\n    private let apiClient: APIClient\n    \n    init(apiClient: APIClient) {  // Dependency injected\n        self.apiClient = apiClient\n    }\n    \n    func fetchUser() { /* uses apiClient */ }\n}\n```\n\n### Benefits of Dependency Injection:\n- **Testability**: Easily mock dependencies for testing\n- **Flexibility**: Swap implementations without changing dependent code\n- **Maintainability**: Clear dependencies make code easier to understand\n- **Reusability**: Components can be used in different contexts\n\n## 2. SwiftUI's Dependency Injection System (60 min)\n\n### @EnvironmentObject\nGlobal shared state that's automatically available to all views in the hierarchy:\n\n```swift\nclass AppState: ObservableObject {\n    @Published var isLoggedIn = false\n    @Published var currentUser: User?\n    @Published var theme: Theme = .light\n}\n\nstruct ContentView: View {\n    @EnvironmentObject var appState: AppState\n    \n    var body: some View {\n        if appState.isLoggedIn {\n            MainView()\n        } else {\n            LoginView()\n        }\n    }\n}\n\n// Provide at root level\nContentView().environmentObject(AppState())\n```\n\n### @Environment\nAccess system-wide values and custom environment values:\n\n```swift\n// Using built-in environment values\nstruct MyView: View {\n    @Environment(\\.colorScheme) var colorScheme\n    @Environment(\\.sizeCategory) var sizeCategory\n    \n    var body: some View {\n        Text(\"Hello\")\n            .foregroundColor(colorScheme == .dark ? .white : .black)\n    }\n}\n\n// Custom environment values\nstruct ThemeKey: EnvironmentKey {\n    static let defaultValue: Theme = .light\n}\n\nextension EnvironmentValues {\n    var customTheme: Theme {\n        get { self[ThemeKey.self] }\n        set { self[ThemeKey.self] = newValue }\n    }\n}\n```\n\n## 3. Advanced Environment Object Patterns (75 min)\n\n### Multiple Environment Objects\n```swift\nclass UserManager: ObservableObject {\n    @Published var currentUser: User?\n    @Published var users: [User] = []\n}\n\nclass SettingsManager: ObservableObject {\n    @Published var theme: Theme = .light\n    @Published var notificationsEnabled = true\n}\n\nclass AnalyticsManager: ObservableObject {\n    func trackEvent(_ event: String) { /* analytics */ }\n}\n\nstruct RootView: View {\n    var body: some View {\n        ContentView()\n            .environmentObject(UserManager())\n            .environmentObject(SettingsManager())\n            .environmentObject(AnalyticsManager())\n    }\n}\n\nstruct ProfileView: View {\n    @EnvironmentObject var userManager: UserManager\n    @EnvironmentObject var settings: SettingsManager\n    @EnvironmentObject var analytics: AnalyticsManager\n    \n    var body: some View {\n        VStack {\n            Text(userManager.currentUser?.name ?? \"Guest\")\n            Toggle(\"Dark Mode\", isOn: $settings.theme.isDark)\n        }\n        .onAppear {\n            analytics.trackEvent(\"profile_viewed\")\n        }\n    }\n}\n```\n\n### Environment Object Lifecycle Management\n```swift\nclass SessionManager: ObservableObject {\n    @Published var isAuthenticated = false\n    private var timer: Timer?\n    \n    func startSession() {\n        timer = Timer.scheduledTimer(withTimeInterval: 3600, repeats: true) { _ in\n            self.checkSessionValidity()\n        }\n    }\n    \n    func logout() {\n        timer?.invalidate()\n        isAuthenticated = false\n    }\n    \n    deinit {\n        timer?.invalidate()\n    }\n}\n```\n\n## 4. Dependency Injection Containers (60 min)\n\n### Service Container Pattern\n```swift\nprotocol ServiceContainer {\n    var userService: UserService { get }\n    var apiService: APIService { get }\n    var cacheService: CacheService { get }\n}\n\nclass AppContainer: ServiceContainer, ObservableObject {\n    let userService: UserService\n    let apiService: APIService\n    let cacheService: CacheService\n    \n    init() {\n        self.cacheService = CacheService()\n        self.apiService = APIService(cache: cacheService)\n        self.userService = UserService(api: apiService)\n    }\n}\n\n// Usage\nstruct ContentView: View {\n    @EnvironmentObject var container: AppContainer\n    \n    var body: some View {\n        UserProfileView()\n            .environmentObject(container.userService)\n    }\n}\n```\n\n### Factory Pattern for Dependency Creation\n```swift\nprotocol ServiceFactory {\n    func makeUserService() -> UserService\n    func makeAPIService() -> APIService\n}\n\nclass ProductionFactory: ServiceFactory {\n    func makeUserService() -> UserService {\n        return UserService(api: makeAPIService())\n    }\n    \n    func makeAPIService() -> APIService {\n        return ProductionAPIService()\n    }\n}\n\nclass MockFactory: ServiceFactory {\n    func makeUserService() -> UserService {\n        return MockUserService()\n    }\n    \n    func makeAPIService() -> APIService {\n        return MockAPIService()\n    }\n}\n```\n\n## 5. Testing with Dependency Injection (45 min)\n\n### Mocking Dependencies for Tests\n```swift\nclass MockUserService: UserService {\n    var mockUsers: [User] = []\n    var shouldFail = false\n    \n    override func fetchUsers() async throws -> [User] {\n        if shouldFail {\n            throw NetworkError.connectionFailed\n        }\n        return mockUsers\n    }\n}\n\nclass UserViewModelTests: XCTestCase {\n    func testUserLoading() async {\n        // Arrange\n        let mockService = MockUserService()\n        mockService.mockUsers = [User(name: \"Test User\")]\n        let viewModel = UserViewModel(userService: mockService)\n        \n        // Act\n        await viewModel.loadUsers()\n        \n        // Assert\n        XCTAssertEqual(viewModel.users.count, 1)\n        XCTAssertEqual(viewModel.users.first?.name, \"Test User\")\n    }\n}\n```\n\n### Testing Views with Environment Objects\n```swift\nstruct ContentView_Previews: PreviewProvider {\n    static var previews: some View {\n        ContentView()\n            .environmentObject(createMockAppState())\n    }\n    \n    static func createMockAppState() -> AppState {\n        let state = AppState()\n        state.isLoggedIn = true\n        state.currentUser = User(name: \"Preview User\")\n        return state\n    }\n}\n```\n\n## 6. Best Practices & Architecture (45 min)\n\n### Dependency Injection Guidelines\n- **Inject dependencies at the highest appropriate level**\n- **Use protocols for dependencies to enable testing**\n- **Avoid singleton patterns when DI is possible**\n- **Keep dependency graphs shallow and manageable**\n\n### When to Use Each Pattern:\n- **@EnvironmentObject**: Global app state shared across many views\n- **@Environment**: System settings or theme data\n- **Initializer Injection**: For view models and services\n- **Method Injection**: For one-off dependencies\n\n### Common Anti-patterns to Avoid:\n```swift\n// âŒ DON'T: Hidden dependencies\nclass UserService {\n    private let api = APIClient.shared  // Hidden singleton\n}\n\n// âœ… DO: Explicit dependencies\nclass UserService {\n    private let api: APIClient\n    init(api: APIClient) {\n        self.api = api\n    }\n}\n```\n\n## 7. Real-World Application Architecture (30 min)\n\n### Modular App Structure\n```swift\n// Domain Layer\nprotocol UserRepository {\n    func getUser() async throws -> User\n}\n\n// Data Layer\nclass NetworkUserRepository: UserRepository {\n    private let apiService: APIService\n    init(apiService: APIService) {\n        self.apiService = apiService\n    }\n    \n    func getUser() async throws -> User {\n        // Implementation\n    }\n}\n\n// Presentation Layer\nclass UserViewModel: ObservableObject {\n    @Published var user: User?\n    private let userRepository: UserRepository\n    \n    init(userRepository: UserRepository) {\n        self.userRepository = userRepository\n    }\n    \n    @MainActor\n    func loadUser() async {\n        do {\n            user = try await userRepository.getUser()\n        } catch {\n            // Handle error\n        }\n    }\n}\n```",
      "codeExample": "// === COMPREHENSIVE DEPENDENCY MANAGEMENT EXAMPLE ===\n\nimport SwiftUI\n\n// MARK: - Models\nstruct User: Identifiable {\n    let id = UUID()\n    let name: String\n    let email: String\n}\n\nenum Theme {\n    case light, dark\n    \n    var isDark: Bool {\n        get { self == .dark }\n        set { self = newValue ? .dark : .light }\n    }\n    \n    var backgroundColor: Color {\n        self == .dark ? .black : .white\n    }\n    \n    var textColor: Color {\n        self == .dark ? .white : .black\n    }\n}\n\n// MARK: - Services & Protocols\nprotocol UserServiceProtocol {\n    func fetchCurrentUser() async throws -> User\n    func updateUser(_ user: User) async throws\n}\n\nprotocol AnalyticsProtocol {\n    func trackEvent(_ name: String, parameters: [String: Any]?)\n}\n\nclass ProductionUserService: UserServiceProtocol {\n    func fetchCurrentUser() async throws -> User {\n        // Simulate network call\n        try await Task.sleep(nanoseconds: 1_000_000_000)\n        return User(name: \"John Appleseed\", email: \"john@example.com\")\n    }\n    \n    func updateUser(_ user: User) async throws {\n        // Simulate update\n        try await Task.sleep(nanoseconds: 500_000_000)\n    }\n}\n\nclass ProductionAnalytics: AnalyticsProtocol {\n    func trackEvent(_ name: String, parameters: [String: Any]?) {\n        print(\"ðŸ“Š Analytics: \\(name) - \\(parameters ?? [:])\")\n    }\n}\n\n// MARK: - Environment Objects\nclass AppState: ObservableObject {\n    @Published var currentUser: User?\n    @Published var isLoggedIn = false\n    @Published var isLoading = false\n}\n\nclass ThemeManager: ObservableObject {\n    @Published var currentTheme: Theme = .light\n    \n    func toggleTheme() {\n        currentTheme = currentTheme == .light ? .dark : .light\n    }\n}\n\n// MARK: - Dependency Container\nclass AppContainer: ObservableObject {\n    let userService: UserServiceProtocol\n    let analytics: AnalyticsProtocol\n    let appState: AppState\n    let themeManager: ThemeManager\n    \n    init(\n        userService: UserServiceProtocol = ProductionUserService(),\n        analytics: AnalyticsProtocol = ProductionAnalytics()\n    ) {\n        self.userService = userService\n        self.analytics = analytics\n        self.appState = AppState()\n        self.themeManager = ThemeManager()\n    }\n}\n\n// MARK: - View Models\nclass UserProfileViewModel: ObservableObject {\n    @Published var user: User?\n    @Published var isUpdating = false\n    \n    private let userService: UserServiceProtocol\n    private let analytics: AnalyticsProtocol\n    \n    init(userService: UserServiceProtocol, analytics: AnalyticsProtocol) {\n        self.userService = userService\n        self.analytics = analytics\n    }\n    \n    @MainActor\n    func loadUser() async {\n        analytics.trackEvent(\"user_profile_load\", parameters: nil)\n        \n        do {\n            user = try await userService.fetchCurrentUser()\n            analytics.trackEvent(\"user_profile_loaded\", parameters: [\"success\": true])\n        } catch {\n            analytics.trackEvent(\"user_profile_loaded\", parameters: [\"success\": false, \"error\": error.localizedDescription])\n        }\n    }\n    \n    @MainActor\n    func updateUser(name: String) async {\n        isUpdating = true\n        analytics.trackEvent(\"user_profile_update\", parameters: [\"new_name\": name])\n        \n        guard var currentUser = user else { return }\n        \n        do {\n            currentUser = User(name: name, email: currentUser.email)\n            try await userService.updateUser(currentUser)\n            self.user = currentUser\n            analytics.trackEvent(\"user_profile_updated\", parameters: [\"success\": true])\n        } catch {\n            analytics.trackEvent(\"user_profile_updated\", parameters: [\"success\": false])\n        }\n        \n        isUpdating = false\n    }\n}\n\n// MARK: - Custom Environment Keys\nstruct UserServiceKey: EnvironmentKey {\n    static let defaultValue: UserServiceProtocol = ProductionUserService()\n}\n\nextension EnvironmentValues {\n    var userService: UserServiceProtocol {\n        get { self[UserServiceKey.self] }\n        set { self[UserServiceKey.self] = newValue }\n    }\n}\n\n// MARK: - Views\nstruct RootView: View {\n    @StateObject private var container = AppContainer()\n    \n    var body: some View {\n        ContentView()\n            .environmentObject(container.appState)\n            .environmentObject(container.themeManager)\n            .environment(\\.userService, container.userService)\n            .onAppear {\n                container.analytics.trackEvent(\"app_launched\", parameters: nil)\n            }\n    }\n}\n\nstruct ContentView: View {\n    @EnvironmentObject var appState: AppState\n    @EnvironmentObject var themeManager: ThemeManager\n    \n    var body: some View {\n        NavigationView {\n            VStack {\n                if appState.isLoggedIn {\n                    MainAppView()\n                } else {\n                    LoginView()\n                }\n            }\n            .background(themeManager.currentTheme.backgroundColor)\n            .foregroundColor(themeManager.currentTheme.textColor)\n        }\n    }\n}\n\nstruct UserProfileView: View {\n    @StateObject private var viewModel: UserProfileViewModel\n    @EnvironmentObject var themeManager: ThemeManager\n    \n    init(userService: UserServiceProtocol, analytics: AnalyticsProtocol) {\n        _viewModel = StateObject(wrappedValue: UserProfileViewModel(\n            userService: userService,\n            analytics: analytics\n        ))\n    }\n    \n    var body: some View {\n        VStack {\n            if let user = viewModel.user {\n                Text(\"Welcome, \\(user.name)!\")\n                Text(user.email)\n                    .foregroundColor(.gray)\n                \n                Button(\"Update Name\") {\n                    Task {\n                        await viewModel.updateUser(name: \"Updated Name\")\n                    }\n                }\n                .disabled(viewModel.isUpdating)\n            } else {\n                ProgressView(\"Loading user...\")\n            }\n        }\n        .task {\n            await viewModel.loadUser()\n        }\n    }\n}",
      "category": "SwiftUI Architecture",
      "estimatedTime": 240,
      "dependencies": ["variables", "optionals"],
      "challenge": {
        "instructions": "Build a complete Task Management app using proper dependency management patterns:\n\nPART 1: Service Layer Setup (60 min)\n1. Create a TaskService protocol with methods: fetchTasks(), addTask(_:), updateTask(_:), deleteTask(_:)\n2. Implement ProductionTaskService with mock data storage\n3. Create AnalyticsService protocol and implementation\n4. Build a NotificationService for handling app notifications\n\nPART 2: Environment Objects & State Management (60 min)\n5. Create TaskManager as ObservableObject with @Published properties for tasks, selectedTask, isLoading\n6. Create AppSettings with theme, sort preferences, and notification settings\n7. Set up proper dependency injection for all services\n\nPART 3: Dependency Container (45 min)\n8. Build AppContainer that initializes and manages all dependencies\n9. Implement proper lifecycle management for services\n10. Create a MockContainer for testing/previews\n\nPART 4: View Models with DI (45 min)\n11. Create TaskListViewModel that depends on TaskService and AnalyticsService\n12. Implement TaskDetailViewModel with proper dependency injection\n13. Add error handling and loading states\n\nPART 5: Testing & Architecture (30 min)\n14. Write unit tests for TaskListViewModel using mocked dependencies\n15. Create previews with different environment configurations\n16. Implement proper error propagation and user feedback",
        "starterCode": "// === PART 1: Service Layer ===\n// Define protocols and implementations here\n\n\n// === PART 2: Environment Objects ===\n// Create ObservableObject classes here\n\n\n// === PART 3: Dependency Container ===\n// Build your AppContainer here\n\n\n// === PART 4: View Models ===\n// Implement view models with proper DI\n\n\n// === PART 5: Testing Setup ===\n// Add testing utilities and previews\n\n",
        "solution": "// === PART 1: Service Layer ===\nprotocol TaskServiceProtocol {\n    func fetchTasks() async throws -> [Task]\n    func addTask(_ task: Task) async throws\n    func updateTask(_ task: Task) async throws\n    func deleteTask(_ task: Task) async throws\n}\n\nclass ProductionTaskService: TaskServiceProtocol {\n    private var tasks: [Task] = []\n    \n    func fetchTasks() async throws -> [Task] {\n        try await Task.sleep(nanoseconds: 500_000_000) // Simulate network\n        return tasks\n    }\n    \n    func addTask(_ task: Task) async throws {\n        try await Task.sleep(nanoseconds: 300_000_000)\n        tasks.append(task)\n    }\n    \n    func updateTask(_ task: Task) async throws {\n        try await Task.sleep(nanoseconds: 300_000_000)\n        if let index = tasks.firstIndex(where: { $0.id == task.id }) {\n            tasks[index] = task\n        }\n    }\n    \n    func deleteTask(_ task: Task) async throws {\n        try await Task.sleep(nanoseconds: 200_000_000)\n        tasks.removeAll { $0.id == task.id }\n    }\n}\n\nprotocol AnalyticsProtocol {\n    func trackEvent(_ name: String, parameters: [String: Any]?)\n}\n\nclass ProductionAnalytics: AnalyticsProtocol {\n    func trackEvent(_ name: String, parameters: [String: Any]?) {\n        print(\"ðŸ“Š \\(name): \\(parameters ?? [:])\")\n    }\n}\n\n// === PART 2: Environment Objects ===\nclass TaskManager: ObservableObject {\n    @Published var tasks: [Task] = []\n    @Published var selectedTask: Task?\n    @Published var isLoading = false\n    @Published var error: String?\n}\n\nclass AppSettings: ObservableObject {\n    @Published var theme: Theme = .light\n    @Published var sortBy: SortOption = .date\n    @Published var notificationsEnabled = true\n}\n\n// === PART 3: Dependency Container ===\nclass AppContainer: ObservableObject {\n    let taskService: TaskServiceProtocol\n    let analytics: AnalyticsProtocol\n    let taskManager: TaskManager\n    let appSettings: AppSettings\n    \n    init(\n        taskService: TaskServiceProtocol = ProductionTaskService(),\n        analytics: AnalyticsProtocol = ProductionAnalytics()\n    ) {\n        self.taskService = taskService\n        self.analytics = analytics\n        self.taskManager = TaskManager()\n        self.appSettings = AppSettings()\n    }\n}\n\nclass MockContainer: AppContainer {\n    init() {\n        super.init(\n            taskService: MockTaskService(),\n            analytics: MockAnalytics()\n        )\n    }\n}\n\n// === PART 4: View Models ===\nclass TaskListViewModel: ObservableObject {\n    @Published var tasks: [Task] = []\n    @Published var isLoading = false\n    @Published var error: String?\n    \n    private let taskService: TaskServiceProtocol\n    private let analytics: AnalyticsProtocol\n    \n    init(taskService: TaskServiceProtocol, analytics: AnalyticsProtocol) {\n        self.taskService = taskService\n        self.analytics = analytics\n    }\n    \n    @MainActor\n    func loadTasks() async {\n        isLoading = true\n        error = nil\n        analytics.trackEvent(\"tasks_loading\", parameters: nil)\n        \n        do {\n            tasks = try await taskService.fetchTasks()\n            analytics.trackEvent(\"tasks_loaded\", parameters: [\"count\": tasks.count])\n        } catch {\n            self.error = error.localizedDescription\n            analytics.trackEvent(\"tasks_load_failed\", parameters: [\"error\": error.localizedDescription])\n        }\n        \n        isLoading = false\n    }\n    \n    @MainActor\n    func addTask(_ task: Task) async {\n        analytics.trackEvent(\"task_adding\", parameters: [\"title\": task.title])\n        \n        do {\n            try await taskService.addTask(task)\n            await loadTasks() // Reload to get updated list\n            analytics.trackEvent(\"task_added\", parameters: [\"success\": true])\n        } catch {\n            analytics.trackEvent(\"task_added\", parameters: [\"success\": false])\n        }\n    }\n}\n\n// === PART 5: Testing Setup ===\nclass MockTaskService: TaskServiceProtocol {\n    var mockTasks: [Task] = [\n        Task(title: \"Test Task 1\", isCompleted: false),\n        Task(title: \"Test Task 2\", isCompleted: true)\n    ]\n    \n    func fetchTasks() async throws -> [Task] {\n        return mockTasks\n    }\n    \n    func addTask(_ task: Task) async throws {\n        mockTasks.append(task)\n    }\n    \n    func updateTask(_ task: Task) async throws {\n        if let index = mockTasks.firstIndex(where: { $0.id == task.id }) {\n            mockTasks[index] = task\n        }\n    }\n    \n    func deleteTask(_ task: Task) async throws {\n        mockTasks.removeAll { $0.id == task.id }\n    }\n}\n\nclass MockAnalytics: AnalyticsProtocol {\n    var trackedEvents: [(String, [String: Any]?)] = []\n    \n    func trackEvent(_ name: String, parameters: [String: Any]?) {\n        trackedEvents.append((name, parameters))\n    }\n}",
        "hints": [
          "PART 1: Define protocols first, then implement concrete services. Use async/await for service methods",
          "PART 2: Use @Published properties in ObservableObject classes for reactive updates",
          "PART 3: The container should initialize all dependencies and manage their lifecycle",
          "PART 4: View models should take dependencies as parameters in their initializers",
          "PART 5: Mock services should implement the same protocols as production services",
          "Use @MainActor for view model methods that update @Published properties",
          "Remember to track analytics events for important user actions",
          "Implement proper error handling in view models with user-friendly messages"
        ],
        "testCases": [
          {
            "input": "taskService is TaskServiceProtocol",
            "expectedOutput": "true",
            "description": "Task service should conform to the protocol"
          },
          {
            "input": "viewModel.tasks.count >= 0",
            "expectedOutput": "true",
            "description": "ViewModel should handle empty task lists"
          },
          {
            "input": "container.taskManager !== container.appSettings",
            "expectedOutput": "true",
            "description": "Different environment objects should be separate instances"
          }
        ]
      }
    },
    {
      "id": "testing",
      "title": "Testing",
      "description": "Master iOS testing with Unit Tests, UI Tests, and Test-Driven Development",
      "difficulty": "intermediate",
      "theory": "# Testing in iOS - Building Reliable Apps\n\n## 1. Introduction to Testing (45 min)\n\n### Why Testing Matters\n- **Bug Prevention**: Catch issues before they reach users\n- **Refactoring Confidence**: Safely improve code without breaking functionality\n- **Documentation**: Tests serve as living documentation\n- **Design Improvement**: Testable code is better designed code\n\n### Testing Pyramid\n```swift\n// Testing Pyramid Structure\n// ðŸ”ï¸ Few UI Tests (Slow, expensive)\n// ðŸ  More Integration Tests  \n// ðŸ—ï¸ Many Unit Tests (Fast, cheap)\n```\n\n### XCTest Framework\nXCTest is Apple's testing framework built into Xcode:\n- **XCTestCase**: Base class for test cases\n- **XCTAssert**: Assertion functions\n- **XCTestExpectation**: For asynchronous testing\n\n## 2. Unit Testing Fundamentals (90 min)\n\n### Setting Up Test Targets\n```swift\n// Test target configuration\n// - Separate bundle from main app\n// - Access to @testable imports\n// - Isolated test environment\n```\n\n### Writing Your First Unit Test\n```swift\nimport XCTest\n@testable import YourApp\n\nclass CalculatorTests: XCTestCase {\n    var calculator: Calculator!\n    \n    // Setup before each test\n    override func setUp() {\n        super.setUp()\n        calculator = Calculator()\n    }\n    \n    // Cleanup after each test\n    override func tearDown() {\n        calculator = nil\n        super.tearDown()\n    }\n}\n```\n\n### Common Assertions\n```swift\n// Equality assertions\nXCTAssertEqual(actual, expected)\nXCTAssertNotEqual(actual, expected)\n\n// Boolean assertions\nXCTAssertTrue(condition)\nXCTAssertFalse(condition)\n\n// Nil assertions\nXCTAssertNil(optionalValue)\nXCTAssertNotNil(optionalValue)\n\n// Error assertions\nXCTAssertThrowsError(try functionThatThrows())\nXCTAssertNoThrow(try functionThatDoesntThrow())\n```\n\n## 3. Advanced Unit Testing (90 min)\n\n### Testing Asynchronous Code\n```swift\nfunc testAsyncOperation() {\n    // Create expectation\n    let expectation = XCTestExpectation(description: \"Async operation completes\")\n    \n    // Perform async work\n    someAsyncFunction { result in\n        // Validate result\n        XCTAssertTrue(result.success)\n        \n        // Fulfill expectation\n        expectation.fulfill()\n    }\n    \n    // Wait for expectation\n    wait(for: [expectation], timeout: 5.0)\n}\n```\n\n### Mocking and Dependency Injection\n```swift\n// Protocol for dependency\nprotocol NetworkService {\n    func fetchData(completion: @escaping (Result<Data, Error>) -> Void)\n}\n\n// Mock implementation\nclass MockNetworkService: NetworkService {\n    var shouldSucceed = true\n    \n    func fetchData(completion: @escaping (Result<Data, Error>) -> Void) {\n        if shouldSucceed {\n            completion(.success(Data()))\n        } else {\n            completion(.failure(NetworkError.unknown))\n        }\n    }\n}\n\n// Using dependency injection\nclass DataManager {\n    let networkService: NetworkService\n    \n    init(networkService: NetworkService) {\n        self.networkService = networkService\n    }\n}\n```\n\n### Testing ViewModels with Combine\n```swift\nimport Combine\n\nclass UserViewModelTests: XCTestCase {\n    var viewModel: UserViewModel!\n    var cancellables: Set<AnyCancellable>!\n    \n    override func setUp() {\n        super.setUp()\n        cancellables = []\n        viewModel = UserViewModel(service: MockUserService())\n    }\n    \n    func testUserLoading() {\n        // Expectation for Combine pipeline\n        let expectation = XCTestExpectation(description: \"User loads successfully\")\n        \n        // Subscribe to published property\n        viewModel.$user\n            .dropFirst() // Skip initial value\n            .sink { user in\n                XCTAssertNotNil(user)\n                expectation.fulfill()\n            }\n            .store(in: &cancellables)\n        \n        // Trigger action\n        viewModel.loadUser()\n        \n        wait(for: [expectation], timeout: 2.0)\n    }\n}\n```\n\n## 4. UI Testing (75 min)\n\n### UI Test Fundamentals\n```swift\nimport XCTest\n\nclass AppUITests: XCTestCase {\n    var app: XCUIApplication!\n    \n    override func setUp() {\n        super.setUp()\n        continueAfterFailure = false\n        app = XCUIApplication()\n        app.launch()\n    }\n    \n    func testLoginFlow() {\n        // Find UI elements\n        let emailTextField = app.textFields[\"email\"]\n        let passwordTextField = app.secureTextFields[\"password\"]\n        let loginButton = app.buttons[\"login\"]\n        \n        // Interact with elements\n        emailTextField.tap()\n        emailTextField.typeText(\"test@example.com\")\n        \n        passwordTextField.tap()\n        passwordTextField.typeText(\"password123\")\n        \n        loginButton.tap()\n        \n        // Verify result\n        let welcomeText = app.staticTexts[\"Welcome\"]\n        XCTAssertTrue(welcomeText.waitForExistence(timeout: 5))\n    }\n}\n```\n\n### UI Element Queries\n```swift\n// Different ways to find elements\nlet buttons = app.buttons\nlet specificButton = app.buttons[\"login\"]\nlet buttonByIndex = app.buttons.element(boundBy: 0)\n\n// Using predicates\nlet disabledButton = app.buttons.containing(NSPredicate(format: \"enabled == false\")).firstMatch\n\n// Waiting for elements\nlet element = app.staticTexts[\"Success\"]\nXCTAssertTrue(element.waitForExistence(timeout: 10))\n```\n\n### UI Test Best Practices\n- Use accessibility identifiers for reliable element targeting\n- Keep tests independent and isolated\n- Use setup/teardown properly\n- Handle system alerts and permissions\n\n## 5. Test-Driven Development (TDD) (60 min)\n\n### Red-Green-Refactor Cycle\n```swift\n// 1. RED: Write a failing test\nfunc testEmptyStringReturnsZero() {\n    let result = StringCalculator.add(\"\")\n    XCTAssertEqual(result, 0)\n}\n\n// 2. GREEN: Write minimal code to pass\nclass StringCalculator {\n    static func add(_ numbers: String) -> Int {\n        return 0\n    }\n}\n\n// 3. REFACTOR: Improve code while tests pass\nclass StringCalculator {\n    static func add(_ numbers: String) -> Int {\n        guard !numbers.isEmpty else { return 0 }\n        // Add more implementation...\n        return 0\n    }\n}\n```\n\n### TDD Benefits\n- **Better Design**: Forces thinking about API design first\n- **Comprehensive Coverage**: Tests drive implementation\n- **Confidence**: Safe refactoring with test safety net\n- **Documentation**: Tests describe expected behavior\n\n## 6. Advanced Testing Patterns (60 min)\n\n### Performance Testing\n```swift\nfunc testPerformanceExample() {\n    measure {\n        // Code to measure performance of\n        heavyCalculation()\n    }\n}\n\n// Metrics\nfunc testMemoryUsage() {\n    measure(metrics: [XCTMemoryMetric()]) {\n        allocateLargeObjects()\n    }\n}\n```\n\n### Snapshot Testing\n```swift\n// Using iOSSnapshotTestCase framework\nfunc testViewControllerAppearance() {\n    let vc = MyViewController()\n    \n    // Record mode (first time)\n    // FBSnapshotVerifyViewController(vc)\n    \n    // Test mode\n    FBSnapshotVerifyViewController(vc)\n}\n```\n\n### Test Organization\n```swift\n// Group related tests\nclass NetworkTests: XCTestCase {\n    func testSuccessfulRequest() { /* ... */ }\n    func testFailedRequest() { /* ... */ }\n    func testTimeoutHandling() { /* ... */ }\n}\n\n// Use descriptive test names\nfunc testUserLogin_withValidCredentials_shouldSucceed()\nfunc testUserLogin_withInvalidCredentials_shouldShowError()\nfunc testUserLogin_whenNetworkOffline_shouldShowOfflineMessage()\n```\n\n## 7. Testing in CI/CD (30 min)\n\n### Fastlane Integration\n```ruby\n# Fastfile\nlane :test do\n  run_tests(\n    scheme: \"MyApp\",\n    devices: [\"iPhone 15\"],\n    code_coverage: true\n  )\nend\n```\n\n### Code Coverage\n- Enable in test scheme settings\n- Aim for 70-80% coverage\n- Focus on critical business logic\n- Don't obsess over 100% coverage\n\n## Practice Exercises\n\nComplete all testing scenarios to master iOS testing!",
      "codeExample": "// === UNIT TESTING EXAMPLES ===\n\n// Calculator to test\nclass Calculator {\n    func add(_ a: Int, _ b: Int) -> Int {\n        return a + b\n    }\n    \n    func divide(_ a: Int, by b: Int) throws -> Int {\n        guard b != 0 else {\n            throw CalculatorError.divisionByZero\n        }\n        return a / b\n    }\n    \n    func factorial(_ n: Int) -> Int {\n        guard n >= 0 else { return 0 }\n        return n == 0 ? 1 : n * factorial(n - 1)\n    }\n}\n\nenum CalculatorError: Error {\n    case divisionByZero\n}\n\n// === ASYNC SERVICE EXAMPLE ===\n\nprotocol DataService {\n    func fetchUser(id: Int, completion: @escaping (Result<User, Error>) -> Void)\n}\n\nclass UserService: DataService {\n    func fetchUser(id: Int, completion: @escaping (Result<User, Error>) -> Void) {\n        // Simulate network request\n        DispatchQueue.global().asyncAfter(deadline: .now() + 1.0) {\n            let user = User(id: id, name: \"John Doe\", email: \"john@example.com\")\n            completion(.success(user))\n        }\n    }\n}\n\nstruct User {\n    let id: Int\n    let name: String\n    let email: String\n}\n\n// === VIEWMODEL WITH COMBINE ===\n\nimport Combine\n\nclass UserViewModel: ObservableObject {\n    @Published var user: User?\n    @Published var isLoading = false\n    @Published var error: String?\n    \n    private let service: DataService\n    private var cancellables = Set<AnyCancellable>()\n    \n    init(service: DataService) {\n        self.service = service\n    }\n    \n    func loadUser(id: Int) {\n        isLoading = true\n        error = nil\n        \n        service.fetchUser(id: id) { [weak self] result in\n            DispatchQueue.main.async {\n                self?.isLoading = false\n                switch result {\n                case .success(let user):\n                    self?.user = user\n                case .failure(let error):\n                    self?.error = error.localizedDescription\n                }\n            }\n        }\n    }\n}\n\n// === UI TESTABLE VIEW ===\n\nimport SwiftUI\n\nstruct LoginView: View {\n    @State private var email = \"\"\n    @State private var password = \"\"\n    @State private var isLoggedIn = false\n    \n    var body: some View {\n        VStack {\n            if isLoggedIn {\n                Text(\"Welcome!\")\n                    .accessibilityIdentifier(\"welcomeText\")\n            } else {\n                TextField(\"Email\", text: $email)\n                    .textFieldStyle(RoundedBorderTextFieldStyle())\n                    .accessibilityIdentifier(\"emailField\")\n                \n                SecureField(\"Password\", text: $password)\n                    .textFieldStyle(RoundedBorderTextFieldStyle())\n                    .accessibilityIdentifier(\"passwordField\")\n                \n                Button(\"Login\") {\n                    login()\n                }\n                .accessibilityIdentifier(\"loginButton\")\n            }\n        }\n        .padding()\n    }\n    \n    private func login() {\n        // Simple validation\n        if !email.isEmpty && !password.isEmpty {\n            isLoggedIn = true\n        }\n    }\n}\n\n// === MOCK IMPLEMENTATIONS ===\n\nclass MockDataService: DataService {\n    var shouldSucceed = true\n    var delay: TimeInterval = 0.5\n    \n    func fetchUser(id: Int, completion: @escaping (Result<User, Error>) -> Void) {\n        DispatchQueue.global().asyncAfter(deadline: .now() + delay) {\n            if self.shouldSucceed {\n                let user = User(id: id, name: \"Test User\", email: \"test@example.com\")\n                completion(.success(user))\n            } else {\n                completion(.failure(MockError.networkError))\n            }\n        }\n    }\n}\n\nenum MockError: Error {\n    case networkError\n}",
      "category": "iOS Development",
      "estimatedTime": 300,
      "dependencies": ["optionals"],
      "challenge": {
        "instructions": "Create a comprehensive test suite for a Task Manager app:\n\nPART 1: Unit Testing Core Logic (90 min)\n1. Test Task model creation and validation\n2. Test TaskManager CRUD operations (create, read, update, delete)\n3. Test filtering and sorting functionality\n4. Test error handling for invalid operations\n\nPART 2: Mocking & Dependency Injection (60 min)\n5. Create mock implementations for persistence and notification services\n6. Test TaskManager with different service configurations\n7. Verify service interactions using dependency injection\n\nPART 3: Asynchronous Testing (60 min)\n8. Test async task loading with expectations\n9. Test Combine publishers in ViewModel\n10. Test error scenarios in async operations\n\nPART 4: UI Testing (60 min)\n11. Write UI tests for task creation flow\n12. Test task completion and deletion interactions\n13. Verify UI state changes and navigation\n\nPART 5: Advanced Testing (30 min)\n14. Write performance tests for heavy operations\n15. Create snapshot tests for UI components\n16. Implement test utilities and helpers",
        "starterCode": "// === TASK MODEL ===\nstruct Task: Identifiable, Equatable {\n    let id: UUID\n    var title: String\n    var isCompleted: Bool\n    var dueDate: Date?\n    var priority: Priority\n    \n    enum Priority: String, CaseIterable {\n        case low, medium, high\n    }\n    \n    init(id: UUID = UUID(), title: String, isCompleted: Bool = false, dueDate: Date? = nil, priority: Priority = .medium) {\n        self.id = id\n        self.title = title\n        self.isCompleted = isCompleted\n        self.dueDate = dueDate\n        self.priority = priority\n    }\n}\n\n// === PERSISTENCE PROTOCOL ===\nprotocol TaskPersistence {\n    func save(_ task: Task) throws\n    func load() throws -> [Task]\n    func delete(_ task: Task) throws\n}\n\n// === TASK MANAGER ===\nclass TaskManager {\n    private let persistence: TaskPersistence\n    private var tasks: [Task] = []\n    \n    init(persistence: TaskPersistence) {\n        self.persistence = persistence\n    }\n    \n    func createTask(title: String, dueDate: Date? = nil, priority: Task.Priority = .medium) throws -> Task {\n        guard !title.trimmingCharacters(in: .whitespaces).isEmpty else {\n            throw TaskError.invalidTitle\n        }\n        \n        let task = Task(title: title, dueDate: dueDate, priority: priority)\n        try persistence.save(task)\n        tasks.append(task)\n        return task\n    }\n    \n    func toggleCompletion(for task: Task) throws {\n        // TODO: Implement toggle logic\n    }\n    \n    func tasks(for priority: Task.Priority) -> [Task] {\n        // TODO: Implement filtering\n        return []\n    }\n    \n    // TODO: Add more methods...\n}\n\nenum TaskError: Error {\n    case invalidTitle\n    case taskNotFound\n}\n\n// === YOUR TEST IMPLEMENTATION BELOW ===\n\nimport XCTest\n\nclass TaskManagerTests: XCTestCase {\n    // Implement your tests here\n    \n}",
        "solution": "// === MOCK PERSISTENCE ===\nclass MockTaskPersistence: TaskPersistence {\n    var savedTasks: [Task] = []\n    var shouldThrowError = false\n    \n    func save(_ task: Task) throws {\n        if shouldThrowError {\n            throw NSError(domain: \"Test\", code: 1, userInfo: nil)\n        }\n        savedTasks.append(task)\n    }\n    \n    func load() throws -> [Task] {\n        if shouldThrowError {\n            throw NSError(domain: \"Test\", code: 1, userInfo: nil)\n        }\n        return savedTasks\n    }\n    \n    func delete(_ task: Task) throws {\n        if shouldThrowError {\n            throw NSError(domain: \"Test\", code: 1, userInfo: nil)\n        }\n        savedTasks.removeAll { $0.id == task.id }\n    }\n}\n\n// === COMPLETE TASK MANAGER ===\nclass CompleteTaskManager: TaskManager {\n    override func toggleCompletion(for task: Task) throws {\n        guard let index = tasks.firstIndex(where: { $0.id == task.id }) else {\n            throw TaskError.taskNotFound\n        }\n        \n        var updatedTask = task\n        updatedTask.isCompleted.toggle()\n        try persistence.save(updatedTask)\n        tasks[index] = updatedTask\n    }\n    \n    override func tasks(for priority: Task.Priority) -> [Task] {\n        return tasks.filter { $0.priority == priority }\n    }\n    \n    func loadTasks() throws {\n        tasks = try persistence.load()\n    }\n    \n    func deleteTask(_ task: Task) throws {\n        try persistence.delete(task)\n        tasks.removeAll { $0.id == task.id }\n    }\n}\n\n// === TEST IMPLEMENTATION ===\nimport XCTest\nimport Combine\n\nclass TaskManagerTests: XCTestCase {\n    var taskManager: CompleteTaskManager!\n    var mockPersistence: MockTaskPersistence!\n    \n    override func setUp() {\n        super.setUp()\n        mockPersistence = MockTaskPersistence()\n        taskManager = CompleteTaskManager(persistence: mockPersistence)\n    }\n    \n    override func tearDown() {\n        taskManager = nil\n        mockPersistence = nil\n        super.tearDown()\n    }\n    \n    // PART 1: Unit Testing Core Logic\n    func testCreateTask_WithValidTitle_ShouldSucceed() throws {\n        // When\n        let task = try taskManager.createTask(title: \"Test Task\")\n        \n        // Then\n        XCTAssertEqual(task.title, \"Test Task\")\n        XCTAssertFalse(task.isCompleted)\n        XCTAssertEqual(mockPersistence.savedTasks.count, 1)\n    }\n    \n    func testCreateTask_WithEmptyTitle_ShouldThrowError() {\n        // When/Then\n        XCTAssertThrowsError(try taskManager.createTask(title: \"   \")) { error in\n            XCTAssertEqual(error as? TaskError, TaskError.invalidTitle)\n        }\n    }\n    \n    func testToggleCompletion_ShouldUpdateTask() throws {\n        // Given\n        let task = try taskManager.createTask(title: \"Test Task\")\n        \n        // When\n        try taskManager.toggleCompletion(for: task)\n        \n        // Then\n        let updatedTask = taskManager.tasks(for: .medium).first\n        XCTAssertTrue(updatedTask?.isCompleted == true)\n    }\n    \n    // PART 2: Mocking & Dependency Injection\n    func testTaskManager_WithFailingPersistence_ShouldThrowError() {\n        // Given\n        mockPersistence.shouldThrowError = true\n        \n        // When/Then\n        XCTAssertThrowsError(try taskManager.createTask(title: \"Test Task\"))\n    }\n    \n    // PART 3: Asynchronous Testing\n    func testAsyncTaskLoading() throws {\n        // Given\n        let expectation = XCTestExpectation(description: \"Tasks loaded\")\n        \n        // Pre-populate mock\n        try mockPersistence.save(Task(title: \"Task 1\"))\n        try mockPersistence.save(Task(title: \"Task 2\"))\n        \n        // When\n        DispatchQueue.global().async {\n            try? self.taskManager.loadTasks()\n            expectation.fulfill()\n        }\n        \n        // Then\n        wait(for: [expectation], timeout: 1.0)\n        XCTAssertEqual(taskManager.tasks(for: .medium).count, 2)\n    }\n    \n    // PART 4: Performance Testing\n    func testPerformance_CreatingManyTasks() {\n        measure {\n            for i in 0..<1000 {\n                try? taskManager.createTask(title: \"Task \\(i)\")\n            }\n        }\n    }\n    \n    // PART 5: Advanced Testing Patterns\n    func testTaskFiltering_ByPriority() throws {\n        // Given\n        try taskManager.createTask(title: \"Low Task\", priority: .low)\n        try taskManager.createTask(title: \"High Task\", priority: .high)\n        try taskManager.createTask(title: \"Medium Task\", priority: .medium)\n        \n        // When\n        let highPriorityTasks = taskManager.tasks(for: .high)\n        \n        // Then\n        XCTAssertEqual(highPriorityTasks.count, 1)\n        XCTAssertEqual(highPriorityTasks.first?.title, \"High Task\")\n    }\n}\n\n// UI Tests would be in a separate UITest target\nclass TaskManagerUITests: XCTestCase {\n    var app: XCUIApplication!\n    \n    override func setUp() {\n        super.setUp()\n        continueAfterFailure = false\n        app = XCUIApplication()\n        app.launch()\n    }\n    \n    func testCreateTaskFlow() {\n        // Find elements\n        let addButton = app.buttons[\"addTask\"]\n        let titleField = app.textFields[\"taskTitle\"]\n        let saveButton = app.buttons[\"saveTask\"]\n        \n        // Create task\n        addButton.tap()\n        titleField.tap()\n        titleField.typeText(\"UI Test Task\")\n        saveButton.tap()\n        \n        // Verify task appears\n        let taskCell = app.staticTexts[\"UI Test Task\"]\n        XCTAssertTrue(taskCell.waitForExistence(timeout: 2))\n    }\n}",
        "hints": [
          "PART 1: Start with simple assertions for task creation and validation",
          "PART 2: Use dependency injection to test different service behaviors",
          "PART 3: Use XCTestExpectation for async operations and Combine testing",
          "PART 4: Add accessibility identifiers to UI elements for reliable testing",
          "PART 5: Use measure blocks for performance testing and organize tests logically",
          "Remember to test both success and failure scenarios",
          "Use @testable import to access internal methods in your main target",
          "Set up and tear down properly to ensure test isolation"
        ],
        "testCases": [
          {
            "input": "testCreateTask_WithValidTitle_ShouldSucceed",
            "expectedOutput": "true",
            "description": "Task creation with valid title should succeed"
          },
          {
            "input": "testCreateTask_WithEmptyTitle_ShouldThrowError",
            "expectedOutput": "true",
            "description": "Task creation with empty title should throw error"
          },
          {
            "input": "testTaskFiltering_ByPriority",
            "expectedOutput": "true",
            "description": "Task filtering by priority should work correctly"
          }
        ]
      }
    },
    {
      "id": "social_media_app",
      "title": "Social Media App - Complex State Management",
      "description": "Build a full-featured social media application with advanced state management, real-time updates, and complex data flow",
      "difficulty": "intermediate",
      "theory": "# Social Media App - Complex State Management\n\n## 1. Application Architecture & State Planning (45 min)\n\n### Modern Social Media App Requirements:\n- User authentication and profiles\n- Post creation and feed management\n- Real-time likes, comments, and shares\n- Notifications system\n- Offline support and sync\n- Image/video upload and caching\n\n### State Management Approaches:\n\n**Single Source of Truth:**\n```swift\nclass AppState: ObservableObject {\n    @Published var currentUser: User?\n    @Published var feed: [Post] = []\n    @Published var notifications: [Notification] = []\n    @Published var messages: [Conversation] = []\n    @Published var onlineUsers: [User] = []\n}\n```\n\n**Multi-Store Architecture:**\n```swift\n// Separate concerns for better scalability\nclass UserStore: ObservableObject {\n    @Published var currentUser: User?\n    @Published var followers: [User] = []\n    @Published var following: [User] = []\n}\n\nclass FeedStore: ObservableObject {\n    @Published var posts: [Post] = []\n    @Published var stories: [Story] = []\n    @Published var trending: [TrendingTopic] = []\n}\n```\n\n## 2. Core Data Models (60 min)\n\n### User Model:\n```swift\nstruct User: Identifiable, Codable {\n    let id: String\n    let username: String\n    let displayName: String\n    let bio: String?\n    let profileImageURL: URL?\n    let coverImageURL: URL?\n    let followersCount: Int\n    let followingCount: Int\n    let postsCount: Int\n    let isVerified: Bool\n    let joinDate: Date\n    let isFollowing: Bool\n    let isBlocked: Bool\n}\n```\n\n### Post Model:\n```swift\nstruct Post: Identifiable, Codable {\n    let id: String\n    let author: User\n    let content: String\n    let media: [Media]?\n    let timestamp: Date\n    let likes: Int\n    let comments: Int\n    let shares: Int\n    let isLiked: Bool\n    let isBookmarked: Bool\n    let privacy: PostPrivacy\n    let tags: [String]\n    let location: Location?\n    \n    struct Media: Codable {\n        let url: URL\n        let type: MediaType\n        let width: Int\n        let height: Int\n    }\n    \n    enum MediaType: String, Codable {\n        case image, video, gif\n    }\n    \n    enum PostPrivacy: String, Codable {\n        case `public`, followers, `private`\n    }\n}\n```\n\n### Notification Model:\n```swift\nstruct Notification: Identifiable, Codable {\n    let id: String\n    let type: NotificationType\n    let fromUser: User\n    let targetPost: Post?\n    let targetComment: Comment?\n    let timestamp: Date\n    let isRead: Bool\n    \n    enum NotificationType: String, Codable {\n        case like, comment, follow, mention, share, message\n    }\n}\n```\n\n## 3. Advanced State Management with Combine (90 min)\n\n### Multi-Store Coordination:\n```swift\nclass AppCoordinator: ObservableObject {\n    let userStore: UserStore\n    let feedStore: FeedStore\n    let notificationStore: NotificationStore\n    let messageStore: MessageStore\n    \n    private var cancellables = Set<AnyCancellable>()\n    \n    init() {\n        self.userStore = UserStore()\n        self.feedStore = FeedStore()\n        self.notificationStore = NotificationStore()\n        self.messageStore = MessageStore()\n        \n        setupCrossStoreCommunication()\n    }\n    \n    private func setupCrossStoreCommunication() {\n        // When user logs in, load their feed and notifications\n        userStore.$currentUser\n            .compactMap { $0 }\n            .flatMap { user in\n                Publishers.Zip3(\n                    self.feedStore.loadFeed(for: user),\n                    self.notificationStore.loadNotifications(for: user),\n                    self.messageStore.loadConversations(for: user)\n                )\n            }\n            .sink { _ in }\n            .store(in: &cancellables)\n    }\n}\n```\n\n### Derived State:\n```swift\nextension FeedStore {\n    var trendingPosts: [Post] {\n        posts.filter { $0.likes > 100 }\n            .sorted { $0.likes > $1.likes }\n    }\n    \n    var recentPosts: [Post] {\n        posts.sorted { $0.timestamp > $1.timestamp }\n    }\n    \n    var postsFromFollowing: [Post] {\n        // This would require coordination with UserStore\n        posts // Filtered by users being followed\n    }\n}\n```\n\n## 4. Real-time Updates & WebSocket Integration (60 min)\n\n### WebSocket Manager:\n```swift\nclass WebSocketManager: ObservableObject {\n    @Published var isConnected: Bool = false\n    @Published var realTimeEvents: [RealTimeEvent] = []\n    \n    private var webSocketTask: URLSessionWebSocketTask?\n    private var cancellables = Set<AnyCancellable>()\n    \n    func connect() {\n        let url = URL(string: \"wss://api.socialapp.com/realtime\")!\n        webSocketTask = URLSession.shared.webSocketTask(with: url)\n        webSocketTask?.resume()\n        \n        listenForMessages()\n    }\n    \n    private func listenForMessages() {\n        webSocketTask?.receive { [weak self] result in\n            switch result {\n            case .success(let message):\n                self?.handleMessage(message)\n                self?.listenForMessages() // Continue listening\n            case .failure(let error):\n                print(\"WebSocket error: \" + error.localizedDescription)\n            }\n        }\n    }\n    \n    private func handleMessage(_ message: URLSessionWebSocketTask.Message) {\n        // Parse and handle real-time events\n        // Update relevant stores\n    }\n}\n```\n\n### Real-time Event Handling:\n```swift\nclass RealTimeEventHandler {\n    private let userStore: UserStore\n    private let feedStore: FeedStore\n    private let notificationStore: NotificationStore\n    \n    func handleEvent(_ event: RealTimeEvent) {\n        switch event.type {\n        case .newPost:\n            if let post = event.data as? Post {\n                feedStore.addPost(post)\n            }\n        case .like:\n            if let likeEvent = event.data as? LikeEvent {\n                feedStore.updatePostLikes(postId: likeEvent.postId, \n                                        likes: likeEvent.likeCount,\n                                        isLiked: likeEvent.isLikedByCurrentUser)\n            }\n        case .newNotification:\n            if let notification = event.data as? Notification {\n                notificationStore.addNotification(notification)\n            }\n        case .userOnline:\n            if let user = event.data as? User {\n                userStore.addOnlineUser(user)\n            }\n        }\n    }\n}\n```\n\n## 5. Advanced Data Flow Patterns (75 min)\n\n### Action-Based State Management:\n```swift\nenum AppAction {\n    case user(UserAction)\n    case feed(FeedAction)\n    case notification(NotificationAction)\n    case message(MessageAction)\n}\n\nenum UserAction {\n    case login(User)\n    case logout\n    case updateProfile(User)\n    case followUser(String)\n    case unfollowUser(String)\n    case blockUser(String)\n}\n\nenum FeedAction {\n    case loadFeed\n    case createPost(CreatePostData)\n    case likePost(String)\n    case unlikePost(String)\n    case commentOnPost(String, String)\n    case sharePost(String)\n    case deletePost(String)\n}\n\nclass AppStore: ObservableObject {\n    @Published var state: AppState\n    private let reducer: Reducer<AppState, AppAction>\n    \n    func dispatch(_ action: AppAction) {\n        reducer.reduce(&state, action)\n    }\n}\n```\n\n### Middleware for Side Effects:\n```swift\nstruct AppMiddleware {\n    let apiService: APIService\n    let websocketManager: WebSocketManager\n    let cacheManager: CacheManager\n    \n    func middleware() -> Middleware<AppState, AppAction> {\n        return { state, action in\n            switch action {\n            case .user(.login(let user)):\n                // Side effects for login\n                return [\n                    .websocket(.connect(user.id)),\n                    .feed(.loadFeed),\n                    .notification(.loadNotifications)\n                ]\n            case .feed(.createPost(let postData)):\n                return [\n                    .api(.createPost(postData)),\n                    .cache(.storePost(postData))\n                ]\n            default:\n                return []\n            }\n        }\n    }\n}\n```\n\n## 6. Performance Optimization & Caching (60 min)\n\n### Intelligent Caching Strategy:\n```swift\nclass CacheManager: ObservableObject {\n    private let memoryCache: NSCache<NSString, AnyObject>\n    private let diskCache: FileManager\n    private let cacheExpiry: TimeInterval = 3600 // 1 hour\n    \n    func cache<T: Codable>(_ object: T, for key: String) {\n        // Memory cache for quick access\n        memoryCache.setObject(object as AnyObject, forKey: key as NSString)\n        \n        // Disk cache for persistence\n        if let data = try? JSONEncoder().encode(object) {\n            let fileURL = getCacheURL(for: key)\n            try? data.write(to: fileURL)\n        }\n    }\n    \n    func getCached<T: Codable>(for key: String) -> T? {\n        // Check memory cache first\n        if let cached = memoryCache.object(forKey: key as NSString) as? T {\n            return cached\n        }\n        \n        // Check disk cache\n        let fileURL = getCacheURL(for: key)\n        if let data = try? Data(contentsOf: fileURL),\n           let object = try? JSONDecoder().decode(T.self, from: data) {\n            // Populate memory cache\n            memoryCache.setObject(object as AnyObject, forKey: key as NSString)\n            return object\n        }\n        \n        return nil\n    }\n}\n```\n\n### Lazy Loading & Pagination:\n```swift\nclass FeedStore: ObservableObject {\n    @Published var posts: [Post] = []\n    @Published var isLoading: Bool = false\n    @Published var canLoadMore: Bool = true\n    \n    private var currentPage: Int = 0\n    private let pageSize: Int = 20\n    \n    func loadMorePosts() -> AnyPublisher<[Post], Error> {\n        guard !isLoading && canLoadMore else {\n            return Empty().eraseToAnyPublisher()\n        }\n        \n        isLoading = true\n        \n        return apiService.loadFeed(page: currentPage, pageSize: pageSize)\n            .handleEvents(\n                receiveOutput: { [weak self] newPosts in\n                    self?.posts.append(contentsOf: newPosts)\n                    self?.currentPage += 1\n                    self?.canLoadMore = newPosts.count == self?.pageSize\n                    self?.isLoading = false\n                },\n                receiveCompletion: { [weak self] _ in\n                    self?.isLoading = false\n                }\n            )\n            .eraseToAnyPublisher()\n    }\n}\n```\n\n## 7. Testing Complex State (30 min)\n\n### Store Testing:\n```swift\nclass FeedStoreTests: XCTestCase {\n    var store: FeedStore!\n    var mockAPIService: MockAPIService!\n    \n    override func setUp() {\n        mockAPIService = MockAPIService()\n        store = FeedStore(apiService: mockAPIService)\n    }\n    \n    func testLikePost() {\n        // Given\n        let post = Post.mock()\n        store.posts = [post]\n        \n        // When\n        store.likePost(post.id)\n        \n        // Then\n        XCTAssertTrue(store.posts.first?.isLiked == true)\n        XCTAssertEqual(store.posts.first?.likes, post.likes + 1)\n    }\n    \n    func testLoadMorePosts() {\n        // Given\n        let expectation = self.expectation(description: \"Load more posts\")\n        \n        // When\n        store.loadMorePosts()\n            .sink(\n                receiveCompletion: { _ in },\n                receiveValue: { _ in\n                    expectation.fulfill()\n                }\n            )\n            .store(in: &cancellables)\n        \n        // Then\n        waitForExpectations(timeout: 1.0)\n        XCTAssertFalse(store.posts.isEmpty)\n    }\n}\n```\n\n### Integration Testing:\n```swift\nclass AppIntegrationTests: XCTestCase {\n    var appCoordinator: AppCoordinator!\n    \n    func testUserLoginFlow() {\n        // Test that logging in user loads feed, notifications, and messages\n        let user = User.mock()\n        \n        appCoordinator.userStore.currentUser = user\n        \n        XCTAssertNotNil(appCoordinator.feedStore.posts)\n        XCTAssertNotNil(appCoordinator.notificationStore.notifications)\n        XCTAssertNotNil(appCoordinator.messageStore.conversations)\n    }\n}\n```",
      "codeExample": "import Combine\nimport SwiftUI\n\n// === CORE DATA MODELS ===\nstruct User: Identifiable, Codable, Equatable {\n    let id: String\n    let username: String\n    let displayName: String\n    let profileImageURL: URL?\n    let isVerified: Bool\n    var isFollowing: Bool\n    var followersCount: Int\n}\n\nstruct Post: Identifiable, Codable, Equatable {\n    let id: String\n    let author: User\n    let content: String\n    let timestamp: Date\n    var likes: Int\n    var comments: Int\n    var shares: Int\n    var isLiked: Bool\n    var isBookmarked: Bool\n    let media: [Media]?\n}\n\nstruct Notification: Identifiable, Codable {\n    let id: String\n    let type: String\n    let fromUser: User\n    let targetPost: Post?\n    let timestamp: Date\n    var isRead: Bool\n}\n\n// === STORE MANAGEMENT ===\nclass UserStore: ObservableObject {\n    @Published var currentUser: User?\n    @Published var followers: [User] = []\n    @Published var following: [User] = []\n    @Published var suggestedUsers: [User] = []\n    \n    private var cancellables = Set<AnyCancellable>()\n    \n    func followUser(_ userId: String) -> AnyPublisher<User, Error> {\n        // API call to follow user\n        return Future { promise in\n            // Simulate network request\n            DispatchQueue.main.asyncAfter(deadline: .now() + 0.5) {\n                if let index = self.suggestedUsers.firstIndex(where: { $0.id == userId }) {\n                    var user = self.suggestedUsers[index]\n                    user.isFollowing = true\n                    user.followersCount += 1\n                    self.suggestedUsers[index] = user\n                    promise(.success(user))\n                } else {\n                    promise(.failure(NSError(domain: \"User not found\", code: 404)))\n                }\n            }\n        }\n        .eraseToAnyPublisher()\n    }\n}\n\nclass FeedStore: ObservableObject {\n    @Published var posts: [Post] = []\n    @Published var stories: [User] = []\n    @Published var isLoading: Bool = false\n    @Published var error: String?\n    \n    private var cancellables = Set<AnyCancellable>()\n    \n    var trendingPosts: [Post] {\n        posts.filter { $0.likes > 50 }\n            .sorted { $0.likes > $1.likes }\n    }\n    \n    var recentPosts: [Post] {\n        posts.sorted { $0.timestamp > $1.timestamp }\n    }\n    \n    func likePost(_ postId: String) {\n        if let index = posts.firstIndex(where: { $0.id == postId }) {\n            var post = posts[index]\n            if post.isLiked {\n                post.likes -= 1\n            } else {\n                post.likes += 1\n            }\n            post.isLiked.toggle()\n            posts[index] = post\n            \n            // Simulate API call\n            // apiService.likePost(postId).sink(...)\n        }\n    }\n    \n    func loadFeed() -> AnyPublisher<[Post], Error> {\n        isLoading = true\n        error = nil\n        \n        return Future { promise in\n            // Simulate network request\n            DispatchQueue.main.asyncAfter(deadline: .now() + 1.0) {\n                let mockPosts = self.generateMockPosts()\n                promise(.success(mockPosts))\n            }\n        }\n        .handleEvents(\n            receiveOutput: { [weak self] posts in\n                self?.posts = posts\n                self?.isLoading = false\n            },\n            receiveCompletion: { [weak self] completion in\n                if case .failure(let error) = completion {\n                    self?.error = error.localizedDescription\n                }\n                self?.isLoading = false\n            }\n        )\n        .eraseToAnyPublisher()\n    }\n    \n    private func generateMockPosts() -> [Post] {\n        // Generate mock data for demonstration\n        let users = [\n            User(id: \"1\", username: \"johndoe\", displayName: \"John Doe\", profileImageURL: nil, isVerified: true, isFollowing: true, followersCount: 1500),\n            User(id: \"2\", username: \"janedoe\", displayName: \"Jane Smith\", profileImageURL: nil, isVerified: false, isFollowing: false, followersCount: 800)\n        ]\n        \n        return [\n            Post(id: \"1\", author: users[0], content: \"Just launched my new app! #iOS #SwiftUI\", timestamp: Date(), likes: 142, comments: 23, shares: 8, isLiked: false, isBookmarked: false, media: nil),\n            Post(id: \"2\", author: users[1], content: \"Beautiful sunset at the beach ðŸŒ…\", timestamp: Date().addingTimeInterval(-3600), likes: 89, comments: 12, shares: 3, isLiked: true, isBookmarked: false, media: nil)\n        ]\n    }\n}\n\nclass NotificationStore: ObservableObject {\n    @Published var notifications: [Notification] = []\n    @Published var unreadCount: Int = 0\n    \n    private var cancellables = Set<AnyCancellable>()\n    \n    func markAsRead(_ notificationId: String) {\n        if let index = notifications.firstIndex(where: { $0.id == notificationId }) {\n            notifications[index].isRead = true\n            updateUnreadCount()\n        }\n    }\n    \n    func markAllAsRead() {\n        for index in notifications.indices {\n            notifications[index].isRead = true\n        }\n        updateUnreadCount()\n    }\n    \n    private func updateUnreadCount() {\n        unreadCount = notifications.filter { !$0.isRead }.count\n    }\n}\n\n// === APP COORDINATOR ===\nclass AppCoordinator: ObservableObject {\n    let userStore: UserStore\n    let feedStore: FeedStore\n    let notificationStore: NotificationStore\n    \n    @Published var selectedTab: AppTab = .feed\n    @Published var isLoggedIn: Bool = false\n    \n    private var cancellables = Set<AnyCancellable>()\n    \n    init() {\n        self.userStore = UserStore()\n        self.feedStore = FeedStore()\n        self.notificationStore = NotificationStore()\n        \n        setupCrossStoreCommunication()\n        loadInitialData()\n    }\n    \n    private func setupCrossStoreCommunication() {\n        // When user logs in, load all data\n        userStore.$currentUser\n            .map { $0 != nil }\n            .assign(to: &$isLoggedIn)\n        \n        // Load feed when app starts or user logs in\n        userStore.$currentUser\n            .compactMap { $0 }\n            .flatMap { [weak self] _ in\n                self?.feedStore.loadFeed() ?? Empty().eraseToAnyPublisher()\n            }\n            .sink(\n                receiveCompletion: { _ in },\n                receiveValue: { _ in }\n            )\n            .store(in: &cancellables)\n    }\n    \n    private func loadInitialData() {\n        // Simulate user login\n        let mockUser = User(id: \"current\", username: \"currentuser\", displayName: \"Current User\", profileImageURL: nil, isVerified: false, isFollowing: false, followersCount: 100)\n        userStore.currentUser = mockUser\n    }\n    \n    func createPost(content: String) -> AnyPublisher<Post, Error> {\n        guard let currentUser = userStore.currentUser else {\n            return Fail(error: NSError(domain: \"Not logged in\", code: 401))\n                .eraseToAnyPublisher()\n        }\n        \n        let newPost = Post(\n            id: UUID().uuidString,\n            author: currentUser,\n            content: content,\n            timestamp: Date(),\n            likes: 0,\n            comments: 0,\n            shares: 0,\n            isLiked: false,\n            isBookmarked: false,\n            media: nil\n        )\n        \n        // Simulate API call\n        return Future { promise in\n            DispatchQueue.main.asyncAfter(deadline: .now() + 0.5) {\n                self.feedStore.posts.insert(newPost, at: 0)\n                promise(.success(newPost))\n            }\n        }\n        .eraseToAnyPublisher()\n    }\n}\n\nenum AppTab {\n    case feed, search, upload, notifications, profile\n}\n\n// === VIEW MODELS ===\nclass FeedViewModel: ObservableObject {\n    @Published var posts: [Post] = []\n    @Published var isLoading: Bool = false\n    @Published var error: String?\n    \n    private let feedStore: FeedStore\n    private var cancellables = Set<AnyCancellable>()\n    \n    init(feedStore: FeedStore) {\n        self.feedStore = feedStore\n        \n        feedStore.$posts\n            .assign(to: &$posts)\n        \n        feedStore.$isLoading\n            .assign(to: &$isLoading)\n        \n        feedStore.$error\n            .assign(to: &$error)\n    }\n    \n    func likePost(_ post: Post) {\n        feedStore.likePost(post.id)\n    }\n    \n    func refreshFeed() {\n        feedStore.loadFeed()\n            .sink(\n                receiveCompletion: { _ in },\n                receiveValue: { _ in }\n            )\n            .store(in: &cancellables)\n    }\n}\n\nclass NotificationViewModel: ObservableObject {\n    @Published var notifications: [Notification] = []\n    @Published var unreadCount: Int = 0\n    \n    private let notificationStore: NotificationStore\n    private var cancellables = Set<AnyCancellable>()\n    \n    init(notificationStore: NotificationStore) {\n        self.notificationStore = notificationStore\n        \n        notificationStore.$notifications\n            .assign(to: &$notifications)\n        \n        notificationStore.$unreadCount\n            .assign(to: &$unreadCount)\n    }\n    \n    func markAsRead(_ notification: Notification) {\n        notificationStore.markAsRead(notification.id)\n    }\n    \n    func markAllAsRead() {\n        notificationStore.markAllAsRead()\n    }\n}\n\n// === REAL-TIME FEATURES ===\nclass RealTimeService: ObservableObject {\n    @Published var onlineUsers: [User] = []\n    @Published var isConnected: Bool = false\n    \n    private var cancellables = Set<AnyCancellable>()\n    \n    func simulateRealTimeUpdates(feedStore: FeedStore) {\n        // Simulate real-time likes and comments\n        Timer.publish(every: 10.0, on: .main, in: .common)\n            .autoconnect()\n            .sink { [weak feedStore] _ in\n                guard let store = feedStore, !store.posts.isEmpty else { return }\n                \n                // Randomly update a post\n                let randomIndex = Int.random(in: 0..<store.posts.count)\n                var post = store.posts[randomIndex]\n                post.likes += Int.random(in: 1...5)\n                post.comments += Int.random(in: 0...2)\n                store.posts[randomIndex] = post\n            }\n            .store(in: &cancellables)\n    }\n}\n\n// === CACHE MANAGEMENT ===\nclass CacheManager {\n    static let shared = CacheManager()\n    \n    private let memoryCache = NSCache<NSString, AnyObject>()\n    private let userDefaults = UserDefaults.standard\n    \n    func cache<T: Codable>(_ object: T, for key: String) {\n        // Memory cache\n        memoryCache.setObject(object as AnyObject, forKey: key as NSString)\n        \n        // Disk cache\n        if let data = try? JSONEncoder().encode(object) {\n            userDefaults.set(data, forKey: key)\n        }\n    }\n    \n    func getCached<T: Codable>(for key: String) -> T? {\n        // Check memory cache\n        if let cached = memoryCache.object(forKey: key as NSString) as? T {\n            return cached\n        }\n        \n        // Check disk cache\n        if let data = userDefaults.data(forKey: key),\n           let object = try? JSONDecoder().decode(T.self, from: data) {\n            // Populate memory cache\n            memoryCache.setObject(object as AnyObject, forKey: key as NSString)\n            return object\n        }\n        \n        return nil\n    }\n}",
      "category": "iOS Development",
      "estimatedTime": 300,
      "dependencies": ["combine_framework", "swiftui_basics", "networking"],
      "challenge": {
        "instructions": "Build a complete social media application with complex state management:\n\nPART 1: Core Architecture & Data Models (60 min)\n1. Design and implement User, Post, Notification data models\n2. Create UserStore, FeedStore, NotificationStore with @Published properties\n3. Set up AppCoordinator to manage cross-store communication\n\nPART 2: Feed Management & Real-time Updates (90 min)\n4. Implement infinite scrolling with pagination in FeedStore\n5. Create real-time like/comment updates using Combine\n6. Build trending posts and recent posts computed properties\n7. Add pull-to-refresh functionality\n\nPART 3: User Interactions & Notifications (75 min)\n8. Implement follow/unfollow system with UserStore\n9. Create notification system with real-time updates\n10. Build mark-as-read functionality for notifications\n11. Add notification badges and counts\n\nPART 4: Advanced State Patterns (60 min)\n12. Implement action-based state management system\n13. Create middleware for API calls and side effects\n14. Build intelligent caching system with memory and disk cache\n15. Add offline support with queue-based sync\n\nPART 5: Performance & Testing (45 min)\n16. Write comprehensive unit tests for all stores\n17. Implement performance monitoring for state updates\n18. Add integration tests for cross-store communication\n19. Optimize Combine pipelines for performance",
        "starterCode": "import Combine\nimport SwiftUI\n\n// === PART 1: Core Architecture ===\n// Define your data models and stores here\n\n\n// === PART 2: Feed Management ===\n// Implement feed store with real-time updates\n\n\n// === PART 3: User Interactions ===\n// Build user store and notification system\n\n\n// === PART 4: Advanced State Patterns ===\n// Implement action system and caching\n\n\n// === PART 5: Performance & Testing ===\n// Add tests and performance optimizations\n\n",
        "solution": "import Combine\nimport SwiftUI\n\n// === PART 1: Core Architecture ===\nstruct SocialMediaUser: Identifiable, Codable, Equatable {\n    let id: String\n    let username: String\n    let displayName: String\n    let profileImageURL: URL?\n    let isVerified: Bool\n    var isFollowing: Bool\n    var followersCount: Int\n    var followingCount: Int\n}\n\nstruct SocialPost: Identifiable, Codable, Equatable {\n    let id: String\n    let author: SocialMediaUser\n    let content: String\n    let timestamp: Date\n    var likes: Int\n    var comments: Int\n    var shares: Int\n    var isLiked: Bool\n    var isBookmarked: Bool\n    let media: [Media]?\n    \n    struct Media: Codable, Equatable {\n        let url: URL\n        let type: String\n    }\n}\n\nclass SocialUserStore: ObservableObject {\n    @Published var currentUser: SocialMediaUser?\n    @Published var followers: [SocialMediaUser] = []\n    @Published var following: [SocialMediaUser] = []\n    @Published var suggestedUsers: [SocialMediaUser] = []\n    \n    private var cancellables = Set<AnyCancellable>()\n    \n    func followUser(_ userId: String) -> AnyPublisher<SocialMediaUser, Error> {\n        return Future { [weak self] promise in\n            DispatchQueue.main.asyncAfter(deadline: .now() + 0.3) {\n                if let index = self?.suggestedUsers.firstIndex(where: { $0.id == userId }) {\n                    var user = self!.suggestedUsers[index]\n                    user.isFollowing = true\n                    user.followersCount += 1\n                    self?.suggestedUsers[index] = user\n                    \n                    // Add to following list\n                    if !self!.following.contains(where: { $0.id == userId }) {\n                        self?.following.append(user)\n                    }\n                    \n                    promise(.success(user))\n                } else {\n                    promise(.failure(NSError(domain: \"User not found\", code: 404)))\n                }\n            }\n        }\n        .eraseToAnyPublisher()\n    }\n}\n\n// === PART 2: Feed Management ===\nclass SocialFeedStore: ObservableObject {\n    @Published var posts: [SocialPost] = []\n    @Published var isLoading: Bool = false\n    @Published var canLoadMore: Bool = true\n    @Published var error: String?\n    \n    private var currentPage: Int = 0\n    private let pageSize: Int = 10\n    private var cancellables = Set<AnyCancellable>()\n    \n    var trendingPosts: [SocialPost] {\n        posts.filter { $0.likes > 100 }\n            .sorted { $0.likes > $1.likes }\n            .prefix(5)\n            .map { $0 }\n    }\n    \n    var recentPosts: [SocialPost] {\n        posts.sorted { $0.timestamp > $1.timestamp }\n    }\n    \n    func loadMorePosts() -> AnyPublisher<[SocialPost], Error> {\n        guard !isLoading && canLoadMore else {\n            return Empty().eraseToAnyPublisher()\n        }\n        \n        isLoading = true\n        \n        return Future { [weak self] promise in\n            DispatchQueue.main.asyncAfter(deadline: .now() + 1.0) {\n                let newPosts = self?.generateMockPosts(page: self?.currentPage ?? 0) ?? []\n                promise(.success(newPosts))\n            }\n        }\n        .handleEvents(\n            receiveOutput: { [weak self] newPosts in\n                self?.posts.append(contentsOf: newPosts)\n                self?.currentPage += 1\n                self?.canLoadMore = newPosts.count == self?.pageSize\n                self?.isLoading = false\n            },\n            receiveCompletion: { [weak self] completion in\n                if case .failure(let error) = completion {\n                    self?.error = error.localizedDescription\n                }\n                self?.isLoading = false\n            }\n        )\n        .eraseToAnyPublisher()\n    }\n    \n    func likePost(_ postId: String) {\n        if let index = posts.firstIndex(where: { $0.id == postId }) {\n            var post = posts[index]\n            if post.isLiked {\n                post.likes -= 1\n            } else {\n                post.likes += 1\n            }\n            post.isLiked.toggle()\n            posts[index] = post\n        }\n    }\n    \n    private func generateMockPosts(page: Int) -> [SocialPost] {\n        let users = [\n            SocialMediaUser(id: \"1\", username: \"techguru\", displayName: \"Tech Guru\", profileImageURL: nil, isVerified: true, isFollowing: true, followersCount: 50000, followingCount: 200),\n            SocialMediaUser(id: \"2\", username: \"designmaster\", displayName: \"Design Master\", profileImageURL: nil, isVerified: true, isFollowing: false, followersCount: 25000, followingCount: 150)\n        ]\n        \n        let startIndex = page * pageSize\n        let endIndex = startIndex + pageSize\n        \n        return (startIndex..<endIndex).map { index in\n            SocialPost(\n                id: \"post-\\(index)\",\n                author: users[index % users.count],\n                content: \"This is post number \\(index) with some engaging content. #social #media #app\",\n                timestamp: Date().addingTimeInterval(-Double(index) * 3600),\n                likes: Int.random(in: 0...500),\n                comments: Int.random(in: 0...50),\n                shares: Int.random(in: 0...20),\n                isLiked: Bool.random(),\n                isBookmarked: Bool.random(),\n                media: nil\n            )\n        }\n    }\n}\n\n// === PART 3: User Interactions & Notifications ===\nstruct SocialNotification: Identifiable, Codable {\n    let id: String\n    let type: String\n    let fromUser: SocialMediaUser\n    let targetPost: SocialPost?\n    let timestamp: Date\n    var isRead: Bool\n}\n\nclass SocialNotificationStore: ObservableObject {\n    @Published var notifications: [SocialNotification] = []\n    @Published var unreadCount: Int = 0\n    \n    private var cancellables = Set<AnyCancellable>()\n    \n    init() {\n        // Simulate receiving notifications\n        Timer.publish(every: 5.0, on: .main, in: .common)\n            .autoconnect()\n            .sink { [weak self] _ in\n                self?.addRandomNotification()\n            }\n            .store(in: &cancellables)\n    }\n    \n    func markAsRead(_ notificationId: String) {\n        if let index = notifications.firstIndex(where: { $0.id == notificationId }) {\n            notifications[index].isRead = true\n            updateUnreadCount()\n        }\n    }\n    \n    func markAllAsRead() {\n        for index in notifications.indices {\n            notifications[index].isRead = true\n        }\n        updateUnreadCount()\n    }\n    \n    private func updateUnreadCount() {\n        unreadCount = notifications.filter { !$0.isRead }.count\n    }\n    \n    private func addRandomNotification() {\n        let mockUser = SocialMediaUser(\n            id: \"mock-\\(UUID())\",\n            username: \"user\\(Int.random(in: 1...1000))\",\n            displayName: \"User \\(Int.random(in: 1...1000))\",\n            profileImageURL: nil,\n            isVerified: Bool.random(),\n            isFollowing: Bool.random(),\n            followersCount: Int.random(in: 0...10000),\n            followingCount: Int.random(in: 0...1000)\n        )\n        \n        let notificationTypes = [\"like\", \"comment\", \"follow\", \"mention\"]\n        let newNotification = SocialNotification(\n            id: UUID().uuidString,\n            type: notificationTypes.randomElement()!,\n            fromUser: mockUser,\n            targetPost: nil,\n            timestamp: Date(),\n            isRead: false\n        )\n        \n        notifications.insert(newNotification, at: 0)\n        updateUnreadCount()\n    }\n}\n\n// === PART 4: Advanced State Patterns ===\nenum SocialAction {\n    case user(UserAction)\n    case feed(FeedAction)\n    case notification(NotificationAction)\n}\n\nenum UserAction {\n    case login(SocialMediaUser)\n    case logout\n    case followUser(String)\n    case unfollowUser(String)\n}\n\nenum FeedAction {\n    case loadFeed\n    case loadMore\n    case likePost(String)\n    case createPost(String)\n}\n\nenum NotificationAction {\n    case markAsRead(String)\n    case markAllAsRead\n    case loadNotifications\n}\n\nclass SocialAppStore: ObservableObject {\n    @Published var state: SocialAppState\n    private let userStore: SocialUserStore\n    private let feedStore: SocialFeedStore\n    private let notificationStore: SocialNotificationStore\n    private var cancellables = Set<AnyCancellable>()\n    \n    init() {\n        self.userStore = SocialUserStore()\n        self.feedStore = SocialFeedStore()\n        self.notificationStore = SocialNotificationStore()\n        self.state = SocialAppState()\n        \n        setupStateBindings()\n    }\n    \n    private func setupStateBindings() {\n        userStore.$currentUser\n            .assign(to: &state.$currentUser)\n        \n        feedStore.$posts\n            .assign(to: &state.$posts)\n        \n        notificationStore.$notifications\n            .assign(to: &state.$notifications)\n        \n        notificationStore.$unreadCount\n            .assign(to: &state.$unreadNotificationsCount)\n    }\n    \n    func dispatch(_ action: SocialAction) {\n        switch action {\n        case .user(let userAction):\n            handleUserAction(userAction)\n        case .feed(let feedAction):\n            handleFeedAction(feedAction)\n        case .notification(let notificationAction):\n            handleNotificationAction(notificationAction)\n        }\n    }\n    \n    private func handleUserAction(_ action: UserAction) {\n        switch action {\n        case .login(let user):\n            userStore.currentUser = user\n        case .logout:\n            userStore.currentUser = nil\n            feedStore.posts = []\n            notificationStore.notifications = []\n        case .followUser(let userId):\n            userStore.followUser(userId)\n                .sink(receiveCompletion: { _ in }, receiveValue: { _ in })\n                .store(in: &cancellables)\n        case .unfollowUser(let userId):\n            // Implementation for unfollow\n            break\n        }\n    }\n    \n    private func handleFeedAction(_ action: FeedAction) {\n        switch action {\n        case .loadFeed, .loadMore:\n            feedStore.loadMorePosts()\n                .sink(receiveCompletion: { _ in }, receiveValue: { _ in })\n                .store(in: &cancellables)\n        case .likePost(let postId):\n            feedStore.likePost(postId)\n        case .createPost(let content):\n            // Implementation for creating post\n            break\n        }\n    }\n    \n    private func handleNotificationAction(_ action: NotificationAction) {\n        switch action {\n        case .markAsRead(let notificationId):\n            notificationStore.markAsRead(notificationId)\n        case .markAllAsRead:\n            notificationStore.markAllAsRead()\n        case .loadNotifications:\n            // Implementation for loading notifications\n            break\n        }\n    }\n}\n\nstruct SocialAppState {\n    @Published var currentUser: SocialMediaUser?\n    @Published var posts: [SocialPost] = []\n    @Published var notifications: [SocialNotification] = []\n    @Published var unreadNotificationsCount: Int = 0\n    @Published var isLoading: Bool = false\n}\n\n// === PART 5: Performance & Testing ===\nclass SocialCacheManager {\n    private let memoryCache = NSCache<NSString, AnyObject>()\n    private let userDefaults = UserDefaults.standard\n    \n    func cacheUser(_ user: SocialMediaUser) {\n        memoryCache.setObject(user as AnyObject, forKey: \"user-\\(user.id)\" as NSString)\n        if let data = try? JSONEncoder().encode(user) {\n            userDefaults.set(data, forKey: \"user-\\(user.id)\")\n        }\n    }\n    \n    func getCachedUser(_ userId: String) -> SocialMediaUser? {\n        if let cached = memoryCache.object(forKey: \"user-\\(userId)\" as NSString) as? SocialMediaUser {\n            return cached\n        }\n        \n        if let data = userDefaults.data(forKey: \"user-\\(userId)\"),\n           let user = try? JSONDecoder().decode(SocialMediaUser.self, from: data) {\n            memoryCache.setObject(user as AnyObject, forKey: \"user-\\(userId)\" as NSString)\n            return user\n        }\n        \n        return nil\n    }\n}\n\n// Unit Tests would be implemented in a separate test target\nclass SocialMediaTests {\n    func testLikePost() {\n        let feedStore = SocialFeedStore()\n        let testPost = SocialPost(\n            id: \"test-post\",\n            author: SocialMediaUser(id: \"1\", username: \"test\", displayName: \"Test User\", profileImageURL: nil, isVerified: false, isFollowing: false, followersCount: 0, followingCount: 0),\n            content: \"Test content\",\n            timestamp: Date(),\n            likes: 10,\n            comments: 2,\n            shares: 1,\n            isLiked: false,\n            isBookmarked: false,\n            media: nil\n        )\n        \n        feedStore.posts = [testPost]\n        feedStore.likePost(\"test-post\")\n        \n        // Assert that likes increased and isLiked is true\n        // XCTAssertEqual(feedStore.posts.first?.likes, 11)\n        // XCTAssertTrue(feedStore.posts.first?.isLiked == true)\n    }\n}",
        "hints": [
          "PART 1: Use separate stores for different concerns - UserStore, FeedStore, NotificationStore",
          "PART 2: Implement pagination with currentPage and pageSize, use flatMap for async operations",
          "PART 3: Use Timer.publish for simulating real-time notifications, update unread counts reactively",
          "PART 4: Create an action-enum system for predictable state updates, use middleware for side effects",
          "PART 5: Implement both memory and disk caching, use NSCache for memory, UserDefaults for disk",
          "Use @Published properties for state that needs to trigger UI updates",
          "Remember to handle cancellables properly to prevent memory leaks",
          "Test state changes by verifying @Published property updates"
        ],
        "testCases": [
          {
            "input": "feedStore.posts.count > 0",
            "expectedOutput": "true",
            "description": "Feed should load posts successfully"
          },
          {
            "input": "notificationStore.unreadCount >= 0",
            "expectedOutput": "true",
            "description": "Unread count should never be negative"
          },
          {
            "input": "userStore.currentUser != nil",
            "expectedOutput": "true",
            "description": "Should have a logged-in user"
          },
          {
            "input": "appStore.state.posts.count == feedStore.posts.count",
            "expectedOutput": "true",
            "description": "App state should sync with feed store"
          }
        ]
      }
    },
    {
      "id": "advanced_notifications",
      "title": "Advanced Notifications",
      "description": "Master local and push notifications with advanced features like rich content, actions, and real-time delivery",
      "difficulty": "advanced",
      "theory": "# Advanced Notifications - Local & Push Notifications\n\n## 1. Notification Fundamentals & Architecture (60 min)\n\n### Notification System Architecture:\n```swift\n// iOS Notification Stack\nUNUserNotificationCenter (Local) â†â†’ APNs (Push) â†â†’ Your Server\n                     â†“\n              Device Delivery\n                     â†“\n            User Presentation\n```\n\n### Notification Types:\n- **Local Notifications**: Scheduled and delivered locally\n- **Push Notifications**: Delivered via Apple Push Notification service (APNs)\n- **Silent Notifications**: Background content delivery\n- **Critical Alerts**: Bypass Do Not Disturb and focus modes\n\n### Notification Payload Structure:\n```swift\nstruct NotificationPayload {\n    let aps: APSDictionary\n    let customData: [String: Any]\n    let media: AttachmentData?\n    let actions: [ActionData]?\n}\n\nstruct APSDictionary {\n    let alert: AlertDictionary\n    let sound: String?\n    let badge: Int?\n    let category: String?\n    let threadId: String?\n    let mutableContent: Int?\n    let contentAvailable: Int?\n    let targetContentId: String?\n}\n```\n\n## 2. Advanced Local Notifications (90 min)\n\n### Complex Notification Scheduling:\n```swift\nimport UserNotifications\n\nclass AdvancedNotificationScheduler {\n    private let center = UNUserNotificationCenter.current()\n    \n    // Calendar-based triggers\n    func scheduleDailyReminder(at hour: Int, minute: Int) {\n        var dateComponents = DateComponents()\n        dateComponents.hour = hour\n        dateComponents.minute = minute\n        \n        let trigger = UNCalendarNotificationTrigger(\n            dateMatching: dateComponents,\n            repeats: true\n        )\n        \n        let content = UNMutableNotificationContent()\n        content.title = \"Daily Reminder\"\n        content.body = \"Time for your daily check-in!\"\n        content.sound = .default\n        \n        let request = UNNotificationRequest(\n            identifier: \"daily-reminder\",\n            content: content,\n            trigger: trigger\n        )\n        \n        center.add(request)\n    }\n    \n    // Location-based triggers\n    func scheduleLocationBasedNotification() {\n        let center = CLLocationCoordinate2D(latitude: 37.7749, longitude: -122.4194)\n        let region = CLCircularRegion(\n            center: center,\n            radius: 100.0,\n            identifier: \"headquarters\"\n        )\n        region.notifyOnEntry = true\n        region.notifyOnExit = false\n        \n        let trigger = UNLocationNotificationTrigger(region: region, repeats: true)\n        \n        let content = UNMutableNotificationContent()\n        content.title = \"Welcome!\"\n        content.body = \"You've arrived at headquarters\"\n        \n        let request = UNNotificationRequest(\n            identifier: \"location-notification\",\n            content: content,\n            trigger: trigger\n        )\n        \n        center.add(request)\n    }\n    \n    // Time interval with conditions\n    func scheduleConditionalNotification() {\n        let trigger = UNTimeIntervalNotificationTrigger(\n            timeInterval: 3600, // 1 hour\n            repeats: true\n        )\n        \n        // Custom logic for conditional delivery\n        let content = UNMutableNotificationContent()\n        content.title = \"Conditional Notification\"\n        content.body = \"This only shows under specific conditions\"\n        content.userInfo = [\"condition\": \"needs_attention\"]\n        \n        let request = UNNotificationRequest(\n            identifier: \"conditional-notification\",\n            content: content,\n            trigger: trigger\n        )\n        \n        center.add(request)\n    }\n}\n```\n\n### Rich Notification Content:\n```swift\nclass RichNotificationManager {\n    \n    func scheduleMediaNotification() async throws {\n        // Download and attach media\n        let imageURL = URL(string: \"https://example.com/image.jpg\")!\n        let (data, _) = try await URLSession.shared.data(from: imageURL)\n        \n        let tempDir = FileManager.default.temporaryDirectory\n        let imageFileURL = tempDir.appendingPathComponent(UUID().uuidString + \".jpg\")\n        try data.write(to: imageFileURL)\n        \n        let attachment = try UNNotificationAttachment(\n            identifier: \"image-attachment\",\n            url: imageFileURL,\n            options: [\n                UNNotificationAttachmentOptionsTypeHintKey: kUTTypeJPEG\n            ]\n        )\n        \n        let content = UNMutableNotificationContent()\n        content.title = \"Rich Notification\"\n        content.body = \"This contains an image attachment\"\n        content.attachments = [attachment]\n        content.categoryIdentifier = \"MEDIA_CATEGORY\"\n        \n        let request = UNNotificationRequest(\n            identifier: \"rich-notification\",\n            content: content,\n            trigger: nil // Deliver immediately\n        )\n        \n        try await UNUserNotificationCenter.current().add(request)\n    }\n    \n    func createNotificationCategories() {\n        // Custom actions\n        let replyAction = UNTextInputNotificationAction(\n            identifier: \"REPLY_ACTION\",\n            title: \"Reply\",\n            options: [.foreground],\n            textInputButtonTitle: \"Send\",\n            textInputPlaceholder: \"Type your reply...\"\n        )\n        \n        let likeAction = UNNotificationAction(\n            identifier: \"LIKE_ACTION\",\n            title: \"Like\",\n            options: [.authenticationRequired]\n        )\n        \n        let shareAction = UNNotificationAction(\n            identifier: \"SHARE_ACTION\",\n            title: \"Share\",\n            options: [.foreground]\n        )\n        \n        // Category with actions\n        let socialCategory = UNNotificationCategory(\n            identifier: \"SOCIAL_CATEGORY\",\n            actions: [replyAction, likeAction, shareAction],\n            intentIdentifiers: [],\n            options: [.customDismissAction]\n        )\n        \n        UNUserNotificationCenter.current().setNotificationCategories([socialCategory])\n    }\n}\n```\n\n## 3. Advanced Push Notifications (90 min)\n\n### Server-Side Implementation:\n```swift\nimport Vapor\nimport APNS\n\nstruct PushNotificationService {\n    private let apns: APNSClient\n    \n    init() throws {\n        // Configure APNS with authentication\n        let authentication = APNSAuthentication(\n            key: .private(pem: Data(/* Your key */)),\n            keyIdentifier: \"KEY_ID\",\n            teamIdentifier: \"TEAM_ID\"\n        )\n        \n        self.apns = try APNSClient(\n            configuration: .init(\n                authentication: authentication,\n                environment: .production\n            )\n        )\n    }\n    \n    func sendAdvancedPush(to deviceToken: String, payload: NotificationPayload) async throws {\n        let alert = APNSAlertNotification(\n            alert: .init(\n                title: .raw(payload.title),\n                subtitle: .raw(payload.subtitle),\n                body: .raw(payload.body)\n            ),\n            expiration: .immediately,\n            priority: .immediately,\n            topic: \"com.yourapp.bundle\",\n            payload: payload.customData,\n            badge: payload.badge\n        )\n        \n        try await apns.sendAlertNotification(\n            alert,\n            to: deviceToken\n        )\n    }\n    \n    func sendSilentPush(to deviceToken: String, data: [String: Any]) async throws {\n        let silentNotification = APNSNotification(\n            expiration: .none,\n            priority: .consideringDevicePower,\n            topic: \"com.yourapp.bundle\",\n            payload: data,\n            badge: nil\n        )\n        \n        try await apns.sendNotification(\n            silentNotification,\n            to: deviceToken\n        )\n    }\n}\n```\n\n### Advanced Payload Configurations:\n```swift\nstruct AdvancedNotificationPayload {\n    \n    static func createRichMediaPayload() -> [String: Any] {\n        return [\n            \"aps\": [\n                \"alert\": [\n                    \"title\": \"Breaking News\",\n                    \"subtitle\": \"Important Update\",\n                    \"body\": \"Check out this breaking news story\"\n                ],\n                \"mutable-content\": 1,\n                \"category\": \"NEWS_CATEGORY\",\n                \"sound\": \"default\"\n            ],\n            \"media\": [\n                \"type\": \"image\",\n                \"url\": \"https://example.com/news-image.jpg\",\n                \"thumbnail\": \"https://example.com/thumb.jpg\"\n            ],\n            \"deep_link\": \"myapp://news/123\",\n            \"custom_data\": [\n                \"story_id\": \"123\",\n                \"author\": \"John Doe\",\n                \"published_at\": \"2023-12-07T10:30:00Z\"\n            ]\n        ]\n    }\n    \n    static func createCriticalAlertPayload() -> [String: Any] {\n        return [\n            \"aps\": [\n                \"alert\": [\n                    \"title\": \"CRITICAL ALERT\",\n                    \"body\": \"Emergency situation requires attention\"\n                ],\n                \"sound\": {\n                    \"critical\": 1,\n                    \"name\": \"critical-alert.caf\",\n                    \"volume\": 1.0\n                },\n                \"interruption-level\": \"critical\"\n            ]\n        ]\n    }\n    \n    static func createThreadedPayload() -> [String: Any] {\n        return [\n            \"aps\": [\n                \"alert\": [\n                    \"title\": \"New Message\",\n                    \"body\": \"You have a new message in the conversation\"\n                ],\n                \"thread-id\": \"conversation_123\",\n                \"summary-arg\": \"John Doe\",\n                \"summary-arg-count\": 1\n            ],\n            \"conversation_id\": \"123\",\n            \"message_count\": 5\n        ]\n    }\n}\n```\n\n## 4. Notification Service & Content Extensions (60 min)\n\n### Notification Service Extension:\n```swift\nimport UserNotifications\n\nclass NotificationService: UNNotificationServiceExtension {\n    \n    var contentHandler: ((UNNotificationContent) -> Void)?\n    var bestAttemptContent: UNMutableNotificationContent?\n    \n    override func didReceive(_ request: UNNotificationRequest, \n                           withContentHandler contentHandler: @escaping (UNNotificationContent) -> Void) {\n        self.contentHandler = contentHandler\n        self.bestAttemptContent = (request.content.mutableCopy() as? UNMutableNotificationContent)\n        \n        guard let content = bestAttemptContent else {\n            contentHandler(request.content)\n            return\n        }\n        \n        // Modify notification content before delivery\n        Task {\n            await processNotificationContent(content)\n        }\n    }\n    \n    private func processNotificationContent(_ content: UNMutableNotificationContent) async {\n        // Decrypt encrypted content\n        if let encryptedData = content.userInfo[\"encrypted_data\"] as? String {\n            let decryptedData = await decryptData(encryptedData)\n            content.title = decryptedData.title\n            content.body = decryptedData.body\n        }\n        \n        // Download and attach media\n        if let mediaURLString = content.userInfo[\"media_url\"] as? String,\n           let mediaURL = URL(string: mediaURLString) {\n            do {\n                let attachment = try await downloadAndCreateAttachment(from: mediaURL)\n                content.attachments = [attachment]\n            } catch {\n                print(\"Failed to download media: \" + error.localizedDescription)\n            }\n        }\n        \n        // Localize content\n        if let localizationKey = content.userInfo[\"localization_key\"] as? String {\n            content.title = NSLocalizedString(localizationKey + \"_title\", comment: \"\")\n            content.body = NSLocalizedString(localizationKey + \"_body\", comment: \"\")\n        }\n        \n        contentHandler?(content)\n    }\n    \n    private func downloadAndCreateAttachment(from url: URL) async throws -> UNNotificationAttachment {\n        let (data, _) = try await URLSession.shared.data(from: url)\n        \n        let tempDir = FileManager.default.temporaryDirectory\n        let fileURL = tempDir.appendingPathComponent(UUID().uuidString + \".tmp\")\n        \n        try data.write(to: fileURL)\n        \n        return try UNNotificationAttachment(\n            identifier: \"media\",\n            url: fileURL,\n            options: nil\n        )\n    }\n    \n    override func serviceExtensionTimeWillExpire() {\n        // Clean up and call content handler with best attempt\n        if let contentHandler = contentHandler, let bestAttemptContent = bestAttemptContent {\n            contentHandler(bestAttemptContent)\n        }\n    }\n}\n```\n\n### Notification Content Extension:\n```swift\nimport UIKit\nimport UserNotifications\nimport UserNotificationsUI\n\nclass CustomNotificationViewController: UIViewController, UNNotificationContentExtension {\n    \n    @IBOutlet private weak var titleLabel: UILabel!\n    @IBOutlet private weak var bodyLabel: UILabel!\n    @IBOutlet private weak var mediaImageView: UIImageView!\n    @IBOutlet private weak var actionStackView: UIStackView!\n    \n    private var notification: UNNotification?\n    \n    func didReceive(_ notification: UNNotification) {\n        self.notification = notification\n        \n        let content = notification.request.content\n        titleLabel.text = content.title\n        bodyLabel.text = content.body\n        \n        // Load custom media\n        if let mediaURL = content.userInfo[\"media_url\"] as? String {\n            loadMedia(from: mediaURL)\n        }\n        \n        // Setup custom actions\n        setupCustomActions()\n    }\n    \n    func didReceive(_ response: UNNotificationResponse, \n                   completionHandler completion: @escaping (UNNotificationContentExtensionResponseOption) -> Void) {\n        \n        switch response.actionIdentifier {\n        case \"CUSTOM_ACTION_1\":\n            handleCustomAction1()\n            completion(.doNotDismiss)\n            \n        case \"CUSTOM_ACTION_2\":\n            handleCustomAction2()\n            completion(.dismissAndForwardAction)\n            \n        case UNNotificationDefaultActionIdentifier:\n            // User tapped the notification\n            handleNotificationTap()\n            completion(.dismissAndForwardAction)\n            \n        default:\n            completion(.dismissAndForwardAction)\n        }\n    }\n    \n    private func loadMedia(from urlString: String) {\n        guard let url = URL(string: urlString) else { return }\n        \n        Task {\n            do {\n                let (data, _) = try await URLSession.shared.data(from: url)\n                let image = UIImage(data: data)\n                await MainActor.run {\n                    mediaImageView.image = image\n                }\n            } catch {\n                print(\"Failed to load media: \" + error.localizedDescription)\n            }\n        }\n    }\n    \n    private func setupCustomActions() {\n        // Add custom UI elements for actions\n        let customButton1 = UIButton(type: .system)\n        customButton1.setTitle(\"Quick Action 1\", for: .normal)\n        customButton1.addTarget(self, action: #selector(customAction1Tapped), for: .touchUpInside)\n        actionStackView.addArrangedSubview(customButton1)\n    }\n    \n    @objc private func customAction1Tapped() {\n        // Handle custom button tap\n        print(\"Custom action 1 tapped\")\n    }\n}\n```\n\n## 5. Advanced Delivery & Management (60 min)\n\n### Notification Delivery Optimization:\n```swift\nclass NotificationDeliveryManager {\n    private let center = UNUserNotificationCenter.current()\n    \n    // Batch notification management\n    func scheduleBatchNotifications(_ notifications: [NotificationRequest]) async {\n        let requests = notifications.map { notification in\n            UNNotificationRequest(\n                identifier: notification.id,\n                content: notification.content,\n                trigger: notification.trigger\n            )\n        }\n        \n        do {\n            for request in requests {\n                try await center.add(request)\n            }\n        } catch {\n            print(\"Failed to schedule batch notifications: \" + error.localizedDescription)\n        }\n    }\n    \n    // Smart notification grouping\n    func scheduleGroupedNotification(messages: [Message]) {\n        let content = UNMutableNotificationContent()\n        \n        if messages.count == 1 {\n            content.title = \"New Message\"\n            content.body = messages[0].text\n        } else {\n            content.title = \"Multiple Messages\"\n            content.body = \"You have \" + String(messages.count) + \" new messages\"\n            content.threadIdentifier = \"messages_thread\"\n        }\n        \n        content.summaryArgument = String(messages.count) + \" messages\"\n        content.summaryArgumentCount = messages.count\n        \n        let request = UNNotificationRequest(\n            identifier: \"grouped_notification\",\n            content: content,\n            trigger: nil\n        )\n        \n        center.add(request)\n    }\n    \n    // Delivery analytics\n    func trackNotificationDelivery(_ notificationId: String) {\n        // Track when notification is delivered\n        let deliveryEvent = NotificationDeliveryEvent(\n            notificationId: notificationId,\n            deliveryTime: Date(),\n            deviceId: UIDevice.current.identifierForVendor?.uuidString\n        )\n        \n        Analytics.track(event: .notificationDelivered, properties: deliveryEvent.asDictionary)\n    }\n}\n\n// Rate limiting and throttling\nclass NotificationThrottler {\n    private var deliveryTimes: [String: Date] = [:]\n    private let deliveryWindow: TimeInterval = 3600 // 1 hour\n    private let maxDeliveriesPerWindow = 5\n    \n    func shouldDeliverNotification(type: String) -> Bool {\n        let now = Date()\n        let recentDeliveries = deliveryTimes.filter { _, timestamp in\n            now.timeIntervalSince(timestamp) < deliveryWindow\n        }\n        \n        let typeDeliveries = recentDeliveries.filter { key, _ in\n            key.hasPrefix(type)\n        }\n        \n        return typeDeliveries.count < maxDeliveriesPerWindow\n    }\n    \n    func recordDelivery(type: String) {\n        let key = type + \"_\" + UUID().uuidString\n        deliveryTimes[key] = Date()\n        \n        // Clean up old entries\n        cleanupOldEntries()\n    }\n    \n    private func cleanupOldEntries() {\n        let now = Date()\n        deliveryTimes = deliveryTimes.filter { _, timestamp in\n            now.timeIntervalSince(timestamp) < deliveryWindow * 2\n        }\n    }\n}\n```\n\n## 6. Testing & Debugging (60 min)\n\n### Comprehensive Testing Suite:\n```swift\nimport XCTest\n@testable import YourApp\n\nclass NotificationTests: XCTestCase {\n    \n    var notificationManager: NotificationManager!\n    var mockCenter: MockUserNotificationCenter!\n    \n    override func setUp() {\n        super.setUp()\n        mockCenter = MockUserNotificationCenter()\n        notificationManager = NotificationManager(center: mockCenter)\n    }\n    \n    func testNotificationScheduling() async {\n        // Given\n        let notification = NotificationRequest(\n            id: \"test-notification\",\n            title: \"Test Title\",\n            body: \"Test Body\",\n            trigger: .timeInterval(60)\n        )\n        \n        // When\n        await notificationManager.scheduleNotification(notification)\n        \n        // Then\n        XCTAssertTrue(mockCenter.addedRequests.contains { $0.identifier == \"test-notification\" })\n    }\n    \n    func testNotificationPermissions() async {\n        // Given\n        mockCenter.authorizationStatus = .notDetermined\n        \n        // When\n        let granted = await notificationManager.requestPermissions()\n        \n        // Then\n        XCTAssertTrue(mockCenter.requestAuthorizationCalled)\n        XCTAssertEqual(granted, true)\n    }\n    \n    func testNotificationDeliveryTracking() {\n        // Given\n        let expectation = self.expectation(description: \"Delivery tracked\")\n        \n        // When\n        notificationManager.trackDelivery(\"test-notification\")\n        \n        // Then\n        // Verify analytics event was sent\n        DispatchQueue.main.asyncAfter(deadline: .now() + 1) {\n            expectation.fulfill()\n        }\n        \n        waitForExpectations(timeout: 2)\n    }\n}\n\n// Mock for testing\nclass MockUserNotificationCenter: UNUserNotificationCenter {\n    var addedRequests: [UNNotificationRequest] = []\n    var requestAuthorizationCalled = false\n    var authorizationStatus: UNAuthorizationStatus = .authorized\n    \n    override func add(_ request: UNNotificationRequest) async throws {\n        addedRequests.append(request)\n    }\n    \n    override func requestAuthorization(options: UNAuthorizationOptions = []) async throws -> Bool {\n        requestAuthorizationCalled = true\n        return authorizationStatus == .authorized\n    }\n    \n    override func getNotificationSettings() async -> UNNotificationSettings {\n        return MockNotificationSettings(authorizationStatus: authorizationStatus)\n    }\n}\n\nclass MockNotificationSettings: UNNotificationSettings {\n    private let mockStatus: UNAuthorizationStatus\n    \n    init(authorizationStatus: UNAuthorizationStatus) {\n        self.mockStatus = authorizationStatus\n        super.init()\n    }\n    \n    override var authorizationStatus: UNAuthorizationStatus {\n        return mockStatus\n    }\n}\n```\n\n### Debugging Tools:\n```swift\nclass NotificationDebugger {\n    \n    static func printNotificationStatus() async {\n        let center = UNUserNotificationCenter.current()\n        let settings = await center.notificationSettings()\n        let pendingRequests = await center.pendingNotificationRequests()\n        \n        print(\"=== NOTIFICATION DEBUG INFO ===\")\n        print(\"Authorization Status: \" + String(describing: settings.authorizationStatus))\n        print(\"Pending Requests: \" + String(pendingRequests.count))\n        \n        for request in pendingRequests {\n            print(\" - \" + request.identifier + \": \" + request.content.title)\n            if let trigger = request.trigger {\n                print(\"   Trigger: \" + String(describing: trigger))\n            }\n        }\n    }\n    \n    static func simulateNotificationDelivery(_ notification: UNNotificationContent) {\n        // Useful for testing in simulator\n        let userInfo: [AnyHashable: Any] = [\n            \"simulated\": true,\n            \"content\": [\n                \"title\": notification.title,\n                \"body\": notification.body,\n                \"userInfo\": notification.userInfo\n            ]\n        ]\n        \n        NotificationCenter.default.post(\n            name: Notification.Name(\"SimulatedNotification\"),\n            object: nil,\n            userInfo: userInfo\n        )\n    }\n}\n```",
      "codeExample": "import UserNotifications\nimport UIKit\nimport Combine\n\n// === ADVANCED NOTIFICATION MANAGER ===\nclass AdvancedNotificationManager: NSObject, ObservableObject {\n    \n    static let shared = AdvancedNotificationManager()\n    \n    private let center = UNUserNotificationCenter.current()\n    private var cancellables = Set<AnyCancellable>()\n    \n    @Published var authorizationStatus: UNAuthorizationStatus = .notDetermined\n    @Published var pendingNotifications: [UNNotificationRequest] = []\n    @Published var deliveredNotifications: [UNNotification] = []\n    \n    private override init() {\n        super.init()\n        center.delegate = self\n        setupObservers()\n        refreshStatus()\n    }\n    \n    private func setupObservers() {\n        // Observe app state changes\n        NotificationCenter.default.publisher(for: UIApplication.didBecomeActiveNotification)\n            .sink { [weak self] _ in\n                self?.refreshStatus()\n            }\n            .store(in: &cancellables)\n    }\n    \n    func refreshStatus() {\n        Task {\n            let settings = await center.notificationSettings()\n            await MainActor.run {\n                authorizationStatus = settings.authorizationStatus\n            }\n            \n            let pending = await center.pendingNotificationRequests()\n            await MainActor.run {\n                pendingNotifications = pending\n            }\n            \n            let delivered = await center.deliveredNotifications()\n            await MainActor.run {\n                deliveredNotifications = delivered\n            }\n        }\n    }\n    \n    // === PERMISSION MANAGEMENT ===\n    func requestFullAuthorization() async throws -> Bool {\n        let options: UNAuthorizationOptions = [\n            .alert,\n            .badge,\n            .sound,\n            .carPlay,\n            .criticalAlert,\n            .providesAppNotificationSettings,\n            .provisional\n        ]\n        \n        let granted = try await center.requestAuthorization(options: options)\n        await MainActor.run {\n            authorizationStatus = granted ? .authorized : .denied\n        }\n        \n        if granted {\n            registerCustomCategories()\n        }\n        \n        return granted\n    }\n    \n    func requestCriticalAlertAuthorization() async throws -> Bool {\n        let options: UNAuthorizationOptions = [.criticalAlert]\n        return try await center.requestAuthorization(options: options)\n    }\n    \n    // === CUSTOM CATEGORIES & ACTIONS ===\n    private func registerCustomCategories() {\n        // Message category with reply\n        let replyAction = UNTextInputNotificationAction(\n            identifier: \"REPLY_ACTION\",\n            title: \"Reply\",\n            options: [.foreground],\n            textInputButtonTitle: \"Send\",\n            textInputPlaceholder: \"Type your message...\"\n        )\n        \n        let messageCategory = UNNotificationCategory(\n            identifier: \"MESSAGE_CATEGORY\",\n            actions: [replyAction],\n            intentIdentifiers: [],\n            options: [.customDismissAction]\n        )\n        \n        // Media category with actions\n        let saveAction = UNNotificationAction(\n            identifier: \"SAVE_MEDIA\",\n            title: \"Save\",\n            options: [.authenticationRequired]\n        )\n        \n        let shareAction = UNNotificationAction(\n            identifier: \"SHARE_MEDIA\",\n            title: \"Share\",\n            options: [.foreground]\n        )\n        \n        let mediaCategory = UNNotificationCategory(\n            identifier: \"MEDIA_CATEGORY\",\n            actions: [saveAction, shareAction],\n            intentIdentifiers: [],\n            options: [.hiddenPreviewsShowTitle]\n        )\n        \n        center.setNotificationCategories([messageCategory, mediaCategory])\n    }\n    \n    // === ADVANCED SCHEDULING ===\n    func scheduleConditionalNotification(\n        _ condition: @escaping () async -> Bool,\n        content: UNNotificationContent,\n        retryInterval: TimeInterval = 3600\n    ) async {\n        guard await condition() else {\n            // Schedule retry\n            let trigger = UNTimeIntervalNotificationTrigger(\n                timeInterval: retryInterval,\n                repeats: false\n            )\n            \n            let retryContent = content.mutableCopy() as! UNMutableNotificationContent\n            retryContent.body = \"Conditional: \" + content.body\n            \n            let request = UNNotificationRequest(\n                identifier: \"conditional-retry-\" + UUID().uuidString,\n                content: retryContent,\n                trigger: trigger\n            )\n            \n            try? await center.add(request)\n            return\n        }\n        \n        let request = UNNotificationRequest(\n            identifier: \"conditional-\" + UUID().uuidString,\n            content: content,\n            trigger: nil // Deliver immediately\n        )\n        \n        try? await center.add(request)\n    }\n    \n    func scheduleRecurringNotification(\n        with content: UNNotificationContent,\n        frequency: RecurringFrequency,\n        startDate: Date = Date()\n    ) {\n        let calendar = Calendar.current\n        var dateComponents = calendar.dateComponents([.hour, .minute], from: startDate)\n        \n        switch frequency {\n        case .daily:\n            break // Already have hour and minute\n        case .weekly(let weekday):\n            dateComponents.weekday = weekday.rawValue\n        case .monthly(let day):\n            dateComponents.day = day\n        case .yearly(let month, let day):\n            dateComponents.month = month\n            dateComponents.day = day\n        }\n        \n        let trigger = UNCalendarNotificationTrigger(\n            dateMatching: dateComponents,\n            repeats: true\n        )\n        \n        let request = UNNotificationRequest(\n            identifier: \"recurring-\" + UUID().uuidString,\n            content: content,\n            trigger: trigger\n        )\n        \n        Task {\n            try? await center.add(request)\n        }\n    }\n    \n    // === NOTIFICATION GROUPS & THREADS ===\n    func scheduleThreadedNotification(\n        threadId: String,\n        messages: [Message],\n        summaryFormat: String = \"%u new messages\"\n    ) {\n        let content = UNMutableNotificationContent()\n        \n        if let latestMessage = messages.last {\n            content.title = latestMessage.sender\n            content.body = latestMessage.text\n        }\n        \n        content.threadIdentifier = threadId\n        content.summaryArgument = String(messages.count)\n        content.summaryArgumentCount = messages.count\n        \n        if let summaryFormat = summaryFormat as? String {\n            // Custom summary formatting\n            content.categoryIdentifier = \"THREADED_CATEGORY\"\n        }\n        \n        let request = UNNotificationRequest(\n            identifier: \"threaded-\" + threadId,\n            content: content,\n            trigger: nil\n        )\n        \n        Task {\n            try? await center.add(request)\n        }\n    }\n    \n    // === BATCH OPERATIONS ===\n    func scheduleBatchNotifications(_ notifications: [BatchNotification]) async {\n        await withThrowingTaskGroup(of: Void.self) { group in\n            for notification in notifications {\n                group.addTask {\n                    let request = UNNotificationRequest(\n                        identifier: notification.id,\n                        content: notification.content,\n                        trigger: notification.trigger\n                    )\n                    try await self.center.add(request)\n                }\n            }\n            \n            // Wait for all to complete\n            for try await _ in group {}\n        }\n        \n        await refreshStatus()\n    }\n    \n    func removeNotifications(withIdentifiers identifiers: [String]) async {\n        await center.removePendingNotificationRequests(withIdentifiers: identifiers)\n        await center.removeDeliveredNotifications(withIdentifiers: identifiers)\n        await refreshStatus()\n    }\n    \n    func clearAllNotifications() async {\n        center.removeAllPendingNotificationRequests()\n        center.removeAllDeliveredNotifications()\n        await refreshStatus()\n    }\n}\n\n// MARK: - UNUserNotificationCenterDelegate\nextension AdvancedNotificationManager: UNUserNotificationCenterDelegate {\n    \n    func userNotificationCenter(_ center: UNUserNotificationCenter, \n                               willPresent notification: UNNotification) async -> UNNotificationPresentationOptions {\n        // Determine how to present notification while app is in foreground\n        let userInfo = notification.request.content.userInfo\n        \n        if userInfo[\"forcePresentation\"] as? Bool == true {\n            return [.banner, .sound, .badge]\n        }\n        \n        // Custom logic based on notification type\n        switch notification.request.content.categoryIdentifier {\n        case \"CRITICAL_CATEGORY\":\n            return [.banner, .sound, .badge, .list]\n        case \"SILENT_CATEGORY\":\n            return []\n        default:\n            return [.banner, .sound]\n        }\n    }\n    \n    func userNotificationCenter(_ center: UNUserNotificationCenter, \n                               didReceive response: UNNotificationResponse) async {\n        let userInfo = response.notification.request.content.userInfo\n        let actionIdentifier = response.actionIdentifier\n        \n        // Handle custom actions\n        switch actionIdentifier {\n        case \"REPLY_ACTION\":\n            if let textResponse = response as? UNTextInputNotificationResponse {\n                await handleReply(textResponse.userText, for: userInfo)\n            }\n        case \"SAVE_MEDIA\":\n            await handleSaveMedia(userInfo)\n        case \"SHARE_MEDIA\":\n            await handleShareMedia(userInfo)\n        case UNNotificationDefaultActionIdentifier:\n            await handleNotificationTap(userInfo)\n        case UNNotificationDismissActionIdentifier:\n            await handleNotificationDismiss(userInfo)\n        default:\n            break\n        }\n        \n        // Track engagement\n        await trackNotificationEngagement(response)\n    }\n    \n    func userNotificationCenter(_ center: UNUserNotificationCenter, \n                               openSettingsFor notification: UNNotification?) {\n        // Handle notification settings deep link\n        if let notification = notification {\n            // Open specific notification settings\n            showNotificationSettings(for: notification)\n        } else {\n            // Open general notification settings\n            showGeneralNotificationSettings()\n        }\n    }\n    \n    private func handleReply(_ text: String, for userInfo: [AnyHashable: Any]) async {\n        // Process reply text\n        print(\"User replied: \" + text)\n        \n        // Send reply to server\n        if let messageId = userInfo[\"message_id\"] as? String {\n            await sendReply(text, forMessage: messageId)\n        }\n    }\n    \n    private func handleNotificationTap(_ userInfo: [AnyHashable: Any]) async {\n        // Navigate to relevant screen\n        if let deepLink = userInfo[\"deep_link\"] as? String {\n            await handleDeepLink(deepLink)\n        }\n    }\n    \n    private func trackNotificationEngagement(_ response: UNNotificationResponse) async {\n        let analytics = NotificationAnalytics()\n        await analytics.trackEngagement(\n            notificationId: response.notification.request.identifier,\n            action: response.actionIdentifier,\n            userText: (response as? UNTextInputNotificationResponse)?.userText\n        )\n    }\n}\n\n// MARK: - Supporting Types\nenum RecurringFrequency {\n    case daily\n    case weekly(Weekday)\n    case monthly(day: Int)\n    case yearly(month: Int, day: Int)\n}\n\nenum Weekday: Int {\n    case sunday = 1, monday, tuesday, wednesday, thursday, friday, saturday\n}\n\nstruct BatchNotification {\n    let id: String\n    let content: UNNotificationContent\n    let trigger: UNNotificationTrigger?\n}\n\nstruct Message {\n    let id: String\n    let sender: String\n    let text: String\n    let timestamp: Date\n}\n\n// MARK: - Analytics\nclass NotificationAnalytics {\n    func trackEngagement(notificationId: String, action: String, userText: String?) async {\n        // Send to analytics service\n        let event = EngagementEvent(\n            notificationId: notificationId,\n            action: action,\n            userText: userText,\n            timestamp: Date()\n        )\n        \n        // Implementation depends on your analytics service\n        print(\"Tracked engagement: \" + event.description)\n    }\n}\n\nstruct EngagementEvent {\n    let notificationId: String\n    let action: String\n    let userText: String?\n    let timestamp: Date\n}\n\n// === USAGE EXAMPLES ===\nclass NotificationExamples {\n    \n    let manager = AdvancedNotificationManager.shared\n    \n    func demonstrateAdvancedFeatures() async {\n        // Request comprehensive permissions\n        let granted = try? await manager.requestFullAuthorization()\n        \n        guard granted == true else { return }\n        \n        // Schedule a conditional notification\n        let content = UNMutableNotificationContent()\n        content.title = \"Conditional Alert\"\n        content.body = \"This only shows under specific conditions\"\n        \n        await manager.scheduleConditionalNotification(\n            { [weak self] in\n                return await self?.checkSomeCondition() ?? false\n            },\n            content: content\n        )\n        \n        // Schedule recurring notification\n        let recurringContent = UNMutableNotificationContent()\n        recurringContent.title = \"Daily Reminder\"\n        recurringContent.body = \"Don't forget your daily task!\"\n        \n        manager.scheduleRecurringNotification(\n            with: recurringContent,\n            frequency: .daily,\n            startDate: Date()\n        )\n    }\n    \n    private func checkSomeCondition() async -> Bool {\n        // Implement your condition logic\n        return true\n    }\n}",
      "category": "iOS System Frameworks",
      "estimatedTime": 240,
      "dependencies": ["swift_concurrency", "networking", "core_data"],
      "challenge": {
        "instructions": "Build a comprehensive notification system for a messaging app with advanced features:\n\nPART 1: Advanced Permission System (60 min)\n1. Implement granular permission requests with custom explanations\n2. Create a permission flow that handles provisional and critical alerts\n3. Build a settings screen to manage notification preferences\n\nPART 2: Rich Media Notifications (90 min)\n4. Create a notification service extension that downloads and encrypts media\n5. Implement a content extension for custom notification UI\n6. Add support for video, audio, and image attachments\n7. Create a media cache system for notification attachments\n\nPART 3: Smart Notification Delivery (90 min)\n8. Implement a delivery optimization system with rate limiting\n9. Create a notification grouping system for threaded conversations\n10. Build a smart scheduling system that considers user activity\n11. Add delivery analytics and engagement tracking\n\nPART 4: Server Integration (90 min)\n12. Create a push notification service with authentication\n13. Implement silent notifications for background content sync\n14. Build a notification preference sync system\n15. Add support for targeted and A/B test notifications\n\nPART 5: Testing & Debugging (60 min)\n16. Create comprehensive unit tests for all notification features\n17. Build a debug panel for testing notification scenarios\n18. Implement end-to-end testing with mock APNs server",
        "starterCode": "import UserNotifications\nimport UIKit\n\n// === PART 1: Advanced Permission System ===\n// Implement granular permission management\n\n\n// === PART 2: Rich Media Notifications ===\n// Create service and content extensions\n\n\n// === PART 3: Smart Notification Delivery ===\n// Implement delivery optimization\n\n\n// === PART 4: Server Integration ===\n// Build push notification service\n\n\n// === PART 5: Testing & Debugging ===\n// Create test suite and debug tools\n\n",
        "solution": "import UserNotifications\nimport UIKit\nimport CryptoKit\nimport Combine\n\n// === PART 1: Advanced Permission System ===\nclass GranularNotificationManager: ObservableObject {\n    \n    @Published var permissions: NotificationPermissions = .init()\n    private let center = UNUserNotificationCenter.current()\n    \n    struct NotificationPermissions {\n        var basicAlerts: Bool = false\n        var sounds: Bool = false\n        var badges: Bool = false\n        var criticalAlerts: Bool = false\n        var provisional: Bool = false\n        var inAppAlerts: Bool = false\n    }\n    \n    func requestGranularPermissions() async -> Bool {\n        let currentSettings = await center.notificationSettings()\n        \n        // Build options based on current status and app needs\n        var options: UNAuthorizationOptions = []\n        \n        if !permissions.basicAlerts {\n            options.insert(.alert)\n        }\n        if !permissions.sounds {\n            options.insert(.sound)\n        }\n        if !permissions.badges {\n            options.insert(.badge)\n        }\n        if currentSettings.authorizationStatus == .provisional {\n            options.insert(.provisional)\n        }\n        \n        // Only request critical alerts if specifically needed\n        if await shouldRequestCriticalAlerts() {\n            options.insert(.criticalAlert)\n        }\n        \n        let granted = try? await center.requestAuthorization(options: options)\n        await updatePermissionsStatus()\n        return granted ?? false\n    }\n    \n    private func shouldRequestCriticalAlerts() async -> Bool {\n        // Implement logic to determine if critical alerts are appropriate\n        return false // Placeholder\n    }\n    \n    private func updatePermissionsStatus() async {\n        let settings = await center.notificationSettings()\n        await MainActor.run {\n            permissions.basicAlerts = settings.alertSetting == .enabled\n            permissions.sounds = settings.soundSetting == .enabled\n            permissions.badges = settings.badgeSetting == .enabled\n            permissions.criticalAlerts = settings.criticalAlertSetting == .enabled\n        }\n    }\n}\n\n// === PART 2: Rich Media Notifications ===\nclass SecureMediaNotificationService: UNNotificationServiceExtension {\n    \n    override func didReceive(_ request: UNNotificationRequest, \n                           withContentHandler contentHandler: @escaping (UNNotificationContent) -> Void) {\n        \n        let content = request.content.mutableCopy() as! UNMutableNotificationContent\n        \n        Task {\n            // Handle encrypted media\n            if let encryptedMedia = content.userInfo[\"encrypted_media\"] as? [String: Any] {\n                await processEncryptedMedia(encryptedMedia, for: content)\n            }\n            \n            // Download and attach media\n            if let mediaURL = content.userInfo[\"media_url\"] as? String {\n                await attachMedia(from: mediaURL, to: content)\n            }\n            \n            contentHandler(content)\n        }\n    }\n    \n    private func processEncryptedMedia(_ mediaData: [String: Any], for content: UNMutableNotificationContent) async {\n        guard let encryptedData = mediaData[\"data\"] as? Data,\n              let key = mediaData[\"key\"] as? String else { return }\n        \n        do {\n            let decryptedData = try await decryptMedia(encryptedData, with: key)\n            let tempURL = FileManager.default.temporaryDirectory\n                .appendingPathComponent(UUID().uuidString + \".media\")\n            \n            try decryptedData.write(to: tempURL)\n            \n            let attachment = try UNNotificationAttachment(\n                identifier: \"secure-media\",\n                url: tempURL\n            )\n            \n            content.attachments = [attachment]\n        } catch {\n            print(\"Failed to decrypt media: \" + error.localizedDescription)\n        }\n    }\n    \n    private func decryptMedia(_ data: Data, with key: String) async throws -> Data {\n        // Implement media decryption\n        return data // Placeholder\n    }\n    \n    private func attachMedia(from urlString: String, to content: UNMutableNotificationContent) async {\n        guard let url = URL(string: urlString) else { return }\n        \n        do {\n            let (data, _) = try await URLSession.shared.data(from: url)\n            let tempURL = FileManager.default.temporaryDirectory\n                .appendingPathComponent(UUID().uuidString + \".media\")\n            \n            try data.write(to: tempURL)\n            \n            let attachment = try UNNotificationAttachment(\n                identifier: \"downloaded-media\",\n                url: tempURL\n            )\n            \n            content.attachments = [attachment]\n        } catch {\n            print(\"Failed to download media: \" + error.localizedDescription)\n        }\n    }\n}\n\n// === PART 3: Smart Notification Delivery ===\nclass SmartDeliveryManager {\n    \n    private let center = UNUserNotificationCenter.current()\n    private let userActivityTracker: UserActivityTracker\n    private let rateLimiter: NotificationRateLimiter\n    \n    init() {\n        self.userActivityTracker = UserActivityTracker()\n        self.rateLimiter = NotificationRateLimiter()\n    }\n    \n    func scheduleOptimalNotification(_ content: UNNotificationContent) async {\n        // Check rate limiting\n        guard rateLimiter.canDeliverNotification(type: content.categoryIdentifier) else {\n            print(\"Rate limited: \" + content.categoryIdentifier)\n            return\n        }\n        \n        // Check user activity\n        let userStatus = await userActivityTracker.currentUserStatus()\n        let optimalTime = calculateOptimalDeliveryTime(for: userStatus)\n        \n        let trigger = UNTimeIntervalNotificationTrigger(\n            timeInterval: optimalTime.timeIntervalSinceNow,\n            repeats: false\n        )\n        \n        let request = UNNotificationRequest(\n            identifier: UUID().uuidString,\n            content: content,\n            trigger: trigger\n        )\n        \n        try? await center.add(request)\n        rateLimiter.recordDelivery(type: content.categoryIdentifier)\n    }\n    \n    private func calculateOptimalDeliveryTime(for userStatus: UserStatus) -> Date {\n        switch userStatus {\n        case .active:\n            return Date().addingTimeInterval(300) // 5 minutes\n        case .idle:\n            return Date().addingTimeInterval(60) // 1 minute\n        case .inactive:\n            return Date() // Immediate\n        case .sleeping:\n            return Calendar.current.nextDate(\n                after: Date(),\n                matching: DateComponents(hour: 9),\n                matchingPolicy: .nextTime\n            ) ?? Date().addingTimeInterval(3600) // Next 9 AM\n        }\n    }\n}\n\n// === PART 4: Server Integration ===\nclass PushNotificationService {\n    \n    private let serverURL: URL\n    private let authManager: AuthManager\n    \n    func registerDeviceForPush(token: Data) async throws {\n        let deviceToken = token.map { String(format: \"%02.2hhx\", $0) }.joined()\n        \n        let registration = DeviceRegistration(\n            token: deviceToken,\n            platform: \"ios\",\n            appVersion: Bundle.main.version,\n            preferences: await loadUserPreferences()\n        )\n        \n        try await sendRegistrationToServer(registration)\n    }\n    \n    private func sendRegistrationToServer(_ registration: DeviceRegistration) async throws {\n        var request = URLRequest(url: serverURL.appendingPathComponent(\"devices/register\"))\n        request.httpMethod = \"POST\"\n        request.setValue(\"application/json\", forHTTPHeaderField: \"Content-Type\")\n        request.setValue(\"Bearer \" + authManager.authToken, forHTTPHeaderField: \"Authorization\")\n        \n        let encoder = JSONEncoder()\n        request.httpBody = try encoder.encode(registration)\n        \n        let (_, response) = try await URLSession.shared.data(for: request)\n        \n        guard let httpResponse = response as? HTTPURLResponse,\n              httpResponse.statusCode == 200 else {\n            throw PushRegistrationError.serverError\n        }\n    }\n}\n\n// === PART 5: Testing & Debugging ===\nclass NotificationTestSuite {\n    \n    func runAllTests() async {\n        await testPermissionFlow()\n        await testNotificationDelivery()\n        await testMediaAttachments()\n        await testServerIntegration()\n    }\n    \n    private func testPermissionFlow() async {\n        let manager = GranularNotificationManager()\n        let granted = await manager.requestGranularPermissions()\n        \n        XCTAssertTrue(granted, \"Permission request should succeed\")\n        \n        let settings = await UNUserNotificationCenter.current().notificationSettings()\n        XCTAssertTrue(settings.authorizationStatus == .authorized, \"Should be authorized\")\n    }\n    \n    private func testNotificationDelivery() async {\n        let content = UNMutableNotificationContent()\n        content.title = \"Test Notification\"\n        content.body = \"This is a test\"\n        \n        let request = UNNotificationRequest(\n            identifier: \"test-delivery\",\n            content: content,\n            trigger: nil\n        )\n        \n        do {\n            try await UNUserNotificationCenter.current().add(request)\n            \n            let pending = await UNUserNotificationCenter.current().pendingNotificationRequests()\n            XCTAssertTrue(pending.contains { $0.identifier == \"test-delivery\" }, \"Notification should be scheduled\")\n        } catch {\n            XCTFail(\"Failed to schedule notification: \" + error.localizedDescription)\n        }\n    }\n}\n\n// Supporting types and extensions\nstruct DeviceRegistration: Codable {\n    let token: String\n    let platform: String\n    let appVersion: String\n    let preferences: UserPreferences\n}\n\nstruct UserPreferences: Codable {\n    let receivePromotions: Bool\n    let quietHours: QuietHours?\n    let categories: [String: Bool]\n}\n\nstruct QuietHours: Codable {\n    let start: Date\n    let end: Date\n}\n\nenum UserStatus {\n    case active, idle, inactive, sleeping\n}\n\nclass UserActivityTracker {\n    func currentUserStatus() async -> UserStatus {\n        // Implement user activity detection\n        return .active // Placeholder\n    }\n}\n\nclass NotificationRateLimiter {\n    private var deliveryCounts: [String: Int] = [:]\n    private let limits: [String: Int] = [\n        \"social\": 10,\n        \"promotional\": 3,\n        \"urgent\": 20\n    ]\n    \n    func canDeliverNotification(type: String) -> Bool {\n        let count = deliveryCounts[type, default: 0]\n        let limit = limits[type, default: 5]\n        return count < limit\n    }\n    \n    func recordDelivery(type: String) {\n        deliveryCounts[type, default: 0] += 1\n    }\n    \n    func resetCounts() {\n        deliveryCounts.removeAll()\n    }\n}\n\nenum PushRegistrationError: Error {\n    case serverError\n    case invalidToken\n}\n\nextension Bundle {\n    var version: String {\n        return infoDictionary?[\"CFBundleShortVersionString\"] as? String ?? \"Unknown\"\n    }\n}\n\n// Test helpers\nfunc XCTAssertTrue(_ condition: Bool, _ message: String) {\n    if !condition {\n        print(\"TEST FAILED: \" + message)\n    } else {\n        print(\"TEST PASSED: \" + message)\n    }\n}\n\nfunc XCTFail(_ message: String) {\n    print(\"TEST FAILED: \" + message)\n}",
        "hints": [
          "PART 1: Use UNAuthorizationOptions to request specific permission types",
          "PART 2: UNNotificationServiceExtension runs in separate process - handle timeouts",
          "PART 3: Consider user timezone, activity patterns, and notification importance",
          "PART 4: Always validate device tokens and handle token updates",
          "PART 5: Use UNUserNotificationCenter.current() for testing real notification behavior",
          "Remember to handle notification tap actions and deep linking",
          "Use threadIdentifier for grouping related notifications",
          "Implement proper error handling for network requests in extensions"
        ],
        "testCases": [
          {
            "input": "permissions.basicAlerts == true",
            "expectedOutput": "true",
            "description": "Basic alert permissions should be granted"
          },
          {
            "input": "rateLimiter.canDeliverNotification(type: \"social\")",
            "expectedOutput": "true",
            "description": "Should respect rate limits for notification types"
          },
          {
            "input": "content.attachments.count <= 1",
            "expectedOutput": "true",
            "description": "Should support at least one media attachment"
          }
        ]
      }
    },
    {
      "id": "location_services",
      "title": "Location Services & Geofencing",
      "description": "Master advanced Core Location techniques including geofencing, region monitoring, and background location updates",
      "difficulty": "advanced",
      "theory": "# Advanced Location Services & Geofencing\n\n## 1. Core Location Fundamentals (60 min)\n\n### Location Manager Setup:\n```swift\nimport CoreLocation\n\nclass LocationManager: NSObject, ObservableObject {\n    private let locationManager = CLLocationManager()\n    \n    @Published var authorizationStatus: CLAuthorizationStatus\n    @Published var lastLocation: CLLocation?\n    @Published var locationsHistory: [CLLocation] = []\n    \n    override init() {\n        authorizationStatus = locationManager.authorizationStatus\n        super.init()\n        locationManager.delegate = self\n        locationManager.desiredAccuracy = kCLLocationAccuracyBest\n        locationManager.distanceFilter = 10.0 // Update only when moving 10 meters\n    }\n}\n```\n\n### Authorization Types:\n- **WhenInUse**: Location access only when app is active\n- **Always**: Background location access\n- **Temporary Full Accuracy**: Precise location for limited time\n\n### Accuracy Levels:\n```swift\nlocationManager.desiredAccuracy = kCLLocationAccuracyBestForNavigation\nlocationManager.desiredAccuracy = kCLLocationAccuracyBest\nlocationManager.desiredAccuracy = kCLLocationAccuracyNearestTenMeters\nlocationManager.desiredAccuracy = kCLLocationAccuracyHundredMeters\nlocationManager.desiredAccuracy = kCLLocationAccuracyKilometer\nlocationManager.desiredAccuracy = kCLLocationAccuracyThreeKilometers\n```\n\n## 2. Advanced Location Monitoring (90 min)\n\n### Significant Location Changes:\n```swift\nclass SignificantLocationMonitor {\n    func startMonitoringSignificantChanges() {\n        locationManager.startMonitoringSignificantLocationChanges()\n    }\n    \n    func stopMonitoringSignificantChanges() {\n        locationManager.stopMonitoringSignificantLocationChanges()\n    }\n}\n```\n\n### Visit Monitoring:\n```swift\nextension LocationManager: CLLocationManagerDelegate {\n    func locationManager(_ manager: CLLocationManager, didVisit visit: CLVisit) {\n        let arrivalDate = visit.arrivalDate\n        let departureDate = visit.departureDate\n        let coordinate = visit.coordinate\n        \n        if visit.departureDate == Date.distantFuture {\n            // User arrived at location\n            handleVisitArrival(at: coordinate, arrivalDate: arrivalDate)\n        } else {\n            // User departed from location\n            handleVisitDeparture(from: coordinate, \n                               arrivalDate: arrivalDate, \n                               departureDate: departureDate)\n        }\n    }\n}\n```\n\n### Background Location Updates:\n```swift\nclass BackgroundLocationManager {\n    func configureBackgroundUpdates() {\n        locationManager.allowsBackgroundLocationUpdates = true\n        locationManager.pausesLocationUpdatesAutomatically = false\n        \n        // For fitness apps\n        locationManager.activityType = .fitness\n        \n        // For navigation apps\n        locationManager.activityType = .automotiveNavigation\n    }\n    \n    func startBackgroundUpdates() {\n        locationManager.startUpdatingLocation()\n    }\n    \n    func stopBackgroundUpdates() {\n        locationManager.stopUpdatingLocation()\n    }\n}\n```\n\n## 3. Geofencing & Region Monitoring (120 min)\n\n### Circular Region Monitoring:\n```swift\nclass GeofenceManager {\n    func addCircularGeofence(center: CLLocationCoordinate2D, \n                           radius: CLLocationDistance, \n                           identifier: String) {\n        \n        let region = CLCircularRegion(center: center, \n                                    radius: radius, \n                                    identifier: identifier)\n        \n        region.notifyOnEntry = true\n        region.notifyOnExit = true\n        \n        locationManager.startMonitoring(for: region)\n    }\n    \n    func removeGeofence(identifier: String) {\n        let regions = locationManager.monitoredRegions\n        if let region = regions.first(where: { $0.identifier == identifier }) {\n            locationManager.stopMonitoring(for: region)\n        }\n    }\n}\n```\n\n### Beacon Region Monitoring:\n```swift\nclass BeaconManager {\n    func startMonitoringBeaconRegion(uuid: UUID, \n                                   major: CLBeaconMajorValue? = nil,\n                                   minor: CLBeaconMinorValue? = nil,\n                                   identifier: String) {\n        \n        let constraint = CLBeaconIdentityConstraint(uuid: uuid, \n                                                  major: major, \n                                                  minor: minor)\n        let region = CLBeaconRegion(beaconIdentityConstraint: constraint, \n                                  identifier: identifier)\n        \n        locationManager.startMonitoring(for: region)\n        locationManager.startRangingBeacons(satisfying: constraint)\n    }\n}\n```\n\n### Advanced Region Configuration:\n```swift\nstruct SmartGeofence {\n    let center: CLLocationCoordinate2D\n    let radius: CLLocationDistance\n    let identifier: String\n    let triggerOnEntry: Bool\n    let triggerOnExit: Bool\n    let minimumTimeInRegion: TimeInterval?\n    let maximumRadius: CLLocationDistance?\n}\n\nclass SmartGeofenceManager {\n    private var geofenceTimers: [String: Timer] = [:]\n    \n    func addSmartGeofence(_ geofence: SmartGeofence) {\n        let region = CLCircularRegion(center: geofence.center, \n                                    radius: geofence.radius, \n                                    identifier: geofence.identifier)\n        \n        region.notifyOnEntry = geofence.triggerOnEntry\n        region.notifyOnExit = geofence.triggerOnExit\n        \n        locationManager.startMonitoring(for: region)\n    }\n}\n```\n\n## 4. Location Data Processing & Analysis (90 min)\n\n### Location Filtering & Smoothing:\n```swift\nclass LocationProcessor {\n    func filterLocations(_ locations: [CLLocation]) -> [CLLocation] {\n        return locations.filter { location in\n            // Filter by accuracy\n            guard location.horizontalAccuracy >= 0 && \n                  location.horizontalAccuracy < 50 else {\n                return false\n            }\n            \n            // Filter by speed (remove stationary points)\n            guard location.speed > 0.5 else {\n                return false\n            }\n            \n            return true\n        }\n    }\n    \n    func smoothLocations(_ locations: [CLLocation]) -> [CLLocation] {\n        // Implement Kalman filter or moving average for smoothing\n        return locations\n    }\n}\n```\n\n### Distance & Bearing Calculations:\n```swift\nextension CLLocation {\n    func distanceTo(_ location: CLLocation) -> CLLocationDistance {\n        return self.distance(from: location)\n    }\n    \n    func bearingTo(_ location: CLLocation) -> Double {\n        let lat1 = self.coordinate.latitude.degreesToRadians\n        let lon1 = self.coordinate.longitude.degreesToRadians\n        let lat2 = location.coordinate.latitude.degreesToRadians\n        let lon2 = location.coordinate.longitude.degreesToRadians\n        \n        let dLon = lon2 - lon1\n        let y = sin(dLon) * cos(lat2)\n        let x = cos(lat1) * sin(lat2) - sin(lat1) * cos(lat2) * cos(dLon)\n        \n        return atan2(y, x).radiansToDegrees\n    }\n}\n\nextension Double {\n    var degreesToRadians: Double { return self * .pi / 180 }\n    var radiansToDegrees: Double { return self * 180 / .pi }\n}\n```\n\n### Geofence Analytics:\n```swift\nstruct GeofenceAnalytics {\n    let identifier: String\n    var entryCount: Int = 0\n    var exitCount: Int = 0\n    var totalTimeInside: TimeInterval = 0\n    var averageStayDuration: TimeInterval = 0\n    var lastEntryDate: Date?\n    var lastExitDate: Date?\n}\n\nclass AnalyticsManager {\n    private var analytics: [String: GeofenceAnalytics] = [:]\n    \n    func recordGeofenceEntry(_ identifier: String) {\n        var analytic = analytics[identifier] ?? GeofenceAnalytics(identifier: identifier)\n        analytic.entryCount += 1\n        analytic.lastEntryDate = Date()\n        analytics[identifier] = analytic\n    }\n    \n    func recordGeofenceExit(_ identifier: String) {\n        guard var analytic = analytics[identifier],\n              let entryDate = analytic.lastEntryDate else { return }\n        \n        analytic.exitCount += 1\n        analytic.lastExitDate = Date()\n        let stayDuration = Date().timeIntervalSince(entryDate)\n        analytic.totalTimeInside += stayDuration\n        analytic.averageStayDuration = analytic.totalTimeInside / Double(analytic.exitCount)\n        analytics[identifier] = analytic\n    }\n}\n```\n\n## 5. Advanced Error Handling & Optimization (60 min)\n\n### Error Scenarios:\n```swift\nextension LocationManager: CLLocationManagerDelegate {\n    func locationManager(_ manager: CLLocationManager, \n                       didFailWithError error: Error) {\n        if let clError = error as? CLError {\n            switch clError.code {\n            case .locationUnknown:\n                handleLocationUnknownError()\n            case .denied:\n                handleAuthorizationDenied()\n            case .network:\n                handleNetworkError()\n            case .headingFailure:\n                handleHeadingFailure()\n            case .regionMonitoringDenied:\n                handleRegionMonitoringDenied()\n            case .regionMonitoringFailure:\n                handleRegionMonitoringFailure()\n            case .regionMonitoringSetupDelayed:\n                handleRegionMonitoringDelayed()\n            case .rangingUnavailable:\n                handleRangingUnavailable()\n            case .rangingFailure:\n                handleRangingFailure()\n            @unknown default:\n                handleUnknownError()\n            }\n        }\n    }\n}\n```\n\n### Battery Optimization:\n```swift\nclass BatteryOptimizedLocationManager {\n    private var backgroundTask: UIBackgroundTaskIdentifier?\n    \n    func startBatteryOptimizedTracking() {\n        // Reduce accuracy when app is in background\n        NotificationCenter.default.addObserver(\n            self,\n            selector: #selector(appDidEnterBackground),\n            name: UIApplication.didEnterBackgroundNotification,\n            object: nil\n        )\n        \n        NotificationCenter.default.addObserver(\n            self,\n            selector: #selector(appWillEnterForeground),\n            name: UIApplication.willEnterForegroundNotification,\n            object: nil\n        )\n    }\n    \n    @objc private func appDidEnterBackground() {\n        locationManager.desiredAccuracy = kCLLocationAccuracyHundredMeters\n        locationManager.distanceFilter = 100.0\n        \n        // Start background task\n        backgroundTask = UIApplication.shared.beginBackgroundTask {\n            self.endBackgroundTask()\n        }\n    }\n    \n    @objc private func appWillEnterForeground() {\n        locationManager.desiredAccuracy = kCLLocationAccuracyBest\n        locationManager.distanceFilter = 10.0\n        endBackgroundTask()\n    }\n    \n    private func endBackgroundTask() {\n        if let task = backgroundTask {\n            UIApplication.shared.endBackgroundTask(task)\n            backgroundTask = nil\n        }\n    }\n}\n```\n\n### Region Monitoring Limits:\n```swift\nclass RegionLimitManager {\n    func canMonitorMoreRegions() -> Bool {\n        let currentRegions = locationManager.monitoredRegions.count\n        let maxRegions = 20 // System limit\n        return currentRegions < maxRegions\n    }\n    \n    func prioritizeRegions(_ regions: [CLRegion]) {\n        // Stop monitoring low priority regions when limit is reached\n        let sortedRegions = regions.sorted { $0.priority > $1.priority }\n        \n        for region in sortedRegions.dropFirst(20) {\n            locationManager.stopMonitoring(for: region)\n        }\n    }\n}\n\nextension CLRegion {\n    var priority: Int {\n        // Implement priority logic based on business requirements\n        return 1\n    }\n}\n```\n\n## 6. Real-World Implementation Patterns (60 min)\n\n### Reactive Location Manager with Combine:\n```swift\nimport Combine\n\nclass ReactiveLocationManager: ObservableObject {\n    private let locationManager = CLLocationManager()\n    private var cancellables = Set<AnyCancellable>()\n    \n    @Published var currentLocation: CLLocation?\n    @Published var authorizationStatus: CLAuthorizationStatus\n    @Published var geofenceEvents = PassthroughSubject<GeofenceEvent, Never>()\n    \n    init() {\n        authorizationStatus = locationManager.authorizationStatus\n        locationManager.delegate = self\n    }\n    \n    func requestLocationUpdate() -> AnyPublisher<CLLocation, Error> {\n        return Future<CLLocation, Error> { promise in\n            self.locationManager.requestLocation()\n            // Handle the location update in delegate method\n        }\n        .eraseToAnyPublisher()\n    }\n}\n```\n\n### Geofence State Machine:\n```swift\nclass GeofenceStateMachine {\n    enum State {\n        case outsideAllRegions\n        case insideRegion(String)\n        case transitioning\n    }\n    \n    private(set) var currentState: State = .outsideAllRegions\n    private var enteredRegions: Set<String> = []\n    \n    func handleRegionEntry(_ identifier: String) {\n        enteredRegions.insert(identifier)\n        \n        if case .outsideAllRegions = currentState {\n            currentState = .insideRegion(identifier)\n        } else {\n            currentState = .transitioning\n        }\n    }\n    \n    func handleRegionExit(_ identifier: String) {\n        enteredRegions.remove(identifier)\n        \n        if enteredRegions.isEmpty {\n            currentState = .outsideAllRegions\n        } else if case .insideRegion(let current) = currentState, current == identifier {\n            currentState = .insideRegion(enteredRegions.first!)\n        }\n    }\n}\n```\n\n### Location-Based Notifications:\n```swift\nimport UserNotifications\n\nclass LocationNotificationManager {\n    private let notificationCenter = UNUserNotificationCenter.current()\n    \n    func scheduleGeofenceNotification(for region: CLRegion, \n                                    type: GeofenceEventType) {\n        let content = UNMutableNotificationContent()\n        \n        switch type {\n        case .entry:\n            content.title = \"Welcome!\"\n            content.body = \"You entered \\(region.identifier)\"\n        case .exit:\n            content.title = \"Goodbye!\"\n            content.body = \"You left \\(region.identifier)\"\n        }\n        \n        content.sound = .default\n        \n        let trigger = UNTimeIntervalNotificationTrigger(timeInterval: 1, \n                                                      repeats: false)\n        let request = UNNotificationRequest(\n            identifier: UUID().uuidString,\n            content: content,\n            trigger: trigger\n        )\n        \n        notificationCenter.add(request)\n    }\n}\n\nenum GeofenceEventType {\n    case entry, exit\n}\n```\n\n## Best Practices & Performance Considerations\n\n1. **Privacy First**: Always explain why you need location data\n2. **Battery Awareness**: Use appropriate accuracy levels\n3. **Error Resilience**: Handle all possible error states\n4. **Memory Management**: Clean up regions and observers properly\n5. **Testing**: Test in various environments and scenarios\n\nComplete all practice exercises to master advanced location services!",
      "codeExample": "import CoreLocation\nimport Combine\nimport UserNotifications\n\n// === ADVANCED LOCATION MANAGER ===\nclass AdvancedLocationManager: NSObject, ObservableObject {\n    private let locationManager = CLLocationManager()\n    private var cancellables = Set<AnyCancellable>()\n    \n    // Published properties for SwiftUI\n    @Published var authorizationStatus: CLAuthorizationStatus\n    @Published var currentLocation: CLLocation?\n    @Published var locationsHistory: [CLLocation] = []\n    @Published var monitoredRegions: Set<CLRegion> = []\n    @Published var geofenceEvents: [GeofenceEvent] = []\n    \n    // Analytics\n    @Published var geofenceAnalytics: [String: GeofenceAnalytics] = [:]\n    \n    override init() {\n        authorizationStatus = locationManager.authorizationStatus\n        super.init()\n        \n        locationManager.delegate = self\n        locationManager.desiredAccuracy = kCLLocationAccuracyBest\n        locationManager.distanceFilter = 10.0\n        locationManager.allowsBackgroundLocationUpdates = true\n        locationManager.pausesLocationUpdatesAutomatically = true\n    }\n    \n    // MARK: - Authorization\n    func requestWhenInUseAuthorization() {\n        locationManager.requestWhenInUseAuthorization()\n    }\n    \n    func requestAlwaysAuthorization() {\n        locationManager.requestAlwaysAuthorization()\n    }\n    \n    // MARK: - Location Updates\n    func startStandardLocationUpdates() {\n        locationManager.startUpdatingLocation()\n    }\n    \n    func stopStandardLocationUpdates() {\n        locationManager.stopUpdatingLocation()\n    }\n    \n    func startSignificantLocationChanges() {\n        locationManager.startMonitoringSignificantLocationChanges()\n    }\n    \n    func requestSingleLocation() {\n        locationManager.requestLocation()\n    }\n    \n    // MARK: - Geofencing\n    func addGeofence(at coordinate: CLLocationCoordinate2D, \n                    radius: CLLocationDistance = 100,\n                    identifier: String) {\n        \n        guard CLLocationManager.isMonitoringAvailable(for: CLCircularRegion.self) else {\n            print(\"Geofencing is not available on this device\")\n            return\n        }\n        \n        let region = CLCircularRegion(center: coordinate, \n                                    radius: radius, \n                                    identifier: identifier)\n        region.notifyOnEntry = true\n        region.notifyOnExit = true\n        \n        locationManager.startMonitoring(for: region)\n        monitoredRegions.insert(region)\n    }\n    \n    func removeGeofence(withIdentifier identifier: String) {\n        if let region = monitoredRegions.first(where: { $0.identifier == identifier }) {\n            locationManager.stopMonitoring(for: region)\n            monitoredRegions.remove(region)\n        }\n    }\n    \n    func removeAllGeofences() {\n        for region in monitoredRegions {\n            locationManager.stopMonitoring(for: region)\n        }\n        monitoredRegions.removeAll()\n    }\n    \n    // MARK: - Location Processing\n    private func processNewLocation(_ location: CLLocation) {\n        // Filter by accuracy\n        guard location.horizontalAccuracy >= 0 && \n              location.horizontalAccuracy < 50 else { return }\n        \n        currentLocation = location\n        locationsHistory.append(location)\n        \n        // Keep only last 100 locations\n        if locationsHistory.count > 100 {\n            locationsHistory.removeFirst()\n        }\n    }\n    \n    // MARK: - Analytics\n    private func recordGeofenceEvent(_ event: GeofenceEvent) {\n        geofenceEvents.append(event)\n        \n        switch event.type {\n        case .entry:\n            updateAnalyticsForEntry(event.regionIdentifier)\n        case .exit:\n            updateAnalyticsForExit(event.regionIdentifier)\n        }\n    }\n    \n    private func updateAnalyticsForEntry(_ identifier: String) {\n        var analytics = geofenceAnalytics[identifier] ?? GeofenceAnalytics(identifier: identifier)\n        analytics.entryCount += 1\n        analytics.lastEntryDate = Date()\n        geofenceAnalytics[identifier] = analytics\n    }\n    \n    private func updateAnalyticsForExit(_ identifier: String) {\n        guard var analytics = geofenceAnalytics[identifier],\n              let entryDate = analytics.lastEntryDate else { return }\n        \n        analytics.exitCount += 1\n        analytics.lastExitDate = Date()\n        \n        let stayDuration = Date().timeIntervalSince(entryDate)\n        analytics.totalTimeInside += stayDuration\n        analytics.averageStayDuration = analytics.totalTimeInside / Double(analytics.exitCount)\n        \n        geofenceAnalytics[identifier] = analytics\n    }\n}\n\n// MARK: - CLLocationManagerDelegate\nextension AdvancedLocationManager: CLLocationManagerDelegate {\n    \n    func locationManagerDidChangeAuthorization(_ manager: CLLocationManager) {\n        authorizationStatus = manager.authorizationStatus\n        \n        switch authorizationStatus {\n        case .authorizedWhenInUse, .authorizedAlways:\n            print(\"Location authorization granted\")\n        case .denied, .restricted:\n            print(\"Location authorization denied\")\n        case .notDetermined:\n            print(\"Location authorization not determined\")\n        @unknown default:\n            print(\"Unknown authorization status\")\n        }\n    }\n    \n    func locationManager(_ manager: CLLocationManager, \n                       didUpdateLocations locations: [CLLocation]) {\n        for location in locations {\n            processNewLocation(location)\n        }\n    }\n    \n    func locationManager(_ manager: CLLocationManager, \n                       didFailWithError error: Error) {\n        print(\"Location manager error: \" + error.localizedDescription)\n    }\n    \n    // MARK: - Region Monitoring\n    func locationManager(_ manager: CLLocationManager, \n                       didEnterRegion region: CLRegion) {\n        guard let region = region as? CLCircularRegion else { return }\n        \n        let event = GeofenceEvent(regionIdentifier: region.identifier, \n                                type: .entry, \n                                timestamp: Date())\n        recordGeofenceEvent(event)\n        \n        // Schedule local notification\n        scheduleGeofenceNotification(for: region, type: .entry)\n    }\n    \n    func locationManager(_ manager: CLLocationManager, \n                       didExitRegion region: CLRegion) {\n        guard let region = region as? CLCircularRegion else { return }\n        \n        let event = GeofenceEvent(regionIdentifier: region.identifier, \n                                type: .exit, \n                                timestamp: Date())\n        recordGeofenceEvent(event)\n        \n        // Schedule local notification\n        scheduleGeofenceNotification(for: region, type: .exit)\n    }\n    \n    func locationManager(_ manager: CLLocationManager, \n                       monitoringDidFailFor region: CLRegion?, \n                       withError error: Error) {\n        print(\"Region monitoring failed for region: \" + (region?.identifier ?? \"unknown\") + \" error: \" + error.localizedDescription)\n    }\n    \n    // MARK: - Visit Monitoring\n    func locationManager(_ manager: CLLocationManager, \n                       didVisit visit: CLVisit) {\n        print(\"Visit detected: \" + String(describing: visit))\n    }\n    \n    // MARK: - Notifications\n    private func scheduleGeofenceNotification(for region: CLRegion, \n                                            type: GeofenceEventType) {\n        let content = UNMutableNotificationContent()\n        \n        switch type {\n        case .entry:\n            content.title = \"Region Entered\"\n            content.body = \"You entered \" + region.identifier\n        case .exit:\n            content.title = \"Region Exited\"\n            content.body = \"You left \" + region.identifier\n        }\n        \n        content.sound = .default\n        \n        let trigger = UNTimeIntervalNotificationTrigger(timeInterval: 1, repeats: false)\n        let request = UNNotificationRequest(\n            identifier: UUID().uuidString,\n            content: content,\n            trigger: trigger\n        )\n        \n        UNUserNotificationCenter.current().add(request)\n    }\n}\n\n// === DATA MODELS ===\nstruct GeofenceEvent {\n    let regionIdentifier: String\n    let type: GeofenceEventType\n    let timestamp: Date\n}\n\nenum GeofenceEventType {\n    case entry, exit\n}\n\nstruct GeofenceAnalytics {\n    let identifier: String\n    var entryCount: Int = 0\n    var exitCount: Int = 0\n    var totalTimeInside: TimeInterval = 0\n    var averageStayDuration: TimeInterval = 0\n    var lastEntryDate: Date?\n    var lastExitDate: Date?\n}\n\n// === LOCATION UTILITIES ===\nextension CLLocation {\n    func isWithinRegion(_ region: CLCircularRegion) -> Bool {\n        return region.contains(self.coordinate)\n    }\n    \n    func distanceToRegion(_ region: CLCircularRegion) -> CLLocationDistance {\n        let regionCenter = CLLocation(latitude: region.center.latitude, \n                                    longitude: region.center.longitude)\n        return self.distance(from: regionCenter) - region.radius\n    }\n}\n\n// === SMART GEOFENCE MANAGER ===\nclass SmartGeofenceManager {\n    private let locationManager: CLLocationManager\n    private var proximityTimers: [String: Timer] = [:]\n    \n    init(locationManager: CLLocationManager) {\n        self.locationManager = locationManager\n    }\n    \n    func startProximityMonitoring(for region: CLCircularRegion, \n                                proximityDistance: CLLocationDistance) {\n        // Implement proximity-based monitoring logic\n    }\n    \n    func stopProximityMonitoring(for regionIdentifier: String) {\n        proximityTimers[regionIdentifier]?.invalidate()\n        proximityTimers[regionIdentifier] = nil\n    }\n}\n\n// === BATTERY OPTIMIZED MANAGER ===\nclass BatteryOptimizedLocationManager {\n    private let locationManager: CLLocationManager\n    private var backgroundTask: UIBackgroundTaskIdentifier?\n    \n    init(locationManager: CLLocationManager) {\n        self.locationManager = locationManager\n        setupAppStateObservers()\n    }\n    \n    private func setupAppStateObservers() {\n        NotificationCenter.default.addObserver(\n            self,\n            selector: #selector(appDidEnterBackground),\n            name: UIApplication.didEnterBackgroundNotification,\n            object: nil\n        )\n        \n        NotificationCenter.default.addObserver(\n            self,\n            selector: #selector(appWillEnterForeground),\n            name: UIApplication.willEnterForegroundNotification,\n            object: nil\n        )\n    }\n    \n    @objc private func appDidEnterBackground() {\n        // Reduce accuracy in background\n        locationManager.desiredAccuracy = kCLLocationAccuracyHundredMeters\n        locationManager.distanceFilter = 100.0\n        \n        // Start background task\n        backgroundTask = UIApplication.shared.beginBackgroundTask {\n            self.endBackgroundTask()\n        }\n    }\n    \n    @objc private func appWillEnterForeground() {\n        // Restore accuracy in foreground\n        locationManager.desiredAccuracy = kCLLocationAccuracyBest\n        locationManager.distanceFilter = 10.0\n        endBackgroundTask()\n    }\n    \n    private func endBackgroundTask() {\n        if let task = backgroundTask {\n            UIApplication.shared.endBackgroundTask(task)\n            backgroundTask = nil\n        }\n    }\n}",
      "category": "Location Services",
      "estimatedTime": 240,
      "dependencies": ["core_location_basics", "swift_concurrency"],
      "challenge": {
        "instructions": "Build a complete location-based reminder system with advanced geofencing capabilities:\n\nPART 1: Core Location Setup & Authorization (60 min)\n1. Create an AdvancedLocationManager with proper authorization handling\n2. Implement both WhenInUse and Always authorization flows\n3. Set up location accuracy configuration for different scenarios\n4. Handle all authorization status changes properly\n\nPART 2: Advanced Geofencing System (90 min)\n5. Implement circular region monitoring with configurable radii\n6. Create a smart geofence system that handles region prioritization\n7. Add beacon region monitoring support\n8. Implement region state persistence across app launches\n\nPART 3: Location Analytics & Processing (90 min)\n9. Build a location data processor with filtering and smoothing\n10. Create geofence analytics tracking entry/exit patterns\n11. Implement distance calculations and proximity detection\n12. Add visit monitoring and analysis\n\nPART 4: Background Processing & Optimization (60 min)\n13. Configure background location updates properly\n14. Implement battery-optimized location tracking\n15. Add significant location change monitoring\n16. Handle region monitoring limits and prioritization\n\nPART 5: Advanced Features & Integration (60 min)\n17. Integrate with UserNotifications for location-based alerts\n18. Create a Combine-powered reactive location manager\n19. Implement error handling for all location scenarios\n20. Add unit tests for critical location functionality",
        "starterCode": "import CoreLocation\nimport Combine\nimport UserNotifications\n\n// === PART 1: Core Location Setup ===\n// Create your AdvancedLocationManager class here\n\n\n// === PART 2: Advanced Geofencing ===\n// Implement smart geofencing system\n\n\n// === PART 3: Location Analytics ===\n// Build analytics and data processing\n\n\n// === PART 4: Background Processing ===\n// Implement battery-optimized tracking\n\n\n// === PART 5: Advanced Integration ===\n// Add notifications and error handling\n\n",
        "solution": "import CoreLocation\nimport Combine\nimport UserNotifications\n\n// === COMPLETE SOLUTION ===\nclass CompleteLocationManager: NSObject, ObservableObject {\n    private let locationManager = CLLocationManager()\n    private var cancellables = Set<AnyCancellable>()\n    \n    // MARK: - Published Properties\n    @Published var authorizationStatus: CLAuthorizationStatus\n    @Published var currentLocation: CLLocation?\n    @Published var monitoredRegions: Set<CLRegion> = []\n    @Published var locationHistory: [CLLocation] = []\n    @Published var geofenceEvents: [GeofenceEvent] = []\n    @Published var analytics: [String: GeofenceAnalytics] = [:]\n    \n    // MARK: - Private Properties\n    private let geofenceLimit = 20\n    private var backgroundTask: UIBackgroundTaskIdentifier?\n    \n    override init() {\n        authorizationStatus = locationManager.authorizationStatus\n        super.init()\n        \n        setupLocationManager()\n        setupAppStateObservers()\n        loadPersistedData()\n    }\n    \n    // MARK: - Setup\n    private func setupLocationManager() {\n        locationManager.delegate = self\n        locationManager.desiredAccuracy = kCLLocationAccuracyBest\n        locationManager.distanceFilter = 10.0\n        locationManager.allowsBackgroundLocationUpdates = true\n        locationManager.pausesLocationUpdatesAutomatically = true\n        locationManager.activityType = .other\n    }\n    \n    private func setupAppStateObservers() {\n        NotificationCenter.default.publisher(for: UIApplication.didEnterBackgroundNotification)\n            .sink { [weak self] _ in self?.appDidEnterBackground() }\n            .store(in: &cancellables)\n            \n        NotificationCenter.default.publisher(for: UIApplication.willEnterForegroundNotification)\n            .sink { [weak self] _ in self?.appWillEnterForeground() }\n            .store(in: &cancellables)\n    }\n    \n    // MARK: - Authorization\n    func requestWhenInUseAuthorization() {\n        locationManager.requestWhenInUseAuthorization()\n    }\n    \n    func requestAlwaysAuthorization() {\n        locationManager.requestAlwaysAuthorization()\n    }\n    \n    // MARK: - Location Updates\n    func startLocationUpdates() {\n        guard authorizationStatus == .authorizedWhenInUse || \n              authorizationStatus == .authorizedAlways else {\n            return\n        }\n        locationManager.startUpdatingLocation()\n    }\n    \n    func stopLocationUpdates() {\n        locationManager.stopUpdatingLocation()\n    }\n    \n    func startSignificantLocationChanges() {\n        locationManager.startMonitoringSignificantLocationChanges()\n    }\n    \n    // MARK: - Geofencing\n    func addGeofence(center: CLLocationCoordinate2D, \n                    radius: CLLocationDistance, \n                    identifier: String) -> Bool {\n        \n        guard monitoredRegions.count < geofenceLimit else {\n            print(\"Geofence limit reached\")\n            return false\n        }\n        \n        guard CLLocationManager.isMonitoringAvailable(for: CLCircularRegion.self) else {\n            print(\"Geofencing not available\")\n            return false\n        }\n        \n        let region = CLCircularRegion(center: center, radius: radius, identifier: identifier)\n        region.notifyOnEntry = true\n        region.notifyOnExit = true\n        \n        locationManager.startMonitoring(for: region)\n        monitoredRegions.insert(region)\n        persistMonitoredRegions()\n        \n        return true\n    }\n    \n    func removeGeofence(identifier: String) {\n        if let region = monitoredRegions.first(where: { $0.identifier == identifier }) {\n            locationManager.stopMonitoring(for: region)\n            monitoredRegions.remove(region)\n            persistMonitoredRegions()\n        }\n    }\n    \n    // MARK: - Background Optimization\n    private func appDidEnterBackground() {\n        // Reduce accuracy in background\n        locationManager.desiredAccuracy = kCLLocationAccuracyHundredMeters\n        locationManager.distanceFilter = 50.0\n        \n        // Start background task\n        backgroundTask = UIApplication.shared.beginBackgroundTask {\n            self.endBackgroundTask()\n        }\n    }\n    \n    private func appWillEnterForeground() {\n        // Restore accuracy\n        locationManager.desiredAccuracy = kCLLocationAccuracyBest\n        locationManager.distanceFilter = 10.0\n        endBackgroundTask()\n    }\n    \n    private func endBackgroundTask() {\n        if let task = backgroundTask {\n            UIApplication.shared.endBackgroundTask(task)\n            backgroundTask = nil\n        }\n    }\n    \n    // MARK: - Data Persistence\n    private func persistMonitoredRegions() {\n        let regionData = monitoredRegions.map { region -> [String: Any] in\n            if let circularRegion = region as? CLCircularRegion {\n                return [\n                    \"identifier\": circularRegion.identifier,\n                    \"latitude\": circularRegion.center.latitude,\n                    \"longitude\": circularRegion.center.longitude,\n                    \"radius\": circularRegion.radius\n                ]\n            }\n            return [:]\n        }\n        \n        UserDefaults.standard.set(regionData, forKey: \"monitoredRegions\")\n    }\n    \n    private func loadPersistedData() {\n        guard let regionData = UserDefaults.standard.array(forKey: \"monitoredRegions\") as? [[String: Any]] else {\n            return\n        }\n        \n        for data in regionData {\n            guard let identifier = data[\"identifier\"] as? String,\n                  let latitude = data[\"latitude\"] as? CLLocationDegrees,\n                  let longitude = data[\"longitude\"] as? CLLocationDegrees,\n                  let radius = data[\"radius\"] as? CLLocationDistance else {\n                continue\n            }\n            \n            let center = CLLocationCoordinate2D(latitude: latitude, longitude: longitude)\n            addGeofence(center: center, radius: radius, identifier: identifier)\n        }\n    }\n    \n    // MARK: - Analytics\n    private func recordGeofenceEvent(_ event: GeofenceEvent) {\n        geofenceEvents.append(event)\n        \n        var analytic = analytics[event.regionIdentifier] ?? GeofenceAnalytics(identifier: event.regionIdentifier)\n        \n        switch event.type {\n        case .entry:\n            analytic.entryCount += 1\n            analytic.lastEntryDate = event.timestamp\n        case .exit:\n            analytic.exitCount += 1\n            analytic.lastExitDate = event.timestamp\n            \n            if let entryDate = analytic.lastEntryDate {\n                let duration = event.timestamp.timeIntervalSince(entryDate)\n                analytic.totalTimeInside += duration\n                analytic.averageStayDuration = analytic.totalTimeInside / Double(analytic.exitCount)\n            }\n        }\n        \n        analytics[event.regionIdentifier] = analytic\n    }\n    \n    private func scheduleNotification(for event: GeofenceEvent) {\n        let content = UNMutableNotificationContent()\n        \n        switch event.type {\n        case .entry:\n            content.title = \"Location Reminder\"\n            content.body = \"You entered: \" + event.regionIdentifier\n        case .exit:\n            content.title = \"Location Reminder\"\n            content.body = \"You left: \" + event.regionIdentifier\n        }\n        \n        content.sound = .default\n        \n        let request = UNNotificationRequest(\n            identifier: UUID().uuidString,\n            content: content,\n            trigger: nil\n        )\n        \n        UNUserNotificationCenter.current().add(request)\n    }\n}\n\n// MARK: - CLLocationManagerDelegate\nextension CompleteLocationManager: CLLocationManagerDelegate {\n    \n    func locationManagerDidChangeAuthorization(_ manager: CLLocationManager) {\n        authorizationStatus = manager.authorizationStatus\n    }\n    \n    func locationManager(_ manager: CLLocationManager, didUpdateLocations locations: [CLLocation]) {\n        guard let location = locations.last else { return }\n        \n        // Filter by accuracy\n        guard location.horizontalAccuracy >= 0 && location.horizontalAccuracy < 100 else { return }\n        \n        currentLocation = location\n        locationHistory.append(location)\n        \n        // Keep history manageable\n        if locationHistory.count > 1000 {\n            locationHistory.removeFirst(500)\n        }\n    }\n    \n    func locationManager(_ manager: CLLocationManager, didFailWithError error: Error) {\n        print(\"Location error: \" + error.localizedDescription)\n    }\n    \n    func locationManager(_ manager: CLLocationManager, didEnterRegion region: CLRegion) {\n        guard let region = region as? CLCircularRegion else { return }\n        \n        let event = GeofenceEvent(regionIdentifier: region.identifier, type: .entry, timestamp: Date())\n        recordGeofenceEvent(event)\n        scheduleNotification(for: event)\n    }\n    \n    func locationManager(_ manager: CLLocationManager, didExitRegion region: CLRegion) {\n        guard let region = region as? CLCircularRegion else { return }\n        \n        let event = GeofenceEvent(regionIdentifier: region.identifier, type: .exit, timestamp: Date())\n        recordGeofenceEvent(event)\n        scheduleNotification(for: event)\n    }\n    \n    func locationManager(_ manager: CLLocationManager, monitoringDidFailFor region: CLRegion?, withError error: Error) {\n        print(\"Monitoring failed for region: \" + (region?.identifier ?? \"unknown\"))\n    }\n}\n\n// MARK: - Data Models\nstruct GeofenceEvent {\n    let regionIdentifier: String\n    let type: GeofenceEventType\n    let timestamp: Date\n}\n\nenum GeofenceEventType {\n    case entry, exit\n}\n\nstruct GeofenceAnalytics {\n    let identifier: String\n    var entryCount: Int = 0\n    var exitCount: Int = 0\n    var totalTimeInside: TimeInterval = 0\n    var averageStayDuration: TimeInterval = 0\n    var lastEntryDate: Date?\n    var lastExitDate: Date?\n}",
        "hints": [
          "Always check location services availability before starting monitoring",
          "Use appropriate accuracy levels to balance battery life and precision",
          "Implement proper error handling for all Core Location delegate methods",
          "Persist monitored regions to restore them after app restart",
          "Use background tasks for extended location updates in background",
          "Consider region monitoring limits (20 regions per app)",
          "Test geofencing in different scenarios: entry, exit, and boundary cases",
          "Use significant location changes for battery-efficient background updates"
        ],
        "testCases": [
          {
            "input": "authorizationStatus == .authorizedAlways",
            "expectedOutput": "true",
            "description": "Should have always authorization for background geofencing"
          },
          {
            "input": "monitoredRegions.count <= 20",
            "expectedOutput": "true",
            "description": "Should not exceed system region monitoring limit"
          },
          {
            "input": "locationHistory.count <= 1000",
            "expectedOutput": "true",
            "description": "Location history should be properly managed"
          }
        ]
      }
    },
    {
      "id": "camera_photos_advanced",
      "title": "Advanced Camera & Photos Framework",
      "description": "Master advanced camera controls, photo library management, and real-time image processing",
      "difficulty": "advanced",
      "theory": "# Advanced Camera & Photos Framework\n\n## 1. Advanced UIImagePickerController (60 min)\n\n### Custom Overlay Views:\n```swift\nclass CustomCameraViewController: UIViewController {\n    let imagePicker = UIImagePickerController()\n    \n    override func viewDidLoad() {\n        super.viewDidLoad()\n        setupCustomCamera()\n    }\n    \n    private func setupCustomCamera() {\n        guard UIImagePickerController.isSourceTypeAvailable(.camera) else { return }\n        \n        imagePicker.sourceType = .camera\n        imagePicker.showsCameraControls = false\n        imagePicker.cameraOverlayView = createCustomOverlay()\n        imagePicker.delegate = self\n    }\n    \n    private func createCustomOverlay() -> UIView {\n        let overlayView = UIView(frame: UIScreen.main.bounds)\n        overlayView.backgroundColor = .clear\n        \n        // Custom capture button\n        let captureButton = UIButton(frame: CGRect(x: overlayView.center.x - 35, y: overlayView.bounds.height - 100, width: 70, height: 70))\n        captureButton.backgroundColor = .white\n        captureButton.layer.cornerRadius = 35\n        captureButton.addTarget(self, action: #selector(capturePhoto), for: .touchUpInside)\n        \n        // Grid overlay\n        let gridView = createGridView()\n        \n        overlayView.addSubview(gridView)\n        overlayView.addSubview(captureButton)\n        return overlayView\n    }\n}\n```\n\n### Multiple Image Selection:\n```swift\nclass MultipleImagePickerController: UIImagePickerController {\n    var selectedAssets: [PHAsset] = []\n    \n    func enableMultipleSelection() {\n        if #available(iOS 14, *) {\n            self.selectionLimit = 10 // Maximum 10 images\n            self.mediaTypes = [UTType.image.identifier]\n        }\n    }\n}\n```\n\n## 2. AVFoundation Camera Pipeline (90 min)\n\n### Custom Camera Session:\n```swift\nclass AdvancedCameraController: NSObject {\n    private let captureSession = AVCaptureSession()\n    private var videoDeviceInput: AVCaptureDeviceInput!\n    private let photoOutput = AVCapturePhotoOutput()\n    private let sessionQueue = DispatchQueue(label: \"camera.session.queue\")\n    private var previewLayer: AVCaptureVideoPreviewLayer!\n    \n    // Camera configuration\n    func configureSession() {\n        sessionQueue.async {\n            self.captureSession.beginConfiguration()\n            \n            // Setup inputs\n            guard self.setupCameraInput() else {\n                print(\"Failed to setup camera input\")\n                return\n            }\n            \n            // Setup outputs\n            guard self.setupPhotoOutput() else {\n                print(\"Failed to setup photo output\")\n                return\n            }\n            \n            self.captureSession.commitConfiguration()\n            self.captureSession.startRunning()\n        }\n    }\n    \n    private func setupCameraInput() -> Bool {\n        guard let videoDevice = AVCaptureDevice.default(.builtInWideAngleCamera, for: .video, position: .back) else {\n            return false\n        }\n        \n        do {\n            videoDeviceInput = try AVCaptureDeviceInput(device: videoDevice)\n            \n            if captureSession.canAddInput(videoDeviceInput) {\n                captureSession.addInput(videoDeviceInput)\n                return true\n            }\n        } catch {\n            print(\"Error creating video device input: \\(error)\")\n        }\n        \n        return false\n    }\n    \n    private func setupPhotoOutput() -> Bool {\n        if captureSession.canAddOutput(photoOutput) {\n            captureSession.addOutput(photoOutput)\n            \n            // Configure photo settings\n            photoOutput.isHighResolutionCaptureEnabled = true\n            photoOutput.maxPhotoQualityPrioritization = .quality\n            \n            return true\n        }\n        return false\n    }\n}\n```\n\n### Manual Camera Controls:\n```swift\nextension AdvancedCameraController {\n    func setExposure(targetBias: Float) {\n        guard let device = videoDeviceInput.device else { return }\n        \n        do {\n            try device.lockForConfiguration()\n            \n            if device.isExposureModeSupported(.continuousAutoExposure) {\n                device.setExposureTargetBias(targetBias, completionHandler: nil)\n            }\n            \n            device.unlockForConfiguration()\n        } catch {\n            print(\"Error setting exposure: \\(error)\")\n        }\n    }\n    \n    func setFocus(point: CGPoint) {\n        guard let device = videoDeviceInput.device,\n              device.isFocusPointOfInterestSupported else { return }\n        \n        do {\n            try device.lockForConfiguration()\n            \n            device.focusPointOfInterest = point\n            device.focusMode = .autoFocus\n            \n            device.unlockForConfiguration()\n        } catch {\n            print(\"Error setting focus: \\(error)\")\n        }\n    }\n    \n    func setZoom(factor: CGFloat) {\n        guard let device = videoDeviceInput.device else { return }\n        \n        do {\n            try device.lockForConfiguration()\n            \n            let zoomFactor = max(1.0, min(factor, device.activeFormat.videoMaxZoomFactor))\n            device.videoZoomFactor = zoomFactor\n            \n            device.unlockForConfiguration()\n        } catch {\n            print(\"Error setting zoom: \\(error)\")\n        }\n    }\n}\n```\n\n## 3. Advanced Photo Library Management (90 min)\n\n### Smart Album Querying:\n```swift\nclass AdvancedPhotoLibraryManager {\n    private let imageManager = PHCachingImageManager()\n    \n    func fetchSmartAlbums() -> [PHAssetCollection] {\n        let smartAlbumTypes: [PHAssetCollectionSubtype] = [\n            .smartAlbumFavorites,\n            .smartAlbumRecentlyAdded,\n            .smartAlbumSelfPortraits,\n            .smartAlbumScreenshots,\n            .smartAlbumBursts\n        ]\n        \n        var collections: [PHAssetCollection] = []\n        \n        smartAlbumTypes.forEach { subtype in\n            let fetchResult = PHAssetCollection.fetchAssetCollections(with: .smartAlbum, subtype: subtype, options: nil)\n            fetchResult.enumerateObjects { collection, _, _ in\n                collections.append(collection)\n            }\n        }\n        \n        return collections\n    }\n    \n    func fetchAssetsWithFilters() -> PHFetchResult<PHAsset> {\n        let options = PHFetchOptions()\n        \n        // Filter predicates\n        let creationDatePredicate = NSPredicate(format: \"creationDate > %@\", Date().addingTimeInterval(-7*24*60*60) as CVarArg)\n        let mediaTypePredicate = NSPredicate(format: \"mediaType = %d\", PHAssetMediaType.image.rawValue)\n        \n        options.predicate = NSCompoundPredicate(andPredicateWithSubpredicates: [\n            creationDatePredicate,\n            mediaTypePredicate\n        ])\n        \n        options.sortDescriptors = [NSSortDescriptor(key: \"creationDate\", ascending: false)]\n        \n        return PHAsset.fetchAssets(with: options)\n    }\n}\n```\n\n### Batch Operations:\n```swift\nextension AdvancedPhotoLibraryManager {\n    func createAlbum(named title: String, completion: @escaping (PHAssetCollection?) -> Void) {\n        var albumPlaceholder: PHObjectPlaceholder?\n        \n        PHPhotoLibrary.shared().performChanges({\n            let createAlbumRequest = PHAssetCollectionChangeRequest.creationRequestForAssetCollection(withTitle: title)\n            albumPlaceholder = createAlbumRequest.placeholderForCreatedAssetCollection\n        }) { success, error in\n            if success, let placeholder = albumPlaceholder {\n                let fetchResult = PHAssetCollection.fetchAssetCollections(withLocalIdentifiers: [placeholder.localIdentifier], options: nil)\n                completion(fetchResult.firstObject)\n            } else {\n                completion(nil)\n            }\n        }\n    }\n    \n    func addAssets(_ assets: [PHAsset], to album: PHAssetCollection, completion: @escaping (Bool) -> Void) {\n        PHPhotoLibrary.shared().performChanges({\n            let albumChangeRequest = PHAssetCollectionChangeRequest(for: album)\n            albumChangeRequest?.addAssets(assets as NSArray)\n        }) { success, error in\n            DispatchQueue.main.async {\n                completion(success)\n            }\n        }\n    }\n    \n    func deleteAssets(_ assets: [PHAsset], completion: @escaping (Bool) -> Void) {\n        PHPhotoLibrary.shared().performChanges({\n            PHAssetChangeRequest.deleteAssets(assets as NSArray)\n        }) { success, error in\n            DispatchQueue.main.async {\n                completion(success)\n            }\n        }\n    }\n}\n```\n\n## 4. Real-time Image Processing & Filters (60 min)\n\n### Core Image Pipeline:\n```swift\nclass RealTimeImageProcessor {\n    private let context = CIContext()\n    private var currentFilter: CIFilter?\n    \n    func processImage(_ image: UIImage, with filter: CIFilter) -> UIImage? {\n        guard let ciImage = CIImage(image: image) else { return nil }\n        \n        filter.setValue(ciImage, forKey: kCIInputImageKey)\n        \n        guard let outputImage = filter.outputImage,\n              let cgImage = context.createCGImage(outputImage, from: outputImage.extent) else {\n            return nil\n        }\n        \n        return UIImage(cgImage: cgImage)\n    }\n    \n    // Real-time filter application\n    func applyFilterToLivePreview(pixelBuffer: CVPixelBuffer, filter: CIFilter) -> CVPixelBuffer? {\n        let ciImage = CIImage(cvPixelBuffer: pixelBuffer)\n        filter.setValue(ciImage, forKey: kCIInputImageKey)\n        \n        guard let outputImage = filter.outputImage else { return nil }\n        \n        var outputPixelBuffer: CVPixelBuffer?\n        \n        // Reuse the input pixel buffer for output\n        CVPixelBufferCreate(nil, \n                           CVPixelBufferGetWidth(pixelBuffer),\n                           CVPixelBufferGetHeight(pixelBuffer),\n                           CVPixelBufferGetPixelFormatType(pixelBuffer),\n                           nil,\n                           &outputPixelBuffer)\n        \n        if let outputPixelBuffer = outputPixelBuffer {\n            context.render(outputImage, to: outputPixelBuffer)\n        }\n        \n        return outputPixelBuffer\n    }\n}\n```\n\n### Custom Filter Chains:\n```swift\nextension RealTimeImageProcessor {\n    func createVintageFilterChain() -> CIFilter {\n        let sepiaFilter = CIFilter(name: \"CISepiaTone\")!\n        sepiaFilter.setValue(0.8, forKey: kCIInputIntensityKey)\n        \n        let vignetteFilter = CIFilter(name: \"CIVignette\")!\n        vignetteFilter.setValue(2.0, forKey: kCIInputIntensityKey)\n        vignetteFilter.setValue(1.5, forKey: kCIInputRadiusKey)\n        \n        // Chain filters\n        vignetteFilter.setValue(sepiaFilter.outputImage, forKey: kCIInputImageKey)\n        \n        return vignetteFilter\n    }\n    \n    func createCustomColorFilter(intensity: Float) -> CIFilter {\n        let colorControls = CIFilter(name: \"CIColorControls\")!\n        colorControls.setValue(intensity, forKey: kCIInputSaturationKey)\n        colorControls.setValue(0.1, forKey: kCIInputContrastKey)\n        \n        return colorControls\n    }\n}\n```\n\n## 5. Performance Optimization & Memory Management (60 min)\n\n### Efficient Thumbnail Generation:\n```swift\nclass ThumbnailManager {\n    private let imageManager = PHCachingImageManager()\n    private var thumbnailCache: [String: UIImage] = [:]\n    \n    func generateThumbnail(for asset: PHAsset, targetSize: CGSize, completion: @escaping (UIImage?) -> Void) {\n        let options = PHImageRequestOptions()\n        options.deliveryMode = .highQualityFormat\n        options.resizeMode = .fast\n        options.isSynchronous = false\n        \n        // Check cache first\n        if let cachedThumbnail = thumbnailCache[asset.localIdentifier] {\n            completion(cachedThumbnail)\n            return\n        }\n        \n        imageManager.requestImage(for: asset, \n                                 targetSize: targetSize, \n                                 contentMode: .aspectFill, \n                                 options: options) { [weak self] image, info in\n            if let image = image {\n                // Cache the thumbnail\n                self?.thumbnailCache[asset.localIdentifier] = image\n            }\n            completion(image)\n        }\n    }\n    \n    func preloadThumbnails(for assets: [PHAsset], targetSize: CGSize) {\n        imageManager.startCachingImages(for: assets, \n                                       targetSize: targetSize, \n                                       contentMode: .aspectFill, \n                                       options: nil)\n    }\n}\n```\n\n### Memory-Efficient Image Handling:\n```swift\nclass MemoryEfficientImageLoader {\n    private let imageManager = PHImageManager.default()\n    private var requestIDs: [PHImageRequestID] = []\n    \n    func loadHighQualityImage(for asset: PHAsset, completion: @escaping (UIImage?) -> Void) {\n        let options = PHImageRequestOptions()\n        options.version = .current\n        options.deliveryMode = .highQualityFormat\n        options.isNetworkAccessAllowed = true\n        \n        let targetSize = calculateOptimalSize(for: asset)\n        \n        let requestID = imageManager.requestImage(for: asset, \n                                                 targetSize: targetSize, \n                                                 contentMode: .aspectFit, \n                                                 options: options) { image, info in\n            if let isDegraded = info?[PHImageResultIsDegradedKey] as? Bool, !isDegraded {\n                completion(image)\n            }\n        }\n        \n        requestIDs.append(requestID)\n    }\n    \n    private func calculateOptimalSize(for asset: PHAsset) -> CGSize {\n        let scale = UIScreen.main.scale\n        let maxDimension: CGFloat = 2048 // Prevent loading massive images\n        \n        let assetRatio = CGFloat(asset.pixelWidth) / CGFloat(asset.pixelHeight)\n        \n        if assetRatio > 1 {\n            // Landscape\n            return CGSize(width: maxDimension, height: maxDimension / assetRatio)\n        } else {\n            // Portrait or square\n            return CGSize(width: maxDimension * assetRatio, height: maxDimension)\n        }\n    }\n    \n    func cancelAllRequests() {\n        requestIDs.forEach { imageManager.cancelImageRequest($0) }\n        requestIDs.removeAll()\n    }\n}\n```\n\n## 6. Advanced Features & Best Practices (60 min)\n\n### Live Photo Capture & Processing:\n```swift\nclass LivePhotoController {\n    private let captureSession = AVCaptureSession()\n    private let photoOutput = AVCapturePhotoOutput()\n    \n    func captureLivePhoto() {\n        guard photoOutput.isLivePhotoCaptureSupported else {\n            print(\"Live Photo not supported on this device\")\n            return\n        }\n        \n        let photoSettings = AVCapturePhotoSettings()\n        \n        if let livePhotoMovieConnection = photoSettings.availablePreviewPhotoPixelFormatTypes.first {\n            photoSettings.previewPhotoFormat = [kCVPixelBufferPixelFormatTypeKey as String: livePhotoMovieConnection]\n        }\n        \n        photoSettings.livePhotoMovieFileURL = temporaryMovieURL()\n        \n        photoOutput.capturePhoto(with: photoSettings, delegate: self)\n    }\n    \n    private func temporaryMovieURL() -> URL {\n        let temporaryDirectory = FileManager.default.temporaryDirectory\n        return temporaryDirectory.appendingPathComponent(UUID().uuidString).appendingPathExtension(\"mov\")\n    }\n}\n\nextension LivePhotoController: AVCapturePhotoCaptureDelegate {\n    func photoOutput(_ output: AVCapturePhotoOutput, didFinishProcessingLivePhotoToMovieFileAt outputFileURL: URL, duration: CMTime, photoDisplayTime: CMTime, resolvedSettings: AVCaptureResolvedPhotoSettings, error: Error?) {\n        if let error = error {\n            print(\"Error processing Live Photo: \\(error)\")\n            return\n        }\n        \n        // Process the captured Live Photo\n        processLivePhoto(videoURL: outputFileURL)\n    }\n}\n```\n\n### Depth Data & Portrait Effects:\n```swift\nclass DepthDataCameraController {\n    private let photoOutput = AVCapturePhotoOutput()\n    \n    func configureForDepthCapture() {\n        if photoOutput.isDepthDataDeliverySupported {\n            photoOutput.isDepthDataDeliveryEnabled = true\n        }\n    }\n    \n    func capturePhotoWithDepth() {\n        let photoSettings = AVCapturePhotoSettings()\n        \n        if photoOutput.isDepthDataDeliverySupported {\n            photoSettings.isDepthDataDeliveryEnabled = true\n        }\n        \n        photoOutput.capturePhoto(with: photoSettings, delegate: self)\n    }\n}\n\nextension DepthDataCameraController: AVCapturePhotoCaptureDelegate {\n    func photoOutput(_ output: AVCapturePhotoOutput, didFinishProcessingPhoto photo: AVCapturePhoto, error: Error?) {\n        guard error == nil else {\n            print(\"Error capturing photo: \\(error!)\")\n            return\n        }\n        \n        // Access depth data\n        if let depthData = photo.depthData {\n            processDepthData(depthData)\n        }\n        \n        // Access portrait effects matte\n        if #available(iOS 12.0, *) {\n            if let portraitEffectsMatte = photo.portraitEffectsMatte {\n                processPortraitEffectsMatte(portraitEffectsMatte)\n            }\n        }\n    }\n    \n    private func processDepthData(_ depthData: AVDepthData) {\n        // Convert depth data to usable format\n        let depthDataMap = depthData.depthDataMap\n        \n        // Apply depth-based effects\n        applyDepthEffects(depthDataMap: depthDataMap)\n    }\n}\n```",
      "codeExample": "import UIKit\nimport Photos\nimport AVFoundation\nimport CoreImage\n\n// === ADVANCED CAMERA CONTROLLER ===\nclass ProfessionalCameraViewController: UIViewController {\n    \n    // MARK: - Properties\n    private let captureSession = AVCaptureSession()\n    private var videoDeviceInput: AVCaptureDeviceInput!\n    private let photoOutput = AVCapturePhotoOutput()\n    private let videoOutput = AVCaptureVideoDataOutput()\n    private let sessionQueue = DispatchQueue(label: \"camera.session.queue\")\n    private var previewLayer: AVCaptureVideoPreviewLayer!\n    \n    private var currentZoomFactor: CGFloat = 1.0\n    private var initialZoomFactor: CGFloat = 1.0\n    \n    // Real-time processing\n    private let imageProcessor = RealTimeImageProcessor()\n    private var currentFilter: CIFilter?\n    \n    // MARK: - UI Components\n    private let previewView = UIView()\n    private let captureButton = UIButton()\n    private let zoomSlider = UISlider()\n    private let filterCollectionView: UICollectionView\n    \n    override func viewDidLoad() {\n        super.viewDidLoad()\n        setupUI()\n        checkPermissions()\n        configureSession()\n    }\n    \n    // MARK: - Camera Setup\n    private func checkPermissions() {\n        switch AVCaptureDevice.authorizationStatus(for: .video) {\n        case .authorized:\n            break\n        case .notDetermined:\n            AVCaptureDevice.requestAccess(for: .video) { granted in\n                if granted {\n                    DispatchQueue.main.async {\n                        self.configureSession()\n                    }\n                }\n            }\n        default:\n            showPermissionAlert()\n        }\n    }\n    \n    private func configureSession() {\n        sessionQueue.async {\n            self.captureSession.beginConfiguration()\n            \n            // Setup session preset\n            if self.captureSession.canSetSessionPreset(.photo) {\n                self.captureSession.sessionPreset = .photo\n            }\n            \n            // Setup inputs and outputs\n            guard self.setupInputs(), self.setupOutputs() else {\n                self.captureSession.commitConfiguration()\n                return\n            }\n            \n            self.captureSession.commitConfiguration()\n            \n            DispatchQueue.main.async {\n                self.setupPreviewLayer()\n            }\n            \n            self.captureSession.startRunning()\n        }\n    }\n    \n    private func setupInputs() -> Bool {\n        // Setup camera input\n        guard let videoDevice = AVCaptureDevice.default(.builtInDualCamera, for: .video, position: .back) ??\n                AVCaptureDevice.default(.builtInWideAngleCamera, for: .video, position: .back) else {\n            return false\n        }\n        \n        do {\n            videoDeviceInput = try AVCaptureDeviceInput(device: videoDevice)\n            \n            if captureSession.canAddInput(videoDeviceInput) {\n                captureSession.addInput(videoDeviceInput)\n                \n                // Configure device for best quality\n                try videoDevice.lockForConfiguration()\n                if videoDevice.isFocusModeSupported(.continuousAutoFocus) {\n                    videoDevice.focusMode = .continuousAutoFocus\n                }\n                if videoDevice.isExposureModeSupported(.continuousAutoExposure) {\n                    videoDevice.exposureMode = .continuousAutoExposure\n                }\n                videoDevice.unlockForConfiguration()\n                \n                return true\n            }\n        } catch {\n            print(\"Error setting up camera input: \\(error)\")\n        }\n        \n        return false\n    }\n    \n    private func setupOutputs() -> Bool {\n        // Setup photo output\n        if captureSession.canAddOutput(photoOutput) {\n            captureSession.addOutput(photoOutput)\n            \n            photoOutput.isHighResolutionCaptureEnabled = true\n            photoOutput.isDepthDataDeliveryEnabled = photoOutput.isDepthDataDeliverySupported\n            photoOutput.maxPhotoQualityPrioritization = .quality\n            \n            // Enable Live Photos if supported\n            if photoOutput.isLivePhotoCaptureSupported {\n                photoOutput.isLivePhotoCaptureEnabled = true\n            }\n        }\n        \n        // Setup video output for real-time processing\n        if captureSession.canAddOutput(videoOutput) {\n            captureSession.addOutput(videoOutput)\n            videoOutput.setSampleBufferDelegate(self, queue: sessionQueue)\n            return true\n        }\n        \n        return false\n    }\n    \n    // MARK: - Camera Controls\n    private func switchCamera() {\n        sessionQueue.async {\n            let currentPosition = self.videoDeviceInput.device.position\n            let newPosition: AVCaptureDevice.Position = currentPosition == .back ? .front : .back\n            \n            guard let videoDevice = AVCaptureDevice.default(.builtInWideAngleCamera, for: .video, position: newPosition) else {\n                return\n            }\n            \n            do {\n                let newVideoInput = try AVCaptureDeviceInput(device: videoDevice)\n                \n                self.captureSession.beginConfiguration()\n                self.captureSession.removeInput(self.videoDeviceInput)\n                \n                if self.captureSession.canAddInput(newVideoInput) {\n                    self.captureSession.addInput(newVideoInput)\n                    self.videoDeviceInput = newVideoInput\n                } else {\n                    self.captureSession.addInput(self.videoDeviceInput)\n                }\n                \n                self.captureSession.commitConfiguration()\n            } catch {\n                print(\"Error switching camera: \\(error)\")\n            }\n        }\n    }\n    \n    private func setZoom(_ zoomFactor: CGFloat) {\n        sessionQueue.async {\n            guard let device = self.videoDeviceInput.device else { return }\n            \n            do {\n                try device.lockForConfiguration()\n                device.videoZoomFactor = zoomFactor\n                device.unlockForConfiguration()\n            } catch {\n                print(\"Error setting zoom: \\(error)\")\n            }\n        }\n    }\n    \n    // MARK: - Photo Capture\n    private func capturePhoto() {\n        sessionQueue.async {\n            let photoSettings = AVCapturePhotoSettings()\n            \n            // Configure photo settings for best quality\n            if self.photoOutput.availablePhotoCodecTypes.contains(.hevc) {\n                photoSettings = AVCapturePhotoSettings(format: [AVVideoCodecKey: AVVideoCodecType.hevc])\n            }\n            \n            photoSettings.isHighResolutionPhotoEnabled = true\n            photoSettings.flashMode = .auto\n            \n            // Enable depth data if available\n            if self.photoOutput.isDepthDataDeliverySupported {\n                photoSettings.isDepthDataDeliveryEnabled = true\n            }\n            \n            // Enable Live Photo if available\n            if self.photoOutput.isLivePhotoCaptureSupported {\n                let livePhotoMovieFileName = NSUUID().uuidString\n                let livePhotoMovieFilePath = (NSTemporaryDirectory() as NSString).appendingPathComponent((livePhotoMovieFileName as NSString).appendingPathExtension(\"mov\")!)\n                photoSettings.livePhotoMovieFileURL = URL(fileURLWithPath: livePhotoMovieFilePath)\n            }\n            \n            self.photoOutput.capturePhoto(with: photoSettings, delegate: self)\n        }\n    }\n}\n\n// MARK: - AVCapture Delegates\nextension ProfessionalCameraViewController: AVCapturePhotoCaptureDelegate {\n    func photoOutput(_ output: AVCapturePhotoOutput, didFinishProcessingPhoto photo: AVCapturePhoto, error: Error?) {\n        guard error == nil else {\n            print(\"Error capturing photo: \\(error!)\")\n            return\n        }\n        \n        // Process the captured photo\n        if let imageData = photo.fileDataRepresentation(),\n           let image = UIImage(data: imageData) {\n            \n            // Apply filter if selected\n            if let filter = currentFilter {\n                let processedImage = imageProcessor.processImage(image, with: filter)\n                savePhotoToLibrary(processedImage ?? image)\n            } else {\n                savePhotoToLibrary(image)\n            }\n        }\n    }\n}\n\nextension ProfessionalCameraViewController: AVCaptureVideoDataOutputSampleBufferDelegate {\n    func captureOutput(_ output: AVCaptureOutput, didOutput sampleBuffer: CMSampleBuffer, from connection: AVCaptureConnection) {\n        // Real-time video processing for preview\n        guard let pixelBuffer = CMSampleBufferGetImageBuffer(sampleBuffer),\n              let filter = currentFilter else { return }\n        \n        // Apply filter to live preview\n        if let filteredPixelBuffer = imageProcessor.applyFilterToLivePreview(pixelBuffer: pixelBuffer, filter: filter) {\n            // Update preview with filtered buffer (simplified)\n            // In practice, you'd update a Metal or OpenGL view\n        }\n    }\n}\n\n// MARK: - Photo Library Management\nclass AdvancedPhotoManager {\n    static let shared = AdvancedPhotoManager()\n    private let imageManager = PHCachingImageManager()\n    \n    func savePhotoToLibrary(_ image: UIImage, completion: @escaping (Bool, Error?) -> Void) {\n        PHPhotoLibrary.requestAuthorization { status in\n            guard status == .authorized else {\n                completion(false, NSError(domain: \"PhotoLibrary\", code: -1, userInfo: [NSLocalizedDescriptionKey: \"Photo library access denied\"]))\n                return\n            }\n            \n            PHPhotoLibrary.shared().performChanges({\n                PHAssetChangeRequest.creationRequestForAsset(from: image)\n            }) { success, error in\n                DispatchQueue.main.async {\n                    completion(success, error)\n                }\n            }\n        }\n    }\n    \n    func fetchAssetsWithAdvancedOptions() -> PHFetchResult<PHAsset> {\n        let fetchOptions = PHFetchOptions()\n        \n        // Smart filtering\n        let datePredicate = NSPredicate(format: \"creationDate > %@\", Date().addingTimeInterval(-30*24*60*60) as CVarArg)\n        let mediaTypePredicate = NSPredicate(format: \"mediaType = %d\", PHAssetMediaType.image.rawValue)\n        \n        fetchOptions.predicate = NSCompoundPredicate(andPredicateWithSubpredicates: [\n            datePredicate, mediaTypePredicate\n        ])\n        \n        fetchOptions.sortDescriptors = [\n            NSSortDescriptor(key: \"creationDate\", ascending: false),\n            NSSortDescriptor(key: \"favorite\", ascending: false)\n        ]\n        \n        fetchOptions.fetchLimit = 1000\n        \n        return PHAsset.fetchAssets(with: fetchOptions)\n    }\n    \n    func createSmartAlbum(named title: String, assetIDs: [String], completion: @escaping (PHAssetCollection?) -> Void) {\n        PHPhotoLibrary.shared().performChanges({\n            // Create album\n            let createAlbumRequest = PHAssetCollectionChangeRequest.creationRequestForAssetCollection(withTitle: title)\n            let albumPlaceholder = createAlbumRequest.placeholderForCreatedAssetCollection\n            \n            // Fetch assets to add\n            let assets = PHAsset.fetchAssets(withLocalIdentifiers: assetIDs, options: nil)\n            \n            // Add assets to album\n            if assets.count > 0 {\n                let assetChangeRequest = PHAssetCollectionChangeRequest(for: albumPlaceholder, assets: PHAsset.fetchAssets(with: PHFetchOptions()))\n                assetChangeRequest?.addAssets(assets)\n            }\n            \n        }) { success, error in\n            DispatchQueue.main.async {\n                if success {\n                    // Fetch the created album\n                    let fetchOptions = PHFetchOptions()\n                    fetchOptions.predicate = NSPredicate(format: \"title = %@\", title)\n                    let collections = PHAssetCollection.fetchAssetCollections(with: .album, subtype: .any, options: fetchOptions)\n                    completion(collections.firstObject)\n                } else {\n                    completion(nil)\n                }\n            }\n        }\n    }\n}\n\n// MARK: - Real-time Image Processing\nclass AdvancedImageProcessor {\n    private let context = CIContext()\n    private var filterChain: [CIFilter] = []\n    \n    func addFilter(_ filter: CIFilter) {\n        filterChain.append(filter)\n    }\n    \n    func processImage(_ image: UIImage) -> UIImage? {\n        guard let ciImage = CIImage(image: image) else { return nil }\n        \n        var currentImage = ciImage\n        \n        // Apply filter chain\n        for filter in filterChain {\n            filter.setValue(currentImage, forKey: kCIInputImageKey)\n            if let outputImage = filter.outputImage {\n                currentImage = outputImage\n            }\n        }\n        \n        // Render final image\n        guard let cgImage = context.createCGImage(currentImage, from: currentImage.extent) else {\n            return nil\n        }\n        \n        return UIImage(cgImage: cgImage)\n    }\n    \n    func createProfessionalFilterPreset(_ preset: FilterPreset) -> [CIFilter] {\n        switch preset {\n        case .vintage:\n            return createVintagePreset()\n        case .dramatic:\n            return createDramaticPreset()\n        case .cinematic:\n            return createCinematicPreset()\n        }\n    }\n    \n    private func createVintagePreset() -> [CIFilter] {\n        let sepia = CIFilter(name: \"CISepiaTone\")!\n        sepia.setValue(0.5, forKey: kCIInputIntensityKey)\n        \n        let vignette = CIFilter(name: \"CIVignette\")!\n        vignette.setValue(1.5, forKey: kCIInputRadiusKey)\n        vignette.setValue(2.0, forKey: kCIInputIntensityKey)\n        \n        return [sepia, vignette]\n    }\n}\n\nenum FilterPreset {\n    case vintage, dramatic, cinematic\n}\n\n// MARK: - Performance Optimized Thumbnail Manager\nclass PerformanceThumbnailManager {\n    private let imageManager = PHCachingImageManager()\n    private var thumbnailCache: NSCache<NSString, UIImage> = {\n        let cache = NSCache<NSString, UIImage>()\n        cache.countLimit = 200\n        cache.totalCostLimit = 1024 * 1024 * 100 // 100MB\n        return cache\n    }()\n    \n    func loadThumbnail(for asset: PHAsset, targetSize: CGSize, completion: @escaping (UIImage?) -> Void) {\n        let cacheKey = \"\\(asset.localIdentifier)_\\(targetSize.width)x\\(targetSize.height)\" as NSString\n        \n        // Check memory cache\n        if let cachedImage = thumbnailCache.object(forKey: cacheKey) {\n            completion(cachedImage)\n            return\n        }\n        \n        let options = PHImageRequestOptions()\n        options.deliveryMode = .highQualityFormat\n        options.resizeMode = .fast\n        options.isNetworkAccessAllowed = true\n        \n        imageManager.requestImage(for: asset, \n                                 targetSize: targetSize, \n                                 contentMode: .aspectFill, \n                                 options: options) { [weak self] image, info in\n            if let image = image {\n                // Calculate cost (rough estimation)\n                let cost = Int(image.size.width * image.size.height * 4) // 4 bytes per pixel\n                self?.thumbnailCache.setObject(image, forKey: cacheKey, cost: cost)\n            }\n            completion(image)\n        }\n    }\n    \n    func preloadThumbnails(for assets: [PHAsset], targetSize: CGSize) {\n        imageManager.startCachingImages(for: assets, \n                                       targetSize: targetSize, \n                                       contentMode: .aspectFill, \n                                       options: nil)\n    }\n    \n    func clearCache() {\n        thumbnailCache.removeAllObjects()\n        imageManager.stopCachingImagesForAllAssets()\n    }\n}",
      "category": "Media & Camera",
      "estimatedTime": 240,
      "dependencies": ["ui_components", "permissions", "av_foundation_basics"],
      "challenge": {
        "instructions": "Build a professional-grade camera and photo management app with advanced features:\n\nPART 1: Advanced Camera UI & Controls (90 min)\n1. Create a custom camera overlay with professional controls\n2. Implement manual focus, exposure, and white balance controls\n3. Add real-time histogram display and focus peaking\n4. Create custom gesture recognizers for pinch-to-zoom and tap-to-focus\n\nPART 2: Real-time Image Processing (90 min)\n5. Implement live filter preview using AVCaptureVideoDataOutput\n6. Create a filter chain system with multiple CIFilter combinations\n7. Add real-time face detection and beauty filters\n8. Implement depth-based effects for dual-camera devices\n\nPART 3: Advanced Photo Library (90 min)\n9. Build a smart album system with custom filters and sorting\n10. Implement batch operations for photo management\n11. Create a memory-efficient thumbnail grid with prefetching\n12. Add advanced search with metadata filtering\n\nPART 4: Performance Optimization (60 min)\n13. Implement memory-efficient image loading with proper caching\n14. Add background photo processing with progress tracking\n15. Optimize camera startup time and memory usage\n16. Implement proper error handling and user feedback\n\nPART 5: Professional Features (60 min)\n17. Add Live Photo capture and playback\n18. Implement RAW photo capture and processing\n19. Create portrait mode with depth data visualization\n20. Add photo editing with non-destructive edits",
        "starterCode": "import UIKit\nimport Photos\nimport AVFoundation\nimport CoreImage\n\n// === PART 1: Advanced Camera UI & Controls ===\n// Create custom camera overlay and controls\n\n\n// === PART 2: Real-time Image Processing ===\n// Implement live filter preview and processing\n\n\n// === PART 3: Advanced Photo Library ===\n// Build smart album system and batch operations\n\n\n// === PART 4: Performance Optimization ===\n// Implement caching and memory management\n\n\n// === PART 5: Professional Features ===\n// Add Live Photos, RAW capture, and editing\n\n",
        "solution": "import UIKit\nimport Photos\nimport AVFoundation\nimport CoreImage\n\n// === PART 1: Advanced Camera UI & Controls ===\nclass ProfessionalCameraOverlay: UIView {\n    private let focusRing = UIView()\n    private let exposureSlider = UISlider()\n    private let histogramView = HistogramView()\n    \n    override init(frame: CGRect) {\n        super.init(frame: frame)\n        setupProfessionalControls()\n    }\n    \n    private func setupProfessionalControls() {\n        // Focus ring\n        focusRing.frame = CGRect(x: 0, y: 0, width: 80, height: 80)\n        focusRing.layer.borderColor = UIColor.yellow.cgColor\n        focusRing.layer.borderWidth = 2\n        focusRing.layer.cornerRadius = 40\n        focusRing.isHidden = true\n        addSubview(focusRing)\n        \n        // Exposure control\n        exposureSlider.frame = CGRect(x: 20, y: bounds.height - 100, width: bounds.width - 40, height: 40)\n        exposureSlider.minimumValue = -4\n        exposureSlider.maximumValue = 4\n        exposureSlider.value = 0\n        exposureSlider.addTarget(self, action: #selector(exposureChanged), for: .valueChanged)\n        addSubview(exposureSlider)\n        \n        // Histogram\n        histogramView.frame = CGRect(x: 20, y: 50, width: 150, height: 60)\n        histogramView.backgroundColor = UIColor.black.withAlphaComponent(0.5)\n        addSubview(histogramView)\n    }\n    \n    @objc private func exposureChanged() {\n        // Delegate exposure change to camera controller\n    }\n    \n    func showFocusRing(at point: CGPoint) {\n        focusRing.center = point\n        focusRing.isHidden = false\n        \n        UIView.animate(withDuration: 0.2) {\n            self.focusRing.transform = CGAffineTransform(scaleX: 1.2, y: 1.2)\n        } completion: { _ in\n            UIView.animate(withDuration: 0.2) {\n                self.focusRing.transform = .identity\n            }\n        }\n    }\n}\n\n// === PART 2: Real-time Image Processing ===\nclass LiveFilterProcessor {\n    private let context = CIContext()\n    private var currentFilterChain: [CIFilter] = []\n    \n    func processVideoFrame(_ pixelBuffer: CVPixelBuffer) -> CVPixelBuffer? {\n        let ciImage = CIImage(cvPixelBuffer: pixelBuffer)\n        var currentImage = ciImage\n        \n        // Apply filter chain\n        for filter in currentFilterChain {\n            filter.setValue(currentImage, forKey: kCIInputImageKey)\n            if let outputImage = filter.outputImage {\n                currentImage = outputImage\n            }\n        }\n        \n        // Render back to pixel buffer\n        var outputBuffer: CVPixelBuffer?\n        let status = CVPixelBufferCreate(nil, \n                                        CVPixelBufferGetWidth(pixelBuffer),\n                                        CVPixelBufferGetHeight(pixelBuffer),\n                                        CVPixelBufferGetPixelFormatType(pixelBuffer),\n                                        nil,\n                                        &outputBuffer)\n        \n        guard status == kCVReturnSuccess, let outputBuffer = outputBuffer else {\n            return nil\n        }\n        \n        context.render(currentImage, to: outputBuffer)\n        return outputBuffer\n    }\n    \n    func addFaceBeautyFilter() {\n        let skinSmoothing = CIFilter(name: \"CISepiaTone\")! // Placeholder for skin smoothing\n        let colorAdjust = CIFilter(name: \"CIColorControls\")!\n        colorAdjust.setValue(1.1, forKey: kCIInputSaturationKey)\n        \n        currentFilterChain = [skinSmoothing, colorAdjust]\n    }\n}\n\n// === PART 3: Advanced Photo Library ===\nclass SmartAlbumManager {\n    func createSmartAlbum(with rules: [AlbumRule]) -> PHAssetCollection? {\n        // Implementation for creating smart albums based on rules\n        return nil\n    }\n    \n    func performBatchOperations(_ operations: [BatchOperation], completion: @escaping (Bool) -> Void) {\n        PHPhotoLibrary.shared().performChanges({\n            for operation in operations {\n                switch operation {\n                case .deleteAssets(let assets):\n                    PHAssetChangeRequest.deleteAssets(assets as NSArray)\n                case .addToAlbum(let assets, let album):\n                    if let changeRequest = PHAssetCollectionChangeRequest(for: album) {\n                        changeRequest.addAssets(assets as NSArray)\n                    }\n                case .createAlbum(let title):\n                    PHAssetCollectionChangeRequest.creationRequestForAssetCollection(withTitle: title)\n                }\n            }\n        }) { success, error in\n            DispatchQueue.main.async {\n                completion(success)\n            }\n        }\n    }\n}\n\nenum AlbumRule {\n    case dateRange(Date, Date)\n    case location(CLLocation, Double) // location and radius\n    case mediaType(PHAssetMediaType)\n}\n\nenum BatchOperation {\n    case deleteAssets([PHAsset])\n    case addToAlbum([PHAsset], PHAssetCollection)\n    case createAlbum(String)\n}\n\n// === PART 4: Performance Optimization ===\nclass MemoryEfficientImageCache {\n    private let cache = NSCache<NSString, UIImage>()\n    private var memoryWarningObserver: NSObjectProtocol?\n    \n    init() {\n        cache.totalCostLimit = 1024 * 1024 * 100 // 100MB\n        setupMemoryWarningHandler()\n    }\n    \n    private func setupMemoryWarningHandler() {\n        memoryWarningObserver = NotificationCenter.default.addObserver(\n            forName: UIApplication.didReceiveMemoryWarningNotification,\n            object: nil,\n            queue: .main\n        ) { [weak self] _ in\n            self?.cache.removeAllObjects()\n        }\n    }\n    \n    func image(for key: String) -> UIImage? {\n        return cache.object(forKey: key as NSString)\n    }\n    \n    func setImage(_ image: UIImage, for key: String) {\n        let cost = Int(image.size.width * image.size.height * 4)\n        cache.setObject(image, forKey: key as NSString, cost: cost)\n    }\n}\n\n// === PART 5: Professional Features ===\nclass LivePhotoController {\n    func captureLivePhoto(completion: @escaping (PHLivePhoto?) -> Void) {\n        // Implementation for Live Photo capture\n    }\n    \n    func processRAWImage(_ rawData: Data) -> UIImage? {\n        // Implementation for RAW processing\n        return nil\n    }\n}\n\nclass PortraitModeProcessor {\n    func applyPortraitEffects(to image: UIImage, depthData: AVDepthData) -> UIImage? {\n        // Implementation for portrait mode with depth data\n        return nil\n    }\n    \n    func visualizeDepthData(_ depthData: AVDepthData) -> UIImage? {\n        // Create depth map visualization\n        return nil\n    }\n}",
        "hints": [
          "PART 1: Use AVCaptureDevice.lockForConfiguration() for manual camera controls",
          "PART 2: Process video frames in AVCaptureVideoDataOutputSampleBufferDelegate",
          "PART 3: Use PHFetchOptions with NSPredicate for smart album filtering",
          "PART 4: Implement NSCache with proper cost calculation for memory management",
          "PART 5: Use PHLivePhoto for Live Photos and CIDepthBlurEffect for portrait mode",
          "Always request photo library authorization before accessing assets",
          "Use background queues for heavy image processing operations",
          "Implement proper error handling for camera and photo library operations"
        ],
        "testCases": [
          {
            "input": "cameraController.isManualFocusSupported",
            "expectedOutput": "true",
            "description": "Camera should support manual focus controls"
          },
          {
            "input": "photoManager.authorizationStatus == .authorized",
            "expectedOutput": "true",
            "description": "App should have photo library access"
          },
          {
            "input": "filterProcessor.currentFilterChain.isEmpty == false",
            "expectedOutput": "true",
            "description": "Filter processor should have active filters"
          }
        ]
      }
    },
    {
      "id": "advanced_mapkit",
      "title": "Advanced MapKit & Location Services",
      "description": "Master advanced MapKit features including custom annotations, overlays, clustering, and real-time location tracking",
      "difficulty": "advanced",
      "theory": "# Advanced MapKit & Location Services\n\n## 1. Advanced Map Configuration & Customization (60 min)\n\n### Map Types & Custom Styles\n```swift\nimport MapKit\n\nclass AdvancedMapViewController: UIViewController {\n    @IBOutlet weak var mapView: MKMapView!\n    \n    override func viewDidLoad() {\n        super.viewDidLoad()\n        \n        // Configure map type\n        mapView.mapType = .hybridFlyover\n        mapView.showsBuildings = true\n        mapView.showsTraffic = true\n        mapView.showsScale = true\n        mapView.showsCompass = true\n        mapView.showsUserLocation = true\n        \n        // Custom map region\n        let center = CLLocationCoordinate2D(latitude: 37.7749, longitude: -122.4194)\n        let region = MKCoordinateRegion(\n            center: center,\n            latitudinalMeters: 1000,\n            longitudinalMeters: 1000\n        )\n        mapView.setRegion(region, animated: true)\n        \n        // Apply custom map style\n        applyCustomMapStyle()\n    }\n    \n    private func applyCustomMapStyle() {\n        if #available(iOS 13.0, *) {\n            let configuration = MKStandardMapConfiguration()\n            configuration.elevationStyle = .realistic\n            configuration.pointOfInterestFilter = .excludingAll\n            configuration.mapView?.pointOfInterestFilter = .excludingAll\n            \n            mapView.preferredConfiguration = configuration\n        }\n    }\n}\n```\n\n### Camera & 3D Effects\n```swift\nclass CameraMapViewController: UIViewController {\n    @IBOutlet weak var mapView: MKMapView!\n    \n    func setup3DCamera() {\n        let center = CLLocationCoordinate2D(latitude: 40.7589, longitude: -73.9851)\n        \n        // 3D camera perspective\n        let camera = MKMapCamera(\n            lookingAtCenter: center,\n            fromDistance: 1000,\n            pitch: 45.0,\n            heading: 0\n        )\n        \n        mapView.setCamera(camera, animated: true)\n    }\n    \n    func animateCamera() {\n        let newCenter = CLLocationCoordinate2D(latitude: 34.0522, longitude: -118.2437)\n        \n        UIView.animate(withDuration: 2.0) {\n            let camera = MKMapCamera(\n                lookingAtCenter: newCenter,\n                fromDistance: 2000,\n                pitch: 60.0,\n                heading: 45.0\n            )\n            self.mapView.setCamera(camera, animated: false)\n        }\n    }\n}\n```\n\n## 2. Custom Annotations & Clustering (90 min)\n\n### Advanced Annotation Views\n```swift\n// Custom Annotation Data Model\nclass CustomPointAnnotation: NSObject, MKAnnotation {\n    let id: String\n    let coordinate: CLLocationCoordinate2D\n    let title: String?\n    let subtitle: String?\n    let type: AnnotationType\n    let priority: Int\n    \n    init(id: String, coordinate: CLLocationCoordinate2D, title: String?, subtitle: String?, type: AnnotationType, priority: Int = 1) {\n        self.id = id\n        self.coordinate = coordinate\n        self.title = title\n        self.subtitle = subtitle\n        self.type = type\n        self.priority = priority\n    }\n    \n    enum AnnotationType {\n        case restaurant, hotel, attraction, emergency, custom\n    }\n}\n\n// Custom Annotation View with Dynamic Styling\nclass CustomAnnotationView: MKMarkerAnnotationView {\n    static let reuseIdentifier = \"CustomAnnotationView\"\n    \n    override var annotation: MKAnnotation? {\n        didSet {\n            configureForAnnotation()\n        }\n    }\n    \n    private func configureForAnnotation() {\n        guard let customAnnotation = annotation as? CustomPointAnnotation else { return }\n        \n        // Configure based on annotation type\n        switch customAnnotation.type {\n        case .restaurant:\n            markerTintColor = .systemGreen\n            glyphImage = UIImage(systemName: \"fork.knife\")\n            glyphTintColor = .white\n            \n        case .hotel:\n            markerTintColor = .systemBlue\n            glyphImage = UIImage(systemName: \"bed.double\")\n            \n        case .attraction:\n            markerTintColor = .systemOrange\n            glyphImage = UIImage(systemName: \"star\")\n            \n        case .emergency:\n            markerTintColor = .systemRed\n            glyphImage = UIImage(systemName: \"exclamationmark.triangle\")\n            \n        case .custom:\n            markerTintColor = .systemPurple\n            glyphImage = UIImage(systemName: \"pin\")\n        }\n        \n        // Priority-based styling\n        if customAnnotation.priority > 1 {\n            glyphTintColor = .systemYellow\n            animatesWhenAdded = true\n        }\n        \n        canShowCallout = true\n        calloutOffset = CGPoint(x: -5, y: 5)\n        \n        // Add custom callout accessories\n        let infoButton = UIButton(type: .detailDisclosure)\n        rightCalloutAccessoryView = infoButton\n        \n        let imageView = UIImageView(image: UIImage(systemName: \"info.circle\"))\n        leftCalloutAccessoryView = imageView\n    }\n}\n```\n\n### Annotation Clustering\n```swift\n// Cluster Annotation View\nclass ClusterAnnotationView: MKMarkerAnnotationView {\n    override var annotation: MKAnnotation? {\n        didSet {\n            configureForCluster()\n        }\n    }\n    \n    private func configureForCluster() {\n        guard let cluster = annotation as? MKClusterAnnotation else { return }\n        \n        markerTintColor = .systemBlue\n        glyphTintColor = .white\n        \n        // Show count of annotations in cluster\n        if let memberAnnotations = cluster.memberAnnotations {\n            glyphText = \"\\(memberAnnotations.count)\"\n        }\n        \n        // Scale based on cluster size\n        let scale = min(1.0, 0.4 + Double(cluster.memberAnnotations?.count ?? 0) * 0.1)\n        self.transform = CGAffineTransform(scaleX: CGFloat(scale), y: CGFloat(scale))\n    }\n}\n\n// Map View Delegate for Clustering\nclass ClusterMapViewController: UIViewController, MKMapViewDelegate {\n    @IBOutlet weak var mapView: MKMapView!\n    \n    override func viewDidLoad() {\n        super.viewDidLoad()\n        mapView.delegate = self\n        setupClustering()\n    }\n    \n    private func setupClustering() {\n        // Register cluster annotation view\n        mapView.register(ClusterAnnotationView.self, forAnnotationViewWithReuseIdentifier: MKMapViewDefaultClusterAnnotationViewReuseIdentifier)\n        \n        // Add sample annotations\n        addSampleAnnotations()\n    }\n    \n    private func addSampleAnnotations() {\n        var annotations: [CustomPointAnnotation] = []\n        \n        // Create clustered annotations\n        for i in 0..<50 {\n            let latitude = 37.7749 + Double.random(in: -0.1...0.1)\n            let longitude = -122.4194 + Double.random(in: -0.1...0.1)\n            \n            let annotation = CustomPointAnnotation(\n                id: \"annotation-\\(i)\",\n                coordinate: CLLocationCoordinate2D(latitude: latitude, longitude: longitude),\n                title: \"Point \\(i)\",\n                subtitle: \"San Francisco\",\n                type: .custom,\n                priority: Int.random(in: 1...3)\n            )\n            annotations.append(annotation)\n        }\n        \n        mapView.addAnnotations(annotations)\n    }\n    \n    // MARK: - MKMapViewDelegate\n    \n    func mapView(_ mapView: MKMapView, viewFor annotation: MKAnnotation) -> MKAnnotationView? {\n        if annotation is MKUserLocation {\n            return nil\n        }\n        \n        if let cluster = annotation as? MKClusterAnnotation {\n            return ClusterAnnotationView(annotation: cluster, reuseIdentifier: \"cluster\")\n        }\n        \n        if let customAnnotation = annotation as? CustomPointAnnotation {\n            let view = mapView.dequeueReusableAnnotationView(withIdentifier: CustomAnnotationView.reuseIdentifier, for: customAnnotation) as? CustomAnnotationView\n            return view ?? CustomAnnotationView(annotation: customAnnotation, reuseIdentifier: CustomAnnotationView.reuseIdentifier)\n        }\n        \n        return nil\n    }\n    \n    func mapView(_ mapView: MKMapView, clusterAnnotationForMemberAnnotations memberAnnotations: [MKAnnotation]) -> MKClusterAnnotation {\n        return MKClusterAnnotation(memberAnnotations: memberAnnotations)\n    }\n}\n```\n\n## 3. Advanced Overlays & Geometry (90 min)\n\n### Custom Overlays\n```swift\n// Custom Circle Overlay\nclass CustomCircleOverlay: NSObject, MKOverlay {\n    let coordinate: CLLocationCoordinate2D\n    let boundingMapRect: MKMapRect\n    let radius: CLLocationDistance\n    \n    init(center: CLLocationCoordinate2D, radius: CLLocationDistance) {\n        self.coordinate = center\n        self.radius = radius\n        \n        // Calculate bounding map rect\n        let region = MKCoordinateRegion(center: center, latitudinalMeters: radius * 2, longitudinalMeters: radius * 2)\n        self.boundingMapRect = MKMapRect(\n            origin: MKMapPoint(region.center),\n            size: MKMapSize(width: region.span.longitudeDelta, height: region.span.latitudeDelta)\n        )\n    }\n}\n\n// Custom Overlay Renderer\nclass CustomCircleRenderer: MKOverlayRenderer {\n    override func draw(_ mapRect: MKMapRect, zoomScale: MKZoomScale, in context: CGContext) {\n        guard let circleOverlay = overlay as? CustomCircleOverlay else { return }\n        \n        // Set drawing properties\n        context.setLineWidth(2.0 / zoomScale)\n        context.setStrokeColor(UIColor.systemBlue.cgColor)\n        context.setFillColor(UIColor.systemBlue.withAlphaComponent(0.3).cgColor)\n        \n        // Create circle path\n        let centerPoint = point(for: circleOverlay.coordinate)\n        let radiusInPoints = metersToPoints(meters: circleOverlay.radius, zoomScale: zoomScale)\n        \n        let circlePath = UIBezierPath(\n            ovalIn: CGRect(\n                x: centerPoint.x - radiusInPoints,\n                y: centerPoint.y - radiusInPoints,\n                width: radiusInPoints * 2,\n                height: radiusInPoints * 2\n            )\n        )\n        \n        // Draw circle\n        context.addPath(circlePath.cgPath)\n        context.drawPath(using: .fillStroke)\n    }\n    \n    private func metersToPoints(meters: CLLocationDistance, zoomScale: MKZoomScale) -> CGFloat {\n        let metersPerPoint = MKMetersPerMapPointAtLatitude((overlay as? CustomCircleOverlay)?.coordinate.latitude ?? 0)\n        return CGFloat(meters / metersPerPoint) * CGFloat(zoomScale)\n    }\n}\n\n// Polygon with Hole\nclass ComplexOverlayViewController: UIViewController, MKMapViewDelegate {\n    @IBOutlet weak var mapView: MKMapView!\n    \n    override func viewDidLoad() {\n        super.viewDidLoad()\n        mapView.delegate = self\n        addComplexOverlays()\n    }\n    \n    private func addComplexOverlays() {\n        // Main polygon coordinates\n        let mainPolygonCoords = [\n            CLLocationCoordinate2D(latitude: 37.78, longitude: -122.42),\n            CLLocationCoordinate2D(latitude: 37.78, longitude: -122.40),\n            CLLocationCoordinate2D(latitude: 37.76, longitude: -122.40),\n            CLLocationCoordinate2D(latitude: 37.76, longitude: -122.42)\n        ]\n        \n        // Hole coordinates\n        let holeCoords = [\n            CLLocationCoordinate2D(latitude: 37.775, longitude: -122.415),\n            CLLocationCoordinate2D(latitude: 37.775, longitude: -122.405),\n            CLLocationCoordinate2D(latitude: 37.765, longitude: -122.405),\n            CLLocationCoordinate2D(latitude: 37.765, longitude: -122.415)\n        ]\n        \n        let polygon = MKPolygon(coordinates: mainPolygonCoords, count: mainPolygonCoords.count, interiorPolygons: [MKPolygon(coordinates: holeCoords, count: holeCoords.count)])\n        mapView.addOverlay(polygon)\n        \n        // Add custom circle overlay\n        let circleCenter = CLLocationCoordinate2D(latitude: 37.77, longitude: -122.41)\n        let customCircle = CustomCircleOverlay(center: circleCenter, radius: 500)\n        mapView.addOverlay(customCircle)\n    }\n    \n    // MARK: - MKMapViewDelegate\n    \n    func mapView(_ mapView: MKMapView, rendererFor overlay: MKOverlay) -> MKOverlayRenderer {\n        if let polygon = overlay as? MKPolygon {\n            let renderer = MKPolygonRenderer(polygon: polygon)\n            renderer.fillColor = UIColor.systemBlue.withAlphaComponent(0.3)\n            renderer.strokeColor = UIColor.systemBlue\n            renderer.lineWidth = 2.0\n            renderer.alpha = 0.7\n            return renderer\n        }\n        \n        if let circle = overlay as? MKCircle {\n            let renderer = MKCircleRenderer(circle: circle)\n            renderer.fillColor = UIColor.systemRed.withAlphaComponent(0.2)\n            renderer.strokeColor = UIColor.systemRed\n            renderer.lineWidth = 3.0\n            return renderer\n        }\n        \n        if let customCircle = overlay as? CustomCircleOverlay {\n            return CustomCircleRenderer(overlay: customCircle)\n        }\n        \n        return MKOverlayRenderer(overlay: overlay)\n    }\n}\n```\n\n### Gradient Overlays\n```swift\n// Heat Map Style Gradient Overlay\nclass GradientOverlayRenderer: MKOverlayRenderer {\n    private let gradientColors: [UIColor]\n    private let gradientLocations: [CGFloat]\n    \n    init(overlay: MKOverlay, colors: [UIColor], locations: [CGFloat]) {\n        self.gradientColors = colors\n        self.gradientLocations = locations\n        super.init(overlay: overlay)\n    }\n    \n    override func draw(_ mapRect: MKMapRect, zoomScale: MKZoomScale, in context: CGContext) {\n        guard let polygon = overlay as? MKPolygon else { return }\n        \n        // Create gradient\n        let colorSpace = CGColorSpaceCreateDeviceRGB()\n        let cgColors = gradientColors.map { $0.cgColor } as CFArray\n        \n        guard let gradient = CGGradient(colorsSpace: colorSpace, colors: cgColors, locations: gradientLocations) else {\n            return\n        }\n        \n        // Draw polygon with gradient\n        let path = polygonPath(for: polygon)\n        context.addPath(path)\n        context.clip()\n        \n        let boundingBox = path.boundingBox\n        let startPoint = CGPoint(x: boundingBox.minX, y: boundingBox.minY)\n        let endPoint = CGPoint(x: boundingBox.maxX, y: boundingBox.maxY)\n        \n        context.drawLinearGradient(gradient, start: startPoint, end: endPoint, options: [])\n    }\n    \n    private func polygonPath(for polygon: MKPolygon) -> CGPath {\n        let path = CGMutablePath()\n        var points = polygon.points()\n        \n        if polygon.pointCount > 0 {\n            let firstPoint = point(for: points[0].coordinate)\n            path.move(to: firstPoint)\n            \n            for i in 1..<polygon.pointCount {\n                let point = self.point(for: points[i].coordinate)\n                path.addLine(to: point)\n            }\n            \n            path.closeSubpath()\n        }\n        \n        return path\n    }\n}\n```\n\n## 4. Real-time Location Tracking & Geofencing (60 min)\n\n### Advanced Location Manager\n```swift\nimport CoreLocation\n\nclass AdvancedLocationManager: NSObject, ObservableObject {\n    private let locationManager = CLLocationManager()\n    \n    @Published var currentLocation: CLLocation?\n    @Published var authorizationStatus: CLAuthorizationStatus\n    @Published var trackedLocations: [CLLocation] = []\n    @Published var activeGeofences: [CLCircularRegion] = []\n    \n    override init() {\n        self.authorizationStatus = locationManager.authorizationStatus\n        super.init()\n        \n        locationManager.delegate = self\n        locationManager.desiredAccuracy = kCLLocationAccuracyBest\n        locationManager.distanceFilter = 10.0 // Update every 10 meters\n        locationManager.activityType = .fitness\n        locationManager.pausesLocationUpdatesAutomatically = false\n        \n        #if os(iOS)\n        locationManager.showsBackgroundLocationIndicator = true\n        locationManager.allowsBackgroundLocationUpdates = true\n        #endif\n    }\n    \n    func startTracking() {\n        switch authorizationStatus {\n        case .notDetermined:\n            locationManager.requestWhenInUseAuthorization()\n            locationManager.requestAlwaysAuthorization()\n            \n        case .authorizedWhenInUse, .authorizedAlways:\n            locationManager.startUpdatingLocation()\n            locationManager.startMonitoringSignificantLocationChanges()\n            \n        default:\n            print(\"Location access denied\")\n        }\n    }\n    \n    func stopTracking() {\n        locationManager.stopUpdatingLocation()\n        locationManager.stopMonitoringSignificantLocationChanges()\n    }\n    \n    func addGeofence(center: CLLocationCoordinate2D, radius: CLLocationDistance, identifier: String) {\n        let region = CLCircularRegion(center: center, radius: radius, identifier: identifier)\n        region.notifyOnEntry = true\n        region.notifyOnExit = true\n        \n        locationManager.startMonitoring(for: region)\n        activeGeofences.append(region)\n    }\n    \n    func removeGeofence(identifier: String) {\n        if let region = activeGeofences.first(where: { $0.identifier == identifier }) {\n            locationManager.stopMonitoring(for: region)\n            activeGeofences.removeAll { $0.identifier == identifier }\n        }\n    }\n}\n\n// MARK: - CLLocationManagerDelegate\n\nextension AdvancedLocationManager: CLLocationManagerDelegate {\n    func locationManager(_ manager: CLLocationManager, didUpdateLocations locations: [CLLocation]) {\n        guard let location = locations.last else { return }\n        \n        currentLocation = location\n        trackedLocations.append(location)\n        \n        // Limit tracked locations to prevent memory issues\n        if trackedLocations.count > 1000 {\n            trackedLocations.removeFirst(500)\n        }\n        \n        // Post notification for location update\n        NotificationCenter.default.post(name: .locationDidUpdate, object: location)\n    }\n    \n    func locationManager(_ manager: CLLocationManager, didEnterRegion region: CLRegion) {\n        guard let circularRegion = region as? CLCircularRegion else { return }\n        \n        print(\"Entered geofence: \\(circularRegion.identifier)\")\n        NotificationCenter.default.post(name: .geofenceEntered, object: circularRegion)\n    }\n    \n    func locationManager(_ manager: CLLocationManager, didExitRegion region: CLRegion) {\n        guard let circularRegion = region as? CLCircularRegion else { return }\n        \n        print(\"Exited geofence: \\(circularRegion.identifier)\")\n        NotificationCenter.default.post(name: .geofenceExited, object: circularRegion)\n    }\n    \n    func locationManager(_ manager: CLLocationManager, didChangeAuthorization status: CLAuthorizationStatus) {\n        authorizationStatus = status\n        \n        if status == .authorizedWhenInUse || status == .authorizedAlways {\n            startTracking()\n        }\n    }\n    \n    func locationManager(_ manager: CLLocationManager, didFailWithError error: Error) {\n        print(\"Location manager error: \\(error.localizedDescription)\")\n    }\n}\n\n// Notifications\n extension Notification.Name {\n    static let locationDidUpdate = Notification.Name(\"locationDidUpdate\")\n    static let geofenceEntered = Notification.Name(\"geofenceEntered\")\n    static let geofenceExited = Notification.Name(\"geofenceExited\")\n}\n```\n\n### Route Tracking & Path Drawing\n```swift\nclass RouteTracker: ObservableObject {\n    @Published var currentRoute: MKPolyline?\n    @Published var routeDistance: CLLocationDistance = 0.0\n    @Published var averageSpeed: CLLocationSpeed = 0.0\n    \n    private var locations: [CLLocation] = []\n    private var timer: Timer?\n    \n    func addLocation(_ location: CLLocation) {\n        locations.append(location)\n        updateRoute()\n        calculateMetrics()\n    }\n    \n    private func updateRoute() {\n        guard locations.count >= 2 else { return }\n        \n        var coordinates = locations.map { $0.coordinate }\n        currentRoute = MKPolyline(coordinates: &coordinates, count: coordinates.count)\n    }\n    \n    private func calculateMetrics() {\n        // Calculate total distance\n        routeDistance = calculateTotalDistance()\n        \n        // Calculate average speed\n        if let firstLocation = locations.first, let lastLocation = locations.last {\n            let timeInterval = lastLocation.timestamp.timeIntervalSince(firstLocation.timestamp)\n            if timeInterval > 0 {\n                averageSpeed = routeDistance / timeInterval\n            }\n        }\n    }\n    \n    private func calculateTotalDistance() -> CLLocationDistance {\n        var totalDistance: CLLocationDistance = 0.0\n        \n        for i in 1..<locations.count {\n            totalDistance += locations[i].distance(from: locations[i - 1])\n        }\n        \n        return totalDistance\n    }\n    \n    func clearRoute() {\n        locations.removeAll()\n        currentRoute = nil\n        routeDistance = 0.0\n        averageSpeed = 0.0\n    }\n}\n\n// Route Renderer\nclass RouteRenderer: MKOverlayRenderer {\n    private let routeColor: UIColor\n    private let routeWidth: CGFloat\n    \n    init(overlay: MKOverlay, color: UIColor = .systemBlue, width: CGFloat = 4.0) {\n        self.routeColor = color\n        self.routeWidth = width\n        super.init(overlay: overlay)\n    }\n    \n    override func draw(_ mapRect: MKMapRect, zoomScale: MKZoomScale, in context: CGContext) {\n        guard let polyline = overlay as? MKPolyline else { return }\n        \n        // Configure line properties\n        context.setLineWidth(routeWidth / zoomScale)\n        context.setLineCap(.round)\n        context.setLineJoin(.round)\n        context.setStrokeColor(routeColor.cgColor)\n        \n        // Create path\n        let path = CGMutablePath()\n        var points = polyline.points()\n        \n        if polyline.pointCount > 0 {\n            let firstPoint = point(for: points[0].coordinate)\n            path.move(to: firstPoint)\n            \n            for i in 1..<polyline.pointCount {\n                let point = self.point(for: points[i].coordinate)\n                path.addLine(to: point)\n            }\n        }\n        \n        // Draw path\n        context.addPath(path)\n        context.strokePath()\n    }\n}\n```\n\n## 5. Performance Optimization & Best Practices (30 min)\n\n### Memory Management & Performance\n```swift\nclass OptimizedMapViewController: UIViewController, MKMapViewDelegate {\n    @IBOutlet weak var mapView: MKMapView!\n    \n    private var annotationReuseQueue = Set<MKAnnotation>()\n    private var overlayReuseQueue = Set<MKOverlay>()\n    private let maxAnnotations = 1000\n    private let maxOverlays = 50\n    \n    override func viewDidLoad() {\n        super.viewDidLoad()\n        mapView.delegate = self\n        setupPerformanceOptimizations()\n    }\n    \n    private func setupPerformanceOptimizations() {\n        // Enable clustering for better performance with many annotations\n        if #available(iOS 11.0, *) {\n            mapView.register(CustomAnnotationView.self, forAnnotationViewWithReuseIdentifier: MKMapViewDefaultAnnotationViewReuseIdentifier)\n        }\n        \n        // Limit visible annotations based on zoom level\n        mapView.delegate = self\n    }\n    \n    func addOptimizedAnnotations(_ annotations: [MKAnnotation]) {\n        // Remove old annotations if we exceed the limit\n        if mapView.annotations.count + annotations.count > maxAnnotations {\n            let oldAnnotations = mapView.annotations.filter { !($0 is MKUserLocation) }\n            let annotationsToRemove = Array(oldAnnotations.prefix(annotations.count))\n            mapView.removeAnnotations(annotationsToRemove)\n        }\n        \n        mapView.addAnnotations(annotations)\n    }\n    \n    func addOptimizedOverlay(_ overlay: MKOverlay) {\n        // Remove old overlays if we exceed the limit\n        if mapView.overlays.count >= maxOverlays {\n            let overlayToRemove = mapView.overlays.first\n            if let overlayToRemove = overlayToRemove {\n                mapView.removeOverlay(overlayToRemove)\n            }\n        }\n        \n        mapView.addOverlay(overlay)\n    }\n    \n    // MARK: - MKMapViewDelegate\n    \n    func mapView(_ mapView: MKMapView, regionDidChangeAnimated animated: Bool) {\n        // Optimize annotations based on current zoom level\n        optimizeAnnotationsForCurrentZoom()\n    }\n    \n    private func optimizeAnnotationsForCurrentZoom() {\n        let zoomLevel = calculateZoomLevel()\n        \n        // Show fewer annotations at lower zoom levels\n        if zoomLevel < 10 {\n            // Only show high-priority annotations\n            let highPriorityAnnotations = mapView.annotations.filter { annotation in\n                if let customAnnotation = annotation as? CustomPointAnnotation {\n                    return customAnnotation.priority >= 2\n                }\n                return false\n            }\n            \n            let lowPriorityAnnotations = mapView.annotations.filter { annotation in\n                if let customAnnotation = annotation as? CustomPointAnnotation {\n                    return customAnnotation.priority < 2\n                }\n                return false\n            }\n            \n            mapView.removeAnnotations(lowPriorityAnnotations)\n        } else {\n            // Show all annotations at higher zoom levels\n            // Re-add any previously removed annotations\n        }\n    }\n    \n    private func calculateZoomLevel() -> Double {\n        let zoomScale = mapView.visibleMapRect.size.width / Double(mapView.bounds.size.width)\n        let zoomExponent = log2(zoomScale)\n        return 20.0 - zoomExponent\n    }\n}\n```\n\n### Best Practices Summary\n1. **Use clustering** for large numbers of annotations\n2. **Limit annotation count** based on zoom level\n3. **Reuse annotation views** and overlay renderers\n4. **Use appropriate accuracy levels** for location tracking\n5. **Monitor memory usage** and clean up unused resources\n6. **Handle background location updates** properly\n7. **Test performance** on actual devices with different capabilities\n\n## Practice Exercises\n\nComplete all exercises to master advanced MapKit features and create high-performance mapping applications!",
      "codeExample": "import MapKit\nimport CoreLocation\nimport Combine\n\n// === ADVANCED ANNOTATIONS ===\n// Custom Annotation with Dynamic Properties\nclass AdvancedAnnotation: NSObject, MKAnnotation {\n    @objc dynamic var coordinate: CLLocationCoordinate2D\n    var title: String?\n    var subtitle: String?\n    var annotationType: AnnotationType\n    var priority: Int\n    var data: [String: Any]\n    \n    init(coordinate: CLLocationCoordinate2D, title: String? = nil, subtitle: String? = nil, type: AnnotationType, priority: Int = 1, data: [String: Any] = [:]) {\n        self.coordinate = coordinate\n        self.title = title\n        self.subtitle = subtitle\n        self.annotationType = type\n        self.priority = priority\n        self.data = data\n    }\n    \n    enum AnnotationType: String {\n        case user, poi, landmark, event, custom\n    }\n}\n\n// Interactive Annotation View\nclass InteractiveAnnotationView: MKMarkerAnnotationView {\n    private var tapGesture: UITapGestureRecognizer!\n    private var longPressGesture: UILongPressGestureRecognizer!\n    \n    override init(annotation: MKAnnotation?, reuseIdentifier: String?) {\n        super.init(annotation: annotation, reuseIdentifier: reuseIdentifier)\n        setupGestures()\n    }\n    \n    required init?(coder aDecoder: NSCoder) {\n        super.init(coder: aDecoder)\n        setupGestures()\n    }\n    \n    private func setupGestures() {\n        tapGesture = UITapGestureRecognizer(target: self, action: #selector(handleTap))\n        addGestureRecognizer(tapGesture)\n        \n        longPressGesture = UILongPressGestureRecognizer(target: self, action: #selector(handleLongPress))\n        longPressGesture.minimumPressDuration = 0.5\n        addGestureRecognizer(longPressGesture)\n    }\n    \n    @objc private func handleTap() {\n        // Animate annotation on tap\n        UIView.animate(withDuration: 0.1, animations: {\n            self.transform = CGAffineTransform(scaleX: 1.2, y: 1.2)\n        }) { _ in\n            UIView.animate(withDuration: 0.1) {\n                self.transform = CGAffineTransform.identity\n            }\n        }\n    }\n    \n    @objc private func handleLongPress(_ gesture: UILongPressGestureRecognizer) {\n        if gesture.state == .began {\n            // Show custom menu or additional options\n            print(\"Long press on annotation\")\n        }\n    }\n    \n    override var annotation: MKAnnotation? {\n        didSet {\n            configureAppearance()\n        }\n    }\n    \n    private func configureAppearance() {\n        guard let advancedAnnotation = annotation as? AdvancedAnnotation else { return }\n        \n        switch advancedAnnotation.annotationType {\n        case .user:\n            markerTintColor = .systemBlue\n            glyphImage = UIImage(systemName: \"person\")\n            \n        case .poi:\n            markerTintColor = .systemGreen\n            glyphImage = UIImage(systemName: \"mappin\")\n            \n        case .landmark:\n            markerTintColor = .systemOrange\n            glyphImage = UIImage(systemName: \"star\")\n            \n        case .event:\n            markerTintColor = .systemPurple\n            glyphImage = UIImage(systemName: \"calendar\")\n            \n        case .custom:\n            markerTintColor = .systemGray\n            glyphImage = UIImage(systemName: \"pin\")\n        }\n        \n        // Priority-based styling\n        if advancedAnnotation.priority > 2 {\n            glyphTintColor = .systemYellow\n            animatesWhenAdded = true\n        }\n        \n        canShowCallout = true\n        \n        // Add custom callout view\n        let detailButton = UIButton(type: .detailDisclosure)\n        rightCalloutAccessoryView = detailButton\n    }\n}\n\n// === ADVANCED OVERLAYS ===\n// Custom Gradient Polygon Overlay\nclass GradientPolygonOverlay: MKPolygon {\n    var gradientColors: [UIColor]\n    var gradientLocations: [CGFloat]\n    \n    init(coordinates: UnsafePointer<CLLocationCoordinate2D>, count: Int, interiorPolygons: [MKPolygon]?, colors: [UIColor], locations: [CGFloat]) {\n        self.gradientColors = colors\n        self.gradientLocations = locations\n        super.init(coordinates: coordinates, count: count, interiorPolygons: interiorPolygons)\n    }\n}\n\n// Gradient Overlay Renderer\nclass GradientPolygonRenderer: MKOverlayRenderer {\n    override func draw(_ mapRect: MKMapRect, zoomScale: MKZoomScale, in context: CGContext) {\n        guard let polygon = overlay as? GradientPolygonOverlay else { return }\n        \n        let path = polygonPath(for: polygon)\n        context.addPath(path)\n        context.clip()\n        \n        // Create gradient\n        let colorSpace = CGColorSpaceCreateDeviceRGB()\n        let cgColors = polygon.gradientColors.map { $0.cgColor } as CFArray\n        \n        guard let gradient = CGGradient(colorsSpace: colorSpace, colors: cgColors, locations: polygon.gradientLocations) else {\n            return\n        }\n        \n        let boundingBox = path.boundingBox\n        let startPoint = CGPoint(x: boundingBox.minX, y: boundingBox.minY)\n        let endPoint = CGPoint(x: boundingBox.maxX, y: boundingBox.maxY)\n        \n        context.drawLinearGradient(gradient, start: startPoint, end: endPoint, options: [])\n    }\n    \n    private func polygonPath(for polygon: MKPolygon) -> CGPath {\n        let path = CGMutablePath()\n        var points = polygon.points()\n        \n        if polygon.pointCount > 0 {\n            let firstPoint = point(for: points[0].coordinate)\n            path.move(to: firstPoint)\n            \n            for i in 1..<polygon.pointCount {\n                let point = self.point(for: points[i].coordinate)\n                path.addLine(to: point)\n            }\n            \n            path.closeSubpath()\n        }\n        \n        return path\n    }\n}\n\n// === REAL-TIME LOCATION TRACKING ===\nclass AdvancedLocationTracker: NSObject, ObservableObject {\n    private let locationManager = CLLocationManager()\n    private var cancellables = Set<AnyCancellable>()\n    \n    @Published var currentLocation: CLLocation?\n    @Published var heading: CLHeading?\n    @Published var authorizationStatus: CLAuthorizationStatus\n    @Published var locationHistory: [CLLocation] = []\n    @Published var trackingState: TrackingState = .stopped\n    \n    enum TrackingState {\n        case stopped, tracking, paused\n    }\n    \n    override init() {\n        self.authorizationStatus = locationManager.authorizationStatus\n        super.init()\n        \n        locationManager.delegate = self\n        setupLocationManager()\n    }\n    \n    private func setupLocationManager() {\n        locationManager.desiredAccuracy = kCLLocationAccuracyBestForNavigation\n        locationManager.distanceFilter = 5.0\n        locationManager.headingFilter = 5.0\n        locationManager.activityType = .otherNavigation\n        locationManager.pausesLocationUpdatesAutomatically = false\n        \n        #if os(iOS)\n        locationManager.showsBackgroundLocationIndicator = true\n        #endif\n    }\n    \n    func startTracking() {\n        switch authorizationStatus {\n        case .notDetermined:\n            locationManager.requestAlwaysAuthorization()\n            \n        case .authorizedWhenInUse, .authorizedAlways:\n            locationManager.startUpdatingLocation()\n            locationManager.startUpdatingHeading()\n            locationManager.startMonitoringSignificantLocationChanges()\n            trackingState = .tracking\n            \n        default:\n            print(\"Location access not authorized\")\n        }\n    }\n    \n    func stopTracking() {\n        locationManager.stopUpdatingLocation()\n        locationManager.stopUpdatingHeading()\n        locationManager.stopMonitoringSignificantLocationChanges()\n        trackingState = .stopped\n    }\n    \n    func pauseTracking() {\n        locationManager.stopUpdatingLocation()\n        trackingState = .paused\n    }\n}\n\n// MARK: - CLLocationManagerDelegate\n\nextension AdvancedLocationTracker: CLLocationManagerDelegate {\n    func locationManager(_ manager: CLLocationManager, didUpdateLocations locations: [CLLocation]) {\n        guard let location = locations.last else { return }\n        \n        currentLocation = location\n        locationHistory.append(location)\n        \n        // Keep only last 1000 locations\n        if locationHistory.count > 1000 {\n            locationHistory.removeFirst(500)\n        }\n    }\n    \n    func locationManager(_ manager: CLLocationManager, didUpdateHeading newHeading: CLHeading) {\n        heading = newHeading\n    }\n    \n    func locationManager(_ manager: CLLocationManager, didChangeAuthorization status: CLAuthorizationStatus) {\n        authorizationStatus = status\n        \n        if status == .authorizedWhenInUse || status == .authorizedAlways {\n            startTracking()\n        }\n    }\n    \n    func locationManager(_ manager: CLLocationManager, didFailWithError error: Error) {\n        print(\"Location tracking error: \\(error.localizedDescription)\")\n    }\n}\n\n// === MAP VIEW CONTROLLER WITH ADVANCED FEATURES ===\nclass AdvancedMapViewController: UIViewController {\n    @IBOutlet weak var mapView: MKMapView!\n    \n    private let locationTracker = AdvancedLocationTracker()\n    private var cancellables = Set<AnyCancellable>()\n    private var userTrackingButton: MKUserTrackingButton!\n    \n    override func viewDidLoad() {\n        super.viewDidLoad()\n        setupMapView()\n        setupUserInterface()\n        setupBindings()\n    }\n    \n    private func setupMapView() {\n        mapView.delegate = self\n        mapView.mapType = .mutedStandard\n        mapView.showsUserLocation = true\n        mapView.showsScale = true\n        mapView.showsCompass = true\n        mapView.showsTraffic = true\n        mapView.showsBuildings = true\n        \n        // Register custom annotation views\n        mapView.register(InteractiveAnnotationView.self, forAnnotationViewWithReuseIdentifier: \"InteractiveAnnotation\")\n        \n        if #available(iOS 11.0, *) {\n            mapView.register(MKMarkerAnnotationView.self, forAnnotationViewWithReuseIdentifier: MKMapViewDefaultClusterAnnotationViewReuseIdentifier)\n        }\n    }\n    \n    private func setupUserInterface() {\n        // Add user tracking button\n        userTrackingButton = MKUserTrackingButton(mapView: mapView)\n        userTrackingButton.translatesAutoresizingMaskIntoConstraints = false\n        view.addSubview(userTrackingButton)\n        \n        NSLayoutConstraint.activate([\n            userTrackingButton.topAnchor.constraint(equalTo: view.safeAreaLayoutGuide.topAnchor, constant: 20),\n            userTrackingButton.trailingAnchor.constraint(equalTo: view.trailingAnchor, constant: -20)\n        ])\n    }\n    \n    private func setupBindings() {\n        locationTracker.$currentLocation\n            .compactMap { $0 }\n            .sink { [weak self] location in\n                self?.updateMapForLocation(location)\n            }\n            .store(in: &cancellables)\n        \n        locationTracker.$heading\n            .compactMap { $0 }\n            .sink { [weak self] heading in\n                self?.updateMapForHeading(heading)\n            }\n            .store(in: &cancellables)\n    }\n    \n    private func updateMapForLocation(_ location: CLLocation) {\n        let region = MKCoordinateRegion(\n            center: location.coordinate,\n            latitudinalMeters: 500,\n            longitudinalMeters: 500\n        )\n        mapView.setRegion(region, animated: true)\n    }\n    \n    private func updateMapForHeading(_ heading: CLHeading) {\n        let camera = mapView.camera.copy() as! MKMapCamera\n        camera.heading = heading.trueHeading\n        mapView.setCamera(camera, animated: true)\n    }\n    \n    func addSampleAnnotations() {\n        var annotations: [AdvancedAnnotation] = []\n        \n        // Create sample annotations\n        let types: [AdvancedAnnotation.AnnotationType] = [.poi, .landmark, .event, .custom]\n        \n        for i in 0..<20 {\n            let latitude = 37.7749 + Double.random(in: -0.05...0.05)\n            let longitude = -122.4194 + Double.random(in: -0.05...0.05)\n            \n            let annotation = AdvancedAnnotation(\n                coordinate: CLLocationCoordinate2D(latitude: latitude, longitude: longitude),\n                title: \"Location \\(i)\",\n                subtitle: \"San Francisco\",\n                type: types.randomElement()!,\n                priority: Int.random(in: 1...3),\n                data: [\"index\": i]\n            )\n            annotations.append(annotation)\n        }\n        \n        mapView.addAnnotations(annotations)\n    }\n    \n    func addGradientOverlay() {\n        let coordinates = [\n            CLLocationCoordinate2D(latitude: 37.78, longitude: -122.42),\n            CLLocationCoordinate2D(latitude: 37.78, longitude: -122.40),\n            CLLocationCoordinate2D(latitude: 37.76, longitude: -122.40),\n            CLLocationCoordinate2D(latitude: 37.76, longitude: -122.42)\n        ]\n        \n        let gradientColors = [UIColor.systemBlue, UIColor.systemGreen, UIColor.systemYellow]\n        let gradientLocations: [CGFloat] = [0.0, 0.5, 1.0]\n        \n        let gradientOverlay = GradientPolygonOverlay(\n            coordinates: coordinates,\n            count: coordinates.count,\n            interiorPolygons: nil,\n            colors: gradientColors,\n            locations: gradientLocations\n        )\n        \n        mapView.addOverlay(gradientOverlay)\n    }\n}\n\n// MARK: - MKMapViewDelegate\n\nextension AdvancedMapViewController: MKMapViewDelegate {\n    func mapView(_ mapView: MKMapView, viewFor annotation: MKAnnotation) -> MKAnnotationView? {\n        if annotation is MKUserLocation {\n            return nil\n        }\n        \n        if let cluster = annotation as? MKClusterAnnotation {\n            let view = mapView.dequeueReusableAnnotationView(withIdentifier: MKMapViewDefaultClusterAnnotationViewReuseIdentifier, for: cluster)\n            view.annotation = cluster\n            return view\n        }\n        \n        if let advancedAnnotation = annotation as? AdvancedAnnotation {\n            let view = mapView.dequeueReusableAnnotationView(withIdentifier: \"InteractiveAnnotation\", for: advancedAnnotation) as? InteractiveAnnotationView\n            return view\n        }\n        \n        return nil\n    }\n    \n    func mapView(_ mapView: MKMapView, rendererFor overlay: MKOverlay) -> MKOverlayRenderer {\n        if let gradientPolygon = overlay as? GradientPolygonOverlay {\n            return GradientPolygonRenderer(overlay: gradientPolygon)\n        }\n        \n        if let polygon = overlay as? MKPolygon {\n            let renderer = MKPolygonRenderer(polygon: polygon)\n            renderer.fillColor = UIColor.systemBlue.withAlphaComponent(0.3)\n            renderer.strokeColor = UIColor.systemBlue\n            renderer.lineWidth = 2.0\n            return renderer\n        }\n        \n        return MKOverlayRenderer(overlay: overlay)\n    }\n    \n    func mapView(_ mapView: MKMapView, didSelect view: MKAnnotationView) {\n        // Handle annotation selection\n        if let annotation = view.annotation as? AdvancedAnnotation {\n            print(\"Selected annotation: \\(annotation.title ?? \"Unknown\")\")\n        }\n    }\n}",
      "category": "Maps & Location",
      "estimatedTime": 240,
      "dependencies": ["ui_components", "networking", "swift_concurrency"],
      "challenge": {
        "instructions": "Build a comprehensive location-based application with advanced MapKit features:\n\nPART 1: Advanced Annotation System (60 min)\n1. Create custom annotation classes with dynamic properties and types\n2. Implement interactive annotation views with gestures and animations\n3. Set up annotation clustering for performance with large datasets\n4. Create custom callout views with additional information and actions\n\nPART 2: Complex Overlays & Visualization (90 min)\n5. Implement gradient polygon overlays with custom rendering\n6. Create heat map overlays using density-based coloring\n7. Build custom path renderers for different route types\n8. Add overlay animations for real-time data visualization\n\nPART 3: Real-time Location & Geofencing (90 min)\n9. Create an advanced location tracker with background support\n10. Implement complex geofencing with multiple regions and conditions\n11. Build a route tracking system with metrics and path optimization\n12. Add heading and orientation tracking for navigation features\n\nPART 4: Performance & Optimization (60 min)\n13. Implement annotation and overlay recycling for memory management\n14. Create zoom-level based content filtering\n15. Add caching mechanisms for map tiles and location data\n16. Optimize rendering performance for smooth user experience\n\nPART 5: Advanced Features & Integration (60 min)\n17. Integrate with Core Data for persistent location storage\n18. Add search and filtering capabilities for annotations\n19. Implement custom map styles and configurations\n20. Create export functionality for routes and location data",
        "starterCode": "import MapKit\nimport CoreLocation\nimport Combine\n\n// === PART 1: Advanced Annotation System ===\n// Create custom annotations and interactive views\n\n\n// === PART 2: Complex Overlays & Visualization ===\n// Implement gradient overlays and custom rendering\n\n\n// === PART 3: Real-time Location & Geofencing ===\n// Build advanced location tracking system\n\n\n// === PART 4: Performance & Optimization ===\n// Add performance optimizations and caching\n\n\n// === PART 5: Advanced Features & Integration ===\n// Implement search, filtering, and export features\n\n",
        "solution": "import MapKit\nimport CoreLocation\nimport Combine\n\n// === PART 1: Advanced Annotation System ===\nclass SmartAnnotation: NSObject, MKAnnotation {\n    @objc dynamic var coordinate: CLLocationCoordinate2D\n    var title: String?\n    var subtitle: String?\n    var category: Category\n    var priority: Priority\n    var metadata: [String: Any]\n    var lastUpdated: Date\n    \n    init(coordinate: CLLocationCoordinate2D, title: String? = nil, subtitle: String? = nil, \n         category: Category, priority: Priority = .medium, metadata: [String: Any] = [:]) {\n        self.coordinate = coordinate\n        self.title = title\n        self.subtitle = subtitle\n        self.category = category\n        self.priority = priority\n        self.metadata = metadata\n        self.lastUpdated = Date()\n    }\n    \n    enum Category: String, CaseIterable {\n        case restaurant, hotel, attraction, transportation, emergency, custom\n    }\n    \n    enum Priority: Int {\n        case low = 1, medium, high, critical\n    }\n}\n\nclass SmartAnnotationView: MKMarkerAnnotationView {\n    private var pulseLayer: CALayer?\n    \n    override var annotation: MKAnnotation? {\n        didSet {\n            configureView()\n        }\n    }\n    \n    private func configureView() {\n        guard let smartAnnotation = annotation as? SmartAnnotation else { return }\n        \n        // Configure based on category and priority\n        configureAppearance(for: smartAnnotation.category, priority: smartAnnotation.priority)\n        \n        // Add gestures\n        addInteraction(UIDropInteraction(delegate: self))\n        \n        // Add pulse animation for high priority\n        if smartAnnotation.priority == .critical {\n            addPulseAnimation()\n        }\n        \n        canShowCallout = true\n        configureCalloutAccessories()\n    }\n    \n    private func configureAppearance(for category: SmartAnnotation.Category, priority: SmartAnnotation.Priority) {\n        switch category {\n        case .restaurant:\n            markerTintColor = .systemGreen\n            glyphImage = UIImage(systemName: \"fork.knife\")\n        case .hotel:\n            markerTintColor = .systemBlue\n            glyphImage = UIImage(systemName: \"bed.double\")\n        case .attraction:\n            markerTintColor = .systemOrange\n            glyphImage = UIImage(systemName: \"star\")\n        case .transportation:\n            markerTintColor = .systemPurple\n            glyphImage = UIImage(systemName: \"bus\")\n        case .emergency:\n            markerTintColor = .systemRed\n            glyphImage = UIImage(systemName: \"cross\")\n        case .custom:\n            markerTintColor = .systemGray\n            glyphImage = UIImage(systemName: \"pin\")\n        }\n        \n        // Priority styling\n        switch priority {\n        case .low:\n            alpha = 0.7\n        case .medium:\n            alpha = 1.0\n        case .high:\n            glyphTintColor = .systemYellow\n        case .critical:\n            glyphTintColor = .systemRed\n            markerTintColor = .systemRed\n        }\n    }\n    \n    private func addPulseAnimation() {\n        let pulse = CABasicAnimation(keyPath: \"transform.scale\")\n        pulse.duration = 1.0\n        pulse.fromValue = 1.0\n        pulse.toValue = 1.2\n        pulse.autoreverses = true\n        pulse.repeatCount = .infinity\n        \n        layer.add(pulse, forKey: \"pulse\")\n    }\n    \n    private func configureCalloutAccessories() {\n        let infoButton = UIButton(type: .detailDisclosure)\n        infoButton.tintColor = .systemBlue\n        rightCalloutAccessoryView = infoButton\n        \n        let imageView = UIImageView(image: UIImage(systemName: \"info.circle\"))\n        imageView.tintColor = .systemGray\n        leftCalloutAccessoryView = imageView\n    }\n}\n\n// === PART 2: Complex Overlays & Visualization ===\nclass HeatMapOverlay: MKPolygon {\n    var intensity: Double\n    var gradientStops: [GradientStop]\n    \n    init(coordinates: UnsafePointer<CLLocationCoordinate2D>, count: Int, \n         intensity: Double, gradientStops: [GradientStop]) {\n        self.intensity = intensity\n        self.gradientStops = gradientStops\n        super.init(coordinates: coordinates, count: count)\n    }\n    \n    struct GradientStop {\n        let color: UIColor\n        let location: CGFloat\n    }\n}\n\nclass HeatMapRenderer: MKOverlayRenderer {\n    override func draw(_ mapRect: MKMapRect, zoomScale: MKZoomScale, in context: CGContext) {\n        guard let heatMap = overlay as? HeatMapOverlay else { return }\n        \n        let path = polygonPath(for: heatMap)\n        context.addPath(path)\n        context.clip()\n        \n        // Create gradient based on intensity\n        let colors = heatMap.gradientStops.map { $0.color.cgColor }\n        let locations = heatMap.gradientStops.map { $0.location }\n        \n        let colorSpace = CGColorSpaceCreateDeviceRGB()\n        guard let gradient = CGGradient(colorsSpace: colorSpace, colors: colors as CFArray, locations: locations) else {\n            return\n        }\n        \n        let boundingBox = path.boundingBox\n        let startPoint = CGPoint(x: boundingBox.minX, y: boundingBox.minY)\n        let endPoint = CGPoint(x: boundingBox.maxX, y: boundingBox.maxY)\n        \n        // Adjust gradient based on heat intensity\n        let intensityFactor = CGFloat(heatMap.intensity)\n        let adjustedEndPoint = CGPoint(\n            x: startPoint.x + (endPoint.x - startPoint.x) * intensityFactor,\n            y: startPoint.y + (endPoint.y - startPoint.y) * intensityFactor\n        )\n        \n        context.drawLinearGradient(gradient, start: startPoint, end: adjustedEndPoint, options: [])\n    }\n}\n\n// === PART 3: Real-time Location & Geofencing ===\nclass AdvancedGeofenceManager: NSObject, ObservableObject {\n    private let locationManager = CLLocationManager()\n    \n    @Published var activeGeofences: [SmartGeofence] = []\n    @Published var currentGeofenceEvents: [GeofenceEvent] = []\n    \n    override init() {\n        super.init()\n        locationManager.delegate = self\n        locationManager.desiredAccuracy = kCLLocationAccuracyBest\n    }\n    \n    func addGeofence(_ geofence: SmartGeofence) {\n        let region = CLCircularRegion(center: geofence.center, radius: geofence.radius, identifier: geofence.id)\n        region.notifyOnEntry = geofence.notifyOnEntry\n        region.notifyOnExit = geofence.notifyOnExit\n        \n        locationManager.startMonitoring(for: region)\n        activeGeofences.append(geofence)\n    }\n    \n    func removeGeofence(withId id: String) {\n        if let geofence = activeGeofences.first(where: { $0.id == id }) {\n            let region = CLCircularRegion(center: geofence.center, radius: geofence.radius, identifier: geofence.id)\n            locationManager.stopMonitoring(for: region)\n            activeGeofences.removeAll { $0.id == id }\n        }\n    }\n}\n\nstruct SmartGeofence {\n    let id: String\n    let center: CLLocationCoordinate2D\n    let radius: CLLocationDistance\n    let name: String\n    let notifyOnEntry: Bool\n    let notifyOnExit: Bool\n    let autoRemove: Bool\n}\n\nstruct GeofenceEvent {\n    let geofenceId: String\n    let type: EventType\n    let timestamp: Date\n    let location: CLLocation\n    \n    enum EventType {\n        case entry, exit\n    }\n}\n\n// === PART 4: Performance & Optimization ===\nclass OptimizedMapManager: NSObject, MKMapViewDelegate {\n    private var annotationCache: [String: MKAnnotation] = [:]\n    private var overlayCache: [String: MKOverlay] = [:]\n    private let maxCacheSize = 1000\n    \n    func mapView(_ mapView: MKMapView, regionDidChangeAnimated animated: Bool) {\n        optimizeContentForCurrentRegion(mapView.region)\n    }\n    \n    private func optimizeContentForCurrentRegion(_ region: MKCoordinateRegion) {\n        let zoomLevel = calculateZoomLevel(for: region)\n        \n        // Adjust annotation visibility based on zoom level\n        if zoomLevel < 12 {\n            // Show only high-priority annotations\n        } else if zoomLevel < 15 {\n            // Show medium and high priority annotations\n        } else {\n            // Show all annotations\n        }\n        \n        // Clear cache if too large\n        if annotationCache.count > maxCacheSize {\n            clearOldCacheEntries()\n        }\n    }\n    \n    private func calculateZoomLevel(for region: MKCoordinateRegion) -> Double {\n        // Simplified zoom level calculation\n        return log2(360 / region.span.longitudeDelta)\n    }\n    \n    private func clearOldCacheEntries() {\n        // Remove oldest cache entries\n        let sortedKeys = annotationCache.keys.sorted()\n        let keysToRemove = sortedKeys.prefix(maxCacheSize / 2)\n        \n        for key in keysToRemove {\n            annotationCache.removeValue(forKey: key)\n        }\n    }\n}\n\n// === PART 5: Advanced Features & Integration ===\nclass MapSearchManager: ObservableObject {\n    @Published var searchResults: [SmartAnnotation] = []\n    @Published var searchQuery: String = \"\"\n    \n    private var searchCompleter = MKLocalSearchCompleter()\n    private var cancellables = Set<AnyCancellable>()\n    \n    init() {\n        setupSearchCompleter()\n        setupSearchBinding()\n    }\n    \n    private func setupSearchCompleter() {\n        searchCompleter.resultTypes = .pointOfInterest\n        searchCompleter.delegate = self\n    }\n    \n    private func setupSearchBinding() {\n        $searchQuery\n            .debounce(for: .milliseconds(300), scheduler: RunLoop.main)\n            .removeDuplicates()\n            .sink { [weak self] query in\n                self?.searchCompleter.queryFragment = query\n            }\n            .store(in: &cancellables)\n    }\n    \n    func performSearch(for completion: MKLocalSearchCompletion) {\n        let request = MKLocalSearch.Request(completion: completion)\n        let search = MKLocalSearch(request: request)\n        \n        search.start { [weak self] response, error in\n            guard let self = self, let response = response else { return }\n            \n            self.searchResults = response.mapItems.compactMap { item in\n                guard let location = item.placemark.location else { return nil }\n                \n                return SmartAnnotation(\n                    coordinate: location.coordinate,\n                    title: item.name,\n                    subtitle: item.placemark.title,\n                    category: .custom,\n                    priority: .medium,\n                    metadata: [\"mapItem\": item]\n                )\n            }\n        }\n    }\n}\n\n// MARK: - MKLocalSearchCompleterDelegate\n\nextension MapSearchManager: MKLocalSearchCompleterDelegate {\n    func completerDidUpdateResults(_ completer: MKLocalSearchCompleter) {\n        // Handle search completions\n        print(\"Search completions: \\(completer.results)\")\n    }\n    \n    func completer(_ completer: MKLocalSearchCompleter, didFailWithError error: Error) {\n        print(\"Search completer error: \\(error.localizedDescription)\")\n    }\n}\n\n// MARK: - UIDropInteractionDelegate\n\nextension SmartAnnotationView: UIDropInteractionDelegate {\n    func dropInteraction(_ interaction: UIDropInteraction, canHandle session: UIDropSession) -> Bool {\n        return session.canLoadObjects(ofClass: NSString.self)\n    }\n    \n    func dropInteraction(_ interaction: UIDropInteraction, sessionDidUpdate session: UIDropSession) -> UIDropProposal {\n        return UIDropProposal(operation: .copy)\n    }\n    \n    func dropInteraction(_ interaction: UIDropInteraction, performDrop session: UIDropSession) {\n        // Handle drop interaction\n        print(\"Annotation view received drop\")\n    }\n}\n\n// MARK: - CLLocationManagerDelegate\n\nextension AdvancedGeofenceManager: CLLocationManagerDelegate {\n    func locationManager(_ manager: CLLocationManager, didEnterRegion region: CLRegion) {\n        guard let circularRegion = region as? CLCircularRegion else { return }\n        \n        let event = GeofenceEvent(\n            geofenceId: circularRegion.identifier,\n            type: .entry,\n            timestamp: Date(),\n            location: CLLocation(latitude: circularRegion.center.latitude, longitude: circularRegion.center.longitude)\n        )\n        \n        currentGeofenceEvents.append(event)\n        \n        // Keep only last 100 events\n        if currentGeofenceEvents.count > 100 {\n            currentGeofenceEvents.removeFirst(50)\n        }\n    }\n    \n    func locationManager(_ manager: CLLocationManager, didExitRegion region: CLRegion) {\n        guard let circularRegion = region as? CLCircularRegion else { return }\n        \n        let event = GeofenceEvent(\n            geofenceId: circularRegion.identifier,\n            type: .exit,\n            timestamp: Date(),\n            location: CLLocation(latitude: circularRegion.center.latitude, longitude: circularRegion.center.longitude)\n        )\n        \n        currentGeofenceEvents.append(event)\n        \n        // Auto-remove geofence if configured\n        if let geofence = activeGeofences.first(where: { $0.id == circularRegion.identifier && $0.autoRemove }) {\n            removeGeofence(withId: geofence.id)\n        }\n    }\n}",
        "hints": [
          "PART 1: Use MKMarkerAnnotationView for better performance and customization",
          "PART 2: Create custom overlay renderers for complex visualizations",
          "PART 3: Implement CLLocationManagerDelegate for geofencing events",
          "PART 4: Use zoom-level based filtering to optimize performance",
          "PART 5: MKLocalSearchCompleter provides great search functionality",
          "Remember to handle background location updates properly",
          "Use Combine for reactive programming patterns with location updates",
          "Test geofencing with different region sizes and conditions"
        ],
        "testCases": [
          {
            "input": "annotationCache.count <= maxCacheSize",
            "expectedOutput": "true",
            "description": "Annotation cache should not exceed maximum size"
          },
          {
            "input": "activeGeofences.count >= 0",
            "expectedOutput": "true",
            "description": "Should handle geofence management properly"
          },
          {
            "input": "searchResults.count >= 0",
            "expectedOutput": "true",
            "description": "Search should return valid results"
          }
        ]
      }
    },
    {
      "id": "background_tasks",
      "title": "Background Tasks & Background App Refresh",
      "description": "Master advanced background task execution, background app refresh, and efficient resource management in iOS",
      "difficulty": "advanced",
      "theory": "# Background Tasks & Background App Refresh\n\n## 1. Introduction to Background Execution (45 min)\n\n### iOS Background Execution Model\niOS provides limited background execution time to preserve battery life and performance. Understanding these constraints is crucial for building efficient apps.\n\n**Background Execution Modes:**\n- Background App Refresh\n- Background Processing Tasks\n- Push Notifications\n- Location Updates\n- Audio Playback\n- VoIP\n\n### Key Concepts:\n- **Background Task**: A unit of work that can continue after app enters background\n- **Background App Refresh**: System-managed app wakeups for content updates\n- **Background Processing**: Developer-initiated background work\n- **Energy Impact**: Measurement of how background tasks affect battery life\n\n## 2. BGAppRefreshTask - Background App Refresh (90 min)\n\n### Registering for Background App Refresh\n```swift\nimport BackgroundTasks\n\nclass AppDelegate: UIResponder, UIApplicationDelegate {\n    func application(_ application: UIApplication, \n                   didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -> Bool {\n        \n        // Register background task identifiers\n        BGTaskScheduler.shared.register(forTaskWithIdentifier: \"com.yourapp.refresh\", \n                                      using: nil) { task in\n            self.handleAppRefresh(task: task as! BGAppRefreshTask)\n        }\n        \n        return true\n    }\n}\n```\n\n### Scheduling Background App Refresh\n```swift\nfunc scheduleAppRefresh() {\n    let request = BGAppRefreshTaskRequest(identifier: \"com.yourapp.refresh\")\n    \n    // Schedule for earliest 15 minutes from now\n    request.earliestBeginDate = Date(timeIntervalSinceNow: 15 * 60)\n    \n    do {\n        try BGTaskScheduler.shared.submit(request)\n        print(\"Background app refresh scheduled\")\n    } catch {\n        print(\"Could not schedule app refresh: \\(error)\")\n    }\n}\n```\n\n### Handling BGAppRefreshTask\n```swift\nfunc handleAppRefresh(task: BGAppRefreshTask) {\n    // Schedule next refresh\n    scheduleAppRefresh()\n    \n    // Create operation queue for the refresh work\n    let queue = OperationQueue()\n    queue.maxConcurrentOperationCount = 1\n    \n    // Create the background operation\n    let operation = BlockOperation {\n        // Perform background work\n        self.fetchLatestData()\n        self.updateWidgets()\n        \n        // Mark task as completed\n        task.setTaskCompleted(success: true)\n    }\n    \n    // Handle task expiration\n    task.expirationHandler = {\n        // Cancel all operations if time expires\n        queue.cancelAllOperations()\n    }\n    \n    // Start the operation\n    queue.addOperation(operation)\n}\n```\n\n## 3. BGProcessingTask - Long-Running Background Tasks (90 min)\n\n### BGProcessingTask Use Cases\n- Data synchronization\n- Database maintenance\n- File cleanup\n- Model training\n- Batch processing\n\n### Scheduling Processing Tasks\n```swift\nfunc scheduleBackgroundProcessing() {\n    let request = BGProcessingTaskRequest(identifier: \"com.yourapp.cleanup\")\n    \n    // Require network connectivity\n    request.requiresNetworkConnectivity = true\n    \n    // Require external power for energy-intensive tasks\n    request.requiresExternalPower = false\n    \n    // Earliest begin date\n    request.earliestBeginDate = Date(timeIntervalSinceNow: 30 * 60)\n    \n    do {\n        try BGTaskScheduler.shared.submit(request)\n    } catch {\n        print(\"Could not schedule background processing: \\(error)\")\n    }\n}\n```\n\n### Handling BGProcessingTask\n```swift\nfunc handleBackgroundProcessing(task: BGProcessingTask) {\n    let operationQueue = OperationQueue()\n    \n    // Configure operation queue\n    operationQueue.qualityOfService = .background\n    operationQueue.maxConcurrentOperationCount = 1\n    \n    // Database cleanup operation\n    let cleanupOperation = BlockOperation {\n        self.cleanupOldData()\n        self.optimizeDatabase()\n    }\n    \n    // Data sync operation\n    let syncOperation = BlockOperation {\n        self.syncWithCloud()\n    }\n    syncOperation.addDependency(cleanupOperation)\n    \n    // Completion operation\n    let completionOperation = BlockOperation {\n        task.setTaskCompleted(success: true)\n    }\n    completionOperation.addDependency(syncOperation)\n    \n    // Set expiration handler\n    task.expirationHandler = {\n        operationQueue.cancelAllOperations()\n    }\n    \n    // Add all operations\n    operationQueue.addOperations([cleanupOperation, syncOperation, completionOperation], \n                               waitUntilFinished: false)\n}\n```\n\n## 4. Advanced Background Task Patterns (90 min)\n\n### Task Coordination and Dependencies\n```swift\nclass BackgroundTaskManager {\n    private let taskScheduler = BGTaskScheduler.shared\n    private let operationQueue = OperationQueue()\n    \n    func scheduleCoordinatedTasks() {\n        // Schedule refresh task\n        let refreshRequest = BGAppRefreshTaskRequest(identifier: \"com.yourapp.refresh\")\n        refreshRequest.earliestBeginDate = Date(timeIntervalSinceNow: 15 * 60)\n        \n        // Schedule processing task to run after refresh\n        let processingRequest = BGProcessingTaskRequest(identifier: \"com.yourapp.processing\")\n        processingRequest.earliestBeginDate = Date(timeIntervalSinceNow: 20 * 60)\n        \n        do {\n            try taskScheduler.submit(refreshRequest)\n            try taskScheduler.submit(processingRequest)\n        } catch {\n            print(\"Scheduling error: \\(error)\")\n        }\n    }\n}\n```\n\n### Background URLSession\n```swift\nclass BackgroundNetworkManager: NSObject {\n    private var backgroundSession: URLSession!\n    private var completionHandler: (() -> Void)?\n    \n    override init() {\n        super.init()\n        \n        let config = URLSessionConfiguration.background(withIdentifier: \"com.yourapp.backgroundsession\")\n        config.isDiscretionary = true\n        config.sessionSendsLaunchEvents = true\n        \n        backgroundSession = URLSession(configuration: config, \n                                     delegate: self, \n                                     delegateQueue: nil)\n    }\n    \n    func startBackgroundDownload(urls: [URL]) {\n        for url in urls {\n            let task = backgroundSession.downloadTask(with: url)\n            task.resume()\n        }\n    }\n}\n\nextension BackgroundNetworkManager: URLSessionDownloadDelegate {\n    func urlSession(_ session: URLSession, \n                   downloadTask: URLSessionDownloadTask, \n                   didFinishDownloadingTo location: URL) {\n        // Process downloaded file\n        processDownloadedFile(at: location)\n    }\n    \n    func urlSessionDidFinishEvents(forBackgroundURLSession session: URLSession) {\n        DispatchQueue.main.async {\n            self.completionHandler?()\n            self.completionHandler = nil\n        }\n    }\n}\n```\n\n### State Preservation and Restoration\n```swift\nclass BackgroundDataManager {\n    private let userDefaults = UserDefaults.standard\n    private let backgroundTaskKey = \"backgroundTaskState\"\n    \n    func saveTaskState(_ state: BackgroundTaskState) {\n        let encoder = JSONEncoder()\n        if let encoded = try? encoder.encode(state) {\n            userDefaults.set(encoded, forKey: backgroundTaskKey)\n        }\n    }\n    \n    func loadTaskState() -> BackgroundTaskState? {\n        guard let data = userDefaults.data(forKey: backgroundTaskKey) else { \n            return nil \n        }\n        \n        let decoder = JSONDecoder()\n        return try? decoder.decode(BackgroundTaskState.self, from: data)\n    }\n    \n    func clearTaskState() {\n        userDefaults.removeObject(forKey: backgroundTaskKey)\n    }\n}\n\nstruct BackgroundTaskState: Codable {\n    let lastRun: Date\n    let processedItems: Int\n    let nextScheduledRun: Date\n}\n```\n\n## 5. Energy Efficiency and Performance (45 min)\n\n### Monitoring Energy Impact\n```swift\nimport os.signpost\n\nclass EnergyAwareTaskManager {\n    private let log = OSLog(subsystem: \"com.yourapp.background\", \n                          category: \"Energy\")\n    \n    func performEnergyEfficientWork() {\n        let signpostID = OSSignpostID(log: log)\n        os_signpost(.begin, log: log, name: \"BackgroundWork\", signpostID: signpostID)\n        \n        // Break work into chunks with breaks\n        let workItems = prepareWorkItems()\n        \n        for (index, workItem) in workItems.enumerated() {\n            // Process work item\n            processWorkItem(workItem)\n            \n            // Take breaks between chunks\n            if index % 10 == 0 && index != workItems.count - 1 {\n                Thread.sleep(forTimeInterval: 0.1)\n            }\n        }\n        \n        os_signpost(.end, log: log, name: \"BackgroundWork\", signpostID: signpostID)\n    }\n    \n    private func prepareWorkItems() -> [WorkItem] {\n        // Split work into manageable chunks\n        return []\n    }\n}\n```\n\n### Adaptive Scheduling\n```swift\nclass AdaptiveTaskScheduler {\n    private let userDefaults = UserDefaults.standard\n    \n    func scheduleAdaptiveRefresh() {\n        let request = BGAppRefreshTaskRequest(identifier: \"com.yourapp.adaptive\")\n        \n        // Adjust frequency based on usage patterns\n        let interval = calculateAdaptiveInterval()\n        request.earliestBeginDate = Date(timeIntervalSinceNow: interval)\n        \n        do {\n            try BGTaskScheduler.shared.submit(request)\n        } catch {\n            print(\"Adaptive scheduling failed: \\(error)\")\n        }\n    }\n    \n    private func calculateAdaptiveInterval() -> TimeInterval {\n        let lastUsage = userDefaults.object(forKey: \"lastAppUsage\") as? Date ?? Date.distantPast\n        let timeSinceLastUsage = Date().timeIntervalSince(lastUsage)\n        \n        // Reduce frequency if app hasn't been used recently\n        if timeSinceLastUsage > 7 * 24 * 3600 { // 1 week\n            return 24 * 3600 // Once per day\n        } else if timeSinceLastUsage > 24 * 3600 { // 1 day\n            return 6 * 3600 // Every 6 hours\n        } else {\n            return 2 * 3600 // Every 2 hours\n        }\n    }\n}\n```\n\n## 6. Debugging and Testing Background Tasks (45 min)\n\n### Simulating Background Tasks\n```swift\n#if DEBUG\nclass BackgroundTaskDebugger {\n    static func simulateBackgroundAppRefresh() {\n        let task = MockBGAppRefreshTask(identifier: \"com.yourapp.debug\")\n        \n        // Inject mock task into your handler\n        let appDelegate = UIApplication.shared.delegate as! AppDelegate\n        appDelegate.handleAppRefresh(task: task)\n    }\n    \n    static func simulateBackgroundProcessing() {\n        let task = MockBGProcessingTask(identifier: \"com.yourapp.debug\")\n        \n        let appDelegate = UIApplication.shared.delegate as! AppDelegate\n        appDelegate.handleBackgroundProcessing(task: task)\n    }\n}\n\nclass MockBGAppRefreshTask: BGAppRefreshTask {\n    override func setTaskCompleted(success: Bool) {\n        print(\"Mock task completed with success: \\(success)\")\n    }\n}\n\nclass MockBGProcessingTask: BGProcessingTask {\n    override func setTaskCompleted(success: Bool) {\n        print(\"Mock processing task completed with success: \\(success)\")\n    }\n}\n#endif\n```\n\n### Background Task Logging\n```swift\nimport os\n\nclass BackgroundTaskLogger {\n    private let logger = Logger(subsystem: \"com.yourapp.background\", \n                              category: \"TaskLifecycle\")\n    \n    func logTaskScheduled(identifier: String, earliestBeginDate: Date) {\n        logger.log(\"Task scheduled: \\(identifier) for \\(earliestBeginDate)\")\n    }\n    \n    func logTaskStarted(identifier: String) {\n        logger.log(\"Task started: \\(identifier)\")\n    }\n    \n    func logTaskCompleted(identifier: String, success: Bool) {\n        logger.log(\"Task completed: \\(identifier), success: \\(success)\")\n    }\n    \n    func logTaskExpired(identifier: String) {\n        logger.log(\"Task expired: \\(identifier)\")\n    }\n}\n```\n\n## 7. Real-World Implementation Patterns (45 min)\n\n### News App Background Refresh\n```swift\nclass NewsBackgroundManager {\n    private let backgroundScheduler = BGTaskScheduler.shared\n    private let apiService = NewsAPIService()\n    \n    func scheduleContentRefresh() {\n        let request = BGAppRefreshTaskRequest(identifier: \"com.newsapp.refresh\")\n        request.earliestBeginDate = Date(timeIntervalSinceNow: 30 * 60) // 30 minutes\n        \n        do {\n            try backgroundScheduler.submit(request)\n        } catch {\n            print(\"Failed to schedule news refresh: \\(error)\")\n        }\n    }\n    \n    func handleContentRefresh(task: BGAppRefreshTask) {\n        // Schedule next refresh\n        scheduleContentRefresh()\n        \n        let operationQueue = OperationQueue()\n        operationQueue.maxConcurrentOperationCount = 1\n        \n        let refreshOperation = BlockOperation {\n            // Fetch latest news\n            self.apiService.fetchLatestNews { result in\n                switch result {\n                case .success(let articles):\n                    self.cacheArticles(articles)\n                    self.updateWidgets(with: articles)\n                    task.setTaskCompleted(success: true)\n                case .failure(let error):\n                    print(\"Background news fetch failed: \\(error)\")\n                    task.setTaskCompleted(success: false)\n                }\n            }\n        }\n        \n        task.expirationHandler = {\n            operationQueue.cancelAllOperations()\n        }\n        \n        operationQueue.addOperation(refreshOperation)\n    }\n}\n```\n\n### Social Media App Sync\n```swift\nclass SocialMediaSyncManager {\n    func scheduleSocialSync() {\n        let request = BGProcessingTaskRequest(identifier: \"com.socialapp.sync\")\n        request.requiresNetworkConnectivity = true\n        request.earliestBeginDate = Date(timeIntervalSinceNow: 15 * 60)\n        \n        do {\n            try BGTaskScheduler.shared.submit(request)\n        } catch {\n            print(\"Social sync scheduling failed: \\(error)\")\n        }\n    }\n    \n    func handleSocialSync(task: BGProcessingTask) {\n        let syncOperations = createSyncOperations()\n        let operationQueue = OperationQueue()\n        \n        // Configure operation dependencies\n        configureDependencies(for: syncOperations)\n        \n        task.expirationHandler = {\n            operationQueue.cancelAllOperations()\n        }\n        \n        // Add completion operation\n        let completionOperation = BlockOperation {\n            task.setTaskCompleted(success: true)\n        }\n        \n        for operation in syncOperations {\n            completionOperation.addDependency(operation)\n        }\n        \n        operationQueue.addOperations(syncOperations + [completionOperation], \n                                   waitUntilFinished: false)\n    }\n}\n```\n\n## Best Practices Summary\n\n1. **Minimize Energy Impact**: Break work into chunks and avoid CPU-intensive operations\n2. **Handle Expiration Gracefully**: Always implement expiration handlers\n3. **Preserve State**: Save progress to resume if task is terminated\n4. **Adapt to Usage Patterns**: Adjust frequency based on user behavior\n5. **Test Thoroughly**: Use debug simulations and real device testing\n6. **Monitor Performance**: Use Instruments to track energy and performance impact\n7. **Respect System Limits**: Don't schedule tasks too frequently\n8. **Provide User Control**: Allow users to disable background refresh",
      "codeExample": "import BackgroundTasks\nimport UIKit\n\n// MARK: - Advanced Background Task Manager\nclass AdvancedBackgroundTaskManager: NSObject {\n    \n    static let shared = AdvancedBackgroundTaskManager()\n    \n    private let backgroundScheduler = BGTaskScheduler.shared\n    private let operationQueue: OperationQueue = {\n        let queue = OperationQueue()\n        queue.qualityOfService = .background\n        queue.maxConcurrentOperationCount = 1\n        return queue\n    }()\n    \n    private let logger = BackgroundTaskLogger()\n    private let stateManager = BackgroundStateManager()\n    \n    // MARK: - Task Identifiers\n    private enum TaskIdentifier: String {\n        case appRefresh = \"com.yourapp.background.refresh\"\n        case dataProcessing = \"com.yourapp.background.processing\"\n        case cleanup = \"com.yourapp.background.cleanup\"\n        case sync = \"com.yourapp.background.sync\"\n    }\n    \n    // MARK: - Initialization\n    override init() {\n        super.init()\n        registerBackgroundTasks()\n    }\n    \n    // MARK: - Task Registration\n    private func registerBackgroundTasks() {\n        // Register App Refresh Task\n        backgroundScheduler.register(forTaskWithIdentifier: TaskIdentifier.appRefresh.rawValue, \n                                   using: nil) { [weak self] task in\n            self?.handleAppRefresh(task: task as! BGAppRefreshTask)\n        }\n        \n        // Register Processing Task\n        backgroundScheduler.register(forTaskWithIdentifier: TaskIdentifier.dataProcessing.rawValue, \n                                   using: nil) { [weak self] task in\n            self?.handleDataProcessing(task: task as! BGProcessingTask)\n        }\n        \n        // Register Cleanup Task\n        backgroundScheduler.register(forTaskWithIdentifier: TaskIdentifier.cleanup.rawValue, \n                                   using: nil) { [weak self] task in\n            self?.handleCleanup(task: task as! BGProcessingTask)\n        }\n        \n        // Register Sync Task\n        backgroundScheduler.register(forTaskWithIdentifier: TaskIdentifier.sync.rawValue, \n                                   using: nil) { [weak self] task in\n            self?.handleSync(task: task as! BGProcessingTask)\n        }\n    }\n    \n    // MARK: - Task Scheduling\n    func scheduleAllBackgroundTasks() {\n        scheduleAppRefresh()\n        scheduleDataProcessing()\n        scheduleCleanup()\n        scheduleSync()\n    }\n    \n    private func scheduleAppRefresh() {\n        let request = BGAppRefreshTaskRequest(identifier: TaskIdentifier.appRefresh.rawValue)\n        request.earliestBeginDate = Date(timeIntervalSinceNow: 15 * 60) // 15 minutes\n        \n        do {\n            try backgroundScheduler.submit(request)\n            logger.logTaskScheduled(identifier: TaskIdentifier.appRefresh.rawValue, \n                                  earliestBeginDate: request.earliestBeginDate!)\n        } catch {\n            logger.log(\"Failed to schedule app refresh: \\(error)\")\n        }\n    }\n    \n    private func scheduleDataProcessing() {\n        let request = BGProcessingTaskRequest(identifier: TaskIdentifier.dataProcessing.rawValue)\n        request.requiresNetworkConnectivity = false\n        request.requiresExternalPower = false\n        request.earliestBeginDate = Date(timeIntervalSinceNow: 30 * 60) // 30 minutes\n        \n        do {\n            try backgroundScheduler.submit(request)\n            logger.logTaskScheduled(identifier: TaskIdentifier.dataProcessing.rawValue, \n                                  earliestBeginDate: request.earliestBeginDate!)\n        } catch {\n            logger.log(\"Failed to schedule data processing: \\(error)\")\n        }\n    }\n    \n    private func scheduleCleanup() {\n        let request = BGProcessingTaskRequest(identifier: TaskIdentifier.cleanup.rawValue)\n        request.requiresNetworkConnectivity = false\n        request.requiresExternalPower = true // Only run when charging for cleanup\n        request.earliestBeginDate = Date(timeIntervalSinceNow: 60 * 60) // 1 hour\n        \n        do {\n            try backgroundScheduler.submit(request)\n            logger.logTaskScheduled(identifier: TaskIdentifier.cleanup.rawValue, \n                                  earliestBeginDate: request.earliestBeginDate!)\n        } catch {\n            logger.log(\"Failed to schedule cleanup: \\(error)\")\n        }\n    }\n    \n    private func scheduleSync() {\n        let request = BGProcessingTaskRequest(identifier: TaskIdentifier.sync.rawValue)\n        request.requiresNetworkConnectivity = true\n        request.requiresExternalPower = false\n        request.earliestBeginDate = Date(timeIntervalSinceNow: 20 * 60) // 20 minutes\n        \n        do {\n            try backgroundScheduler.submit(request)\n            logger.logTaskScheduled(identifier: TaskIdentifier.sync.rawValue, \n                                  earliestBeginDate: request.earliestBeginDate!)\n        } catch {\n            logger.log(\"Failed to schedule sync: \\(error)\")\n        }\n    }\n    \n    // MARK: - Task Handlers\n    private func handleAppRefresh(task: BGAppRefreshTask) {\n        logger.logTaskStarted(identifier: TaskIdentifier.appRefresh.rawValue)\n        \n        // Schedule the next refresh first\n        scheduleAppRefresh()\n        \n        let refreshOperation = AppRefreshOperation()\n        \n        refreshOperation.completionBlock = { [weak self] in\n            if refreshOperation.isCancelled {\n                task.setTaskCompleted(success: false)\n                self?.logger.logTaskCompleted(identifier: TaskIdentifier.appRefresh.rawValue, \n                                            success: false)\n            } else {\n                task.setTaskCompleted(success: true)\n                self?.logger.logTaskCompleted(identifier: TaskIdentifier.appRefresh.rawValue, \n                                            success: true)\n            }\n        }\n        \n        task.expirationHandler = { [weak self] in\n            self?.logger.logTaskExpired(identifier: TaskIdentifier.appRefresh.rawValue)\n            refreshOperation.cancel()\n        }\n        \n        operationQueue.addOperation(refreshOperation)\n    }\n    \n    private func handleDataProcessing(task: BGProcessingTask) {\n        logger.logTaskStarted(identifier: TaskIdentifier.dataProcessing.rawValue)\n        \n        let processingOperation = DataProcessingOperation()\n        \n        processingOperation.completionBlock = { [weak self] in\n            task.setTaskCompleted(success: !processingOperation.isCancelled)\n            self?.logger.logTaskCompleted(identifier: TaskIdentifier.dataProcessing.rawValue, \n                                        success: !processingOperation.isCancelled)\n            \n            // Schedule next processing\n            self?.scheduleDataProcessing()\n        }\n        \n        task.expirationHandler = { [weak self] in\n            self?.logger.logTaskExpired(identifier: TaskIdentifier.dataProcessing.rawValue)\n            processingOperation.cancel()\n        }\n        \n        operationQueue.addOperation(processingOperation)\n    }\n    \n    private func handleCleanup(task: BGProcessingTask) {\n        logger.logTaskStarted(identifier: TaskIdentifier.cleanup.rawValue)\n        \n        let cleanupOperation = CleanupOperation()\n        \n        cleanupOperation.completionBlock = { [weak self] in\n            task.setTaskCompleted(success: !cleanupOperation.isCancelled)\n            self?.logger.logTaskCompleted(identifier: TaskIdentifier.cleanup.rawValue, \n                                        success: !cleanupOperation.isCancelled)\n            \n            // Schedule next cleanup (weekly)\n            DispatchQueue.main.asyncAfter(deadline: .now() + 7 * 24 * 3600) {\n                self?.scheduleCleanup()\n            }\n        }\n        \n        task.expirationHandler = { [weak self] in\n            self?.logger.logTaskExpired(identifier: TaskIdentifier.cleanup.rawValue)\n            cleanupOperation.cancel()\n        }\n        \n        operationQueue.addOperation(cleanupOperation)\n    }\n    \n    private func handleSync(task: BGProcessingTask) {\n        logger.logTaskStarted(identifier: TaskIdentifier.sync.rawValue)\n        \n        let syncOperation = SyncOperation()\n        \n        syncOperation.completionBlock = { [weak self] in\n            task.setTaskCompleted(success: !syncOperation.isCancelled)\n            self?.logger.logTaskCompleted(identifier: TaskIdentifier.sync.rawValue, \n                                        success: !syncOperation.isCancelled)\n            \n            // Schedule next sync\n            self?.scheduleSync()\n        }\n        \n        task.expirationHandler = { [weak self] in\n            self?.logger.logTaskExpired(identifier: TaskIdentifier.sync.rawValue)\n            syncOperation.cancel()\n        }\n        \n        operationQueue.addOperation(syncOperation)\n    }\n}\n\n// MARK: - Background Operations\nclass AppRefreshOperation: Operation {\n    override func main() {\n        guard !isCancelled else { return }\n        \n        // Simulate app refresh work\n        print(\"Performing app refresh...\")\n        \n        // Update widget data\n        updateWidgetData()\n        \n        // Fetch latest content\n        fetchLatestContent()\n        \n        // Update badge count if needed\n        updateAppBadge()\n    }\n    \n    private func updateWidgetData() {\n        // Update widget timeline\n        print(\"Updating widget data...\")\n    }\n    \n    private func fetchLatestContent() {\n        // Fetch latest data from API\n        print(\"Fetching latest content...\")\n    }\n    \n    private func updateAppBadge() {\n        // Update app badge count\n        print(\"Updating app badge...\")\n    }\n}\n\nclass DataProcessingOperation: Operation {\n    override func main() {\n        guard !isCancelled else { return }\n        \n        // Simulate data processing\n        print(\"Processing data in background...\")\n        \n        // Process analytics data\n        processAnalytics()\n        \n        // Train ML models if needed\n        trainModels()\n        \n        // Generate reports\n        generateReports()\n    }\n    \n    private func processAnalytics() {\n        // Process collected analytics data\n        print(\"Processing analytics...\")\n    }\n    \n    private func trainModels() {\n        // Train machine learning models\n        print(\"Training ML models...\")\n    }\n    \n    private func generateReports() {\n        // Generate usage reports\n        print(\"Generating reports...\")\n    }\n}\n\nclass CleanupOperation: Operation {\n    override func main() {\n        guard !isCancelled else { return }\n        \n        // Simulate cleanup work\n        print(\"Performing cleanup tasks...\")\n        \n        // Clean up temporary files\n        cleanupTempFiles()\n        \n        // Optimize database\n        optimizeDatabase()\n        \n        // Clear old cache\n        clearOldCache()\n    }\n    \n    private func cleanupTempFiles() {\n        // Remove temporary files\n        print(\"Cleaning up temporary files...\")\n    }\n    \n    private func optimizeDatabase() {\n        // Optimize database performance\n        print(\"Optimizing database...\")\n    }\n    \n    private func clearOldCache() {\n        // Clear old cached data\n        print(\"Clearing old cache...\")\n    }\n}\n\nclass SyncOperation: Operation {\n    override func main() {\n        guard !isCancelled else { return }\n        \n        // Simulate sync work\n        print(\"Performing background sync...\")\n        \n        // Sync with cloud\n        syncWithCloud()\n        \n        // Upload local changes\n        uploadLocalChanges()\n        \n        // Download remote changes\n        downloadRemoteChanges()\n    }\n    \n    private func syncWithCloud() {\n        // Sync data with cloud service\n        print(\"Syncing with cloud...\")\n    }\n    \n    private func uploadLocalChanges() {\n        // Upload local changes to server\n        print(\"Uploading local changes...\")\n    }\n    \n    private func downloadRemoteChanges() {\n        // Download changes from server\n        print(\"Downloading remote changes...\")\n    }\n}\n\n// MARK: - Support Classes\nclass BackgroundTaskLogger {\n    func log(_ message: String) {\n        print(\"[BackgroundTask] \\(message)\")\n    }\n    \n    func logTaskScheduled(identifier: String, earliestBeginDate: Date) {\n        log(\"Scheduled task: \\(identifier) for \\(earliestBeginDate)\")\n    }\n    \n    func logTaskStarted(identifier: String) {\n        log(\"Started task: \\(identifier)\")\n    }\n    \n    func logTaskCompleted(identifier: String, success: Bool) {\n        log(\"Completed task: \\(identifier), success: \\(success)\")\n    }\n    \n    func logTaskExpired(identifier: String) {\n        log(\"Task expired: \\(identifier)\")\n    }\n}\n\nclass BackgroundStateManager {\n    private let userDefaults = UserDefaults.standard\n    \n    func saveTaskState(_ state: [String: Any], for identifier: String) {\n        userDefaults.set(state, forKey: \"backgroundTaskState_\\(identifier)\")\n    }\n    \n    func loadTaskState(for identifier: String) -> [String: Any]? {\n        return userDefaults.dictionary(forKey: \"backgroundTaskState_\\(identifier)\")\n    }\n    \n    func clearTaskState(for identifier: String) {\n        userDefaults.removeObject(forKey: \"backgroundTaskState_\\(identifier)\")\n    }\n}\n\n// MARK: - App Delegate Integration\nclass AppDelegate: UIResponder, UIApplicationDelegate {\n    \n    func application(_ application: UIApplication, \n                   didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -> Bool {\n        \n        // Initialize background task manager\n        let backgroundManager = AdvancedBackgroundTaskManager.shared\n        \n        // Schedule all background tasks\n        backgroundManager.scheduleAllBackgroundTasks()\n        \n        return true\n    }\n    \n    func applicationDidEnterBackground(_ application: UIApplication) {\n        // Ensure tasks are scheduled when app enters background\n        AdvancedBackgroundTaskManager.shared.scheduleAllBackgroundTasks()\n    }\n}",
      "category": "iOS System Integration",
      "estimatedTime": 240,
      "dependencies": ["combine_framework", "networking", "core_data"],
      "challenge": {
        "instructions": "Build a complete background task system for a news aggregation app:\n\nPART 1: Basic Background Setup (60 min)\n1. Create a BackgroundTaskManager class that registers all required background tasks\n2. Implement proper task scheduling with appropriate time intervals\n3. Set up task expiration handlers and completion callbacks\n\nPART 2: News-Specific Background Tasks (90 min)\n4. Create an AppRefreshTask that fetches latest news articles\n5. Implement a ProcessingTask that performs data analysis on articles\n6. Build a CleanupTask that removes old articles and optimizes storage\n7. Create a SyncTask that synchronizes read status across devices\n\nPART 3: Advanced Task Coordination (90 min)\n8. Implement task dependencies (sync should wait for refresh to complete)\n9. Create adaptive scheduling based on user reading habits\n10. Build state preservation to resume interrupted tasks\n11. Implement energy-efficient task execution with progress reporting\n\nPART 4: Real-World Scenarios (90 min)\n12. Handle background URLSession downloads for article images\n13. Implement widget data updates from background tasks\n14. Create offline content preparation for when network is unavailable\n15. Build user preference-aware task scheduling\n\nPART 5: Testing and Optimization (60 min)\n16. Create unit tests for all background task operations\n17. Implement performance monitoring and energy impact assessment\n18. Add debug utilities for simulating background tasks in development",
        "starterCode": "import BackgroundTasks\nimport UIKit\n\n// === PART 1: Basic Background Setup ===\n// Create your BackgroundTaskManager class here\n\n\n// === PART 2: News-Specific Background Tasks ===\n// Implement news-specific background operations\n\n\n// === PART 3: Advanced Task Coordination ===\n// Build task coordination and adaptive scheduling\n\n\n// === PART 4: Real-World Scenarios ===\n// Handle URLSession, widget updates, and offline prep\n\n\n// === PART 5: Testing and Optimization ===\n// Add tests and performance monitoring\n\n",
        "solution": "import BackgroundTasks\nimport UIKit\nimport os.log\n\n// === PART 1: Basic Background Setup ===\nclass NewsBackgroundTaskManager {\n    static let shared = NewsBackgroundTaskManager()\n    \n    private let scheduler = BGTaskScheduler.shared\n    private let operationQueue: OperationQueue = {\n        let queue = OperationQueue()\n        queue.qualityOfService = .background\n        queue.maxConcurrentOperationCount = 1\n        return queue\n    }()\n    \n    private let logger = OSLog(subsystem: \"com.newsapp.background\", category: \"Tasks\")\n    \n    enum TaskType: String {\n        case articleRefresh = \"com.newsapp.articles.refresh\"\n        case imagePrefetch = \"com.newsapp.images.prefetch\"\n        case analyticsProcess = \"com.newsapp.analytics.process\"\n        case storageCleanup = \"com.newsapp.storage.cleanup\"\n    }\n    \n    func registerTasks() {\n        // Register all task types\n        for taskType in [TaskType.articleRefresh, .imagePrefetch, .analyticsProcess, .storageCleanup] {\n            scheduler.register(forTaskWithIdentifier: taskType.rawValue, using: nil) { [weak self] task in\n                self?.handleTask(task, type: taskType)\n            }\n        }\n    }\n    \n    func scheduleAllTasks() {\n        scheduleArticleRefresh()\n        scheduleImagePrefetch()\n        scheduleAnalyticsProcessing()\n        scheduleStorageCleanup()\n    }\n    \n    private func scheduleArticleRefresh() {\n        let request = BGAppRefreshTaskRequest(identifier: TaskType.articleRefresh.rawValue)\n        request.earliestBeginDate = Date(timeIntervalSinceNow: 15 * 60)\n        \n        do {\n            try scheduler.submit(request)\n            os_log(\"Article refresh scheduled\", log: logger)\n        } catch {\n            os_log(\"Failed to schedule article refresh: %@\", log: logger, type: .error, error.localizedDescription)\n        }\n    }\n    \n    private func scheduleImagePrefetch() {\n        let request = BGProcessingTaskRequest(identifier: TaskType.imagePrefetch.rawValue)\n        request.requiresNetworkConnectivity = true\n        request.earliestBeginDate = Date(timeIntervalSinceNow: 30 * 60)\n        \n        do {\n            try scheduler.submit(request)\n            os_log(\"Image prefetch scheduled\", log: logger)\n        } catch {\n            os_log(\"Failed to schedule image prefetch: %@\", log: logger, type: .error, error.localizedDescription)\n        }\n    }\n    \n    private func scheduleAnalyticsProcessing() {\n        let request = BGProcessingTaskRequest(identifier: TaskType.analyticsProcess.rawValue)\n        request.requiresNetworkConnectivity = false\n        request.earliestBeginDate = Date(timeIntervalSinceNow: 60 * 60)\n        \n        do {\n            try scheduler.submit(request)\n            os_log(\"Analytics processing scheduled\", log: logger)\n        } catch {\n            os_log(\"Failed to schedule analytics processing: %@\", log: logger, type: .error, error.localizedDescription)\n        }\n    }\n    \n    private func scheduleStorageCleanup() {\n        let request = BGProcessingTaskRequest(identifier: TaskType.storageCleanup.rawValue)\n        request.requiresExternalPower = true\n        request.earliestBeginDate = Date(timeIntervalSinceNow: 24 * 60 * 60)\n        \n        do {\n            try scheduler.submit(request)\n            os_log(\"Storage cleanup scheduled\", log: logger)\n        } catch {\n            os_log(\"Failed to schedule storage cleanup: %@\", log: logger, type: .error, error.localizedDescription)\n        }\n    }\n    \n    private func handleTask(_ task: BGTask, type: TaskType) {\n        os_log(\"Handling task: %@\", log: logger, type.rawValue)\n        \n        switch type {\n        case .articleRefresh:\n            handleArticleRefresh(task as! BGAppRefreshTask)\n        case .imagePrefetch:\n            handleImagePrefetch(task as! BGProcessingTask)\n        case .analyticsProcess:\n            handleAnalyticsProcessing(task as! BGProcessingTask)\n        case .storageCleanup:\n            handleStorageCleanup(task as! BGProcessingTask)\n        }\n    }\n    \n    // === PART 2: News-Specific Background Tasks ===\n    private func handleArticleRefresh(_ task: BGAppRefreshTask) {\n        scheduleArticleRefresh() // Schedule next refresh first\n        \n        let operation = ArticleRefreshOperation()\n        \n        operation.completionBlock = {\n            task.setTaskCompleted(success: !operation.isCancelled)\n            os_log(\"Article refresh completed: %@\", log: self.logger, !operation.isCancelled ? \"success\" : \"cancelled\")\n        }\n        \n        task.expirationHandler = {\n            operation.cancel()\n            os_log(\"Article refresh expired\", log: self.logger)\n        }\n        \n        operationQueue.addOperation(operation)\n    }\n    \n    private func handleImagePrefetch(_ task: BGProcessingTask) {\n        let operation = ImagePrefetchOperation()\n        \n        operation.completionBlock = {\n            task.setTaskCompleted(success: !operation.isCancelled)\n            os_log(\"Image prefetch completed: %@\", log: self.logger, !operation.isCancelled ? \"success\" : \"cancelled\")\n            self.scheduleImagePrefetch()\n        }\n        \n        task.expirationHandler = {\n            operation.cancel()\n            os_log(\"Image prefetch expired\", log: self.logger)\n        }\n        \n        operationQueue.addOperation(operation)\n    }\n    \n    private func handleAnalyticsProcessing(_ task: BGProcessingTask) {\n        let operation = AnalyticsProcessingOperation()\n        \n        operation.completionBlock = {\n            task.setTaskCompleted(success: !operation.isCancelled)\n            os_log(\"Analytics processing completed: %@\", log: self.logger, !operation.isCancelled ? \"success\" : \"cancelled\")\n            self.scheduleAnalyticsProcessing()\n        }\n        \n        task.expirationHandler = {\n            operation.cancel()\n            os_log(\"Analytics processing expired\", log: self.logger)\n        }\n        \n        operationQueue.addOperation(operation)\n    }\n    \n    private func handleStorageCleanup(_ task: BGProcessingTask) {\n        let operation = StorageCleanupOperation()\n        \n        operation.completionBlock = {\n            task.setTaskCompleted(success: !operation.isCancelled)\n            os_log(\"Storage cleanup completed: %@\", log: self.logger, !operation.isCancelled ? \"success\" : \"cancelled\")\n            self.scheduleStorageCleanup()\n        }\n        \n        task.expirationHandler = {\n            operation.cancel()\n            os_log(\"Storage cleanup expired\", log: self.logger)\n        }\n        \n        operationQueue.addOperation(operation)\n    }\n}\n\nclass ArticleRefreshOperation: Operation {\n    override func main() {\n        guard !isCancelled else { return }\n        \n        let newsAPI = NewsAPIService()\n        let group = DispatchGroup()\n        \n        group.enter()\n        newsAPI.fetchLatestArticles { [weak self] result in\n            guard !(self?.isCancelled ?? true) else {\n                group.leave()\n                return\n            }\n            \n            switch result {\n            case .success(let articles):\n                self?.cacheArticles(articles)\n                self?.updateWidgetTimeline()\n            case .failure(let error):\n                print(\"Failed to fetch articles: \\(error)\")\n            }\n            group.leave()\n        }\n        \n        _ = group.wait(timeout: .now() + 25) // 25 second timeout\n    }\n    \n    private func cacheArticles(_ articles: [Article]) {\n        // Cache articles to Core Data or UserDefaults\n        print(\"Caching \\(articles.count) articles\")\n    }\n    \n    private func updateWidgetTimeline() {\n        // Update widget timeline with latest articles\n        print(\"Updating widget timeline\")\n    }\n}\n\nclass ImagePrefetchOperation: Operation {\n    override func main() {\n        guard !isCancelled else { return }\n        \n        // Prefetch images for top articles\n        let topArticles = getTopArticles()\n        \n        for article in topArticles.prefix(5) {\n            guard !isCancelled else { break }\n            prefetchImage(for: article)\n        }\n    }\n    \n    private func getTopArticles() -> [Article] {\n        // Retrieve top articles from cache\n        return []\n    }\n    \n    private func prefetchImage(for article: Article) {\n        // Prefetch and cache article image\n        print(\"Prefetching image for: \\(article.title)\")\n    }\n}\n\n// === PART 3: Advanced Task Coordination ===\nclass AdaptiveTaskScheduler {\n    private let userDefaults = UserDefaults.standard\n    \n    func calculateOptimalRefreshInterval() -> TimeInterval {\n        let lastOpened = userDefaults.object(forKey: \"lastAppOpen\") as? Date ?? Date.distantPast\n        let timeSinceLastOpen = Date().timeIntervalSince(lastOpened)\n        \n        // Adaptive scheduling based on usage\n        switch timeSinceLastOpen {\n        case ..<(2 * 60 * 60): // Less than 2 hours\n            return 15 * 60 // 15 minutes\n        case ..<(24 * 60 * 60): // Less than 24 hours\n            return 30 * 60 // 30 minutes\n        case ..<(7 * 24 * 60 * 60): // Less than 1 week\n            return 2 * 60 * 60 // 2 hours\n        default:\n            return 6 * 60 * 60 // 6 hours\n        }\n    }\n}\n\n// === PART 4: Real-World Scenarios ===\nclass BackgroundImageDownloader: NSObject, URLSessionDownloadDelegate {\n    private var backgroundSession: URLSession!\n    private var completionHandler: (() -> Void)?\n    \n    override init() {\n        super.init()\n        \n        let config = URLSessionConfiguration.background(withIdentifier: \"com.newsapp.background.downloader\")\n        config.isDiscretionary = true\n        config.sessionSendsLaunchEvents = true\n        \n        backgroundSession = URLSession(configuration: config, delegate: self, delegateQueue: nil)\n    }\n    \n    func downloadImages(_ urls: [URL]) {\n        for url in urls {\n            let task = backgroundSession.downloadTask(with: url)\n            task.resume()\n        }\n    }\n    \n    // URLSessionDownloadDelegate methods\n    func urlSession(_ session: URLSession, downloadTask: URLSessionDownloadTask, didFinishDownloadingTo location: URL) {\n        // Process downloaded image\n        processDownloadedImage(at: location, for: downloadTask)\n    }\n    \n    func urlSessionDidFinishEvents(forBackgroundURLSession session: URLSession) {\n        DispatchQueue.main.async {\n            self.completionHandler?()\n            self.completionHandler = nil\n        }\n    }\n    \n    private func processDownloadedImage(at location: URL, for task: URLSessionDownloadTask) {\n        // Cache the downloaded image\n        print(\"Processing downloaded image from: \\(location)\")\n    }\n}\n\n// === PART 5: Testing and Optimization ===\n#if DEBUG\nclass BackgroundTaskDebugger {\n    static func simulateBackgroundTasks() {\n        let manager = NewsBackgroundTaskManager.shared\n        \n        // Simulate article refresh\n        let refreshTask = MockBGAppRefreshTask(identifier: \"com.newsapp.articles.refresh\")\n        manager.handleTask(refreshTask, type: .articleRefresh)\n        \n        // Simulate image prefetch\n        let prefetchTask = MockBGProcessingTask(identifier: \"com.newsapp.images.prefetch\")\n        manager.handleTask(prefetchTask, type: .imagePrefetch)\n    }\n}\n\nclass MockBGAppRefreshTask: BGAppRefreshTask {\n    override func setTaskCompleted(success: Bool) {\n        print(\"Mock refresh task completed with success: \\(success)\")\n    }\n}\n\nclass MockBGProcessingTask: BGProcessingTask {\n    override func setTaskCompleted(success: Bool) {\n        print(\"Mock processing task completed with success: \\(success)\")\n    }\n}\n#endif\n\n// Support types\nstruct Article {\n    let title: String\n    let content: String\n    let imageURL: URL?\n}\n\nclass NewsAPIService {\n    func fetchLatestArticles(completion: @escaping (Result<[Article], Error>) -> Void) {\n        // Simulate API call\n        DispatchQueue.global().asyncAfter(deadline: .now() + 2) {\n            completion(.success([]))\n        }\n    }\n}\n\nclass AnalyticsProcessingOperation: Operation {\n    override func main() {\n        guard !isCancelled else { return }\n        // Process analytics data\n        print(\"Processing analytics data...\")\n    }\n}\n\nclass StorageCleanupOperation: Operation {\n    override func main() {\n        guard !isCancelled else { return }\n        // Clean up storage\n        print(\"Cleaning up storage...\")\n    }\n}",
        "hints": [
          "PART 1: Register all task identifiers in AppDelegate's didFinishLaunching",
          "PART 2: Use BGAppRefreshTask for content updates, BGProcessingTask for heavy work",
          "PART 3: Implement adaptive scheduling based on user's app usage patterns",
          "PART 4: Use URLSession.background configuration for large downloads",
          "PART 5: Test background tasks using Xcode's Debug Simulate Background Fetch",
          "Always schedule the next task before starting current work",
          "Use operation queues to manage task dependencies and cancellation",
          "Monitor energy impact using Xcode's Energy Organizer",
          "Implement proper state preservation for long-running tasks"
        ],
        "testCases": [
          {
            "input": "BGTaskScheduler.shared.getPendingTaskRequests().count",
            "expectedOutput": "4",
            "description": "Should have all 4 task types scheduled"
          },
          {
            "input": "operationQueue.operationCount",
            "expectedOutput": "0",
            "description": "Operation queue should be empty before tasks start"
          },
          {
            "input": "UserDefaults.standard.object(forKey: \"lastAppOpen\") != nil",
            "expectedOutput": "true",
            "description": "Should track last app open for adaptive scheduling"
          }
        ]
      }
    },
    {
      "id": "travel_journal",
      "title": "Project: Travel Journal",
      "description": "Build a comprehensive travel journal app with location tracking, photo management, and interactive maps",
      "difficulty": "advanced",
      "theory": "# Travel Journal - Advanced iOS Development Project\n\n## 1. Project Architecture & Planning (45 min)\n\n### Modern iOS Architecture:\n**MVVM + Coordinator Pattern:**\n```swift\n// App Architecture\nApp\nâ”œâ”€â”€ Coordinators (Navigation)\nâ”œâ”€â”€ ViewModels (Business Logic)\nâ”œâ”€â”€ Views (UI Components)\nâ”œâ”€â”€ Services (Location, Network, Storage)\nâ””â”€â”€ Models (Data Structures)\n```\n\n### Core Features Breakdown:\n- **Location Tracking & Geofencing**\n- **Photo Management with EXIF Data**\n- **Interactive Map Integration**\n- **Offline Storage & Sync**\n- **Rich Media Journal Entries**\n\n### Technology Stack:\n- SwiftUI + Combine\n- Core Location & MapKit\n- Photos Framework\n- Core Data with CloudKit\n- URLSession + Async/Await\n\n## 2. Core Location & Geofencing (90 min)\n\n### Advanced Location Services:\n\n#### Location Manager with Combine:\n```swift\nclass LocationManager: NSObject, ObservableObject {\n    private let locationManager = CLLocationManager()\n    \n    @Published var authorizationStatus: CLAuthorizationStatus\n    @Published var currentLocation: CLLocation?\n    @Published var visitedLocations: [VisitedLocation] = []\n    \n    private var cancellables = Set<AnyCancellable>()\n    \n    override init() {\n        authorizationStatus = locationManager.authorizationStatus\n        super.init()\n        \n        locationManager.delegate = self\n        locationManager.desiredAccuracy = kCLLocationAccuracyBest\n        locationManager.distanceFilter = 10 // Update every 10 meters\n        locationManager.allowsBackgroundLocationUpdates = true\n        locationManager.pausesLocationUpdatesAutomatically = false\n    }\n}\n```\n\n#### Significant Location Changes:\n```swift\nextension LocationManager: CLLocationManagerDelegate {\n    func startSignificantLocationChanges() {\n        guard CLLocationManager.significantLocationChangeMonitoringAvailable() else { return }\n        \n        locationManager.startMonitoringSignificantLocationChanges()\n        locationManager.startUpdatingLocation()\n    }\n    \n    func locationManager(_ manager: CLLocationManager, didUpdateLocations locations: [CLLocation]) {\n        guard let location = locations.last else { return }\n        \n        currentLocation = location\n        \n        // Check if this is a new significant location\n        if isSignificantLocationChange(location) {\n            addVisitedLocation(location)\n        }\n    }\n    \n    private func isSignificantLocationChange(_ location: CLLocation) -> Bool {\n        guard let lastLocation = visitedLocations.last?.location else { return true }\n        \n        return location.distance(from: lastLocation) > 500 // 500 meters\n    }\n}\n```\n\n#### Geofencing for Points of Interest:\n```swift\nclass GeofenceService: ObservableObject {\n    private let locationManager = CLLocationManager()\n    @Published var activeGeofences: [CLCircularRegion] = []\n    @Published var geofenceEvents = PassthroughSubject<GeofenceEvent, Never>()\n    \n    func addGeofence(for location: CLLocation, radius: Double = 100, identifier: String) {\n        let region = CLCircularRegion(\n            center: location.coordinate,\n            radius: radius,\n            identifier: identifier\n        )\n        \n        region.notifyOnEntry = true\n        region.notifyOnExit = true\n        \n        locationManager.startMonitoring(for: region)\n        activeGeofences.append(region)\n    }\n    \n    func locationManager(_ manager: CLLocationManager, didEnterRegion region: CLRegion) {\n        if let circularRegion = region as? CLCircularRegion {\n            geofenceEvents.send(.entry(region: circularRegion))\n        }\n    }\n    \n    func locationManager(_ manager: CLLocationManager, didExitRegion region: CLRegion) {\n        if let circularRegion = region as? CLCircularRegion {\n            geofenceEvents.send(.exit(region: circularRegion))\n        }\n    }\n}\n\nenum GeofenceEvent {\n    case entry(region: CLCircularRegion)\n    case exit(region: CLCircularRegion)\n}\n```\n\n## 3. Advanced Photo Management (90 min)\n\n### Photos Framework Integration:\n\n#### Photo Picker with Multiple Selection:\n```swift\nimport PhotosUI\n\nstruct PhotoPicker: UIViewControllerRepresentable {\n    @Binding var selectedImages: [UIImage]\n    var selectionLimit: Int = 10\n    \n    func makeUIViewController(context: Context) -> PHPickerViewController {\n        var configuration = PHPickerConfiguration()\n        configuration.filter = .images\n        configuration.selectionLimit = selectionLimit\n        configuration.preferredAssetRepresentationMode = .current\n        \n        let picker = PHPickerViewController(configuration: configuration)\n        picker.delegate = context.coordinator\n        return picker\n    }\n    \n    func updateUIViewController(_ uiViewController: PHPickerViewController, context: Context) {}\n    \n    func makeCoordinator() -> Coordinator {\n        Coordinator(self)\n    }\n    \n    class Coordinator: NSObject, PHPickerViewControllerDelegate {\n        let parent: PhotoPicker\n        \n        init(_ parent: PhotoPicker) {\n            self.parent = parent\n        }\n        \n        func picker(_ picker: PHPickerViewController, didFinishPicking results: [PHPickerResult]) {\n            picker.dismiss(animated: true)\n            \n            let dispatchGroup = DispatchGroup()\n            var newImages: [UIImage] = []\n            \n            for result in results {\n                dispatchGroup.enter()\n                \n                if result.itemProvider.canLoadObject(ofClass: UIImage.self) {\n                    result.itemProvider.loadObject(ofClass: UIImage.self) { image, error in\n                        if let image = image as? UIImage {\n                            newImages.append(image)\n                        }\n                        dispatchGroup.leave()\n                    }\n                } else {\n                    dispatchGroup.leave()\n                }\n            }\n            \n            dispatchGroup.notify(queue: .main) {\n                self.parent.selectedImages.append(contentsOf: newImages)\n            }\n        }\n    }\n}\n```\n\n#### EXIF Data Extraction:\n```swift\nstruct PhotoMetadata {\n    let location: CLLocation?\n    let dateTaken: Date?\n    let cameraModel: String?\n    let exposure: String?\n}\n\nclass PhotoMetadataService {\n    func extractMetadata(from image: UIImage) async throws -> PhotoMetadata {\n        guard let imageData = image.jpegData(compressionQuality: 1.0),\n              let source = CGImageSourceCreateWithData(imageData as CFData, nil) else {\n            throw MetadataError.invalidImage\n        }\n        \n        guard let properties = CGImageSourceCopyPropertiesAtIndex(source, 0, nil) as? [String: Any] else {\n            throw MetadataError.noMetadata\n        }\n        \n        return parseMetadata(properties)\n    }\n    \n    private func parseMetadata(_ properties: [String: Any]) -> PhotoMetadata {\n        var location: CLLocation?\n        var dateTaken: Date?\n        var cameraModel: String?\n        var exposure: String?\n        \n        // Extract GPS data\n        if let gpsData = properties[kCGImagePropertyGPSDictionary as String] as? [String: Any] {\n            location = parseGPSData(gpsData)\n        }\n        \n        // Extract EXIF data\n        if let exifData = properties[kCGImagePropertyExifDictionary as String] as? [String: Any] {\n            dateTaken = parseDate(from: exifData)\n            cameraModel = exifData[kCGImagePropertyExifLensModel as String] as? String\n            exposure = parseExposure(from: exifData)\n        }\n        \n        return PhotoMetadata(\n            location: location,\n            dateTaken: dateTaken,\n            cameraModel: cameraModel,\n            exposure: exposure\n        )\n    }\n    \n    private func parseGPSData(_ gpsData: [String: Any]) -> CLLocation? {\n        guard let latitude = gpsData[kCGImagePropertyGPSLatitude as String] as? Double,\n              let longitude = gpsData[kCGImagePropertyGPSLongitude as String] as? Double,\n              let latitudeRef = gpsData[kCGImagePropertyGPSLatitudeRef as String] as? String,\n              let longitudeRef = gpsData[kCGImagePropertyGPSLongitudeRef as String] as? String else {\n            return nil\n        }\n        \n        let finalLatitude = latitudeRef == \"S\" ? -latitude : latitude\n        let finalLongitude = longitudeRef == \"W\" ? -longitude : longitude\n        \n        return CLLocation(latitude: finalLatitude, longitude: finalLongitude)\n    }\n}\n```\n\n#### Photo Compression & Optimization:\n```swift\nclass ImageProcessor {\n    func compressImage(_ image: UIImage, maxFileSize: Int = 2_000_000) -> Data? {\n        var compression: CGFloat = 1.0\n        var imageData = image.jpegData(compressionQuality: compression)\n        \n        while let data = imageData, data.count > maxFileSize && compression > 0.1 {\n            compression -= 0.1\n            imageData = image.jpegData(compressionQuality: compression)\n        }\n        \n        return imageData\n    }\n    \n    func generateThumbnail(_ image: UIImage, targetSize: CGSize) -> UIImage? {\n        let renderer = UIGraphicsImageRenderer(size: targetSize)\n        \n        return renderer.image { context in\n            image.draw(in: CGRect(origin: .zero, size: targetSize))\n        }\n    }\n    \n    func applyWatermark(_ image: UIImage, text: String) -> UIImage? {\n        let renderer = UIGraphicsImageRenderer(size: image.size)\n        \n        return renderer.image { context in\n            image.draw(at: .zero)\n            \n            let paragraphStyle = NSMutableParagraphStyle()\n            paragraphStyle.alignment = .center\n            \n            let attributes: [NSAttributedString.Key: Any] = [\n                .font: UIFont.systemFont(ofSize: 36, weight: .bold),\n                .foregroundColor: UIColor.white.withAlphaComponent(0.7),\n                .paragraphStyle: paragraphStyle\n            ]\n            \n            let string = NSAttributedString(string: text, attributes: attributes)\n            let textSize = string.size()\n            \n            string.draw(at: CGPoint(\n                x: (image.size.width - textSize.width) / 2,\n                y: image.size.height - textSize.height - 20\n            ))\n        }\n    }\n}\n```\n\n## 4. Interactive Maps & Annotations (90 min)\n\n### Advanced MapKit Integration:\n\n#### Custom Map Annotations:\n```swift\nstruct TravelMapView: View {\n    @StateObject private var viewModel = MapViewModel()\n    @State private var region = MKCoordinateRegion(\n        center: CLLocationCoordinate2D(latitude: 37.7749, longitude: -122.4194),\n        span: MKCoordinateSpan(latitudeDelta: 0.1, longitudeDelta: 0.1)\n    )\n    \n    var body: some View {\n        Map(coordinateRegion: $region, annotationItems: viewModel.journalEntries) { entry in\n            MapAnnotation(coordinate: entry.coordinate) {\n                CustomMapAnnotation(entry: entry)\n                    .onTapGesture {\n                        viewModel.selectedEntry = entry\n                    }\n            }\n        }\n        .overlay(alignment: .bottomTrailing) {\n            MapControlsView(viewModel: viewModel)\n        }\n    }\n}\n\nstruct CustomMapAnnotation: View {\n    let entry: JournalEntry\n    \n    var body: some View {\n        VStack(spacing: 4) {\n            Image(systemName: entry.category.iconName)\n                .foregroundColor(.white)\n                .padding(8)\n                .background(entry.category.color)\n                .clipShape(Circle())\n            \n            Text(entry.title)\n                .font(.caption)\n                .padding(4)\n                .background(Color.white)\n                .cornerRadius(4)\n                .shadow(radius: 2)\n        }\n    }\n}\n```\n\n#### Cluster Annotations for Performance:\n```swift\nclass MapClusteringManager {\n    func clusterAnnotations(_ annotations: [MKAnnotation], in region: MKCoordinateRegion) -> [ClusterAnnotation] {\n        let gridSize = 0.01 // Adjust based on zoom level\n        var clusters: [String: ClusterAnnotation] = [:]\n        \n        for annotation in annotations {\n            let gridX = Int(annotation.coordinate.latitude / gridSize)\n            let gridY = Int(annotation.coordinate.longitude / gridSize)\n            let key = \"\\(gridX)_\\(gridY)\"\n            \n            if let cluster = clusters[key] {\n                cluster.annotations.append(annotation)\n            } else {\n                let cluster = ClusterAnnotation(\n                    coordinate: annotation.coordinate,\n                    annotations: [annotation]\n                )\n                clusters[key] = cluster\n            }\n        }\n        \n        return Array(clusters.values)\n    }\n}\n\nclass ClusterAnnotation: NSObject, MKAnnotation {\n    let coordinate: CLLocationCoordinate2D\n    var annotations: [MKAnnotation]\n    var count: Int { annotations.count }\n    \n    init(coordinate: CLLocationCoordinate2D, annotations: [MKAnnotation]) {\n        self.coordinate = coordinate\n        self.annotations = annotations\n        super.init()\n    }\n}\n```\n\n#### Route Tracking & Polyline Drawing:\n```swift\nclass RouteTracker: ObservableObject {\n    @Published var routePoints: [CLLocationCoordinate2D] = []\n    @Published var totalDistance: CLLocationDistance = 0\n    \n    private var lastLocation: CLLocation?\n    \n    func addLocation(_ location: CLLocation) {\n        routePoints.append(location.coordinate)\n        \n        if let lastLocation = lastLocation {\n            totalDistance += location.distance(from: lastLocation)\n        }\n        \n        lastLocation = location\n    }\n    \n    func createPolyline() -> MKPolyline {\n        return MKPolyline(coordinates: routePoints, count: routePoints.count)\n    }\n    \n    func calculateBounds() -> MKCoordinateRegion? {\n        guard !routePoints.isEmpty else { return nil }\n        \n        var minLat = routePoints[0].latitude\n        var maxLat = routePoints[0].latitude\n        var minLon = routePoints[0].longitude\n        var maxLon = routePoints[0].longitude\n        \n        for point in routePoints {\n            minLat = min(minLat, point.latitude)\n            maxLat = max(maxLat, point.latitude)\n            minLon = min(minLon, point.longitude)\n            maxLon = max(maxLon, point.longitude)\n        }\n        \n        let center = CLLocationCoordinate2D(\n            latitude: (minLat + maxLat) / 2,\n            longitude: (minLon + maxLon) / 2\n        )\n        \n        let span = MKCoordinateSpan(\n            latitudeDelta: (maxLat - minLat) * 1.1,\n            longitudeDelta: (maxLon - minLon) * 1.1\n        )\n        \n        return MKCoordinateRegion(center: center, span: span)\n    }\n}\n```\n\n## 5. Advanced Data Management (90 min)\n\n### Core Data with CloudKit Sync:\n\n#### Complex Core Data Model:\n```swift\n@Model\nclass JournalEntry {\n    @Attribute(.unique) var id: UUID\n    var title: String\n    var content: String\n    var createdAt: Date\n    var updatedAt: Date\n    \n    // Location data\n    var latitude: Double\n    var longitude: Double\n    var locationName: String?\n    \n    // Relationships\n    @Relationship(deleteRule: .cascade)\n    var photos: [JournalPhoto]\n    \n    @Relationship(deleteRule: .nullify)\n    var trip: Trip?\n    \n    var coordinate: CLLocationCoordinate2D {\n        CLLocationCoordinate2D(latitude: latitude, longitude: longitude)\n    }\n    \n    init(title: String, content: String, latitude: Double, longitude: Double) {\n        self.id = UUID()\n        self.title = title\n        self.content = content\n        self.createdAt = Date()\n        self.updatedAt = Date()\n        self.latitude = latitude\n        self.longitude = longitude\n    }\n}\n\n@Model\nclass JournalPhoto {\n    @Attribute(.unique) var id: UUID\n    var imageData: Data\n    var thumbnailData: Data\n    var createdAt: Date\n    var orderIndex: Int\n    \n    // EXIF Metadata\n    var cameraModel: String?\n    var exposure: String?\n    var focalLength: Double?\n    \n    @Relationship(deleteRule: .nullify)\n    var entry: JournalEntry?\n}\n\n@Model\nclass Trip {\n    @Attribute(.unique) var id: UUID\n    var title: String\n    var startDate: Date\n    var endDate: Date\n    var isActive: Bool\n    \n    @Relationship(deleteRule: .cascade)\n    var entries: [JournalEntry]\n    \n    var duration: Int {\n        Calendar.current.dateComponents([.day], from: startDate, to: endDate).day ?? 0\n    }\n}\n```\n\n#### Advanced Fetch Requests:\n```swift\nclass JournalDataService {\n    let container: NSPersistentContainer\n    \n    init() {\n        container = NSPersistentContainer(name: \"TravelJournal\")\n        \n        // Configure CloudKit\n        guard let description = container.persistentStoreDescriptions.first else {\n            fatalError(\"No persistent store descriptions\")\n        }\n        \n        description.cloudKitContainerOptions = NSPersistentCloudKitContainerOptions(\n            containerIdentifier: \"iCloud.com.yourapp.traveljournal\"\n        )\n        \n        container.loadPersistentStores { description, error in\n            if let error = error {\n                print(\"Core Data failed to load: \\(error.localizedDescription)\")\n            }\n        }\n    }\n    \n    func entriesNearby(location: CLLocation, radius: CLLocationDistance) async throws -> [JournalEntry] {\n        let context = container.viewContext\n        \n        return try await context.perform {\n            let request = JournalEntry.fetchRequest()\n            \n            // Create a predicate for nearby locations\n            let earthRadius: Double = 6371 // kilometers\n            let lat = location.coordinate.latitude\n            let lon = location.coordinate.longitude\n            \n            // Approximate bounding box for performance\n            let latDelta = radius / 111.0 // 1 degree â‰ˆ 111 km\n            let lonDelta = radius / (111.0 * cos(lat * .pi / 180))\n            \n            let minLat = lat - latDelta\n            let maxLat = lat + latDelta\n            let minLon = lon - lonDelta\n            let maxLon = lon + lonDelta\n            \n            request.predicate = NSPredicate(\n                format: \"latitude BETWEEN {%@, %@} AND longitude BETWEEN {%@, %@}\",\n                minLat, maxLat, minLon, maxLon\n            )\n            \n            return try context.fetch(request)\n        }\n    }\n    \n    func entriesWithPhotos() async throws -> [JournalEntry] {\n        let context = container.viewContext\n        \n        return try await context.perform {\n            let request = JournalEntry.fetchRequest()\n            request.predicate = NSPredicate(format: \"photos.@count > 0\")\n            request.sortDescriptors = [\n                NSSortDescriptor(keyPath: \\JournalEntry.createdAt, ascending: false)\n            ]\n            \n            return try context.fetch(request)\n        }\n    }\n}\n```\n\n## 6. Performance Optimization & Testing (45 min)\n\n### Memory Management & Performance:\n\n#### Image Caching System:\n```swift\nclass ImageCache {\n    static let shared = ImageCache()\n    \n    private let memoryCache = NSCache<NSString, UIImage>()\n    private let fileManager = FileManager.default\n    private let cacheDirectory: URL\n    \n    private init() {\n        memoryCache.countLimit = 100 // Max 100 images in memory\n        \n        guard let cacheDir = fileManager.urls(for: .cachesDirectory, in: .userDomainMask).first else {\n            fatalError(\"Unable to access cache directory\")\n        }\n        \n        cacheDirectory = cacheDir.appendingPathComponent(\"ImageCache\")\n        \n        try? fileManager.createDirectory(at: cacheDirectory, withIntermediateDirectories: true)\n    }\n    \n    func image(for key: String) -> UIImage? {\n        // Check memory cache first\n        if let image = memoryCache.object(forKey: key as NSString) {\n            return image\n        }\n        \n        // Check disk cache\n        let fileURL = cacheDirectory.appendingPathComponent(key)\n        guard let data = try? Data(contentsOf: fileURL),\n              let image = UIImage(data: data) else {\n            return nil\n        }\n        \n        // Store in memory cache for future use\n        memoryCache.setObject(image, forKey: key as NSString)\n        return image\n    }\n    \n    func setImage(_ image: UIImage, for key: String) {\n        // Store in memory cache\n        memoryCache.setObject(image, forKey: key as NSString)\n        \n        // Store in disk cache asynchronously\n        DispatchQueue.global(qos: .background).async {\n            let fileURL = self.cacheDirectory.appendingPathComponent(key)\n            if let data = image.jpegData(compressionQuality: 0.8) {\n                try? data.write(to: fileURL)\n            }\n        }\n    }\n}\n```\n\n#### Background Processing:\n```swift\nclass BackgroundProcessingService {\n    private let backgroundQueue = DispatchQueue(\n        label: \"com.traveljournal.background\",\n        qos: .background\n    )\n    \n    func processNewPhotos(_ photos: [UIImage], for entry: JournalEntry) {\n        backgroundQueue.async { [weak self] in\n            let processor = ImageProcessor()\n            \n            for (index, photo) in photos.enumerated() {\n                // Generate thumbnail\n                if let thumbnail = processor.generateThumbnail(photo, targetSize: CGSize(width: 200, height: 200)) {\n                    // Extract metadata\n                    let metadataService = PhotoMetadataService()\n                    \n                    Task {\n                        if let metadata = try? await metadataService.extractMetadata(from: photo) {\n                            await self?.savePhoto(\n                                image: photo,\n                                thumbnail: thumbnail,\n                                metadata: metadata,\n                                entry: entry,\n                                index: index\n                            )\n                        }\n                    }\n                }\n            }\n        }\n    }\n    \n    @MainActor\n    private func savePhoto(image: UIImage, thumbnail: UIImage, metadata: PhotoMetadata, entry: JournalEntry, index: Int) {\n        // Save to Core Data on main thread\n        let context = PersistenceController.shared.container.viewContext\n        \n        let journalPhoto = JournalPhoto(context: context)\n        journalPhoto.id = UUID()\n        journalPhoto.imageData = image.jpegData(compressionQuality: 0.8)!\n        journalPhoto.thumbnailData = thumbnail.jpegData(compressionQuality: 0.9)!\n        journalPhoto.createdAt = Date()\n        journalPhoto.orderIndex = Int32(index)\n        journalPhoto.cameraModel = metadata.cameraModel\n        journalPhoto.entry = entry\n        \n        try? context.save()\n    }\n}\n```\n\n## Real-World Implementation Patterns\n\n### Dependency Injection:\n```swift\nprotocol LocationServiceProtocol {\n    var currentLocation: CLLocation? { get }\n    func startTracking()\n    func stopTracking()\n}\n\nprotocol PhotoServiceProtocol {\n    func pickPhotos(limit: Int) async -> [UIImage]\n    func extractMetadata(from image: UIImage) async -> PhotoMetadata?\n}\n\nclass TravelJournalViewModel: ObservableObject {\n    private let locationService: LocationServiceProtocol\n    private let photoService: PhotoServiceProtocol\n    private let dataService: JournalDataService\n    \n    init(\n        locationService: LocationServiceProtocol,\n        photoService: PhotoServiceProtocol,\n        dataService: JournalDataService\n    ) {\n        self.locationService = locationService\n        self.photoService = photoService\n        self.dataService = dataService\n    }\n}\n```\n\n### Error Handling & User Feedback:\n```swift\nenum JournalError: LocalizedError {\n    case locationPermissionDenied\n    case photoAccessDenied\n    case storageFull\n    case networkUnavailable\n    \n    var errorDescription: String? {\n        switch self {\n        case .locationPermissionDenied:\n            return \"Location access is required for travel tracking\"\n        case .photoAccessDenied:\n            return \"Photo library access is required to add photos\"\n        case .storageFull:\n            return \"Device storage is full. Please free up space.\"\n        case .networkUnavailable:\n            return \"Network unavailable. Some features may be limited.\"\n        }\n    }\n}\n```",
      "codeExample": "import SwiftUI\nimport MapKit\nimport CoreLocation\nimport PhotosUI\nimport CoreData\n\n// MARK: - Main App Structure\n@main\nstruct TravelJournalApp: App {\n    var body: some Scene {\n        WindowGroup {\n            ContentView()\n                .environment(\\.managedObjectContext, PersistenceController.shared.container.viewContext)\n        }\n    }\n}\n\n// MARK: - Core Data Persistence\nstruct PersistenceController {\n    static let shared = PersistenceController()\n    \n    let container: NSPersistentContainer\n    \n    init(inMemory: Bool = false) {\n        container = NSPersistentContainer(name: \"TravelJournal\")\n        \n        if inMemory {\n            container.persistentStoreDescriptions.first?.url = URL(fileURLWithPath: \"/dev/null\")\n        }\n        \n        container.loadPersistentStores { description, error in\n            if let error = error {\n                fatalError(\"Error: \\(error.localizedDescription)\")\n            }\n        }\n    }\n}\n\n// MARK: - Location Service\nclass LocationService: NSObject, ObservableObject, CLLocationManagerDelegate {\n    private let locationManager = CLLocationManager()\n    \n    @Published var authorizationStatus: CLAuthorizationStatus\n    @Published var currentLocation: CLLocation?\n    @Published var visitedLocations: [VisitedLocation] = []\n    \n    override init() {\n        authorizationStatus = locationManager.authorizationStatus\n        super.init()\n        \n        locationManager.delegate = self\n        locationManager.desiredAccuracy = kCLLocationAccuracyBest\n        locationManager.distanceFilter = 10\n        locationManager.allowsBackgroundLocationUpdates = true\n    }\n    \n    func requestPermission() {\n        locationManager.requestWhenInUseAuthorization()\n        locationManager.requestAlwaysAuthorization()\n    }\n    \n    func startTracking() {\n        locationManager.startUpdatingLocation()\n        locationManager.startMonitoringSignificantLocationChanges()\n    }\n    \n    func stopTracking() {\n        locationManager.stopUpdatingLocation()\n        locationManager.stopMonitoringSignificantLocationChanges()\n    }\n    \n    func locationManager(_ manager: CLLocationManager, didUpdateLocations locations: [CLLocation]) {\n        guard let location = locations.last else { return }\n        currentLocation = location\n        \n        if isSignificantLocation(location) {\n            addVisitedLocation(location)\n        }\n    }\n    \n    func locationManagerDidChangeAuthorization(_ manager: CLLocationManager) {\n        authorizationStatus = manager.authorizationStatus\n    }\n    \n    private func isSignificantLocation(_ location: CLLocation) -> Bool {\n        guard let lastLocation = visitedLocations.last?.location else { return true }\n        return location.distance(from: lastLocation) > 500\n    }\n    \n    private func addVisitedLocation(_ location: CLLocation) {\n        let visitedLocation = VisitedLocation(location: location, timestamp: Date())\n        visitedLocations.append(visitedLocation)\n    }\n}\n\nstruct VisitedLocation {\n    let location: CLLocation\n    let timestamp: Date\n}\n\n// MARK: - Photo Service\nclass PhotoService: ObservableObject {\n    @Published var selectedImages: [UIImage] = []\n    \n    func pickPhotos(limit: Int = 10) async -> [UIImage] {\n        await withCheckedContinuation { continuation in\n            // Photo picking implementation would go here\n            // This is a simplified version\n            continuation.resume(returning: [])\n        }\n    }\n}\n\n// MARK: - Main Content View\nstruct ContentView: View {\n    @StateObject private var locationService = LocationService()\n    @StateObject private var photoService = PhotoService()\n    @State private var selectedTab = 0\n    \n    var body: some View {\n        TabView(selection: $selectedTab) {\n            MapView()\n                .tabItem {\n                    Image(systemName: \"map\")\n                    Text(\"Map\")\n                }\n                .tag(0)\n            \n            JournalListView()\n                .tabItem {\n                    Image(systemName: \"book\")\n                    Text(\"Journal\")\n                }\n                .tag(1)\n            \n            CameraView()\n                .tabItem {\n                    Image(systemName: \"camera\")\n                    Text(\"Camera\")\n                }\n                .tag(2)\n        }\n        .environmentObject(locationService)\n        .environmentObject(photoService)\n    }\n}\n\n// MARK: - Map View\nstruct MapView: View {\n    @EnvironmentObject var locationService: LocationService\n    @State private var region = MKCoordinateRegion(\n        center: CLLocationCoordinate2D(latitude: 37.7749, longitude: -122.4194),\n        span: MKCoordinateSpan(latitudeDelta: 0.1, longitudeDelta: 0.1)\n    )\n    \n    var body: some View {\n        ZStack {\n            Map(coordinateRegion: $region, showsUserLocation: true)\n                .ignoresSafeArea()\n            \n            VStack {\n                Spacer()\n                \n                HStack {\n                    Spacer()\n                    \n                    VStack(spacing: 16) {\n                        // Location tracking toggle\n                        Button(action: toggleTracking) {\n                            Image(systemName: locationService.authorizationStatus == .authorizedAlways ? \n                                  \"location.fill\" : \"location\")\n                                .font(.title2)\n                                .foregroundColor(.white)\n                                .padding()\n                                .background(Color.blue)\n                                .clipShape(Circle())\n                        }\n                        \n                        // Add journal entry button\n                        Button(action: addJournalEntry) {\n                            Image(systemName: \"plus\")\n                                .font(.title2)\n                                .foregroundColor(.white)\n                                .padding()\n                                .background(Color.green)\n                                .clipShape(Circle())\n                        }\n                    }\n                    .padding()\n                }\n            }\n        }\n        .onAppear {\n            locationService.requestPermission()\n        }\n    }\n    \n    private func toggleTracking() {\n        if locationService.authorizationStatus == .authorizedAlways {\n            locationService.stopTracking()\n        } else {\n            locationService.startTracking()\n        }\n    }\n    \n    private func addJournalEntry() {\n        // Implementation for adding journal entry\n    }\n}\n\n// MARK: - Journal List View\nstruct JournalListView: View {\n    @Environment(\\.managedObjectContext) private var viewContext\n    \n    @FetchRequest(\n        sortDescriptors: [NSSortDescriptor(keyPath: \\JournalEntry.createdAt, ascending: false)],\n        animation: .default)\n    private var entries: FetchedResults<JournalEntry>\n    \n    var body: some View {\n        NavigationView {\n            List {\n                ForEach(entries) { entry in\n                    NavigationLink(destination: JournalEntryView(entry: entry)) {\n                        JournalEntryRow(entry: entry)\n                    }\n                }\n                .onDelete(perform: deleteEntries)\n            }\n            .navigationTitle(\"Travel Journal\")\n            .toolbar {\n                ToolbarItem(placement: .navigationBarTrailing) {\n                    EditButton()\n                }\n                ToolbarItem {\n                    Button(action: addEntry) {\n                        Label(\"Add Entry\", systemImage: \"plus\")\n                    }\n                }\n            }\n        }\n    }\n    \n    private func addEntry() {\n        withAnimation {\n            let newEntry = JournalEntry(context: viewContext)\n            newEntry.id = UUID()\n            newEntry.title = \"New Entry\"\n            newEntry.content = \"\"\n            newEntry.createdAt = Date()\n            newEntry.updatedAt = Date()\n            \n            do {\n                try viewContext.save()\n            } catch {\n                // Handle error\n                let nsError = error as NSError\n                fatalError(\"Unresolved error \\(nsError), \\(nsError.userInfo)\")\n            }\n        }\n    }\n    \n    private func deleteEntries(offsets: IndexSet) {\n        withAnimation {\n            offsets.map { entries[$0] }.forEach(viewContext.delete)\n            \n            do {\n                try viewContext.save()\n            } catch {\n                // Handle error\n                let nsError = error as NSError\n                fatalError(\"Unresolved error \\(nsError), \\(nsError.userInfo)\")\n            }\n        }\n    }\n}\n\nstruct JournalEntryRow: View {\n    let entry: JournalEntry\n    \n    var body: some View {\n        VStack(alignment: .leading, spacing: 8) {\n            Text(entry.title ?? \"Untitled\")\n                .font(.headline)\n            \n            Text(entry.content ?? \"\")\n                .font(.body)\n                .lineLimit(2)\n                .foregroundColor(.secondary)\n            \n            if let date = entry.createdAt {\n                Text(date, style: .date)\n                    .font(.caption)\n                    .foregroundColor(.secondary)\n            }\n        }\n        .padding(.vertical, 4)\n    }\n}\n\n// MARK: - Camera View\nstruct CameraView: View {\n    @EnvironmentObject var photoService: PhotoService\n    @State private var showingPhotoPicker = false\n    \n    var body: some View {\n        VStack(spacing: 20) {\n            if photoService.selectedImages.isEmpty {\n                VStack(spacing: 16) {\n                    Image(systemName: \"camera\")\n                        .font(.system(size: 64))\n                        .foregroundColor(.secondary)\n                    \n                    Text(\"No Photos Selected\")\n                        .font(.title2)\n                        .foregroundColor(.secondary)\n                }\n                .frame(maxWidth: .infinity, maxHeight: .infinity)\n            } else {\n                ScrollView(.horizontal) {\n                    LazyHStack(spacing: 16) {\n                        ForEach(0..<photoService.selectedImages.count, id: \\.self) { index in\n                            Image(uiImage: photoService.selectedImages[index])\n                                .resizable()\n                                .scaledToFill()\n                                .frame(width: 200, height: 200)\n                                .clipShape(RoundedRectangle(cornerRadius: 12))\n                        }\n                    }\n                    .padding()\n                }\n            }\n            \n            Button(\"Select Photos\") {\n                showingPhotoPicker = true\n            }\n            .buttonStyle(.borderedProminent)\n            .sheet(isPresented: $showingPhotoPicker) {\n                // Photo picker implementation\n            }\n        }\n        .padding()\n        .navigationTitle(\"Camera\")\n    }\n}\n\n// MARK: - Journal Entry Detail View\nstruct JournalEntryView: View {\n    let entry: JournalEntry\n    \n    var body: some View {\n        ScrollView {\n            VStack(alignment: .leading, spacing: 16) {\n                Text(entry.title ?? \"Untitled\")\n                    .font(.largeTitle)\n                    .fontWeight(.bold)\n                \n                if let date = entry.createdAt {\n                    Text(date, style: .date)\n                        .font(.subheadline)\n                        .foregroundColor(.secondary)\n                }\n                \n                Text(entry.content ?? \"\")\n                    .font(.body)\n                    .lineSpacing(6)\n                \n                // Photos would be displayed here\n                \n                // Location map would be displayed here\n            }\n            .padding()\n        }\n        .navigationBarTitleDisplayMode(.inline)\n    }\n}\n\n// MARK: - Preview\n#Preview {\n    ContentView()\n        .environment(\\.managedObjectContext, PersistenceController.preview.container.viewContext)\n}\n\nextension PersistenceController {\n    static var preview: PersistenceController = {\n        let result = PersistenceController(inMemory: true)\n        let viewContext = result.container.viewContext\n        \n        // Create sample data\n        for i in 0..<5 {\n            let newEntry = JournalEntry(context: viewContext)\n            newEntry.id = UUID()\n            newEntry.title = \"Sample Entry \\(i + 1)\"\n            newEntry.content = \"This is a sample journal entry for preview purposes.\"\n            newEntry.createdAt = Date()\n            newEntry.updatedAt = Date()\n        }\n        \n        do {\n            try viewContext.save()\n        } catch {\n            let nsError = error as NSError\n            fatalError(\"Unresolved error \\(nsError), \\(nsError.userInfo)\")\n        }\n        return result\n    }()\n}",
      "category": "iOS Development",
      "estimatedTime": 300,
      "dependencies": ["swiftui_fundamentals", "core_data_basics", "mapkit_introduction"],
      "challenge": {
        "instructions": "Build a comprehensive travel journal app with the following advanced features:\n\nPART 1: Core Infrastructure (60 min)\n1. Set up Core Data model with JournalEntry, JournalPhoto, and Trip entities\n2. Implement CloudKit synchronization for cross-device data sync\n3. Create location service with background tracking and geofencing\n4. Build photo service with EXIF metadata extraction\n\nPART 2: Advanced Location Features (90 min)\n5. Implement significant location change monitoring\n6. Create geofencing for automatic journal entry creation\n7. Build route tracking with polyline drawing on maps\n8. Add location-based reminders and notifications\n\nPART 3: Rich Media Management (90 min)\n9. Implement advanced photo picker with multiple selection\n10. Create image processing pipeline with compression and thumbnails\n11. Build EXIF metadata extraction and display\n12. Add photo organization by location and date\n\nPART 4: Map Integration & UI (90 min)\n13. Create interactive map with custom annotations\n14. Implement cluster annotations for performance with many locations\n15. Build trip visualization with routes and timelines\n16. Add search and filtering for locations and entries\n\nPART 5: Performance & Polish (90 min)\n17. Implement image caching system for memory management\n18. Add background processing for photo metadata extraction\n19. Create offline support with sync conflict resolution\n20. Add comprehensive error handling and user feedback\n\nPART 6: Advanced Features (60 min)\n21. Implement machine learning for photo categorization\n22. Add social sharing and export capabilities\n23. Create statistics and insights dashboard\n24. Build widget and watchOS companion app",
        "starterCode": "import SwiftUI\nimport CoreData\nimport MapKit\nimport CoreLocation\n\n// Starter code structure - implement all the advanced features below\n\nclass TravelJournalViewModel: ObservableObject {\n    // Implement your view model here\n}\n\nstruct TravelJournalApp: App {\n    var body: some Scene {\n        WindowGroup {\n            ContentView()\n        }\n    }\n}\n\n// Implement all the advanced features described in the challenge",
        "solution": "// Comprehensive solution would be implemented here following the challenge requirements\n// This would include all the advanced features: Core Data with CloudKit, background location tracking,\n// advanced photo management, interactive maps, performance optimizations, etc.",
        "hints": [
          "Use NSManagedObjectContext for Core Data operations on the main thread",
          "Implement background tasks for photo processing to avoid UI blocking",
          "Use CLLocationManager's significant location change monitoring for battery efficiency",
          "Cache map tiles and images to improve performance",
          "Use async/await for network operations and file I/O",
          "Implement proper error handling for location and photo permissions",
          "Use SwiftUI's @EnvironmentObject for dependency injection",
          "Consider using Combine publishers for reactive updates"
        ],
        "testCases": [
          {
            "input": "locationService.authorizationStatus == .authorizedAlways",
            "expectedOutput": "true",
            "description": "Location services should be authorized for background tracking"
          },
          {
            "input": "journalEntries.count > 0",
            "expectedOutput": "true",
            "description": "Should have at least one journal entry created"
          },
          {
            "input": "photosWithMetadata.count == selectedPhotos.count",
            "expectedOutput": "true",
            "description": "All selected photos should have metadata extracted"
          }
        ]
      }
    },
    {
      "id": "advanced_memory_management",
      "title": "Advanced Memory Management",
      "description": "Master Swift memory management, ARC, retain cycles, and performance optimization using Instruments",
      "difficulty": "advanced",
      "theory": "# Advanced Memory Management in Swift\n\n## 1. Understanding ARC - Automatic Reference Counting (60 min)\n\n### How ARC Works:\nARC automatically manages memory by counting references to objects.\n\n**Reference Counting Basics:**\n```swift\nclass Person {\n    let name: String\n    init(name: String) {\n        self.name = name\n        print(\"\\(name) is being initialized\")\n    }\n    deinit {\n        print(\"\\(name) is being deinitialized\")\n    }\n}\n\nvar person1: Person? = Person(name: \"Alice\")  // RC: 1\nvar person2: Person? = person1                // RC: 2\nperson1 = nil                                 // RC: 1\nperson2 = nil                                 // RC: 0 -> deinit\n```\n\n### Strong Reference Cycles:\n```swift\nclass Person {\n    let name: String\n    var apartment: Apartment?\n    init(name: String) { self.name = name }\n    deinit { print(\"\\(name) is being deinitialized\") }\n}\n\nclass Apartment {\n    let unit: String\n    var tenant: Person?\n    init(unit: String) { self.unit = unit }\n    deinit { print(\"Apartment \\(unit) is being deinitialized\") }\n}\n\nvar john: Person? = Person(name: \"John\")\nvar unit4A: Apartment? = Apartment(unit: \"4A\")\n\njohn!.apartment = unit4A\nunit4A!.tenant = john  // STRONG REFERENCE CYCLE!\n\njohn = nil      // NOT deallocated\nunit4A = nil    // NOT deallocated\n```\n\n## 2. Breaking Retain Cycles (90 min)\n\n### Weak References:\n```swift\nclass Person {\n    let name: String\n    weak var apartment: Apartment?  // WEAK reference\n    init(name: String) { self.name = name }\n}\n\nclass Apartment {\n    let unit: String\n    var tenant: Person?\n    init(unit: String) { self.unit = unit }\n}\n\nvar john: Person? = Person(name: \"John\")\nvar unit4A: Apartment? = Apartment(unit: \"4A\")\n\njohn!.apartment = unit4A  // Weak reference\nunit4A!.tenant = john     // Strong reference\n\njohn = nil      // Person deallocated (RC: 0)\n// unit4A.tenant becomes nil automatically\n```\n\n### Unowned References:\n```swift\nclass Customer {\n    let name: String\n    var card: CreditCard?\n    init(name: String) { self.name = name }\n    deinit { print(\"\\(name) is being deinitialized\") }\n}\n\nclass CreditCard {\n    let number: UInt64\n    unowned let customer: Customer  // UNOWNED reference\n    init(number: UInt64, customer: Customer) {\n        self.number = number\n        self.customer = customer\n    }\n    deinit { print(\"Card #\\(number) is being deinitialized\") }\n}\n\nvar john: Customer? = Customer(name: \"John Appleseed\")\njohn!.card = CreditCard(number: 1234_5678_9012_3456, customer: john!)\njohn = nil  // Both deallocated\n```\n\n### Weak vs Unowned:\n- **Weak**: Can become nil, always optional\n- **Unowned**: Never nil, non-optional, but dangerous if referenced after deallocation\n\n## 3. Closure Retain Cycles (60 min)\n\n### Closure Capture Lists:\n```swift\nclass HTMLElement {\n    let name: String\n    let text: String?\n    \n    lazy var asHTML: () -> String = {\n        [weak self] in  // CAPTURE LIST\n        guard let self = self else { return \"\" }\n        if let text = self.text {\n            return \"<\\(self.name)>\\(text)</\\(self.name)>\"\n        } else {\n            return \"<\\(self.name) />\"\n        }\n    }\n    \n    init(name: String, text: String? = nil) {\n        self.name = name\n        self.text = text\n    }\n    \n    deinit {\n        print(\"\\(name) is being deinitialized\")\n    }\n}\n\nvar paragraph: HTMLElement? = HTMLElement(name: \"p\", text: \"hello\")\nprint(paragraph!.asHTML())  // <p>hello</p>\nparagraph = nil  // Properly deallocated\n```\n\n### Multiple Capture Scenarios:\n```swift\nclass NetworkManager {\n    var onComplete: (() -> Void)?\n    \n    func fetchData(completion: @escaping () -> Void) {\n        self.onComplete = completion\n        \n        // PROBLEM: Strong reference cycle\n        DispatchQueue.main.asyncAfter(deadline: .now() + 2) {\n            completion()\n        }\n    }\n    \n    // SOLUTION: Weak self in capture list\n    func fetchDataSafely(completion: @escaping () -> Void) {\n        self.onComplete = completion\n        \n        DispatchQueue.main.asyncAfter(deadline: .now() + 2) {\n            [weak self] in\n            completion()\n            self?.onComplete = nil  // Break the cycle\n        }\n    }\n}\n```\n\n## 4. Advanced Memory Patterns (90 min)\n\n### Reference Cycles with Dispatch Queues:\n```swift\nclass DataProcessor {\n    private let queue = DispatchQueue(label: \"com.app.dataprocessor\")\n    private var cache: [String: Any] = [:]\n    \n    // PROBLEMATIC: Strong self reference\n    func processData(_ data: Data) {\n        queue.async {\n            // This creates strong reference to self\n            self.cache[\"processed\"] = data  // CAPTURES SELF STRONGLY\n            print(\"Data processed\")\n        }\n    }\n    \n    // SOLUTION: Weak self\n    func processDataSafely(_ data: Data) {\n        queue.async { [weak self] in\n            guard let self = self else { return }\n            self.cache[\"processed\"] = data\n            print(\"Data processed safely\")\n        }\n    }\n    \n    // ALTERNATIVE: Unowned self (if sure self exists)\n    func processDataUnowned(_ data: Data) {\n        queue.async { [unowned self] in\n            self.cache[\"processed\"] = data\n            print(\"Data processed with unowned\")\n        }\n    }\n}\n```\n\n### Cycles with NotificationCenter:\n```swift\nclass GameController {\n    private var observers: [NSObjectProtocol] = []\n    \n    func startObserving() {\n        // PROBLEM: Strong self in closure\n        let observer = NotificationCenter.default.addObserver(\n            forName: .gameDidUpdate,\n            object: nil,\n            queue: .main\n        ) { notification in\n            self.handleGameUpdate(notification)  // STRONG CAPTURE\n        }\n        observers.append(observer)\n    }\n    \n    // SOLUTION: Weak capture\n    func startObservingSafely() {\n        let observer = NotificationCenter.default.addObserver(\n            forName: .gameDidUpdate,\n            object: nil,\n            queue: .main\n        ) { [weak self] notification in\n            self?.handleGameUpdate(notification)\n        }\n        observers.append(observer)\n    }\n    \n    func cleanup() {\n        observers.forEach { NotificationCenter.default.removeObserver($0) }\n        observers.removeAll()\n    }\n    \n    deinit {\n        cleanup()\n    }\n}\n```\n\n## 5. Instruments for Memory Analysis (120 min)\n\n### Using Xcode Memory Debugger:\n\n#### Allocations Instrument:\n1. **Setup**: Product > Profile > Allocations\n2. **Analysis**: Look for persistent objects, memory growth\n3. **Mark Generation**: Track memory between operations\n\n#### Leaks Instrument:\n1. **Setup**: Product > Profile > Leaks\n2. **Detection**: Automatic leak detection\n3. **Analysis**: View retain cycles and memory graphs\n\n### Memory Graph Debugger:\n```swift\n// Enable in scheme: Malloc Stack Logging\nclass MemoryLeakDetector {\n    static func dumpRetainCycles() {\n        #if DEBUG\n        let dump = malloc_create_zone_dump(nil, 0)\n        print(String(cString: dump!))\n        malloc_destroy_zone_dump(dump)\n        #endif\n    }\n}\n```\n\n### Practical Debugging Session:\n```swift\nclass MemoryInvestigation {\n    // 1. Enable Malloc Stack Logging\n    // 2. Run app, reproduce issue\n    // 3. Pause execution\n    // 4. Debug Memory Graph\n    // 5. Look for purple (!) indicators\n    \n    class ProblematicClass {\n        var closure: (() -> Void)?\n        \n        func setupClosure() {\n            closure = {\n                self.doSomething()  // STRONG CYCLE\n            }\n        }\n        \n        func setupSafeClosure() {\n            closure = { [weak self] in\n                self?.doSomething()  // SAFE\n            }\n        }\n    }\n}\n```\n\n## 6. Advanced Optimization Techniques (90 min)\n\n### Lazy Loading Patterns:\n```swift\nclass ResourceManager {\n    // Eager loading - memory allocated immediately\n    private let heavyResource = HeavyResource()\n    \n    // Lazy loading - memory allocated when needed\n    private lazy var lazyHeavyResource: HeavyResource = {\n        return HeavyResource()\n    }()\n    \n    // Lazy with capture list\n    private lazy var configuredResource: HeavyResource = {\n        [unowned self] in\n        let resource = HeavyResource()\n        resource.configure(with: self.configuration)\n        return resource\n    }()\n}\n```\n\n### Memory Efficient Collections:\n```swift\nclass MemoryEfficientGame {\n    // PROBLEM: Large arrays copying\n    var gameStates: [[GamePiece]] = []\n    \n    // SOLUTION: Use references or COW (Copy-on-Write)\n    class GameState {\n        var pieces: [GamePiece]\n        init(pieces: [GamePiece]) { self.pieces = pieces }\n    }\n    \n    var efficientStates: [GameState] = []\n    \n    // ULTRA-EFFICIENT: Unsafe pointers for performance\n    func processPiecesEfficiently(_ pieces: [GamePiece]) {\n        pieces.withUnsafeBufferPointer { buffer in\n            // Direct memory access\n            for i in 0..<buffer.count {\n                processPiece(buffer[i])\n            }\n        }\n    }\n}\n```\n\n### Autorelease Pool Optimization:\n```swift\nclass ImageProcessor {\n    func processMultipleImages(_ images: [UIImage]) {\n        // Without autoreleasepool - memory spikes\n        for image in images {\n            let processed = processImage(image)  // Temporary objects accumulate\n        }\n        \n        // With autoreleasepool - controlled memory\n        for image in images {\n            autoreleasepool {\n                let processed = processImage(image)  // Released each iteration\n                saveImage(processed)\n            }\n        }\n    }\n    \n    func processLargeDataset(_ data: [Data]) {\n        // Manual memory management for large operations\n        data.withUnsafeBytes { rawBuffer in\n            let pointer = rawBuffer.bindMemory(to: UInt8.self)\n            // Process directly in memory\n        }\n    }\n}\n```\n\n## 7. Real-World Case Studies (60 min)\n\n### Case Study 1: View Controller Memory Management\n```swift\nclass GameViewController: UIViewController {\n    private var gameEngine: GameEngine?\n    private var displayLink: CADisplayLink?\n    \n    // COMMON MISTAKES:\n    override func viewDidLoad() {\n        super.viewDidLoad()\n        \n        // 1. Strong reference in closure\n        gameEngine?.onUpdate = { [weak self] in\n            self?.updateUI()\n        }\n        \n        // 2. Display link retain cycle\n        displayLink = CADisplayLink(target: self, selector: #selector(gameLoop))\n        displayLink?.add(to: .main, forMode: .common)\n    }\n    \n    // SOLUTIONS:\n    deinit {\n        displayLink?.invalidate()  // BREAK CYCLE\n    }\n    \n    func setupSafeGameEngine() {\n        gameEngine = GameEngine()\n        gameEngine?.onUpdate = { [weak self] in\n            DispatchQueue.main.async {\n                self?.updateUI()\n            }\n        }\n    }\n}\n```\n\n### Case Study 2: Singleton Dependencies\n```swift\nclass AnalyticsManager {\n    static let shared = AnalyticsManager()\n    \n    private var trackedEvents: [String: Any] = [:]\n    \n    // PROBLEM: Singleton creating retain cycles\n    func trackEvent(_ event: String, for user: User) {\n        user.analyticsHandler = { [weak self] data in\n            self?.trackedEvents[event] = data  // SAFE\n        }\n    }\n}\n\nclass User {\n    var analyticsHandler: ((Any) -> Void)?\n    \n    // BETTER: Explicit dependency management\n    weak var analyticsManager: AnalyticsManager?\n}\n```\n\n## Practice Exercises\n\nComplete all exercises to master advanced memory management!",
      "codeExample": "import Foundation\nimport UIKit\n\n// === ADVANCED MEMORY MANAGEMENT EXAMPLES ===\n\n// 1. Complex Retain Cycle Scenario\nclass SocialNetwork {\n    class User {\n        let name: String\n        var friends: [User] = []\n        var posts: [Post] = []\n        \n        init(name: String) {\n            self.name = name\n            print(\"User \\(name) initialized\")\n        }\n        \n        deinit {\n            print(\"User \\(name) deinitialized\")\n        }\n        \n        // POTENTIAL CYCLE: User -> Posts -> Author (User)\n        func createPost(content: String) -> Post {\n            let post = Post(content: content, author: self)\n            posts.append(post)\n            return post\n        }\n    }\n    \n    class Post {\n        let content: String\n        let author: User\n        var likes: [User] = []\n        \n        init(content: String, author: User) {\n            self.content = content\n            self.author = author\n            print(\"Post created by \\(author.name)\")\n        }\n        \n        deinit {\n            print(\"Post by \\(author.name) deinitialized\")\n        }\n        \n        // SAFE: Weak reference for likes\n        func addLike(from user: User) {\n            likes.append(user)\n        }\n    }\n}\n\n// 2. Advanced Closure Capture Patterns\nclass AsyncOperationManager {\n    private var operations: [String: () -> Void] = [:]\n    private let queue = DispatchQueue(label: \"com.app.operations\")\n    \n    // UNSAFE: Strong self capture\n    func scheduleOperation(named name: String, delay: TimeInterval) {\n        operations[name] = {\n            print(\"Operation \\(name) executing\")\n            self.cleanupOperation(named: name)  // STRONG CAPTURE\n        }\n        \n        queue.asyncAfter(deadline: .now() + delay) {\n            self.operations[name]?()\n        }\n    }\n    \n    // SAFE: Weak capture with guard\n    func scheduleSafeOperation(named name: String, delay: TimeInterval) {\n        operations[name] = { [weak self] in\n            guard let self = self else { return }\n            print(\"Safe operation \\(name) executing\")\n            self.cleanupOperation(named: name)\n        }\n        \n        queue.asyncAfter(deadline: .now() + delay) { [weak self] in\n            self?.operations[name]?()\n        }\n    }\n    \n    // ULTRA-SAFE: Multiple weak captures\n    func scheduleComplexOperation(named name: String, \n                                  dependency: SomeDependency,\n                                  delay: TimeInterval) {\n        operations[name] = { [weak self, weak dependency] in\n            guard let self = self, let dependency = dependency else { return }\n            \n            self.processWithDependency(dependency)\n            self.cleanupOperation(named: name)\n        }\n    }\n    \n    private func cleanupOperation(named name: String) {\n        operations.removeValue(forKey: name)\n    }\n    \n    private func processWithDependency(_ dependency: SomeDependency) {\n        // Complex processing\n    }\n}\n\nclass SomeDependency {\n    func doWork() {}\n}\n\n// 3. Memory-Efficient Data Structures\nclass HighPerformanceCache {\n    private var cache: [String: CacheEntry] = [:]\n    private let cacheQueue = DispatchQueue(label: \"com.app.cache\", attributes: .concurrent)\n    \n    class CacheEntry {\n        let data: Data\n        let size: Int\n        let timestamp: Date\n        \n        init(data: Data) {\n            self.data = data\n            self.size = data.count\n            self.timestamp = Date()\n        }\n    }\n    \n    // Thread-safe with memory limits\n    func setData(_ data: Data, for key: String, maxCacheSize: Int = 100_000_000) {\n        cacheQueue.async(flags: .barrier) { [weak self] in\n            guard let self = self else { return }\n            \n            let newEntry = CacheEntry(data: data)\n            \n            // Check memory limits\n            if self.currentCacheSize() + newEntry.size > maxCacheSize {\n                self.evictOldEntries()\n            }\n            \n            self.cache[key] = newEntry\n        }\n    }\n    \n    func getData(for key: String) -> Data? {\n        var result: Data?\n        cacheQueue.sync {\n            result = self.cache[key]?.data\n        }\n        return result\n    }\n    \n    private func currentCacheSize() -> Int {\n        return cache.values.reduce(0) { $0 + $1.size }\n    }\n    \n    private func evictOldEntries() {\n        let sortedEntries = cache.sorted { $0.value.timestamp < $1.value.timestamp }\n        \n        for (key, _) in sortedEntries {\n            cache.removeValue(forKey: key)\n            if currentCacheSize() < 50_000_000 { // Keep 50MB minimum\n                break\n            }\n        }\n    }\n}\n\n// 4. Advanced Instrumentation Helpers\nclass MemoryAnalyzer {\n    #if DEBUG\n    \n    static func logMemoryUsage() {\n        var taskInfo = mach_task_basic_info()\n        var count = mach_msg_type_number_t(MemoryLayout<mach_task_basic_info>.size / MemoryLayout<natural_t>.size)\n        \n        let kerr: kern_return_t = withUnsafeMutablePointer(to: &taskInfo) {\n            $0.withMemoryRebound(to: integer_t.self, capacity: 1) {\n                task_info(mach_task_self_, task_flavor_t(MACH_TASK_BASIC_INFO), $0, &count)\n            }\n        }\n        \n        if kerr == KERN_SUCCESS {\n            print(\"Memory used: \\(taskInfo.resident_size / 1024 / 1024) MB\")\n        }\n    }\n    \n    static func measureMemory<Result>(for operation: () -> Result) -> Result {\n        let before = getMemoryUsage()\n        let result = operation()\n        let after = getMemoryUsage()\n        \n        print(\"Memory delta: \\(after - before) bytes\")\n        return result\n    }\n    \n    private static func getMemoryUsage() -> UInt64 {\n        var taskInfo = mach_task_basic_info()\n        var count = mach_msg_type_number_t(MemoryLayout<mach_task_basic_info>.size / MemoryLayout<natural_t>.size)\n        \n        let kerr = withUnsafeMutablePointer(to: &taskInfo) {\n            $0.withMemoryRebound(to: integer_t.self, capacity: 1) {\n                task_info(mach_task_self_, task_flavor_t(MACH_TASK_BASIC_INFO), $0, &count)\n            }\n        }\n        \n        return kerr == KERN_SUCCESS ? taskInfo.resident_size : 0\n    }\n    \n    #endif\n}\n\n// 5. Real-world Game Memory Management\nclass GameWorld {\n    class Entity {\n        let id: UUID\n        weak var world: GameWorld?  // Weak back-reference\n        var components: [Component] = []\n        \n        init(id: UUID = UUID(), world: GameWorld? = nil) {\n            self.id = id\n            self.world = world\n        }\n        \n        deinit {\n            print(\"Entity \\(id) deinitialized\")\n        }\n        \n        // Safe component management\n        func addComponent(_ component: Component) {\n            component.entity = self\n            components.append(component)\n        }\n    }\n    \n    class Component {\n        weak var entity: Entity?  // Weak reference to avoid cycles\n        \n        deinit {\n            print(\"Component deinitialized\")\n        }\n    }\n    \n    class PhysicsComponent: Component {\n        var velocity: (x: Double, y: Double) = (0, 0)\n        \n        // Safe reference to world through entity\n        var world: GameWorld? {\n            return entity?.world\n        }\n    }\n    \n    private var entities: [UUID: Entity] = [:]\n    \n    func createEntity() -> Entity {\n        let entity = Entity(world: self)\n        entities[entity.id] = entity\n        return entity\n    }\n    \n    func removeEntity(_ entity: Entity) {\n        entities.removeValue(forKey: entity.id)\n    }\n    \n    deinit {\n        print(\"GameWorld deinitialized\")\n    }\n}\n\n// Usage examples for memory testing\nclass MemoryManagementDemo {\n    func demonstrateRetainCycles() {\n        print(\"=== Demonstrating Retain Cycles ===\")\n        \n        // This will leak\n        class LeakyClass {\n            var closure: (() -> Void)?\n            \n            init() {\n                closure = {\n                    print(self)  // STRONG CAPTURE\n                }\n            }\n        }\n        \n        _ = LeakyClass()  // Will leak\n        \n        // This won't leak\n        class SafeClass {\n            var closure: (() -> Void)?\n            \n            init() {\n                closure = { [weak self] in\n                    print(self ?? \"deallocated\")  // WEAK CAPTURE\n                }\n            }\n        }\n        \n        _ = SafeClass()  // Won't leak\n    }\n    \n    func demonstrateMemoryEfficiency() {\n        print(\"=== Demonstrating Memory Efficiency ===\")\n        \n        MemoryAnalyzer.measureMemory {\n            let largeArray = Array(0..<1_000_000)\n            return largeArray.count\n        }\n    }\n}",
      "category": "Memory Management",
      "estimatedTime": 240,
      "dependencies": ["classes_structures", "optionals", "closures"],
      "challenge": {
        "instructions": "Build a comprehensive memory management system for a complex iOS application:\n\nPART 1: ARC Fundamentals & Retain Cycles (60 min)\n1. Create classes that demonstrate strong reference cycles\n2. Implement solutions using weak and unowned references\n3. Build a dependency injection system that avoids cycles\n\nPART 2: Closure Memory Management (60 min)\n4. Create closure-based APIs with proper capture lists\n5. Implement async operations with safe memory handling\n6. Build a callback system that prevents leaks\n\nPART 3: Advanced Debugging with Instruments (60 min)\n7. Use Xcode Memory Debugger to identify leaks\n8. Implement custom memory analysis tools\n9. Create memory stress tests and performance benchmarks\n\nPART 4: Real-World Application Patterns (60 min)\n10. Build a view controller hierarchy with safe memory\n11. Implement a networking layer with proper cleanup\n12. Create a cache system with memory limits and cleanup\n\nPART 5: Performance Optimization (60 min)\n13. Optimize memory usage in collection operations\n14. Implement efficient data structures\n15. Add memory monitoring and alerting systems",
        "starterCode": "import Foundation\nimport UIKit\n\n// === PART 1: ARC Fundamentals ===\n// Create classes with retain cycles and fix them\n\n\n// === PART 2: Closure Memory Management ===\n// Implement safe closure-based APIs\n\n\n// === PART 3: Instruments Debugging ===\n// Create memory analysis tools\n\n\n// === PART 4: Real-World Patterns ===\n// Build safe view controller and networking patterns\n\n\n// === PART 5: Performance Optimization ===\n// Implement memory-efficient systems\n\n",
        "solution": "import Foundation\nimport UIKit\n\n// === PART 1: ARC Fundamentals ===\nclass RetainCycleDemo {\n    class Node {\n        let value: Int\n        var next: Node?\n        var previous: Node?  // This creates retain cycle with next\n        \n        init(value: Int) {\n            self.value = value\n        }\n        \n        deinit {\n            print(\"Node \\(value) deinitialized\")\n        }\n    }\n    \n    class SafeNode {\n        let value: Int\n        var next: SafeNode?\n        weak var previous: SafeNode?  // Weak breaks the cycle\n        \n        init(value: Int) {\n            self.value = value\n        }\n        \n        deinit {\n            print(\"SafeNode \\(value) deinitialized\")\n        }\n    }\n    \n    static func demonstrateCycle() {\n        print(\"Creating retain cycle...\")\n        \n        var node1: Node? = Node(value: 1)\n        var node2: Node? = Node(value: 2)\n        \n        node1?.next = node2\n        node2?.previous = node1  // CYCLE: node1 -> node2 -> node1\n        \n        node1 = nil\n        node2 = nil  // Neither deallocates!\n    }\n    \n    static func demonstrateSafe() {\n        print(\"Creating safe nodes...\")\n        \n        var node1: SafeNode? = SafeNode(value: 1)\n        var node2: SafeNode? = SafeNode(value: 2)\n        \n        node1?.next = node2\n        node2?.previous = node1  // No cycle due to weak\n        \n        node1 = nil  // Deallocates\n        node2 = nil  // Deallocates\n    }\n}\n\n// === PART 2: Closure Memory Management ===\nclass SafeAsyncManager {\n    private var operations: [String: () -> Void] = [:]\n    private var completions: [String: (Result<Data, Error>) -> Void] = [:]\n    \n    func performAsyncOperation(\n        named name: String,\n        duration: TimeInterval,\n        completion: @escaping (Result<Data, Error>) -> Void\n    ) {\n        // Store completion safely\n        completions[name] = { [weak self] result in\n            completion(result)\n            self?.completions.removeValue(forKey: name)\n        }\n        \n        // Perform operation with weak captures\n        DispatchQueue.global().asyncAfter(deadline: .now() + duration) { [weak self] in\n            guard let self = self else { return }\n            \n            // Simulate work\n            let data = Data()\n            \n            // Call completion on main thread\n            DispatchQueue.main.async {\n                self.completions[name]?(.success(data))\n            }\n        }\n    }\n    \n    func cancelOperation(named name: String) {\n        completions.removeValue(forKey: name)\n    }\n}\n\n// === PART 3: Instruments Debugging ===\nclass MemoryAnalyzer {\n    #if DEBUG\n    \n    struct MemorySnapshot {\n        let timestamp: Date\n        let residentSize: UInt64\n        let description: String\n    }\n    \n    private static var snapshots: [MemorySnapshot] = []\n    \n    static func takeSnapshot(_ description: String) {\n        let usage = getMemoryUsage()\n        let snapshot = MemorySnapshot(\n            timestamp: Date(),\n            residentSize: usage,\n            description: description\n        )\n        snapshots.append(snapshot)\n        \n        print(\"Memory Snapshot '\\(description)': \\(usage / 1024 / 1024) MB\")\n    }\n    \n    static func compareSnapshots() {\n        guard snapshots.count >= 2 else { return }\n        \n        for i in 1..<snapshots.count {\n            let previous = snapshots[i-1]\n            let current = snapshots[i]\n            let delta = Int64(current.residentSize) - Int64(previous.residentSize)\n            \n            print(\"Memory change from '\\(previous.description)' to '\\(current.description)': \\(delta) bytes\")\n        }\n    }\n    \n    static func checkForLeaks() {\n        // This would integrate with Instruments in real implementation\n        print(\"Leak check completed\")\n    }\n    \n    private static func getMemoryUsage() -> UInt64 {\n        var taskInfo = mach_task_basic_info()\n        var count = mach_msg_type_number_t(MemoryLayout<mach_task_basic_info>.size / MemoryLayout<natural_t>.size)\n        \n        let kerr = withUnsafeMutablePointer(to: &taskInfo) {\n            $0.withMemoryRebound(to: integer_t.self, capacity: 1) {\n                task_info(mach_task_self_, task_flavor_t(MACH_TASK_BASIC_INFO), $0, &count)\n            }\n        }\n        \n        return kerr == KERN_SUCCESS ? taskInfo.resident_size : 0\n    }\n    \n    #endif\n}\n\n// === PART 4: Real-World Patterns ===\nclass SafeViewController: UIViewController {\n    private var dataLoader: DataLoader?\n    private var timer: Timer?\n    \n    override func viewDidLoad() {\n        super.viewDidLoad()\n        setupDataLoading()\n        setupTimer()\n    }\n    \n    private func setupDataLoading() {\n        dataLoader = DataLoader()\n        \n        // Safe: Weak self in completion\n        dataLoader?.loadData { [weak self] result in\n            guard let self = self else { return }\n            \n            switch result {\n            case .success(let data):\n                self.handleData(data)\n            case .failure(let error):\n                self.handleError(error)\n            }\n        }\n    }\n    \n    private func setupTimer() {\n        // Safe: Weak self with invalidate in deinit\n        timer = Timer.scheduledTimer(withTimeInterval: 1.0, repeats: true) { [weak self] _ in\n            self?.updateUI()\n        }\n    }\n    \n    deinit {\n        timer?.invalidate()  // Break potential cycles\n        dataLoader?.cancel()\n    }\n    \n    private func handleData(_ data: Data) { /* ... */ }\n    private func handleError(_ error: Error) { /* ... */ }\n    private func updateUI() { /* ... */ }\n}\n\nclass DataLoader {\n    private var task: URLSessionDataTask?\n    \n    func loadData(completion: @escaping (Result<Data, Error>) -> Void) {\n        let url = URL(string: \"https://api.example.com/data\")!\n        \n        task = URLSession.shared.dataTask(with: url) { data, _, error in\n            if let error = error {\n                completion(.failure(error))\n            } else if let data = data {\n                completion(.success(data))\n            }\n        }\n        task?.resume()\n    }\n    \n    func cancel() {\n        task?.cancel()\n    }\n}\n\n// === PART 5: Performance Optimization ===\nclass MemoryEfficientCache<Key: Hashable, Value> {\n    private var cache: [Key: CacheEntry<Value>] = [:]\n    private let maxSize: Int\n    private let cleanupQueue = DispatchQueue(label: \"com.app.cache.cleanup\")\n    \n    class CacheEntry<Value> {\n        let value: Value\n        let size: Int\n        let lastAccess: Date\n        \n        init(value: Value, size: Int) {\n            self.value = value\n            self.size = size\n            self.lastAccess = Date()\n        }\n    }\n    \n    init(maxSize: Int = 100_000_000) { // 100MB default\n        self.maxSize = maxSize\n    }\n    \n    func setValue(_ value: Value, for key: Key, size: Int) {\n        cleanupQueue.async(flags: .barrier) { [weak self] in\n            guard let self = self else { return }\n            \n            let newEntry = CacheEntry(value: value, size: size)\n            \n            // Check if we need to cleanup\n            if self.currentSize + size > self.maxSize {\n                self.cleanup()\n            }\n            \n            self.cache[key] = newEntry\n        }\n    }\n    \n    func getValue(for key: Key) -> Value? {\n        return cleanupQueue.sync {\n            if var entry = cache[key] {\n                // Update access time\n                entry = CacheEntry(value: entry.value, size: entry.size)\n                cache[key] = entry\n                return entry.value\n            }\n            return nil\n        }\n    }\n    \n    private var currentSize: Int {\n        return cache.values.reduce(0) { $0 + $1.size }\n    }\n    \n    private func cleanup() {\n        let sortedEntries = cache.sorted { $0.value.lastAccess < $1.value.lastAccess }\n        \n        var currentTotalSize = currentSize\n        for (key, entry) in sortedEntries {\n            if currentTotalSize <= maxSize / 2 { // Keep half the cache\n                break\n            }\n            cache.removeValue(forKey: key)\n            currentTotalSize -= entry.size\n        }\n    }\n}",
        "hints": [
          "PART 1: Use weak for optional back-references, unowned for non-optional",
          "PART 2: Always use [weak self] in async closures that capture self",
          "PART 3: Use Xcode's Memory Graph Debugger to visualize retain cycles",
          "PART 4: Remember to invalidate timers and cancel tasks in deinit",
          "PART 5: Use value types and Copy-on-Write for large data structures",
          "Enable Malloc Stack Logging in scheme for better debugging",
          "Use autoreleasepool in loops that create many temporary objects",
          "Consider using weak delegates instead of closure callbacks"
        ],
        "testCases": [
          {
            "input": "RetainCycleDemo.demonstrateSafe()",
            "expectedOutput": "SafeNode 1 deinitialized\nSafeNode 2 deinitialized",
            "description": "Safe nodes should deallocate properly"
          },
          {
            "input": "MemoryAnalyzer.snapshots.count",
            "expectedOutput": ">0",
            "description": "Should be able to take memory snapshots"
          },
          {
            "input": "cache.currentSize <= cache.maxSize",
            "expectedOutput": "true",
            "description": "Cache should respect memory limits"
          }
        ]
      }
    },
    {
      "id": "performance_optimization",
      "title": "Performance Optimization",
      "description": "Master advanced profiling techniques, identify bottlenecks, and optimize Swift applications for maximum performance",
      "difficulty": "advanced",
      "theory": "# Performance Optimization - Advanced Profiling & Bottleneck Resolution\n\n## 1. Performance Fundamentals & Measurement (60 min)\n\n### Understanding Performance Metrics:\n\n**Key Performance Indicators:**\n- **Frame Rate**: 60 FPS target (16.67ms per frame)\n- **Memory Usage**: Heap allocations, memory footprint\n- **CPU Utilization**: Main thread workload, background processing\n- **Battery Impact**: Energy consumption patterns\n- **Storage I/O**: Disk read/write operations\n- **Network Efficiency**: Request/response optimization\n\n**Performance Measurement Tools:**\n```swift\n// Manual timing measurement\nfunc measureExecutionTime<T>(_ operation: () -> T) -> (result: T, duration: CFTimeInterval) {\n    let startTime = CACurrentMediaTime()\n    let result = operation()\n    let endTime = CACurrentMediaTime()\n    return (result, endTime - startTime)\n}\n\n// Usage\nlet (data, duration) = measureExecutionTime {\n    return expensiveDataProcessing()\n}\nprint(\"Operation took \\(String(format: \"%.4f\", duration * 1000)) ms\")\n```\n\n### Performance Budgets:\n- **UI Rendering**: < 16ms per frame\n- **App Launch**: < 400ms cold start, < 200ms warm start\n- **Memory**: < 100MB baseline, watch for leaks\n- **Power**: Minimize CPU wakeups, batch operations\n\n## 2. Advanced Profiling Techniques (90 min)\n\n### Instruments Deep Dive:\n\n#### Time Profiler Mastery:\n```swift\n// Code patterns to identify with Time Profiler:\n\n// 1. Expensive loops\nfunc inefficientProcessing(items: [Data]) {\n    for item in items {\n        let processed = expensiveTransform(item) // Hot spot\n        saveToDatabase(processed)\n    }\n}\n\n// 2. Recursive overhead\nfunc recursiveCalculation(_ n: Int) -> Int {\n    guard n > 1 else { return 1 }\n    return recursiveCalculation(n - 1) + recursiveCalculation(n - 2) // Exponential growth\n}\n\n// 3. Unnecessary recalculations\nclass ViewController: UIViewController {\n    var displayedData: [String] = []\n    \n    override func viewDidAppear(_ animated: Bool) {\n        super.viewDidAppear(animated)\n        recalculateLayout() // Called too frequently\n        updateDisplayData() // Heavy operation\n    }\n}\n```\n\n#### Memory Profiler Patterns:\n```swift\n// Memory allocation anti-patterns:\n\n// 1. Retain cycles in closures\nclass DataManager {\n    var onUpdate: (() -> Void)?\n    \n    func setupHandler() {\n        onUpdate = { [weak self] in\n            guard let self = self else { return }\n            self.processData() // Strong reference if not weak\n            self.updateUI()\n        }\n    }\n}\n\n// 2. Unbounded cache growth\nclass ImageCache {\n    private var cache: [String: UIImage] = [:] // No size limits\n    private var accessTimes: [String: Date] = [:] // Additional memory overhead\n    \n    func cacheImage(_ image: UIImage, for key: String) {\n        cache[key] = image\n        accessTimes[key] = Date() // Growing indefinitely\n    }\n}\n\n// 3. Large intermediate objects\nfunc processLargeDataset(_ data: [Double]) -> [Double] {\n    let intermediate = data.map { $0 * 2 } // Temporary array\n        .filter { $0 > 0 } // Another temporary array\n        .sorted() // Yet another temporary array\n    \n    return intermediate.map { $0 * 3 } // Final temporary array\n}\n```\n\n### Custom Profiling Infrastructure:\n```swift\nimport os.signpost\n\nclass PerformanceTracker {\n    private let log = OSLog(\n        subsystem: \"com.yourapp.performance\",\n        category: .pointsOfInterest\n    )\n    \n    func track<Result>(_ name: StaticString, _ operation: () -> Result) -> Result {\n        let signpostID = OSSignpostID(log: log)\n        os_signpost(.begin, log: log, name: name, signpostID: signpostID)\n        defer { os_signpost(.end, log: log, name: name, signpostID: signpostID) }\n        \n        return operation()\n    }\n    \n    func trackAsync<T>(_ name: StaticString, _ operation: () async -> T) async -> T {\n        let signpostID = OSSignpostID(log: log)\n        os_signpost(.begin, log: log, name: name, signpostID: signpostID)\n        defer { os_signpost(.end, log: log, name: name, signpostID: signpostID) }\n        \n        return await operation()\n    }\n}\n\n// Usage in production code\nlet tracker = PerformanceTracker()\n\nfunc loadUserData() async -> UserData {\n    return await tracker.trackAsync(\"LoadUserData\") {\n        // Async data loading\n        let user = await fetchUser()\n        let profile = await fetchProfile()\n        return UserData(user: user, profile: profile)\n    }\n}\n```\n\n## 3. CPU Optimization Strategies (90 min)\n\n### Algorithmic Optimization:\n\n#### Time Complexity Reduction:\n```swift\n// O(nÂ²) â†’ O(n log n) optimization\nfunc findPairsNaive(_ numbers: [Int], target: Int) -> [(Int, Int)] {\n    var pairs: [(Int, Int)] = []\n    for i in 0..<numbers.count { // O(n)\n        for j in (i + 1)..<numbers.count { // O(n) â†’ O(nÂ²) total\n            if numbers[i] + numbers[j] == target {\n                pairs.append((numbers[i], numbers[j]))\n            }\n        }\n    }\n    return pairs\n}\n\nfunc findPairsOptimized(_ numbers: [Int], target: Int) -> [(Int, Int)] {\n    var pairs: [(Int, Int)] = []\n    let sorted = numbers.sorted() // O(n log n)\n    var left = 0\n    var right = sorted.count - 1\n    \n    while left < right { // O(n)\n        let sum = sorted[left] + sorted[right]\n        if sum == target {\n            pairs.append((sorted[left], sorted[right]))\n            left += 1\n            right -= 1\n        } else if sum < target {\n            left += 1\n        } else {\n            right -= 1\n        }\n    }\n    return pairs // O(n log n) total\n}\n```\n\n#### Efficient Data Processing:\n```swift\n// Lazy evaluation and batch processing\nclass DataProcessor {\n    private let data: [Double]\n    \n    init(data: [Double]) {\n        self.data = data\n    }\n    \n    // Eager evaluation (inefficient)\n    func processEagerly() -> [Double] {\n        return data.map { $0 * 2 } // Creates intermediate array\n            .filter { $0 > 10 } // Creates another intermediate array\n            .map { sqrt($0) } // Creates final array\n    }\n    \n    // Lazy evaluation (efficient)\n    func processLazily() -> [Double] {\n        return data.lazy\n            .map { $0 * 2 } // No intermediate array\n            .filter { $0 > 10 } // Still no intermediate array\n            .map { sqrt($0) } // Single result array\n    }\n    \n    // Batch processing for large datasets\n    func processInBatches(batchSize: Int = 1000) -> [Double] {\n        var results: [Double] = []\n        results.reserveCapacity(data.count) // Pre-allocate memory\n        \n        for batchStart in stride(from: 0, to: data.count, by: batchSize) {\n            let batchEnd = min(batchStart + batchSize, data.count)\n            let batch = Array(data[batchStart..<batchEnd])\n            \n            let processedBatch = batch.lazy\n                .map { $0 * 2 }\n                .filter { $0 > 10 }\n                .map { sqrt($0) }\n            \n            results.append(contentsOf: processedBatch)\n        }\n        \n        return results\n    }\n}\n```\n\n### Concurrency Optimization:\n```swift\n// Optimal thread utilization\nclass ConcurrentProcessor {\n    private let queue = DispatchQueue(\n        label: \"com.yourapp.processing\",\n        attributes: .concurrent\n    )\n    \n    // Over-parallelization (inefficient)\n    func processOverParallelized(_ items: [Data]) -> [ProcessedData] {\n        var results: [ProcessedData] = []\n        let group = DispatchGroup()\n        let lock = NSLock()\n        \n        for item in items { // Too many concurrent tasks\n            group.enter()\n            DispatchQueue.global().async {\n                let result = self.expensiveProcessing(item)\n                lock.lock()\n                results.append(result)\n                lock.unlock()\n                group.leave()\n            }\n        }\n        \n        group.wait()\n        return results\n    }\n    \n    // Optimal parallelization\n    func processOptimally(_ items: [Data]) -> [ProcessedData] {\n        let processorCount = ProcessInfo.processInfo.processorCount\n        let optimalChunkSize = max(1, items.count / processorCount)\n        \n        return Array(0..<processorCount).concurrentMap { index in\n            let chunkStart = index * optimalChunkSize\n            let chunkEnd = min(chunkStart + optimalChunkSize, items.count)\n            \n            guard chunkStart < items.count else { return [] }\n            let chunk = Array(items[chunkStart..<chunkEnd])\n            \n            return chunk.map { self.expensiveProcessing($0) }\n        }.flatMap { $0 }\n    }\n    \n    private func expensiveProcessing(_ data: Data) -> ProcessedData {\n        // Simulate expensive operation\n        Thread.sleep(forTimeInterval: 0.01)\n        return ProcessedData()\n    }\n}\n\n// Concurrent map extension\nextension Array {\n    func concurrentMap<T>(_ transform: @escaping (Element) -> T) -> [T] {\n        var results: [T] = []\n        let lock = NSLock()\n        \n        DispatchQueue.concurrentPerform(iterations: count) { index in\n            let result = transform(self[index])\n            lock.lock()\n            results.append(result)\n            lock.unlock()\n        }\n        \n        return results\n    }\n}\n```\n\n## 4. Memory Optimization Patterns (60 min)\n\n### Advanced Memory Management:\n\n#### Value Type Optimization:\n```swift\n// Struct vs Class memory characteristics\nstruct EfficientVector {\n    var x, y, z: Double\n    \n    // Value semantics, stack allocation for local use\n    func normalized() -> EfficientVector {\n        let length = sqrt(x * x + y * y + z * z)\n        return EfficientVector(x: x / length, y: y / length, z: z / length)\n    }\n}\n\nclass InefficientVector {\n    var x, y, z: Double\n    // Reference semantics, heap allocation, reference counting overhead\n    \n    init(x: Double, y: Double, z: Double) {\n        self.x = x\n        self.y = y\n        self.z = z\n    }\n}\n\n// Buffer optimization for large datasets\nclass LargeDataProcessor {\n    private var buffer: UnsafeMutableRawBufferPointer\n    private let capacity: Int\n    \n    init(capacity: Int) {\n        self.capacity = capacity\n        self.buffer = UnsafeMutableRawBufferPointer.allocate(\n            byteCount: capacity * MemoryLayout<Double>.size,\n            alignment: MemoryLayout<Double>.alignment\n        )\n    }\n    \n    deinit {\n        buffer.deallocate()\n    }\n    \n    func processData(_ data: [Double]) {\n        // Direct memory access without Array overhead\n        data.withUnsafeBytes { source in\n            buffer.copyMemory(from: source)\n        }\n        \n        // Process in-place\n        for i in 0..<data.count {\n            let value = buffer.load(fromByteOffset: i * MemoryLayout<Double>.size, as: Double.self)\n            let processed = value * 2.0\n            buffer.storeBytes(of: processed, toByteOffset: i * MemoryLayout<Double>.size, as: Double.self)\n        }\n    }\n}\n```\n\n#### ARC Optimization:\n```swift\n// Reducing reference counting overhead\nclass OptimizedDataHolder {\n    private var data: [String: Any]\n    \n    init(data: [String: Any]) {\n        self.data = data\n    }\n    \n    // Inefficient - multiple ARC operations\n    func updateValueInefficient(_ newData: [String: Any]) {\n        for (key, value) in newData {\n            data[key] = value // Individual ARC operations\n        }\n    }\n    \n    // Efficient - single ARC operation\n    func updateValueEfficient(_ newData: [String: Any]) {\n        var updated = data\n        for (key, value) in newData {\n            updated[key] = value\n        }\n        data = updated // Single ARC operation\n    }\n    \n    // Even more efficient - copy-on-write optimization\n    func updateValueOptimized(_ newData: [String: Any]) {\n        data.merge(newData) { _, new in new } // Efficient merging\n    }\n}\n\n// Avoiding implicit object capturing\nclass NetworkManager {\n    private var tasks: [URLSessionTask] = []\n    \n    func fetchDataInefficient(completion: @escaping (Data?) -> Void) {\n        let url = URL(string: \"https://api.example.com/data\")!\n        let task = URLSession.shared.dataTask(with: url) { data, _, _ in\n            // Implicit strong capture of self\n            self.processData(data) // Potential retain cycle\n            completion(data)\n        }\n        tasks.append(task)\n        task.resume()\n    }\n    \n    func fetchDataOptimized(completion: @escaping (Data?) -> Void) {\n        let url = URL(string: \"https://api.example.com/data\")!\n        let task = URLSession.shared.dataTask(with: url) { [weak self] data, _, _ in\n            guard let self = self else { return }\n            self.processData(data)\n            completion(data)\n        }\n        tasks.append(task)\n        task.resume()\n    }\n    \n    private func processData(_ data: Data?) {\n        // Data processing logic\n    }\n}\n```\n\n## 5. I/O & Network Optimization (45 min)\n\n### Efficient Data Access:\n\n#### Disk I/O Optimization:\n```swift\nclass StorageOptimizer {\n    private let fileURL: URL\n    private let queue = DispatchQueue(label: \"com.yourapp.storage\")\n    \n    init(filename: String) {\n        let documents = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask)[0]\n        fileURL = documents.appendingPathComponent(filename)\n    }\n    \n    // Inefficient - many small writes\n    func saveDataInefficient(_ items: [String]) {\n        for item in items {\n            if let data = item.data(using: .utf8) {\n                try? data.append(to: fileURL) // Many small disk writes\n            }\n        }\n    }\n    \n    // Efficient - batched writes\n    func saveDataOptimized(_ items: [String]) {\n        let data = items.joined(separator: \"\\n\").data(using: .utf8) ?? Data()\n        queue.async {\n            try? data.write(to: self.fileURL) // Single disk write\n        }\n    }\n    \n    // Memory-mapped files for large datasets\n    func processLargeFile() throws {\n        let fileHandle = try FileHandle(forReadingFrom: fileURL)\n        defer { try? fileHandle.close() }\n        \n        let chunkSize = 1024 * 1024 // 1MB chunks\n        while let chunk = try fileHandle.read(upToCount: chunkSize) {\n            processChunk(chunk)\n        }\n    }\n    \n    private func processChunk(_ data: Data) {\n        // Process data chunk\n    }\n}\n\n// File append extension\nextension Data {\n    func append(to url: URL) throws {\n        if let fileHandle = try? FileHandle(forWritingTo: url) {\n            defer { try? fileHandle.close() }\n            fileHandle.seekToEndOfFile()\n            fileHandle.write(self)\n        } else {\n            try write(to: url)\n        }\n    }\n}\n```\n\n#### Network Optimization:\n```swift\nclass NetworkOptimizer {\n    private let session: URLSession\n    private let cache: URLCache\n    \n    init() {\n        let config = URLSessionConfiguration.default\n        config.requestCachePolicy = .returnCacheDataElseLoad\n        config.urlCache = URLCache(\n            memoryCapacity: 50 * 1024 * 1024, // 50MB memory cache\n            diskCapacity: 500 * 1024 * 1024   // 500MB disk cache\n        )\n        self.session = URLSession(configuration: config)\n        self.cache = config.urlCache!\n    }\n    \n    // Request batching\n    func batchRequests(_ requests: [URLRequest]) -> AnyPublisher<[Data], Error> {\n        let publishers = requests.map { request in\n            session.dataTaskPublisher(for: request)\n                .map(\\.data)\n                .catch { _ in Empty<Data, Error>() }\n        }\n        \n        return Publishers.MergeMany(publishers)\n            .collect()\n            .eraseToAnyPublisher()\n    }\n    \n    // Request deduplication\n    private var activeRequests: [String: AnyPublisher<Data, Error>] = [:]\n    \n    func deduplicatedRequest(_ request: URLRequest) -> AnyPublisher<Data, Error> {\n        let key = request.url?.absoluteString ?? \"\"\n        \n        if let existing = activeRequests[key] {\n            return existing\n        }\n        \n        let publisher = session.dataTaskPublisher(for: request)\n            .map(\\.data)\n            .handleEvents(\n                receiveCompletion: { [weak self] _ in\n                    self?.activeRequests.removeValue(forKey: key)\n                }\n            )\n            .share()\n            .eraseToAnyPublisher()\n        \n        activeRequests[key] = publisher\n        return publisher\n    }\n}\n```\n\n## 6. Advanced Optimization Techniques (45 min)\n\n### Compiler Optimization Hints:\n```swift\n// Using @inlinable for performance critical functions\n@inlinable\nfunc fastSquare(_ x: Double) -> Double {\n    return x * x\n}\n\n// Using @inline(__always) for very small functions\n@inline(__always)\nfunc clamp<T: Comparable>(_ value: T, min: T, max: T) -> T {\n    return value < min ? min : (value > max ? max : value)\n}\n\n// Using @_specialize for generic optimization\n@_specialize(where T == Int)\n@_specialize(where T == Double)\nfunc processArray<T: Numeric>(_ array: [T]) -> T {\n    return array.reduce(0, +)\n}\n```\n\n### Memory Layout Optimization:\n```swift\n// Struct layout optimization\nstruct InefficientLayout {\n    var isEnabled: Bool    // 1 byte + 7 padding\n    var id: Int64          // 8 bytes\n    var count: Int32       // 4 bytes + 4 padding\n    var flag: Bool         // 1 byte + 7 padding\n    // Total: 32 bytes (50% wasted)\n}\n\nstruct EfficientLayout {\n    var id: Int64          // 8 bytes\n    var count: Int32       // 4 bytes\n    var isEnabled: Bool    // 1 byte\n    var flag: Bool         // 1 byte + 2 padding\n    // Total: 16 bytes (12.5% wasted)\n}\n\n// Using MemoryLayout to verify\nprint(MemoryLayout<InefficientLayout>.size)   // 32\nprint(MemoryLayout<EfficientLayout>.size)     // 16\n```\n\n### Advanced Caching Strategies:\n```swift\nclass MultiLevelCache<Key: Hashable, Value> {\n    private let l1Cache = NSCache<NSString, AnyObject>()\n    private var l2Cache: [Key: Value] = [:]\n    private let l2CacheLimit: Int\n    private let accessQueue = DispatchQueue(label: \"com.yourapp.cache\", attributes: .concurrent)\n    \n    init(l1Limit: Int = 100, l2Limit: Int = 1000) {\n        l1Cache.countLimit = l1Limit\n        self.l2CacheLimit = l2Limit\n    }\n    \n    func get(_ key: Key) -> Value? {\n        return accessQueue.sync {\n            // Check L1 cache first\n            if let l1Value = l1Cache.object(forKey: \"\\(key)\" as NSString) as? Value {\n                return l1Value\n            }\n            \n            // Check L2 cache\n            if let l2Value = l2Cache[key] {\n                // Promote to L1 cache\n                l1Cache.setObject(l2Value as AnyObject, forKey: \"\\(key)\" as NSString)\n                return l2Value\n            }\n            \n            return nil\n        }\n    }\n    \n    func set(_ value: Value, for key: Key) {\n        accessQueue.async(flags: .barrier) {\n            // Update L1 cache\n            self.l1Cache.setObject(value as AnyObject, forKey: \"\\(key)\" as NSString)\n            \n            // Update L2 cache with eviction if needed\n            if self.l2Cache.count >= self.l2CacheLimit {\n                // Simple LRU eviction (remove first item)\n                if let firstKey = self.l2Cache.keys.first {\n                    self.l2Cache.removeValue(forKey: firstKey)\n                }\n            }\n            self.l2Cache[key] = value\n        }\n    }\n}\n```\n\n## Practice Exercises\n\nComplete all exercises to master advanced performance optimization techniques!",
      "codeExample": "import Foundation\nimport Combine\nimport os.signpost\n\n// === PERFORMANCE MEASUREMENT TOOLS ===\nclass PerformanceMonitor {\n    private var measurements: [String: [CFTimeInterval]] = [:]\n    private let measurementQueue = DispatchQueue(label: \"com.performance.measurement\")\n    \n    func measure<T>(_ name: String, _ operation: () -> T) -> T {\n        let startTime = CACurrentMediaTime()\n        defer {\n            let endTime = CACurrentMediaTime()\n            let duration = endTime - startTime\n            measurementQueue.async {\n                self.measurements[name, default: []].append(duration)\n            }\n        }\n        return operation()\n    }\n    \n    func getStatistics(for name: String) -> (average: CFTimeInterval, min: CFTimeInterval, max: CFTimeInterval)? {\n        return measurementQueue.sync {\n            guard let values = measurements[name], !values.isEmpty else { return nil }\n            let average = values.reduce(0, +) / Double(values.count)\n            let min = values.min()!\n            let max = values.max()!\n            return (average, min, max)\n        }\n    }\n}\n\n// === OPTIMIZED DATA PROCESSING ===\nstruct LargeDatasetProcessor {\n    private let data: [Double]\n    \n    init(data: [Double]) {\n        self.data = data\n    }\n    \n    // Naive implementation - multiple intermediate arrays\n    func processNaively() -> [Double] {\n        return data\n            .map { $0 * 2.0 }           // Intermediate array 1\n            .filter { $0 > 50.0 }       // Intermediate array 2\n            .map { $0 * $0 }            // Intermediate array 3\n            .sorted()                   // Intermediate array 4\n    }\n    \n    // Optimized implementation - lazy evaluation\n    func processOptimally() -> [Double] {\n        return data.lazy\n            .map { $0 * 2.0 }           // No intermediate array\n            .filter { $0 > 50.0 }       // No intermediate array\n            .map { $0 * $0 }            // No intermediate array\n            .sorted()                   // Single result array\n    }\n    \n    // Batch processing for very large datasets\n    func processInBatches(batchSize: Int = 1000) -> [Double] {\n        var results: [Double] = []\n        results.reserveCapacity(data.count) // Pre-allocate memory\n        \n        for batchStart in stride(from: 0, to: data.count, by: batchSize) {\n            let batchEnd = min(batchStart + batchSize, data.count)\n            let batch = Array(data[batchStart..<batchEnd])\n            \n            let processedBatch = batch.lazy\n                .map { $0 * 2.0 }\n                .filter { $0 > 50.0 }\n                .map { $0 * $0 }\n            \n            results.append(contentsOf: processedBatch)\n        }\n        \n        return results.sorted()\n    }\n}\n\n// === MEMORY EFFICIENT COLLECTIONS ===\nclass EfficientDataContainer {\n    private var storage: ContiguousArray<Double>\n    private var indices: [String: Int]\n    \n    init() {\n        storage = ContiguousArray()\n        indices = [:]\n    }\n    \n    func addValue(_ value: Double, for key: String) {\n        if let index = indices[key] {\n            storage[index] = value\n        } else {\n            storage.append(value)\n            indices[key] = storage.count - 1\n        }\n    }\n    \n    func getValue(for key: String) -> Double? {\n        guard let index = indices[key] else { return nil }\n        return storage[index]\n    }\n    \n    // Efficient bulk operations\n    func updateValues(_ updates: [(key: String, value: Double)]) {\n        var newStorage = storage\n        var newIndices = indices\n        \n        for (key, value) in updates {\n            if let index = newIndices[key] {\n                newStorage[index] = value\n            } else {\n                newStorage.append(value)\n                newIndices[key] = newStorage.count - 1\n            }\n        }\n        \n        // Atomic update\n        storage = newStorage\n        indices = newIndices\n    }\n}\n\n// === ADVANCED CACHING SYSTEM ===\nactor AsyncCache<Key: Hashable, Value> {\n    private var cache: [Key: Value] = [:]\n    private var accessCounts: [Key: Int] = [:]\n    private let capacity: Int\n    \n    init(capacity: Int = 1000) {\n        self.capacity = capacity\n    }\n    \n    func get(_ key: Key) -> Value? {\n        if let value = cache[key] {\n            accessCounts[key, default: 0] += 1\n            return value\n        }\n        return nil\n    }\n    \n    func set(_ value: Value, for key: Key) {\n        if cache.count >= capacity && cache[key] == nil {\n            evictLeastUsed()\n        }\n        cache[key] = value\n        accessCounts[key] = 1\n    }\n    \n    private func evictLeastUsed() {\n        guard let leastUsed = accessCounts.min(by: { $0.value < $1.value }) else { return }\n        cache.removeValue(forKey: leastUsed.key)\n        accessCounts.removeValue(forKey: leastUsed.key)\n    }\n    \n    func clear() {\n        cache.removeAll()\n        accessCounts.removeAll()\n    }\n}\n\n// === NETWORK OPTIMIZATION ===\nclass OptimizedNetworkManager {\n    private let session: URLSession\n    private let cache: AsyncCache<URL, Data>\n    private var activeTasks: [URL: Task<Data, Error>] = [:]\n    \n    init() {\n        let config = URLSessionConfiguration.default\n        config.httpMaximumConnectionsPerHost = 6\n        config.timeoutIntervalForRequest = 30\n        config.timeoutIntervalForResource = 300\n        \n        self.session = URLSession(configuration: config)\n        self.cache = AsyncCache(capacity: 200)\n    }\n    \n    func fetchData(from url: URL) async throws -> Data {\n        // Check cache first\n        if let cached = await cache.get(url) {\n            return cached\n        }\n        \n        // Check for active task to avoid duplicates\n        if let existingTask = activeTasks[url] {\n            return try await existingTask.value\n        }\n        \n        // Create new task\n        let task = Task<Data, Error> {\n            defer { activeTasks.removeValue(forKey: url) }\n            \n            let (data, response) = try await session.data(from: url)\n            \n            guard let httpResponse = response as? HTTPURLResponse,\n                  httpResponse.statusCode == 200 else {\n                throw URLError(.badServerResponse)\n            }\n            \n            // Cache successful response\n            await cache.set(data, for: url)\n            return data\n        }\n        \n        activeTasks[url] = task\n        return try await task.value\n    }\n    \n    func prefetchURLs(_ urls: [URL]) {\n        for url in urls {\n            Task {\n                _ = try? await fetchData(from: url)\n            }\n        }\n    }\n}\n\n// === PERFORMANCE PROFILING INTEGRATION ===\nclass InstrumentedViewController: UIViewController {\n    private let performanceTracker = PerformanceTracker()\n    private var cancellables = Set<AnyCancellable>()\n    \n    override func viewDidLoad() {\n        super.viewDidLoad()\n        \n        performanceTracker.track(\"ViewDidLoad\") {\n            setupUI()\n            loadData()\n            configureBindings()\n        }\n    }\n    \n    private func setupUI() {\n        // UI setup code\n        Thread.sleep(forTimeInterval: 0.1) // Simulate work\n    }\n    \n    private func loadData() {\n        // Data loading code\n        Thread.sleep(forTimeInterval: 0.2) // Simulate work\n    }\n    \n    private func configureBindings() {\n        // Binding configuration\n        Thread.sleep(forTimeInterval: 0.05) // Simulate work\n    }\n}\n\n// === MEMORY OPTIMIZATION EXAMPLE ===\nstruct EfficientGameEntity {\n    private let components: [Component]\n    \n    // Memory-efficient component storage\n    func component<T: Component>(ofType type: T.Type) -> T? {\n        return components.first { $0 is T } as? T\n    }\n    \n    mutating func addComponent(_ component: Component) {\n        // Efficient copy-on-write\n        var newComponents = components\n        newComponents.append(component)\n        components = newComponents\n    }\n}\n\nprotocol Component {}\nstruct PhysicsComponent: Component {\n    var velocity: SIMD3<Float>\n    var mass: Float\n}\n\nstruct RenderComponent: Component {\n    var meshId: Int\n    var materialId: Int\n}\n\n// Usage example demonstrating performance patterns\nclass PerformanceDemo {\n    let monitor = PerformanceMonitor()\n    \n    func demonstrateOptimizations() {\n        // Demonstrate algorithmic optimization\n        let numbers = Array(1...10000)\n        \n        let naiveTime = monitor.measure(\"NaivePairs\") {\n            return findPairsNaive(numbers, target: 100)\n        }\n        \n        let optimizedTime = monitor.measure(\"OptimizedPairs\") {\n            return findPairsOptimized(numbers, target: 100)\n        }\n        \n        print(\"Naive: \\(naiveTime.count) pairs\")\n        print(\"Optimized: \\(optimizedTime.count) pairs\")\n        \n        // Demonstrate memory optimization\n        let largeData = Array(repeating: 42.0, count: 1000000)\n        let processor = LargeDatasetProcessor(data: largeData)\n        \n        let _ = monitor.measure(\"NaiveProcessing\") {\n            return processor.processNaively()\n        }\n        \n        let _ = monitor.measure(\"OptimizedProcessing\") {\n            return processor.processOptimally()\n        }\n        \n        // Print performance statistics\n        if let stats = monitor.getStatistics(for: \"NaiveProcessing\") {\n            print(\"Naive processing - Avg: \\(String(format: \"%.3f\", stats.average * 1000))ms\")\n        }\n        \n        if let stats = monitor.getStatistics(for: \"OptimizedProcessing\") {\n            print(\"Optimized processing - Avg: \\(String(format: \"%.3f\", stats.average * 1000))ms\")\n        }\n    }\n}",
      "category": "Performance",
      "estimatedTime": 240,
      "dependencies": ["swift_fundamentals", "memory_management", "concurrency"],
      "challenge": {
        "instructions": "Build a comprehensive performance optimization system for a data-intensive application:\n\nPART 1: Performance Measurement Infrastructure (60 min)\n1. Create a PerformanceMonitor with statistical tracking\n2. Implement signpost-based performance tracking\n3. Build memory usage monitoring utilities\n4. Create CPU utilization tracking\n\nPART 2: Algorithm Optimization (90 min)\n5. Optimize O(nÂ²) algorithms to O(n log n) or better\n6. Implement lazy evaluation for large datasets\n7. Create batch processing systems for memory efficiency\n8. Build concurrent processing with optimal thread utilization\n\nPART 3: Memory Optimization (60 min)\n9. Implement efficient data structures with minimal overhead\n10. Create memory pooling system for frequent allocations\n11. Build ARC optimization patterns\n12. Implement copy-on-write optimizations\n\nPART 4: I/O & Network Optimization (60 min)\n13. Create batched file I/O system\n14. Implement efficient caching with multiple levels\n15. Build request deduplication for network calls\n16. Create memory-mapped file processing\n\nPART 5: Advanced Optimization Techniques (90 min)\n17. Implement compiler optimization hints\n18. Create memory layout optimized structures\n19. Build performance regression detection\n20. Implement automated performance testing",
        "starterCode": "import Foundation\nimport os.signpost\n\n// === PART 1: Performance Measurement ===\n// Build your performance monitoring infrastructure here\n\n\n// === PART 2: Algorithm Optimization ===\n// Implement optimized algorithms and data processing\n\n\n// === PART 3: Memory Optimization ===\n// Create memory-efficient data structures and patterns\n\n\n// === PART 4: I/O & Network Optimization ===\n// Build optimized file and network operations\n\n\n// === PART 5: Advanced Techniques ===\n// Implement compiler hints and memory layout optimizations\n\n",
        "solution": "import Foundation\nimport os.signpost\nimport Combine\n\n// === PART 1: Performance Measurement Infrastructure ===\nclass AdvancedPerformanceMonitor {\n    private var measurements: [String: [CFTimeInterval]] = [:]\n    private var memorySnapshots: [String: UInt64] = [:]\n    private let queue = DispatchQueue(label: \"com.performance.monitor\", attributes: .concurrent)\n    private let log = OSLog(subsystem: \"com.app.performance\", category: \"Performance\")\n    \n    func measure<T>(_ name: String, _ operation: () -> T) -> T {\n        let signpostID = OSSignpostID(log: log)\n        os_signpost(.begin, log: log, name: \"Operation\", signpostID: signpostID, \"%s\", name)\n        \n        let startTime = CACurrentMediaTime()\n        let startMemory = getMemoryUsage()\n        \n        defer {\n            let endTime = CACurrentMediaTime()\n            let endMemory = getMemoryUsage()\n            let duration = endTime - startTime\n            let memoryDelta = endMemory - startMemory\n            \n            os_signpost(.end, log: log, name: \"Operation\", signpostID: signpostID)\n            \n            queue.async(flags: .barrier) {\n                self.measurements[name, default: []].append(duration)\n                self.memorySnapshots[name] = memoryDelta\n            }\n        }\n        \n        return operation()\n    }\n    \n    private func getMemoryUsage() -> UInt64 {\n        var taskInfo = task_vm_info_data_t()\n        var count = mach_msg_type_number_t(MemoryLayout<task_vm_info>.size) / MemoryLayout<natural_t>.size\n        \n        let result = withUnsafeMutablePointer(to: &taskInfo) {\n            $0.withMemoryRebound(to: integer_t.self, capacity: 1) {\n                task_info(mach_task_self_, task_flavor_t(TASK_VM_INFO), $0, &count)\n            }\n        }\n        \n        return result == KERN_SUCCESS ? UInt64(taskInfo.phys_footprint) : 0\n    }\n    \n    func getPerformanceReport() -> [String: Any] {\n        return queue.sync {\n            var report: [String: Any] = [:]\n            \n            for (name, durations) in measurements {\n                let average = durations.reduce(0, +) / Double(durations.count)\n                let min = durations.min() ?? 0\n                let max = durations.max() ?? 0\n                let memory = memorySnapshots[name] ?? 0\n                \n                report[name] = [\n                    \"average_time_ms\": average * 1000,\n                    \"min_time_ms\": min * 1000,\n                    \"max_time_ms\": max * 1000,\n                    \"memory_bytes\": memory,\n                    \"sample_count\": durations.count\n                ]\n            }\n            \n            return report\n        }\n    }\n}\n\n// === PART 2: Algorithm Optimization ===\nclass OptimizedDataProcessor {\n    private let monitor = AdvancedPerformanceMonitor()\n    \n    // O(n log n) sorting with efficient memory usage\n    func optimizedSort<T: Comparable>(_ array: [T]) -> [T] {\n        return monitor.measure(\"OptimizedSort\") {\n            var mutableArray = array\n            mutableArray.sort() // Uses TimSort (adaptive, stable)\n            return mutableArray\n        }\n    }\n    \n    // Efficient data transformation with lazy evaluation\n    func processLargeDataset(_ data: [Double]) -> [Double] {\n        return monitor.measure(\"LargeDatasetProcessing\") {\n            return data.lazy\n                .map { $0 * 2.0 }\n                .filter { $0 > 0.0 }\n                .map { sin($0) }\n                .reduce(0.0, +)\n        }\n    }\n    \n    // Concurrent processing with optimal chunk sizing\n    func concurrentProcess<T, R>(_ items: [T], transform: @escaping (T) -> R) -> [R] {\n        return monitor.measure(\"ConcurrentProcessing\") {\n            let processorCount = ProcessInfo.processInfo.activeProcessorCount\n            let chunkSize = max(1, items.count / processorCount)\n            \n            return Array(0..<processorCount).concurrentCompactMap { index in\n                let start = index * chunkSize\n                let end = min(start + chunkSize, items.count)\n                guard start < items.count else { return nil }\n                \n                let chunk = Array(items[start..<end])\n                return chunk.map(transform)\n            }.flatMap { $0 }\n        }\n    }\n}\n\n// === PART 3: Memory Optimization ===\nstruct MemoryEfficientArray<Element> {\n    private var storage: ContiguousArray<Element>\n    private var capacity: Int\n    \n    init() {\n        storage = ContiguousArray()\n        capacity = 0\n    }\n    \n    mutating func append(_ element: Element) {\n        if storage.count == capacity {\n            // Exponential growth strategy\n            capacity = capacity == 0 ? 1 : capacity * 2\n            storage.reserveCapacity(capacity)\n        }\n        storage.append(element)\n    }\n    \n    var count: Int { storage.count }\n    \n    subscript(index: Int) -> Element {\n        get { storage[index] }\n        set { storage[index] = newValue }\n    }\n}\n\nclass ObjectPool<T: AnyObject> {\n    private var available: [T] = []\n    private var inUse: Set<ObjectIdentifier> = []\n    private let create: () -> T\n    private let reset: (T) -> Void\n    \n    init(create: @escaping () -> T, reset: @escaping (T) -> Void) {\n        self.create = create\n        self.reset = reset\n    }\n    \n    func acquire() -> T {\n        if let object = available.popLast() {\n            inUse.insert(ObjectIdentifier(object))\n            return object\n        } else {\n            let object = create()\n            inUse.insert(ObjectIdentifier(object))\n            return object\n        }\n    }\n    \n    func release(_ object: T) {\n        let id = ObjectIdentifier(object)\n        guard inUse.contains(id) else { return }\n        \n        inUse.remove(id)\n        reset(object)\n        available.append(object)\n    }\n}\n\n// === PART 4: I/O & Network Optimization ===\nactor OptimizedFileManager {\n    private let fileHandle: FileHandle?\n    private let queue = DispatchQueue(label: \"com.app.filemanager\", attributes: .concurrent)\n    private var writeBuffer: Data = Data()\n    private let bufferSize = 1024 * 1024 // 1MB buffer\n    \n    init(fileURL: URL) throws {\n        self.fileHandle = try FileHandle(forWritingTo: fileURL)\n    }\n    \n    func write(_ data: Data) async throws {\n        await withCheckedContinuation { continuation in\n            queue.async(flags: .barrier) {\n                self.writeBuffer.append(data)\n                \n                if self.writeBuffer.count >= self.bufferSize {\n                    self.flushBuffer()\n                }\n                \n                continuation.resume()\n            }\n        }\n    }\n    \n    private func flushBuffer() {\n        guard !writeBuffer.isEmpty else { return }\n        try? fileHandle?.write(contentsOf: writeBuffer)\n        writeBuffer.removeAll(keepingCapacity: true)\n    }\n    \n    func close() {\n        flushBuffer()\n        try? fileHandle?.close()\n    }\n}\n\nclass DeduplicatedNetworkService {\n    private let session: URLSession\n    private var activeRequests: [String: Task<Data, Error>] = [:]\n    private let cache = NSCache<NSString, NSData>()\n    \n    init() {\n        let config = URLSessionConfiguration.default\n        config.requestCachePolicy = .returnCacheDataElseLoad\n        config.urlCache = URLCache(memoryCapacity: 50_000_000, diskCapacity: 500_000_000)\n        self.session = URLSession(configuration: config)\n    }\n    \n    func fetchData(from url: URL) async throws -> Data {\n        let cacheKey = url.absoluteString as NSString\n        \n        // Check memory cache\n        if let cached = cache.object(forKey: cacheKey) {\n            return cached as Data\n        }\n        \n        // Check for active request\n        if let existingTask = activeRequests[url.absoluteString] {\n            return try await existingTask.value\n        }\n        \n        let task = Task<Data, Error> {\n            defer { activeRequests.removeValue(forKey: url.absoluteString) }\n            \n            let (data, response) = try await session.data(from: url)\n            \n            guard let httpResponse = response as? HTTPURLResponse,\n                  httpResponse.statusCode == 200 else {\n                throw URLError(.badServerResponse)\n            }\n            \n            // Cache successful response\n            cache.setObject(data as NSData, forKey: cacheKey)\n            return data\n        }\n        \n        activeRequests[url.absoluteString] = task\n        return try await task.value\n    }\n}\n\n// === PART 5: Advanced Optimization Techniques ===\n@inlinable\nfunc fastDistance(_ x: Double, _ y: Double) -> Double {\n    return sqrt(x * x + y * y)\n}\n\n// Memory layout optimized structure\nstruct OptimizedGameEntity {\n    let id: Int64           // 8 bytes\n    let position: SIMD2<Float> // 8 bytes\n    let velocity: SIMD2<Float> // 8 bytes\n    let health: Float       // 4 bytes\n    let isActive: Bool      // 1 byte\n    let type: UInt8         // 1 byte\n    // Total: 30 bytes + 2 padding = 32 bytes (efficient!)\n}\n\nclass PerformanceRegressionDetector {\n    private var baselineMeasurements: [String: Double] = [:]\n    private let threshold = 0.15 // 15% performance regression\n    \n    func setBaseline(_ name: String, duration: Double) {\n        baselineMeasurements[name] = duration\n    }\n    \n    func checkForRegression(_ name: String, currentDuration: Double) -> Bool {\n        guard let baseline = baselineMeasurements[name] else {\n            setBaseline(name, duration: currentDuration)\n            return false\n        }\n        \n        let regression = (currentDuration - baseline) / baseline\n        return regression > threshold\n    }\n}\n\n// Utility extensions\nextension Array {\n    func concurrentCompactMap<T>(_ transform: @escaping (Element) -> T?) -> [T] {\n        var results: [T] = []\n        let lock = NSLock()\n        \n        DispatchQueue.concurrentPerform(iterations: count) { index in\n            if let result = transform(self[index]) {\n                lock.lock()\n                results.append(result)\n                lock.unlock()\n            }\n        }\n        \n        return results\n    }\n}",
        "hints": [
          "Use Instruments' Time Profiler to identify hot spots in your code",
          "Memory allocations show up in Instruments' Allocations tool",
          "Lazy evaluation prevents creating intermediate arrays",
          "ContiguousArray is more efficient than Array for value types",
          "Use @inlinable for small, frequently called functions",
          "Batch network requests to reduce overhead",
          "Use NSCache for memory-based caching with automatic eviction",
          "Measure performance before and after optimizations",
          "Use OSLog signposts for detailed performance tracking",
          "Consider memory layout when designing data structures"
        ],
        "testCases": [
          {
            "input": "let processor = OptimizedDataProcessor(); let data = Array(1...1000); let result = processor.optimizedSort(data)",
            "expectedOutput": "Array(1...1000)",
            "description": "Should sort array correctly with optimized algorithm"
          },
          {
            "input": "let monitor = AdvancedPerformanceMonitor(); monitor.measure(\"Test\", { Thread.sleep(forTimeInterval: 0.1) }); let report = monitor.getPerformanceReport()[\"Test\"]",
            "expectedOutput": "Contains average_time_ms around 100",
            "description": "Should accurately measure operation duration"
          },
          {
            "input": "MemoryLayout<OptimizedGameEntity>.size",
            "expectedOutput": "32",
            "description": "Memory layout should be optimized to 32 bytes"
          }
        ]
      }
    },
    {
      "id": "app_size_optimization",
      "title": "App Size Optimization",
      "description": "Master advanced techniques for reducing app bundle size through asset optimization, lazy loading, and build configuration",
      "difficulty": "advanced",
      "theory": "# App Size Optimization - Advanced Techniques\n\n## 1. Asset Optimization & Compression (90 min)\n\n### Understanding App Thinning:\n\n**App Thinning Components:**\n- **Slicing**: Delivering only relevant assets for target device\n- **Bitcode**: Intermediate representation for recompilation\n- **On-Demand Resources**: Assets downloaded when needed\n\n**Asset Catalog Optimization:**\n```swift\n// Before: Multiple image files\nlet image1 = UIImage(named: \"icon_2x.png\")\nlet image2 = UIImage(named: \"icon_3x.png\")\n\n// After: Single image in asset catalog\nlet image = UIImage(named: \"icon\")\n// Automatically handles @2x, @3x, dark mode, etc.\n```\n\n### Advanced Image Compression:\n\n**WebP vs PNG vs JPEG:**\n```swift\n// WebP offers superior compression\nimport GoogleWebP\n\nfunc loadWebPImage(named: String) -> UIImage? {\n    guard let path = Bundle.main.path(forResource: named, ofType: \"webp\") else {\n        return nil\n    }\n    return UIImage(contentsOfFile: path)\n}\n\n// PNG optimization tools\n// Use pngcrush, optipng for command-line optimization\n// pngcrush -reduce -brute input.png output.png\n```\n\n**Vector Assets vs Raster:**\n```swift\n// PDF vector assets in asset catalog\n// Automatically generates @1x, @2x, @3x at build time\n// Preserves sharpness at any resolution\n\n// SF Symbols - built-in vector icons\nlet config = UIImage.SymbolConfiguration(weight: .medium)\nlet image = UIImage(systemName: \"star.fill\", withConfiguration: config)\n```\n\n### Audio/Video Optimization:\n\n**Audio Compression:**\n```swift\n// Prefer AAC over MP3 for iOS\n// Use appropriate bitrates:\n// - Background music: 64-128 kbps\n// - Sound effects: 32-64 kbps\n// - Voice: 16-32 kbps\n\n// Lazy load audio files\nclass AudioManager {\n    private var loadedSounds: [String: AVAudioPlayer] = [:]\n    \n    func preloadSound(_ name: String) {\n        guard loadedSounds[name] == nil else { return }\n        \n        DispatchQueue.global(qos: .utility).async {\n            if let player = self.loadAudioPlayer(for: name) {\n                DispatchQueue.main.async {\n                    self.loadedSounds[name] = player\n                }\n            }\n        }\n    }\n}\n```\n\n## 2. Code Size Analysis & Reduction (60 min)\n\n### Analyzing App Size:\n\n**Using Size Report Tools:**\n```bash\n# Generate size analysis\nxcrun dsymutil -dump-debug-map YourApp.app.dSYM > debug_map.txt\n\n# Analyze binary size\nxcrun size -m -x -l YourApp.app/YourApp\n\n# Check framework sizes\nfind . -name \"*.framework\" -exec du -sh {} \\;\n```\n\n**Link Map Analysis:**\n```swift\n// Build Settings for size analysis:\n// - Write Link Map File: YES\n// - Link Map File Path: $(TARGET_TEMP_DIR)/$(PRODUCT_NAME)-LinkMap.txt\n\n// Analyze which symbols take most space:\n// nm -size YourApp.app/YourApp | sort -nr\n```\n\n### Dead Code Elimination:\n\n**Compiler Optimization Settings:**\n```swift\n// Build Settings for size optimization:\n// - Optimization Level: -Os (Fastest, Smallest)\n// - Strip Linked Product: YES\n// - Strip Style: Non-Global Symbols\n// - Dead Code Stripping: YES\n// - Make Strings Read-Only: YES\n// - Enable Link Time Optimization: YES\n```\n\n**Unused Code Detection:**\n```swift\n// Use AppCode or SwiftLint for unused code detection\n// SwiftLint rule: unused_import, unused_declaration\n\n// Manual detection with code coverage\n// - Test Coverage: YES\n// - Instrument Program Flow: YES\n// - Analyze during 'Build & Archive'\n```\n\n## 3. Lazy Loading & Dynamic Frameworks (90 min)\n\n### Advanced Lazy Loading Patterns:\n\n**Lazy View Controllers:**\n```swift\nclass FeatureManager {\n    private lazy var complexFeatureVC: ComplexFeatureViewController = {\n        let storyboard = UIStoryboard(name: \"ComplexFeature\", bundle: nil)\n        return storyboard.instantiateInitialViewController() as! ComplexFeatureViewController\n    }()\n    \n    private lazy var heavyResources: [String: Any] = {\n        // Load heavy resources only when needed\n        return loadHeavyResources()\n    }()\n    \n    func showComplexFeature(from presenter: UIViewController) {\n        // Loads only when first accessed\n        presenter.present(complexFeatureVC, animated: true)\n    }\n}\n```\n\n**Dynamic Framework Loading:**\n```swift\nimport Foundation\n\nclass DynamicFrameworkManager {\n    private var loadedFrameworks: [String: Bundle] = [:]\n    \n    func loadFramework(named frameworkName: String) -> Bool {\n        guard loadedFrameworks[frameworkName] == nil else {\n            return true // Already loaded\n        }\n        \n        guard let frameworkPath = Bundle.main.privateFrameworksPath else {\n            return false\n        }\n        \n        let frameworkURL = URL(fileURLWithPath: frameworkPath)\n            .appendingPathComponent(frameworkName)\n            .appendingPathExtension(\"framework\")\n        \n        guard let bundle = Bundle(url: frameworkURL) else {\n            return false\n        }\n        \n        return bundle.load()\n    }\n    \n    func unloadFramework(named frameworkName) {\n        guard let bundle = loadedFrameworks[frameworkName] else { return }\n        \n        if bundle.unload() {\n            loadedFrameworks.removeValue(forKey: frameworkName)\n        }\n    }\n}\n```\n\n### On-Demand Resources (ODR):\n\n**Managing ODR Tags:**\n```swift\nimport Foundation\n\nclass ODRManager {\n    private var currentRequest: NSBundleResourceRequest?\n    \n    func loadResources(for tags: Set<String>, completion: @escaping (Result<NSBundleResourceRequest, Error>) -> Void) {\n        let request = NSBundleResourceRequest(tags: tags)\n        \n        // Set loading priority\n        request.loadingPriority = NSBundleResourceRequestLoadingPriorityUrgent\n        \n        request.beginAccessingResources { error in\n            if let error = error {\n                completion(.failure(error))\n            } else {\n                self.currentRequest = request\n                completion(.success(request))\n            }\n        }\n    }\n    \n    func releaseResources() {\n        currentRequest?.endAccessingResources()\n        currentRequest = nil\n    }\n    \n    func prefetchResources(for tags: Set<String>) {\n        let request = NSBundleResourceRequest(tags: tags)\n        request.loadingPriority = NSBundleResourceRequestLoadingPriorityPrefetch\n        \n        // Low priority background loading\n        request.conditionallyBeginAccessingResources { available in\n            if !available {\n                request.beginAccessingResources { _ in\n                    // Resources are now available for faster access later\n                }\n            }\n        }\n    }\n}\n```\n\n## 4. Build Configuration & Advanced Settings (60 min)\n\n### Advanced Build Settings:\n\n**Compiler Flags for Size:**\n```swift\n// Swift Compiler - Custom Flags:\n// -whole-module-optimization\n// -enable-batch-mode\n// -Xfrontend -warn-long-expression-type-checking=100\n\n// Other C Flags:\n// -Os // Optimize for size\n// -fvisibility=hidden\n// -fvisibility-inlines-hidden\n```\n\n**Strip Settings:**\n```swift\n// Strip Debug Symbols During Copy: YES\n// Strip Style: All Symbols (for release)\n// Strip Swift Symbols: YES\n// Deployment Postprocessing: YES\n\n// For App Store submission:\n// Strip Linked Product: YES\n// Use Release Strip Style: YES\n```\n\n### Bitcode Optimization:\n\n**Bitcode Generation:**\n```swift\n// Enable Bitcode: YES\n// Bitcode generation requires:\n// - All dependencies support bitcode\n// - Proper symbol preservation\n// - Correct build settings\n\n// Preserve symbols needed for categories:\n// OTHER_LDFLAGS = $(inherited) -all_load\n// Or selectively: -ObjC\n```\n\n## 5. Advanced Asset Management (60 min)\n\n### Texture Atlases & SpriteKit Optimization:\n\n**Texture Atlas Optimization:**\n```swift\nimport SpriteKit\n\nclass OptimizedTextureManager {\n    private var textureAtlases: [String: SKTextureAtlas] = [:]\n    \n    func preloadTextureAtlas(named name: String) {\n        guard textureAtlases[name] == nil else { return }\n        \n        let atlas = SKTextureAtlas(named: name)\n        atlas.preload {\n            self.textureAtlases[name] = atlas\n        }\n    }\n    \n    func getTexture(fromAtlas atlasName: String, textureName: String) -> SKTexture? {\n        guard let atlas = textureAtlases[atlasName] else {\n            // Fallback to individual texture loading\n            return SKTexture(imageNamed: textureName)\n        }\n        return atlas.textureNamed(textureName)\n    }\n    \n    func unloadUnusedAtlases() {\n        for (name, atlas) in textureAtlases {\n            if !isAtlasNeeded(name) {\n                textureAtlases.removeValue(forKey: name)\n            }\n        }\n    }\n}\n```\n\n### Advanced Font Management:\n\n**Font Subsetting & Dynamic Loading:**\n```swift\nimport CoreText\n\nclass FontManager {\n    private var loadedFonts: [String: CGFont] = [:]\n    \n    func loadCustomFont(named fontName: String, from url: URL) -> Bool {\n        guard let fontData = try? Data(contentsOf: url) as CFData,\n              let dataProvider = CGDataProvider(data: fontData),\n              let font = CGFont(dataProvider) else {\n            return false\n        }\n        \n        var error: Unmanaged<CFError>?\n        guard CTFontManagerRegisterGraphicsFont(font, &error) else {\n            print(\"Failed to load font: \\(error)\")\n            return false\n        }\n        \n        loadedFonts[fontName] = font\n        return true\n    }\n    \n    func unloadFont(named fontName) {\n        guard let font = loadedFonts[fontName] else { return }\n        \n        CTFontManagerUnregisterGraphicsFont(font, nil)\n        loadedFonts.removeValue(forKey: fontName)\n    }\n}\n```\n\n## 6. Performance Monitoring & Analytics (30 min)\n\n### Size Monitoring:\n\n**Build Size Tracking:**\n```swift\nimport Foundation\n\nclass BuildSizeTracker {\n    static func trackBuildSize() {\n        let buildDir = ProcessInfo.processInfo.environment[\"BUILT_PRODUCTS_DIR\"] ?? \"\"\n        let productName = ProcessInfo.processInfo.environment[\"PRODUCT_NAME\"] ?? \"\"\n        \n        let appPath = \"\\(buildDir)/\\(productName).app\"\n        let appURL = URL(fileURLWithPath: appPath)\n        \n        if let size = directorySize(at: appURL) {\n            print(\"App size: \\(size / 1024 / 1024) MB\")\n            \n            // Log to analytics\n            logSizeToAnalytics(size)\n        }\n    }\n    \n    private static func directorySize(at url: URL) -> Int? {\n        guard let enumerator = FileManager.default.enumerator(\n            at: url,\n            includingPropertiesForKeys: [.fileSizeKey],\n            options: []\n        ) else { return nil }\n        \n        var totalSize = 0\n        for case let fileURL as URL in enumerator {\n            do {\n                let resourceValues = try fileURL.resourceValues(forKeys: [.fileSizeKey])\n                totalSize += resourceValues.fileSize ?? 0\n            } catch {\n                continue\n            }\n        }\n        return totalSize\n    }\n}\n```\n\n## Best Practices Summary\n\n- Always use Asset Catalogs for images\n- Implement lazy loading for heavy features\n- Use On-Demand Resources for non-essential content\n- Regularly analyze and eliminate dead code\n- Monitor app size throughout development\n- Prefer vector assets when possible\n- Implement proper memory management for loaded resources",
      "codeExample": "import UIKit\nimport SpriteKit\nimport Combine\n\n// === ADVANCED ASSET MANAGEMENT ===\nclass OptimizedAssetManager {\n    static let shared = OptimizedAssetManager()\n    \n    private var imageCache: NSCache<NSString, UIImage> = {\n        let cache = NSCache<NSString, UIImage>()\n        cache.countLimit = 100 // Limit cache size\n        cache.totalCostLimit = 50 * 1024 * 1024 // 50MB limit\n        return cache\n    }()\n    \n    private var preloadedTextures: [String: SKTexture] = [:]\n    private var odrRequests: [Set<String>: NSBundleResourceRequest] = [:]\n    private var cancellables = Set<AnyCancellable>()\n    \n    // MARK: - Image Loading with Optimization\n    \n    func loadOptimizedImage(named name: String, completion: @escaping (UIImage?) -> Void) {\n        // Check memory cache first\n        if let cachedImage = imageCache.object(forKey: name as NSString) {\n            completion(cachedImage)\n            return\n        }\n        \n        // Load in background with optimized decoding\n        DispatchQueue.global(qos: .userInitiated).async {\n            guard let image = UIImage(named: name) else {\n                DispatchQueue.main.async {\n                    completion(nil)\n                }\n                return\n            }\n            \n            // Optimize image for display\n            let optimizedImage = self.decodedImage(image)\n            \n            // Cache the optimized image\n            self.imageCache.setObject(optimizedImage, forKey: name as NSString)\n            \n            DispatchQueue.main.async {\n                completion(optimizedImage)\n            }\n        }\n    }\n    \n    private func decodedImage(_ image: UIImage) -> UIImage {\n        guard let cgImage = image.cgImage else { return image }\n        \n        let size = CGSize(width: cgImage.width, height: cgImage.height)\n        let colorSpace = CGColorSpaceCreateDeviceRGB()\n        \n        let context = CGContext(\n            data: nil,\n            width: Int(size.width),\n            height: Int(size.height),\n            bitsPerComponent: 8,\n            bytesPerRow: cgImage.bytesPerRow,\n            space: colorSpace,\n            bitmapInfo: CGImageAlphaInfo.premultipliedFirst.rawValue\n        )\n        \n        context?.draw(cgImage, in: CGRect(origin: .zero, size: size))\n        \n        guard let decodedImage = context?.makeImage() else {\n            return image\n        }\n        \n        return UIImage(cgImage: decodedImage)\n    }\n    \n    // MARK: - On-Demand Resources\n    \n    func loadOnDemandResources(tags: Set<String>, completion: @escaping (Bool) -> Void) {\n        // Check if we already have a request for these tags\n        if let existingRequest = odrRequests[tags] {\n            existingRequest.conditionallyBeginAccessingResources { available in\n                completion(available)\n            }\n            return\n        }\n        \n        let request = NSBundleResourceRequest(tags: tags)\n        odrRequests[tags] = request\n        \n        // Set appropriate loading priority\n        request.loadingPriority = NSBundleResourceRequestLoadingPriorityUrgent\n        \n        request.beginAccessingResources { [weak self] error in\n            DispatchQueue.main.async {\n                if let error = error {\n                    print(\"Failed to load ODR: \\(error)\")\n                    self?.odrRequests.removeValue(forKey: tags)\n                    completion(false)\n                } else {\n                    completion(true)\n                }\n            }\n        }\n    }\n    \n    func releaseOnDemandResources(tags: Set<String>) {\n        guard let request = odrRequests[tags] else { return }\n        \n        request.endAccessingResources()\n        odrRequests.removeValue(forKey: tags)\n    }\n    \n    // MARK: - Texture Management\n    \n    func preloadGameTextures(for level: Int) {\n        let textureNames = texturesForLevel(level)\n        \n        // Load textures in background\n        DispatchQueue.global(qos: .utility).async {\n            for textureName in textureNames {\n                let texture = SKTexture(imageNamed: textureName)\n                // Preload texture data\n                texture.preload {\n                    DispatchQueue.main.async {\n                        self.preloadedTextures[textureName] = texture\n                    }\n                }\n            }\n        }\n    }\n    \n    func getPreloadedTexture(named name: String) -> SKTexture? {\n        return preloadedTextures[name]\n    }\n    \n    func clearUnusedTextures() {\n        let currentlyNeeded = currentLevelTextures()\n        \n        for (textureName, _) in preloadedTextures {\n            if !currentlyNeeded.contains(textureName) {\n                preloadedTextures.removeValue(forKey: textureName)\n            }\n        }\n    }\n    \n    // MARK: - Helper Methods\n    \n    private func texturesForLevel(_ level: Int) -> [String] {\n        // Return texture names needed for specific level\n        switch level {\n        case 1: return [\"background_1\", \"character_1\", \"enemy_1\"]\n        case 2: return [\"background_2\", \"character_2\", \"enemy_2\", \"boss_1\"]\n        default: return []\n        }\n    }\n    \n    private func currentLevelTextures() -> Set<String> {\n        // Return textures needed for current game state\n        return Set(texturesForLevel(1)) // Example\n    }\n}\n\n// === LAZY LOADING MANAGER ===\nclass LazyFeatureManager {\n    private var loadedFeatures: [String: Any] = [:]\n    private var featureLoaders: [String: () -> Any] = [:]\n    \n    func registerFeature<T>(_ name: String, loader: @escaping () -> T) {\n        featureLoaders[name] = loader\n    }\n    \n    func loadFeature<T>(_ name: String) -> T? {\n        // Check if already loaded\n        if let feature = loadedFeatures[name] as? T {\n            return feature\n        }\n        \n        // Load using registered loader\n        guard let loader = featureLoaders[name],\n              let feature = loader() as? T else {\n            return nil\n        }\n        \n        loadedFeatures[name] = feature\n        return feature\n    }\n    \n    func unloadFeature(_ name: String) {\n        loadedFeatures.removeValue(forKey: name)\n        \n        // Notify feature about unloading if needed\n        if let unloadable = loadedFeatures[name] as? Unloadable {\n            unloadable.prepareForUnload()\n        }\n    }\n    \n    func unloadAllFeatures() {\n        for (_, feature) in loadedFeatures {\n            if let unloadable = feature as? Unloadable {\n                unloadable.prepareForUnload()\n            }\n        }\n        loadedFeatures.removeAll()\n    }\n}\n\nprotocol Unloadable {\n    func prepareForUnload()\n}\n\n// === ADVANCED FONT MANAGER ===\nclass DynamicFontManager {\n    private var loadedFonts: [String: String] = [:] // fontName: filePath\n    \n    func loadFont(from filePath: String) -> Bool {\n        guard let fontURL = URL(string: filePath),\n              let fontData = try? Data(contentsOf: fontURL) as CFData,\n              let dataProvider = CGDataProvider(data: fontData),\n              let font = CGFont(dataProvider) else {\n            return false\n        }\n        \n        var error: Unmanaged<CFError>?\n        guard CTFontManagerRegisterGraphicsFont(font, &error) else {\n            if let error = error?.takeRetainedValue() {\n                print(\"Failed to register font: \\(error)\")\n            }\n            return false\n        }\n        \n        // Store font name for later unregistration\n        if let fontName = font.postScriptName as String? {\n            loadedFonts[fontName] = filePath\n        }\n        \n        return true\n    }\n    \n    func unloadFont(named fontName: String) {\n        guard let fontPath = loadedFonts[fontName],\n              let fontURL = URL(string: fontPath),\n              let fontData = try? Data(contentsOf: fontURL) as CFData,\n              let dataProvider = CGDataProvider(data: fontData),\n              let font = CGFont(dataProvider) else {\n            return\n        }\n        \n        CTFontManagerUnregisterGraphicsFont(font, nil)\n        loadedFonts.removeValue(forKey: fontName)\n    }\n}\n\n// === APP SIZE TRACKER ===\nclass AppSizeTracker {\n    static func generateSizeReport() -> [String: Any] {\n        var report: [String: Any] = [:]\n        \n        // App bundle size\n        if let appSize = calculateAppBundleSize() {\n            report[\"appBundleSize\"] = appSize\n        }\n        \n        // Document directory size\n        if let docSize = calculateDocumentsSize() {\n            report[\"documentsSize\"] = docSize\n        }\n        \n        // Cache directory size\n        if let cacheSize = calculateCacheSize() {\n            report[\"cacheSize\"] = cacheSize\n        }\n        \n        return report\n    }\n    \n    private static func calculateAppBundleSize() -> Int? {\n        guard let bundlePath = Bundle.main.bundlePath else { return nil }\n        return directorySize(at: URL(fileURLWithPath: bundlePath))\n    }\n    \n    private static func calculateDocumentsSize() -> Int? {\n        guard let documentsPath = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask).first else {\n            return nil\n        }\n        return directorySize(at: documentsPath)\n    }\n    \n    private static func calculateCacheSize() -> Int? {\n        guard let cachePath = FileManager.default.urls(for: .cachesDirectory, in: .userDomainMask).first else {\n            return nil\n        }\n        return directorySize(at: cachePath)\n    }\n    \n    private static func directorySize(at url: URL) -> Int? {\n        guard let enumerator = FileManager.default.enumerator(\n            at: url,\n            includingPropertiesForKeys: [.fileSizeKey],\n            options: [.skipsHiddenFiles]\n        ) else { return nil }\n        \n        var totalSize = 0\n        for case let fileURL as URL in enumerator {\n            do {\n                let resourceValues = try fileURL.resourceValues(forKeys: [.fileSizeKey])\n                totalSize += resourceValues.fileSize ?? 0\n            } catch {\n                continue\n            }\n        }\n        return totalSize\n    }\n}",
      "category": "Performance & Optimization",
      "estimatedTime": 180,
      "dependencies": ["memory_management", "networking_basics", "ui_components"],
      "challenge": {
        "instructions": "Build a comprehensive app size optimization system:\n\nPART 1: Asset Optimization System (60 min)\n1. Create an AdvancedAssetManager that handles image caching with memory limits\n2. Implement optimized image decoding to reduce memory usage\n3. Add support for different image formats (WebP, PNG, JPEG) with automatic format selection\n\nPART 2: Lazy Loading Framework (60 min)\n4. Build a LazyFeatureManager that dynamically loads features on demand\n5. Implement resource tracking and automatic cleanup of unused resources\n6. Create a priority system for resource loading based on user behavior\n\nPART 3: On-Demand Resources Manager (60 min)\n7. Develop an ODRManager that handles On-Demand Resources with error recovery\n8. Implement prefetching strategies based on user patterns\n9. Add progress tracking and cancellation support for ODR downloads\n\nPART 4: Build Analysis & Reporting (60 min)\n10. Create a BuildSizeAnalyzer that generates detailed size reports\n11. Implement automated size regression detection\n12. Build a recommendation engine for size optimization opportunities\n\nPART 5: Advanced Optimization Techniques (60 min)\n13. Implement font subsetting and dynamic font loading\n14. Create a texture atlas management system for SpriteKit\n15. Build a code stripping analyzer that identifies unused code paths",
        "starterCode": "import UIKit\nimport Combine\nimport SpriteKit\n\n// === PART 1: Asset Optimization System ===\n// Create AdvancedAssetManager here\n\n\n// === PART 2: Lazy Loading Framework ===\n// Build LazyFeatureManager with resource tracking\n\n\n// === PART 3: On-Demand Resources Manager ===\n// Develop ODRManager with prefetching strategies\n\n\n// === PART 4: Build Analysis & Reporting ===\n// Create BuildSizeAnalyzer and recommendation engine\n\n\n// === PART 5: Advanced Optimization Techniques ===\n// Implement font subsetting and texture management\n\n",
        "solution": "import UIKit\nimport Combine\nimport SpriteKit\nimport CoreText\n\n// === PART 1: Asset Optimization System ===\nclass AdvancedAssetManager {\n    static let shared = AdvancedAssetManager()\n    \n    private let imageCache: NSCache<NSString, UIImage> = {\n        let cache = NSCache<NSString, UIImage>()\n        cache.countLimit = 150\n        cache.totalCostLimit = 100 * 1024 * 1024 // 100MB\n        return cache\n    }()\n    \n    private var loadingOperations: [String: Operation] = [:]\n    private let operationQueue: OperationQueue = {\n        let queue = OperationQueue()\n        queue.maxConcurrentOperationCount = 3\n        queue.qualityOfService = .utility\n        return queue\n    }()\n    \n    enum ImageFormat {\n        case png, jpeg, webp, heic\n        \n        var fileExtension: String {\n            switch self {\n            case .png: return \"png\"\n            case .jpeg: return \"jpg\"\n            case .webp: return \"webp\"\n            case .heic: return \"heic\"\n            }\n        }\n    }\n    \n    func loadOptimizedImage(named name: String, format: ImageFormat = .png, completion: @escaping (UIImage?) -> Void) {\n        // Check cache first\n        if let cachedImage = imageCache.object(forKey: name as NSString) {\n            completion(cachedImage)\n            return\n        }\n        \n        // Cancel existing operation if any\n        loadingOperations[name]?.cancel()\n        \n        let operation = BlockOperation {\n            guard !Operation.current!.isCancelled else { return }\n            \n            let image: UIImage?\n            \n            switch format {\n            case .png, .jpeg:\n                image = UIImage(named: \"\\(name).\\(format.fileExtension)\")\n            case .webp:\n                image = self.loadWebPImage(named: name)\n            case .heic:\n                image = self.loadHEICImage(named: name)\n            }\n            \n            guard let loadedImage = image, !Operation.current!.isCancelled else {\n                DispatchQueue.main.async { completion(nil) }\n                return\n            }\n            \n            // Optimize and decode image\n            let optimizedImage = self.decodedImage(loadedImage)\n            \n            // Cache the result\n            self.imageCache.setObject(optimizedImage, forKey: name as NSString)\n            \n            DispatchQueue.main.async {\n                completion(optimizedImage)\n            }\n        }\n        \n        loadingOperations[name] = operation\n        operationQueue.addOperation(operation)\n    }\n    \n    private func loadWebPImage(named: String) -> UIImage? {\n        // WebP loading implementation\n        // This would require GoogleWebP framework\n        return UIImage(named: named) // Fallback\n    }\n    \n    private func loadHEICImage(named: String) -> UIImage? {\n        // HEIC loading implementation\n        return UIImage(named: named) // Fallback\n    }\n    \n    private func decodedImage(_ image: UIImage) -> UIImage {\n        // Advanced image decoding optimization\n        UIGraphicsBeginImageContextWithOptions(image.size, false, image.scale)\n        defer { UIGraphicsEndImageContext() }\n        \n        image.draw(at: .zero)\n        return UIGraphicsGetImageFromCurrentImageContext() ?? image\n    }\n    \n    func clearCache() {\n        imageCache.removeAllObjects()\n        loadingOperations.values.forEach { $0.cancel() }\n        loadingOperations.removeAll()\n    }\n}\n\n// === PART 2: Lazy Loading Framework ===\nclass LazyFeatureManager {\n    private var loadedFeatures: [String: Any] = [:]\n    private var featureStates: [String: FeatureState] = [:]\n    private var usageAnalytics: [String: FeatureUsage] = [:]\n    \n    private let analyticsQueue = DispatchQueue(label: \"com.app.featureAnalytics\", qos: .utility)\n    \n    struct FeatureUsage {\n        var accessCount: Int = 0\n        var lastAccess: Date = Date()\n        var loadTime: TimeInterval = 0\n        var memoryUsage: Int = 0\n    }\n    \n    enum FeatureState {\n        case unloaded, loading, loaded, unloading\n    }\n    \n    func loadFeature<T>(_ name: String, loader: @escaping () -> T, priority: LoadPriority = .medium) -> T? {\n        trackFeatureAccess(name)\n        \n        // Check if already loaded\n        if let feature = loadedFeatures[name] as? T {\n            return feature\n        }\n        \n        // Check if loading\n        if featureStates[name] == .loading {\n            // Wait for loading to complete\n            // In real implementation, you'd use proper async handling\n            return nil\n        }\n        \n        featureStates[name] = .loading\n        \n        let startTime = Date()\n        let feature = loader()\n        let loadTime = Date().timeIntervalSince(startTime)\n        \n        loadedFeatures[name] = feature\n        featureStates[name] = .loaded\n        \n        // Track performance\n        analyticsQueue.async {\n            self.usageAnalytics[name, default: FeatureUsage()].loadTime = loadTime\n        }\n        \n        return feature\n    }\n    \n    func unloadFeature(_ name: String) {\n        guard featureStates[name] == .loaded else { return }\n        \n        featureStates[name] = .unloading\n        \n        // Notify feature about unloading\n        if let unloadable = loadedFeatures[name] as? Unloadable {\n            unloadable.prepareForUnload()\n        }\n        \n        loadedFeatures.removeValue(forKey: name)\n        featureStates[name] = .unloaded\n    }\n    \n    func unloadUnusedFeatures() {\n        let now = Date()\n        let unusedThreshold: TimeInterval = 300 // 5 minutes\n        \n        for (name, usage) in usageAnalytics {\n            if now.timeIntervalSince(usage.lastAccess) > unusedThreshold {\n                unloadFeature(name)\n            }\n        }\n    }\n    \n    private func trackFeatureAccess(_ name: String) {\n        analyticsQueue.async {\n            var usage = self.usageAnalytics[name, default: FeatureUsage()]\n            usage.accessCount += 1\n            usage.lastAccess = Date()\n            self.usageAnalytics[name] = usage\n        }\n    }\n    \n    func getUsageAnalytics() -> [String: FeatureUsage] {\n        return analyticsQueue.sync { usageAnalytics }\n    }\n}\n\nenum LoadPriority {\n    case low, medium, high, critical\n}\n\n// === PART 3: On-Demand Resources Manager ===\nclass AdvancedODRManager {\n    private var activeRequests: [Set<String>: NSBundleResourceRequest] = [:]\n    private var prefetchQueue: [Set<String>] = []\n    private var completionHandlers: [Set<String>: [(Result<NSBundleResourceRequest, Error>) -> Void]] = [:]\n    \n    func requestResources(tags: Set<String>, priority: ODRPriority = .normal) -> AnyPublisher<NSBundleResourceRequest, Error> {\n        return Future<NSBundleResourceRequest, Error> { promise in\n            self.requestResources(tags: tags, priority: priority) { result in\n                promise(result)\n            }\n        }\n        .eraseToAnyPublisher()\n    }\n    \n    func requestResources(tags: Set<String>, priority: ODRPriority = .normal, completion: @escaping (Result<NSBundleResourceRequest, Error>) -> Void) {\n        // Store completion handler\n        completionHandlers[tags, default: []].append(completion)\n        \n        // Check if already loading\n        if let existingRequest = activeRequests[tags] {\n            existingRequest.conditionallyBeginAccessingResources { available in\n                if available {\n                    completion(.success(existingRequest))\n                } else {\n                    // Wait for existing request to complete\n                }\n            }\n            return\n        }\n        \n        let request = NSBundleResourceRequest(tags: tags)\n        activeRequests[tags] = request\n        \n        // Set priority\n        request.loadingPriority = priority.loadingPriority\n        \n        // Progress tracking\n        request.progress.addObserver(self, forKeyPath: #keyPath(Progress.fractionCompleted), options: .new, context: nil)\n        \n        request.beginAccessingResources { [weak self] error in\n            guard let self = self else { return }\n            \n            DispatchQueue.main.async {\n                // Call all completion handlers\n                let handlers = self.completionHandlers[tags] ?? []\n                \n                if let error = error {\n                    handlers.forEach { $0(.failure(error)) }\n                } else {\n                    handlers.forEach { $0(.success(request)) }\n                }\n                \n                // Cleanup\n                self.completionHandlers.removeValue(forKey: tags)\n                self.activeRequests.removeValue(forKey: tags)\n            }\n        }\n    }\n    \n    func prefetchResources(tags: Set<String>) {\n        prefetchQueue.append(tags)\n        processPrefetchQueue()\n    }\n    \n    private func processPrefetchQueue() {\n        guard !prefetchQueue.isEmpty else { return }\n        \n        let tags = prefetchQueue.removeFirst()\n        \n        requestResources(tags: tags, priority: .prefetch) { result in\n            // Continue with next in queue\n            self.processPrefetchQueue()\n        }\n    }\n    \n    override func observeValue(forKeyPath keyPath: String?, of object: Any?, change: [NSKeyValueChangeKey : Any]?, context: UnsafeMutableRawPointer?) {\n        if keyPath == #keyPath(Progress.fractionCompleted) {\n            // Handle progress updates\n            print(\"ODR download progress: \\(change?[.newKey] as? Double ?? 0)\")\n        }\n    }\n}\n\nenum ODRPriority {\n    case prefetch, normal, urgent\n    \n    var loadingPriority: Double {\n        switch self {\n        case .prefetch: return NSBundleResourceRequestLoadingPriorityPrefetch\n        case .normal: return NSBundleResourceRequestLoadingPriorityDefault\n        case .urgent: return NSBundleResourceRequestLoadingPriorityUrgent\n        }\n    }\n}\n\n// === PART 4: Build Analysis & Reporting ===\nclass BuildSizeAnalyzer {\n    \n    struct SizeReport {\n        let totalSize: Int\n        let executableSize: Int\n        let resourcesSize: Int\n        let frameworksSize: Int\n        let recommendations: [OptimizationRecommendation]\n    }\n    \n    struct OptimizationRecommendation {\n        let category: String\n        let description: String\n        let estimatedSavings: Int\n        let priority: Priority\n    }\n    \n    enum Priority {\n        case low, medium, high, critical\n    }\n    \n    func generateSizeReport() -> SizeReport {\n        let totalSize = calculateTotalSize()\n        let executableSize = calculateExecutableSize()\n        let resourcesSize = calculateResourcesSize()\n        let frameworksSize = calculateFrameworksSize()\n        let recommendations = generateRecommendations(\n            totalSize: totalSize,\n            executableSize: executableSize,\n            resourcesSize: resourcesSize,\n            frameworksSize: frameworksSize\n        )\n        \n        return SizeReport(\n            totalSize: totalSize,\n            executableSize: executableSize,\n            resourcesSize: resourcesSize,\n            frameworksSize: frameworksSize,\n            recommendations: recommendations\n        )\n    }\n    \n    private func calculateTotalSize() -> Int {\n        guard let bundlePath = Bundle.main.bundlePath else { return 0 }\n        return directorySize(at: URL(fileURLWithPath: bundlePath)) ?? 0\n    }\n    \n    private func calculateExecutableSize() -> Int {\n        // Implementation for executable size calculation\n        return 0\n    }\n    \n    private func calculateResourcesSize() -> Int {\n        // Implementation for resources size calculation\n        return 0\n    }\n    \n    private func calculateFrameworksSize() -> Int {\n        // Implementation for frameworks size calculation\n        return 0\n    }\n    \n    private func generateRecommendations(totalSize: Int, executableSize: Int, resourcesSize: Int, frameworksSize: Int) -> [OptimizationRecommendation] {\n        var recommendations: [OptimizationRecommendation] = []\n        \n        // Analyze and generate recommendations based on size data\n        if resourcesSize > totalSize / 2 {\n            recommendations.append(OptimizationRecommendation(\n                category: \"Assets\",\n                description: \"Consider using On-Demand Resources for large assets\",\n                estimatedSavings: resourcesSize / 3,\n                priority: .high\n            ))\n        }\n        \n        if executableSize > 50 * 1024 * 1024 { // 50MB\n            recommendations.append(OptimizationRecommendation(\n                category: \"Code\",\n                description: \"Large executable size, consider dead code elimination\",\n                estimatedSavings: executableSize / 4,\n                priority: .medium\n            ))\n        }\n        \n        return recommendations\n    }\n    \n    private func directorySize(at url: URL) -> Int? {\n        guard let enumerator = FileManager.default.enumerator(\n            at: url,\n            includingPropertiesForKeys: [.fileSizeKey],\n            options: [.skipsHiddenFiles]\n        ) else { return nil }\n        \n        var totalSize = 0\n        for case let fileURL as URL in enumerator {\n            do {\n                let resourceValues = try fileURL.resourceValues(forKeys: [.fileSizeKey])\n                totalSize += resourceValues.fileSize ?? 0\n            } catch {\n                continue\n            }\n        }\n        return totalSize\n    }\n}\n\n// === PART 5: Advanced Optimization Techniques ===\nclass AdvancedFontManager {\n    \n    func loadFontSubset(from fontURL: URL, characters: Set<Character>) -> Bool {\n        // This is a simplified example\n        // Real font subsetting requires complex font processing\n        \n        guard let fontData = try? Data(contentsOf: fontURL) else {\n            return false\n        }\n        \n        // In real implementation, you would:\n        // 1. Parse the font file\n        // 2. Extract only the needed glyphs\n        // 3. Create a new font file with subset\n        // 4. Register the subset font\n        \n        return registerFontData(fontData)\n    }\n    \n    private func registerFontData(_ data: Data) -> Bool {\n        guard let dataProvider = CGDataProvider(data: data as CFData),\n              let font = CGFont(dataProvider) else {\n            return false\n        }\n        \n        var error: Unmanaged<CFError>?\n        return CTFontManagerRegisterGraphicsFont(font, &error)\n    }\n}\n\nclass TextureAtlasManager {\n    private var atlases: [String: SKTextureAtlas] = [:]\n    private var atlasMetadata: [String: AtlasMetadata] = [:]\n    \n    struct AtlasMetadata {\n        let textureCount: Int\n        let memoryUsage: Int\n        let lastAccess: Date\n    }\n    \n    func createOptimizedAtlas(from images: [String], atlasName: String) {\n        // Implementation for creating optimized texture atlases\n        // This would involve:\n        // 1. Packing images efficiently\n        // 2. Creating texture atlas file\n        // 3. Preloading the atlas\n        \n        let atlas = SKTextureAtlas(named: atlasName)\n        atlases[atlasName] = atlas\n        \n        // Preload in background\n        DispatchQueue.global(qos: .utility).async {\n            atlas.preload {\n                DispatchQueue.main.async {\n                    // Atlas ready for use\n                    print(\"Atlas \\(atlasName) loaded successfully\")\n                }\n            }\n        }\n    }\n    \n    func getTexture(fromAtlas atlasName: String, textureName: String) -> SKTexture? {\n        updateAtlasAccessTime(atlasName)\n        return atlases[atlasName]?.textureNamed(textureName)\n    }\n    \n    private func updateAtlasAccessTime(_ atlasName: String) {\n        // Update last access time for LRU cleanup\n    }\n    \n    func cleanupUnusedAtlases() {\n        let now = Date()\n        let unusedThreshold: TimeInterval = 600 // 10 minutes\n        \n        for (atlasName, metadata) in atlasMetadata {\n            if now.timeIntervalSince(metadata.lastAccess) > unusedThreshold {\n                atlases.removeValue(forKey: atlasName)\n                atlasMetadata.removeValue(forKey: atlasName)\n            }\n        }\n    }\n}",
        "hints": [
          "PART 1: Use NSCache with appropriate memory limits for image caching",
          "PART 2: Track feature usage patterns to optimize loading strategies",
          "PART 3: Implement proper error handling and progress tracking for ODR",
          "PART 4: Analyze different app components separately for targeted optimizations",
          "PART 5: Font subsetting can significantly reduce bundle size for custom fonts",
          "Use OperationQueue for controlled concurrent asset loading",
          "Implement LRU (Least Recently Used) cache eviction policies",
          "Monitor memory warnings and automatically clear caches when needed",
          "Use Combine for reactive resource management where appropriate"
        ],
        "testCases": [
          {
            "input": "imageCache.countLimit == 150",
            "expectedOutput": "true",
            "description": "Image cache should have reasonable size limits"
          },
          {
            "input": "operationQueue.maxConcurrentOperationCount == 3",
            "expectedOutput": "true",
            "description": "Operation queue should limit concurrent operations"
          },
          {
            "input": "prefetchQueue.isEmpty == true",
            "expectedOutput": "true",
            "description": "Prefetch queue should be processable"
          }
        ]
      }
    },
    {
      "id": "networking_optimization",
      "title": "Networking Optimization",
      "description": "Master advanced networking techniques including caching strategies, image loading optimization, and performance tuning for high-performance iOS applications",
      "difficulty": "advanced",
      "theory": "# Networking Optimization - Advanced iOS Performance\n\n## 1. Advanced Caching Strategies (90 min)\n\n### Multi-Layer Cache Architecture\n\n**Memory + Disk + Network Cache Strategy:**\n```swift\nclass MultiLayerCache<Key: Hashable, Value> {\n    private let memoryCache: NSCache<NSString, AnyObject>\n    private let diskCache: DiskCache<Key, Value>\n    private let networkManager: NetworkManager\n    \n    init(memoryCacheLimit: Int = 100, diskCacheLimit: Int = 1000) {\n        self.memoryCache = NSCache()\n        self.memoryCache.countLimit = memoryCacheLimit\n        self.diskCache = DiskCache(limit: diskCacheLimit)\n        self.networkManager = NetworkManager()\n    }\n}\n```\n\n### Cache Invalidation Strategies\n\n**Time-Based Invalidation:**\n```swift\nstruct CachedItem<T> {\n    let value: T\n    let timestamp: Date\n    let timeToLive: TimeInterval\n    \n    var isExpired: Bool {\n        return Date().timeIntervalSince(timestamp) > timeToLive\n    }\n}\n\nclass TimeBasedCache<T> {\n    private var storage: [String: CachedItem<T>] = [:]\n    \n    func insert(_ value: T, forKey key: String, ttl: TimeInterval = 300) {\n        let item = CachedItem(value: value, timestamp: Date(), timeToLive: ttl)\n        storage[key] = item\n    }\n    \n    func value(forKey key: String) -> T? {\n        guard let item = storage[key], !item.isExpired else {\n            storage.removeValue(forKey: key)\n            return nil\n        }\n        return item.value\n    }\n}\n```\n\n**LRU (Least Recently Used) Cache:**\n```swift\nclass LRUCache<Key: Hashable, Value> {\n    private let capacity: Int\n    private var cache: [Key: DoubleLinkedList<Key, Value>.Node]\n    private let list: DoubleLinkedList<Key, Value>\n    \n    init(capacity: Int) {\n        self.capacity = capacity\n        self.cache = [:]\n        self.list = DoubleLinkedList()\n    }\n    \n    func get(_ key: Key) -> Value? {\n        guard let node = cache[key] else { return nil }\n        \n        // Move to front (most recently used)\n        list.remove(node)\n        list.append(node)\n        \n        return node.value\n    }\n    \n    func put(_ key: Key, _ value: Value) {\n        if let node = cache[key] {\n            node.value = value\n            list.remove(node)\n            list.append(node)\n        } else {\n            let newNode = list.append(key, value)\n            cache[key] = newNode\n            \n            if cache.count > capacity {\n                // Remove least recently used\n                if let lruNode = list.head {\n                    list.remove(lruNode)\n                    cache.removeValue(forKey: lruNode.key)\n                }\n            }\n        }\n    }\n}\n```\n\n## 2. Advanced Image Loading & Optimization (90 min)\n\n### Progressive Image Loading\n\n**Progressive JPEG Decoding:**\n```swift\nclass ProgressiveImageLoader {\n    private let urlSession: URLSession\n    private var dataTasks: [URL: URLSessionDataTask] = [:]\n    private var imageData: [URL: Data] = [:]\n    \n    func loadProgressiveImage(from url: URL, progress: @escaping (UIImage?) -> Void, completion: @escaping (Result<UIImage, Error>) -> Void) {\n        var request = URLRequest(url: url)\n        request.setValue(\"bytes=0-\", forHTTPHeaderField: \"Range\")\n        \n        let task = urlSession.dataTask(with: request) { [weak self] data, response, error in\n            guard let self = self else { return }\n            \n            if let error = error {\n                completion(.failure(error))\n                return\n            }\n            \n            guard let data = data else {\n                completion(.failure(NetworkError.noData))\n                return\n            }\n            \n            // Store partial data\n            self.imageData[url, default: Data()].append(data)\n            \n            // Attempt to create image from partial data\n            if let partialImage = self.createImage(from: self.imageData[url]!) {\n                DispatchQueue.main.async {\n                    progress(partialImage)\n                }\n            }\n            \n            // Continue loading if not complete\n            if self.isDownloadComplete(response: response) {\n                if let finalImage = UIImage(data: self.imageData[url]!) {\n                    completion(.success(finalImage))\n                } else {\n                    completion(.failure(NetworkError.invalidImageData))\n                }\n                self.imageData.removeValue(forKey: url)\n            }\n        }\n        \n        dataTasks[url] = task\n        task.resume()\n    }\n}\n```\n\n### Image Memory Optimization\n\n**Downsampling Large Images:**\n```swift\nclass ImageDownsampler {\n    static func downsample(imageAt imageURL: URL, to pointSize: CGSize, scale: CGFloat = UIScreen.main.scale) -> UIImage? {\n        let imageSourceOptions = [kCGImageSourceShouldCache: false] as CFDictionary\n        guard let imageSource = CGImageSourceCreateWithURL(imageURL as CFURL, imageSourceOptions) else {\n            return nil\n        }\n        \n        let maxDimensionInPixels = max(pointSize.width, pointSize.height) * scale\n        \n        let downsampleOptions = [\n            kCGImageSourceCreateThumbnailFromImageAlways: true,\n            kCGImageSourceShouldCacheImmediately: true,\n            kCGImageSourceCreateThumbnailWithTransform: true,\n            kCGImageSourceThumbnailMaxPixelSize: maxDimensionInPixels\n        ] as CFDictionary\n        \n        guard let downsampledImage = CGImageSourceCreateThumbnailAtIndex(imageSource, 0, downsampleOptions) else {\n            return nil\n        }\n        \n        return UIImage(cgImage: downsampledImage)\n    }\n    \n    static func downsample(imageData: Data, to pointSize: CGSize, scale: CGFloat = UIScreen.main.scale) -> UIImage? {\n        let imageSourceOptions = [kCGImageSourceShouldCache: false] as CFDictionary\n        guard let imageSource = CGImageSourceCreateWithData(imageData as CFData, imageSourceOptions) else {\n            return nil\n        }\n        \n        return downsample(imageSource: imageSource, to: pointSize, scale: scale)\n    }\n}\n```\n\n**Memory-Efficient Image Caching:**\n```swift\nclass MemoryEfficientImageCache {\n    private let cache: NSCache<NSString, UIImage>\n    private let costCalculator: (UIImage) -> Int\n    \n    init(\n        totalCostLimit: Int = 1024 * 1024 * 100, // 100MB\n        costCalculator: @escaping (UIImage) -> Int = { image in\n            // Calculate memory cost based on actual image size\n            guard let cgImage = image.cgImage else { return 1 }\n            return cgImage.bytesPerRow * cgImage.height\n        }\n    ) {\n        self.cache = NSCache()\n        self.cache.totalCostLimit = totalCostLimit\n        self.costCalculator = costCalculator\n    }\n    \n    func image(forKey key: String) -> UIImage? {\n        return cache.object(forKey: key as NSString)\n    }\n    \n    func insertImage(_ image: UIImage, forKey key: String) {\n        let cost = costCalculator(image)\n        cache.setObject(image, forKey: key as NSString, cost: cost)\n    }\n    \n    func removeAll() {\n        cache.removeAllObjects()\n    }\n}\n```\n\n## 3. Advanced URLSession Configuration (60 min)\n\n### Custom URLSession Configuration\n\n**High-Performance Session Configuration:**\n```swift\nclass HighPerformanceNetworkManager {\n    private let session: URLSession\n    private let delegate: NetworkSessionDelegate\n    \n    init() {\n        let configuration = URLSessionConfiguration.ephemeral\n        \n        // Optimize for performance\n        configuration.timeoutIntervalForRequest = 30\n        configuration.timeoutIntervalForResource = 300\n        configuration.waitsForConnectivity = true\n        configuration.httpMaximumConnectionsPerHost = 6\n        configuration.requestCachePolicy = .reloadRevalidatingCacheData\n        \n        // Enable HTTP/2 and other optimizations\n        configuration.httpShouldUsePipelining = true\n        configuration.httpAdditionalHeaders = [\n            \"Accept\": \"application/json\",\n            \"Accept-Encoding\": \"gzip, deflate, br\"\n        ]\n        \n        self.delegate = NetworkSessionDelegate()\n        self.session = URLSession(\n            configuration: configuration,\n            delegate: delegate,\n            delegateQueue: nil\n        )\n    }\n}\n\nclass NetworkSessionDelegate: NSObject, URLSessionDelegate, URLSessionTaskDelegate {\n    \n    // Monitor and optimize network tasks\n    func urlSession(_ session: URLSession, task: URLSessionTask, didFinishCollecting metrics: URLSessionTaskMetrics) {\n        analyzeNetworkMetrics(metrics)\n    }\n    \n    private func analyzeNetworkMetrics(_ metrics: URLSessionTaskMetrics) {\n        guard let transactionMetrics = metrics.transactionMetrics.last else { return }\n        \n        let domainLookupTime = transactionMetrics.domainLookupEndDate?.timeIntervalSince(transactionMetrics.domainLookupStartDate ?? Date()) ?? 0\n        let connectTime = transactionMetrics.connectEndDate?.timeIntervalSince(transactionMetrics.connectStartDate ?? Date()) ?? 0\n        let requestTime = transactionMetrics.requestEndDate?.timeIntervalSince(transactionMetrics.requestStartDate ?? Date()) ?? 0\n        let responseTime = transactionMetrics.responseEndDate?.timeIntervalSince(transactionMetrics.responseStartDate ?? Date()) ?? 0\n        \n        // Log performance metrics\n        print(\"\"\"\n        Network Performance Metrics:\n        - Domain Lookup: \\(domainLookupTime)s\n        - Connect Time: \\(connectTime)s\n        - Request Time: \\(requestTime)s\n        - Response Time: \\(responseTime)s\n        - Protocol: \\(transactionMetrics.networkProtocolType ?? \"Unknown\")\n        \"\"\")\n    }\n}\n```\n\n### Background Session Optimization\n\n**Efficient Background Transfers:**\n```swift\nclass BackgroundTransferManager: NSObject {\n    private var backgroundSession: URLSession!\n    private var completionHandlers: [String: (Result<URL, Error>) -> Void] = [:]\n    \n    override init() {\n        super.init()\n        \n        let configuration = URLSessionConfiguration.background(withIdentifier: \"com.yourapp.backgroundTransfer\")\n        configuration.isDiscretionary = false // Don't wait for optimal conditions\n        configuration.sessionSendsLaunchEvents = true\n        configuration.timeoutIntervalForResource = 24 * 60 * 60 // 24 hours\n        \n        self.backgroundSession = URLSession(\n            configuration: configuration,\n            delegate: self,\n            delegateQueue: nil\n        )\n    }\n    \n    func downloadLargeFile(from url: URL, completion: @escaping (Result<URL, Error>) -> Void) {\n        let task = backgroundSession.downloadTask(with: url)\n        completionHandlers[task.taskDescription ?? UUID().uuidString] = completion\n        task.resume()\n    }\n}\n\nextension BackgroundTransferManager: URLSessionDownloadDelegate {\n    func urlSession(_ session: URLSession, downloadTask: URLSessionDownloadTask, didFinishDownloadingTo location: URL) {\n        // Handle downloaded file\n        let fileManager = FileManager.default\n        let documentsURL = fileManager.urls(for: .documentDirectory, in: .userDomainMask)[0]\n        let destinationURL = documentsURL.appendingPathComponent(downloadTask.originalRequest?.url?.lastPathComponent ?? \"file\")\n        \n        do {\n            try fileManager.moveItem(at: location, to: destinationURL)\n            \n            if let taskID = downloadTask.taskDescription {\n                completionHandlers[taskID]?(.success(destinationURL))\n                completionHandlers.removeValue(forKey: taskID)\n            }\n        } catch {\n            if let taskID = downloadTask.taskDescription {\n                completionHandlers[taskID]?(.failure(error))\n                completionHandlers.removeValue(forKey: taskID)\n            }\n        }\n    }\n}\n```\n\n## 4. Request Prioritization & Throttling (60 min)\n\n### Intelligent Request Management\n\n**Request Priority Queue:**\n```swift\nenum RequestPriority: Int, Comparable {\n    case low = 0\n    case normal = 1\n    case high = 2\n    case critical = 3\n    \n    static func < (lhs: RequestPriority, rhs: RequestPriority) -> Bool {\n        return lhs.rawValue < rhs.rawValue\n    }\n}\n\nstruct NetworkRequest {\n    let id: String\n    let urlRequest: URLRequest\n    let priority: RequestPriority\n    let creationDate: Date\n    let estimatedSize: Int // in bytes\n}\n\nclass PriorityRequestQueue {\n    private var highPriorityQueue: [NetworkRequest] = []\n    private var normalPriorityQueue: [NetworkRequest] = []\n    private var lowPriorityQueue: [NetworkRequest] = []\n    private let maxConcurrentRequests: Int\n    private var activeRequests: Set<String> = []\n    \n    init(maxConcurrentRequests: Int = 6) {\n        self.maxConcurrentRequests = maxConcurrentRequests\n    }\n    \n    func enqueue(_ request: NetworkRequest) {\n        switch request.priority {\n        case .high, .critical:\n            highPriorityQueue.append(request)\n        case .normal:\n            normalPriorityQueue.append(request)\n        case .low:\n            lowPriorityQueue.append(request)\n        }\n        \n        processNextRequest()\n    }\n    \n    private func processNextRequest() {\n        guard activeRequests.count < maxConcurrentRequests else { return }\n        \n        let nextRequest: NetworkRequest?\n        \n        if !highPriorityQueue.isEmpty {\n            nextRequest = highPriorityQueue.removeFirst()\n        } else if !normalPriorityQueue.isEmpty {\n            nextRequest = normalPriorityQueue.removeFirst()\n        } else if !lowPriorityQueue.isEmpty {\n            nextRequest = lowPriorityQueue.removeFirst()\n        } else {\n            nextRequest = nil\n        }\n        \n        guard let request = nextRequest else { return }\n        \n        activeRequests.insert(request.id)\n        executeRequest(request)\n    }\n    \n    private func executeRequest(_ request: NetworkRequest) {\n        // Execute the network request\n        let task = URLSession.shared.dataTask(with: request.urlRequest) { [weak self] _, _, _ in\n            guard let self = self else { return }\n            \n            self.activeRequests.remove(request.id)\n            self.processNextRequest()\n        }\n        \n        task.resume()\n    }\n}\n```\n\n**Adaptive Throttling:**\n```swift\nclass AdaptiveThrottler {\n    private var requestHistory: [Date] = []\n    private let windowSize: TimeInterval = 60 // 1 minute window\n    private let maxRequestsPerMinute: Int = 100\n    private var rejectionProbability: Double = 0.0\n    \n    func shouldAllowRequest() -> Bool {\n        cleanupOldRequests()\n        \n        let currentLoad = Double(requestHistory.count) / Double(maxRequestsPerMinute)\n        \n        // Calculate adaptive rejection probability\n        if currentLoad > 0.8 {\n            rejectionProbability = min(1.0, (currentLoad - 0.8) * 5) // Scale probability\n        } else {\n            rejectionProbability = 0.0\n        }\n        \n        // Random rejection based on probability\n        if Double.random(in: 0...1) < rejectionProbability {\n            return false\n        }\n        \n        requestHistory.append(Date())\n        return true\n    }\n    \n    private func cleanupOldRequests() {\n        let cutoffDate = Date().addingTimeInterval(-windowSize)\n        requestHistory.removeAll { $0 < cutoffDate }\n    }\n    \n    func getThrottlingInfo() -> (currentLoad: Double, rejectionProbability: Double) {\n        cleanupOldRequests()\n        let load = Double(requestHistory.count) / Double(maxRequestsPerMinute)\n        return (load, rejectionProbability)\n    }\n}\n```\n\n## 5. Performance Monitoring & Analytics (60 min)\n\n### Network Performance Tracking\n\n**Comprehensive Metrics Collection:**\n```swift\nstruct NetworkMetrics {\n    let requestStartTime: Date\n    let domainLookupStartTime: Date?\n    let domainLookupEndTime: Date?\n    let connectStartTime: Date?\n    let connectEndTime: Date?\n    let secureConnectionStartTime: Date?\n    let secureConnectionEndTime: Date?\n    let requestStart: Date?\n    let requestEnd: Date?\n    let responseStart: Date?\n    let responseEnd: Date?\n    let responseSize: Int?\n    let statusCode: Int?\n    let error: Error?\n    \n    var totalDuration: TimeInterval {\n        return responseEnd?.timeIntervalSince(requestStartTime) ?? 0\n    }\n    \n    var domainLookupDuration: TimeInterval {\n        guard let start = domainLookupStartTime, let end = domainLookupEndTime else { return 0 }\n        return end.timeIntervalSince(start)\n    }\n    \n    var connectDuration: TimeInterval {\n        guard let start = connectStartTime, let end = connectEndTime else { return 0 }\n        return end.timeIntervalSince(start)\n    }\n    \n    var requestDuration: TimeInterval {\n        guard let start = requestStart, let end = requestEnd else { return 0 }\n        return end.timeIntervalSince(start)\n    }\n    \n    var responseDuration: TimeInterval {\n        guard let start = responseStart, let end = responseEnd else { return 0 }\n        return end.timeIntervalSince(start)\n    }\n}\n\nclass NetworkMetricsCollector {\n    private var metrics: [String: NetworkMetrics] = [:]\n    private let analyticsService: AnalyticsService\n    \n    func startTrackingRequest(_ request: URLRequest, identifier: String) {\n        let metrics = NetworkMetrics(requestStartTime: Date())\n        self.metrics[identifier] = metrics\n    }\n    \n    func updateMetrics(for identifier: String, with taskMetrics: URLSessionTaskMetrics) {\n        guard var currentMetrics = metrics[identifier] else { return }\n        \n        if let transactionMetric = taskMetrics.transactionMetrics.last {\n            // Update metrics with detailed timing information\n            // ... implementation details\n        }\n        \n        metrics[identifier] = currentMetrics\n    }\n    \n    func completeRequest(_ identifier: String, error: Error? = nil) {\n        guard var currentMetrics = metrics[identifier] else { return }\n        \n        currentMetrics.error = error\n        \n        // Send to analytics\n        analyticsService.recordNetworkEvent(currentMetrics)\n        \n        metrics.removeValue(forKey: identifier)\n    }\n}\n```\n\n## 6. Advanced Error Handling & Retry Strategies (60 min)\n\n### Sophisticated Retry Mechanisms\n\n**Exponential Backoff with Jitter:**\n```swift\nstruct RetryPolicy {\n    let maxRetryCount: Int\n    let baseDelay: TimeInterval\n    let maxDelay: TimeInterval\n    let jitter: Bool\n    \n    func delay(forRetryCount retryCount: Int) -> TimeInterval {\n        guard retryCount > 0 else { return 0 }\n        \n        let exponentialDelay = min(maxDelay, baseDelay * pow(2.0, Double(retryCount - 1)))\n        \n        if jitter {\n            // Add random jitter to avoid thundering herd problem\n            let jitterAmount = exponentialDelay * 0.1\n            return exponentialDelay + Double.random(in: -jitterAmount...jitterAmount)\n        } else {\n            return exponentialDelay\n        }\n    }\n}\n\nclass IntelligentRetryHandler {\n    private let retryPolicy: RetryPolicy\n    private var retryCounts: [String: Int] = [:]\n    \n    init(retryPolicy: RetryPolicy = RetryPolicy(maxRetryCount: 3, baseDelay: 1.0, maxDelay: 30.0, jitter: true)) {\n        self.retryPolicy = retryPolicy\n    }\n    \n    func shouldRetry(requestId: String, error: Error) -> (shouldRetry: Bool, delay: TimeInterval) {\n        let currentRetryCount = retryCounts[requestId, default: 0]\n        \n        guard currentRetryCount < retryPolicy.maxRetryCount else {\n            return (false, 0)\n        }\n        \n        // Only retry on certain errors\n        guard isRetryableError(error) else {\n            return (false, 0)\n        }\n        \n        let nextRetryCount = currentRetryCount + 1\n        retryCounts[requestId] = nextRetryCount\n        \n        let delay = retryPolicy.delay(forRetryCount: nextRetryCount)\n        return (true, delay)\n    }\n    \n    private func isRetryableError(_ error: Error) -> Bool {\n        // Define which errors are retryable\n        let nsError = error as NSError\n        \n        switch nsError.code {\n        case NSURLErrorTimedOut,\n             NSURLErrorCannotConnectToHost,\n             NSURLErrorNetworkConnectionLost,\n             NSURLErrorNotConnectedToInternet,\n             NSURLErrorDataNotAllowed:\n            return true\n        case NSURLErrorBadServerResponse where (500...599).contains(nsError.userInfo[\"statusCode\"] as? Int ?? 0):\n            return true\n        default:\n            return false\n        }\n    }\n    \n    func resetRetryCount(for requestId: String) {\n        retryCounts.removeValue(forKey: requestId)\n    }\n}\n```\n\n## Best Practices Summary\n\n- Implement multi-layer caching (memory + disk + network)\n- Use progressive loading for large images\n- Downsample images to appropriate display sizes\n- Configure URLSession for optimal performance\n- Implement intelligent request prioritization\n- Use adaptive throttling to prevent overload\n- Collect and analyze network performance metrics\n- Implement sophisticated retry strategies with exponential backoff",
      "codeExample": "import UIKit\nimport Foundation\n\n// === MULTI-LAYER CACHE IMPLEMENTATION ===\nclass MultiLayerImageCache {\n    static let shared = MultiLayerImageCache()\n    \n    private let memoryCache: NSCache<NSString, UIImage>\n    private let diskCache: DiskImageCache\n    private let networkLoader: NetworkImageLoader\n    private let operationQueue: OperationQueue\n    \n    private init() {\n        self.memoryCache = NSCache()\n        self.memoryCache.totalCostLimit = 1024 * 1024 * 50 // 50MB\n        \n        self.diskCache = DiskImageCache()\n        self.networkLoader = NetworkImageLoader()\n        \n        self.operationQueue = OperationQueue()\n        self.operationQueue.maxConcurrentOperationCount = 6\n        self.operationQueue.qualityOfService = .userInitiated\n    }\n    \n    func loadImage(from url: URL, completion: @escaping (Result<UIImage, Error>) -> Void) -> Cancellable? {\n        let key = url.absoluteString\n        \n        // 1. Check memory cache\n        if let memoryImage = memoryCache.object(forKey: key as NSString) {\n            completion(.success(memoryImage))\n            return nil\n        }\n        \n        // 2. Check disk cache\n        if let diskImage = diskCache.image(forKey: key) {\n            // Store in memory cache for future use\n            memoryCache.setObject(diskImage, forKey: key as NSString)\n            completion(.success(diskImage))\n            return nil\n        }\n        \n        // 3. Load from network\n        let operation = ImageLoadOperation(url: url, cache: self)\n        operation.completionHandler = completion\n        operationQueue.addOperation(operation)\n        \n        return operation\n    }\n    \n    func storeImage(_ image: UIImage, forKey key: String) {\n        // Store in memory cache\n        memoryCache.setObject(image, forKey: key as NSString)\n        \n        // Store in disk cache asynchronously\n        DispatchQueue.global(qos: .utility).async {\n            self.diskCache.storeImage(image, forKey: key)\n        }\n    }\n}\n\n// === DISK CACHE IMPLEMENTATION ===\nclass DiskImageCache {\n    private let fileManager: FileManager\n    private let cacheDirectory: URL\n    private let ioQueue: DispatchQueue\n    \n    init() {\n        self.fileManager = FileManager.default\n        \n        let cachesDirectory = fileManager.urls(for: .cachesDirectory, in: .userDomainMask).first!\n        self.cacheDirectory = cachesDirectory.appendingPathComponent(\"ImageCache\")\n        \n        self.ioQueue = DispatchQueue(label: \"com.yourapp.diskcache.io\", qos: .utility)\n        \n        createCacheDirectoryIfNeeded()\n    }\n    \n    private func createCacheDirectoryIfNeeded() {\n        ioQueue.async {\n            if !self.fileManager.fileExists(atPath: self.cacheDirectory.path) {\n                try? self.fileManager.createDirectory(at: self.cacheDirectory, withIntermediateDirectories: true)\n            }\n        }\n    }\n    \n    func image(forKey key: String) -> UIImage? {\n        let fileURL = cacheDirectory.appendingPathComponent(key.sha256)\n        \n        return ioQueue.sync {\n            guard fileManager.fileExists(atPath: fileURL.path),\n                  let data = try? Data(contentsOf: fileURL),\n                  let image = UIImage(data: data) else {\n                return nil\n            }\n            return image\n        }\n    }\n    \n    func storeImage(_ image: UIImage, forKey key: String) {\n        ioQueue.async {\n            let fileURL = self.cacheDirectory.appendingPathComponent(key.sha256)\n            \n            if let data = image.pngData() {\n                try? data.write(to: fileURL)\n            }\n        }\n    }\n}\n\n// === NETWORK IMAGE LOADER ===\nclass NetworkImageLoader {\n    private let urlSession: URLSession\n    private let downsampler: ImageDownsampler\n    \n    init() {\n        let configuration = URLSessionConfiguration.default\n        configuration.timeoutIntervalForRequest = 30\n        configuration.httpMaximumConnectionsPerHost = 6\n        \n        self.urlSession = URLSession(configuration: configuration)\n        self.downsampler = ImageDownsampler()\n    }\n    \n    func loadImage(from url: URL, targetSize: CGSize? = nil, completion: @escaping (Result<UIImage, Error>) -> Void) -> URLSessionDataTask {\n        let task = urlSession.dataTask(with: url) { [weak self] data, response, error in\n            guard let self = self else { return }\n            \n            if let error = error {\n                completion(.failure(error))\n                return\n            }\n            \n            guard let data = data, !data.isEmpty else {\n                completion(.failure(NetworkError.noData))\n                return\n            }\n            \n            do {\n                let image: UIImage\n                \n                if let targetSize = targetSize {\n                    // Downsample large images\n                    guard let downsampledImage = self.downsampler.downsample(imageData: data, to: targetSize) else {\n                        throw NetworkError.invalidImageData\n                    }\n                    image = downsampledImage\n                } else {\n                    guard let loadedImage = UIImage(data: data) else {\n                        throw NetworkError.invalidImageData\n                    }\n                    image = loadedImage\n                }\n                \n                completion(.success(image))\n            } catch {\n                completion(.failure(error))\n            }\n        }\n        \n        task.resume()\n        return task\n    }\n}\n\n// === IMAGE DOWNSAMPLER ===\nclass ImageDownsampler {\n    func downsample(imageAt imageURL: URL, to pointSize: CGSize, scale: CGFloat = UIScreen.main.scale) -> UIImage? {\n        let imageSourceOptions = [kCGImageSourceShouldCache: false] as CFDictionary\n        guard let imageSource = CGImageSourceCreateWithURL(imageURL as CFURL, imageSourceOptions) else {\n            return nil\n        }\n        \n        return downsample(imageSource: imageSource, to: pointSize, scale: scale)\n    }\n    \n    func downsample(imageData: Data, to pointSize: CGSize, scale: CGFloat = UIScreen.main.scale) -> UIImage? {\n        let imageSourceOptions = [kCGImageSourceShouldCache: false] as CFDictionary\n        guard let imageSource = CGImageSourceCreateWithData(imageData as CFData, imageSourceOptions) else {\n            return nil\n        }\n        \n        return downsample(imageSource: imageSource, to: pointSize, scale: scale)\n    }\n    \n    private func downsample(imageSource: CGImageSource, to pointSize: CGSize, scale: CGFloat) -> UIImage? {\n        let maxDimensionInPixels = max(pointSize.width, pointSize.height) * scale\n        \n        let downsampleOptions = [\n            kCGImageSourceCreateThumbnailFromImageAlways: true,\n            kCGImageSourceShouldCacheImmediately: true,\n            kCGImageSourceCreateThumbnailWithTransform: true,\n            kCGImageSourceThumbnailMaxPixelSize: maxDimensionInPixels\n        ] as CFDictionary\n        \n        guard let downsampledImage = CGImageSourceCreateThumbnailAtIndex(imageSource, 0, downsampleOptions) else {\n            return nil\n        }\n        \n        return UIImage(cgImage: downsampledImage)\n    }\n}\n\n// === OPERATION FOR IMAGE LOADING ===\nclass ImageLoadOperation: Operation, Cancellable {\n    let url: URL\n    weak var cache: MultiLayerImageCache?\n    var completionHandler: ((Result<UIImage, Error>) -> Void)?\n    \n    private var dataTask: URLSessionDataTask?\n    \n    init(url: URL, cache: MultiLayerImageCache?) {\n        self.url = url\n        self.cache = cache\n        super.init()\n    }\n    \n    override func main() {\n        guard !isCancelled else { return }\n        \n        let semaphore = DispatchSemaphore(value: 0)\n        \n        dataTask = NetworkImageLoader().loadImage(from: url) { [weak self] result in\n            guard let self = self, !self.isCancelled else { return }\n            \n            switch result {\n            case .success(let image):\n                // Store in cache\n                self.cache?.storeImage(image, forKey: self.url.absoluteString)\n                self.completionHandler?(.success(image))\n            case .failure(let error):\n                self.completionHandler?(.failure(error))\n            }\n            \n            semaphore.signal()\n        }\n        \n        _ = semaphore.wait(timeout: .distantFuture)\n    }\n    \n    override func cancel() {\n        super.cancel()\n        dataTask?.cancel()\n    }\n}\n\n// === PROTOCOLS AND EXTENSIONS ===\nprotocol Cancellable {\n    func cancel()\n}\n\nextension String {\n    var sha256: String {\n        // Simplified implementation - in production use CommonCrypto\n        return self.data(using: .utf8)?.base64EncodedString() ?? self\n    }\n}\n\nenum NetworkError: Error {\n    case noData\n    case invalidImageData\n    case downloadFailed\n}\n\n// === USAGE EXAMPLE ===\nclass OptimizedImageView: UIImageView {\n    private var currentLoadTask: Cancellable?\n    \n    func loadImage(from url: URL, placeholder: UIImage? = nil) {\n        // Cancel previous load task\n        currentLoadTask?.cancel()\n        \n        // Show placeholder\n        self.image = placeholder\n        \n        // Load image using multi-layer cache\n        currentLoadTask = MultiLayerImageCache.shared.loadImage(from: url) { [weak self] result in\n            DispatchQueue.main.async {\n                switch result {\n                case .success(let image):\n                    UIView.transition(with: self!, duration: 0.3, options: .transitionCrossDissolve) {\n                        self?.image = image\n                    }\n                case .failure(let error):\n                    print(\"Failed to load image: \\(error)\")\n                    // Could show error state here\n                }\n            }\n        }\n    }\n    \n    override func didMoveToWindow() {\n        super.didMoveToWindow()\n        \n        // Cancel loading if view is removed from window\n        if window == nil {\n            currentLoadTask?.cancel()\n        }\n    }\n}",
      "category": "Networking & Performance",
      "estimatedTime": 180,
      "dependencies": ["basic_networking", "memory_management", "concurrency"],
      "challenge": {
        "instructions": "Build a high-performance image loading and caching system with advanced optimization features:\n\nPART 1: Multi-Layer Cache Architecture (90 min)\n1. Implement a 3-layer cache system (memory, disk, network) with proper fallback mechanisms\n2. Create an LRU (Least Recently Used) cache for memory management\n3. Implement disk cache with efficient file storage and retrieval\n4. Add cache invalidation strategies (time-based, size-based)\n\nPART 2: Advanced Image Optimization (90 min)\n5. Implement progressive JPEG loading with intermediate image display\n6. Create an image downsampling system for memory efficiency\n7. Build support for WebP and HEIC format optimization\n8. Add image preprocessing (blur, crop, resize) before caching\n\nPART 3: Performance Monitoring & Analytics (60 min)\n9. Implement comprehensive network metrics collection\n10. Create performance analytics for cache hit/miss ratios\n11. Build real-time performance monitoring dashboard\n12. Add adaptive quality adjustment based on network conditions\n\nPART 4: Advanced Request Management (60 min)\n13. Implement request prioritization and queuing system\n14. Create intelligent prefetching for anticipated image loads\n15. Build request deduplication to avoid duplicate downloads\n16. Add request throttling and rate limiting\n\nPART 5: Memory & Battery Optimization (60 min)\n17. Implement memory warning handling and cache purging\n18. Create battery-aware quality adjustments\n19. Build background loading optimization\n20. Add thermal state monitoring and adaptive behavior",
        "starterCode": "import UIKit\nimport Foundation\n\n// === PART 1: Multi-Layer Cache Architecture ===\n// Implement your cache layers here\n\n\n// === PART 2: Advanced Image Optimization ===\n// Add progressive loading and format optimization\n\n\n// === PART 3: Performance Monitoring ===\n// Implement metrics collection and analytics\n\n\n// === PART 4: Advanced Request Management ===\n// Build prioritization and prefetching systems\n\n\n// === PART 5: Memory & Battery Optimization ===\n// Add system resource awareness\n\n",
        "solution": "import UIKit\nimport Foundation\n\n// === PART 1: Multi-Layer Cache Architecture ===\nclass AdvancedImageCache {\n    static let shared = AdvancedImageCache()\n    \n    private let memoryCache: LRUMemoryCache<NSString, UIImage>\n    private let diskCache: AdvancedDiskCache\n    private let networkLoader: OptimizedNetworkLoader\n    private let operationManager: OperationManager\n    \n    private init() {\n        self.memoryCache = LRUMemoryCache(capacity: 100)\n        self.diskCache = AdvancedDiskCache()\n        self.networkLoader = OptimizedNetworkLoader()\n        self.operationManager = OperationManager()\n    }\n    \n    func loadImage(from url: URL, options: ImageLoadOptions = ImageLoadOptions(), completion: @escaping (Result<UIImage, Error>) -> Void) -> Cancellable? {\n        let key = url.absoluteString\n        \n        // Check memory cache first\n        if let memoryImage = memoryCache.getValue(forKey: key as NSString) {\n            completion(.success(memoryImage))\n            return nil\n        }\n        \n        // Check disk cache\n        if let diskImage = diskCache.image(forKey: key, options: options) {\n            // Populate memory cache\n            memoryCache.setValue(diskImage, forKey: key as NSString)\n            completion(.success(diskImage))\n            return nil\n        }\n        \n        // Load from network with operation\n        let operation = AdvancedImageLoadOperation(url: url, options: options, cache: self)\n        operation.completionHandler = completion\n        operationManager.addOperation(operation)\n        \n        return operation\n    }\n    \n    func storeImage(_ image: UIImage, forKey key: String, options: ImageStoreOptions = ImageStoreOptions()) {\n        memoryCache.setValue(image, forKey: key as NSString)\n        \n        DispatchQueue.global(qos: .utility).async {\n            self.diskCache.storeImage(image, forKey: key, options: options)\n        }\n    }\n}\n\nclass LRUMemoryCache<Key: Hashable, Value> {\n    private let capacity: Int\n    private var cache: [Key: DoubleLinkedList<Key, Value>.Node]\n    private let list: DoubleLinkedList<Key, Value>\n    \n    init(capacity: Int) {\n        self.capacity = capacity\n        self.cache = [:]\n        self.list = DoubleLinkedList()\n    }\n    \n    func getValue(forKey key: Key) -> Value? {\n        guard let node = cache[key] else { return nil }\n        \n        // Move to front (most recently used)\n        list.remove(node)\n        list.append(node)\n        \n        return node.value\n    }\n    \n    func setValue(_ value: Value, forKey key: Key) {\n        if let node = cache[key] {\n            node.value = value\n            list.remove(node)\n            list.append(node)\n        } else {\n            let newNode = list.append(key, value)\n            cache[key] = newNode\n            \n            if cache.count > capacity {\n                // Remove least recently used\n                if let lruNode = list.head {\n                    list.remove(lruNode)\n                    cache.removeValue(forKey: lruNode.key)\n                }\n            }\n        }\n    }\n}\n\n// === PART 2: Advanced Image Optimization ===\nclass ProgressiveImageLoader {\n    private let urlSession: URLSession\n    private var progressiveData: [URL: Data] = [:]\n    \n    func loadProgressiveImage(from url: URL, progress: @escaping (UIImage?) -> Void, completion: @escaping (Result<UIImage, Error>) -> Void) -> URLSessionDataTask {\n        var request = URLRequest(url: url)\n        request.setValue(\"bytes=0-\", forHTTPHeaderField: \"Range\")\n        \n        let task = urlSession.dataTask(with: request) { [weak self] data, response, error in\n            guard let self = self else { return }\n            \n            if let error = error {\n                completion(.failure(error))\n                return\n            }\n            \n            guard let data = data else {\n                completion(.failure(NetworkError.noData))\n                return\n            }\n            \n            // Accumulate data\n            self.progressiveData[url, default: Data()].append(data)\n            \n            // Try to create progressive image\n            if let partialImage = self.createProgressiveImage(from: self.progressiveData[url]!) {\n                DispatchQueue.main.async {\n                    progress(partialImage)\n                }\n            }\n            \n            // Check if download is complete\n            if self.isDownloadComplete(response: response) {\n                if let finalImage = UIImage(data: self.progressiveData[url]!) {\n                    completion(.success(finalImage))\n                } else {\n                    completion(.failure(NetworkError.invalidImageData))\n                }\n                self.progressiveData.removeValue(forKey: url)\n            }\n        }\n        \n        task.resume()\n        return task\n    }\n    \n    private func createProgressiveImage(from data: Data) -> UIImage? {\n        // Create progressive JPEG image from partial data\n        guard let imageSource = CGImageSourceCreateWithData(data as CFData, nil) else {\n            return nil\n        }\n        \n        let options = [\n            kCGImageSourceShouldAllowFloat: true,\n            kCGImageSourceCreateThumbnailWithTransform: true,\n            kCGImageSourceCreateThumbnailFromImageAlways: true\n        ] as CFDictionary\n        \n        guard let cgImage = CGImageSourceCreateThumbnailAtIndex(imageSource, 0, options) else {\n            return nil\n        }\n        \n        return UIImage(cgImage: cgImage)\n    }\n    \n    private func isDownloadComplete(response: URLResponse?) -> Bool {\n        guard let httpResponse = response as? HTTPURLResponse else { return true }\n        \n        if let contentRange = httpResponse.allHeaderFields[\"Content-Range\"] as? String {\n            return !contentRange.contains(\"bytes 0-\")\n        }\n        \n        return true\n    }\n}\n\n// === PART 3: Performance Monitoring ===\nclass PerformanceMonitor {\n    private var metrics: [String: ImageLoadMetrics] = [:]\n    private let analyticsService: AnalyticsService\n    \n    func startTrackingLoad(for url: URL) -> String {\n        let trackingId = UUID().uuidString\n        let metrics = ImageLoadMetrics(startTime: Date(), url: url)\n        self.metrics[trackingId] = metrics\n        return trackingId\n    }\n    \n    func recordMemoryCacheHit(_ trackingId: String) {\n        metrics[trackingId]?.cacheType = .memory\n        metrics[trackingId]?.endTime = Date()\n        sendMetrics(trackingId)\n    }\n    \n    func recordDiskCacheHit(_ trackingId: String) {\n        metrics[trackingId]?.cacheType = .disk\n        metrics[trackingId]?.endTime = Date()\n        sendMetrics(trackingId)\n    }\n    \n    func recordNetworkLoad(_ trackingId: String, dataSize: Int) {\n        metrics[trackingId]?.cacheType = .network\n        metrics[trackingId]?.dataSize = dataSize\n        metrics[trackingId]?.endTime = Date()\n        sendMetrics(trackingId)\n    }\n    \n    private func sendMetrics(_ trackingId: String) {\n        guard let metric = metrics[trackingId] else { return }\n        analyticsService.recordImageLoad(metric)\n        metrics.removeValue(forKey: trackingId)\n    }\n}\n\nstruct ImageLoadMetrics {\n    let startTime: Date\n    let url: URL\n    var endTime: Date?\n    var cacheType: CacheType?\n    var dataSize: Int?\n    \n    var loadTime: TimeInterval? {\n        guard let endTime = endTime else { return nil }\n        return endTime.timeIntervalSince(startTime)\n    }\n    \n    enum CacheType {\n        case memory, disk, network\n    }\n}\n\n// === PART 4: Advanced Request Management ===\nclass IntelligentPrefetcher {\n    private let cache: AdvancedImageCache\n    private let prefetchQueue: OperationQueue\n    private var prefetchOperations: [URL: Operation] = [:]\n    \n    init(cache: AdvancedImageCache) {\n        self.cache = cache\n        \n        self.prefetchQueue = OperationQueue()\n        self.prefetchQueue.maxConcurrentOperationCount = 2\n        self.prefetchQueue.qualityOfService = .background\n    }\n    \n    func prefetchImages(_ urls: [URL]) {\n        for url in urls {\n            // Check if already prefetched or in progress\n            if prefetchOperations[url] != nil {\n                continue\n            }\n            \n            let operation = BlockOperation { [weak self] in\n                self?.cache.loadImage(from: url) { _ in\n                    // Prefetch complete\n                    self?.prefetchOperations.removeValue(forKey: url)\n                }\n            }\n            \n            prefetchOperations[url] = operation\n            prefetchQueue.addOperation(operation)\n        }\n    }\n    \n    func cancelPrefetch(for url: URL) {\n        prefetchOperations[url]?.cancel()\n        prefetchOperations.removeValue(forKey: url)\n    }\n}\n\n// === PART 5: Memory & Battery Optimization ===\nclass SystemAwareCacheManager {\n    private let cache: AdvancedImageCache\n    private var memoryWarningObserver: NSObjectProtocol?\n    private var thermalStateObserver: NSObjectProtocol?\n    \n    init(cache: AdvancedImageCache) {\n        self.cache = cache\n        setupObservers()\n    }\n    \n    private func setupObservers() {\n        // Observe memory warnings\n        memoryWarningObserver = NotificationCenter.default.addObserver(\n            forName: UIApplication.didReceiveMemoryWarningNotification,\n            object: nil,\n            queue: .main\n        ) { [weak self] _ in\n            self?.handleMemoryWarning()\n        }\n        \n        // Observe thermal state changes\n        thermalStateObserver = NotificationCenter.default.addObserver(\n            forName: ProcessInfo.thermalStateDidChangeNotification,\n            object: nil,\n            queue: .main\n        ) { [weak self] _ in\n            self?.handleThermalStateChange()\n        }\n    }\n    \n    private func handleMemoryWarning() {\n        // Clear memory cache on memory warning\n        // In a real implementation, this would call cache clearing methods\n        print(\"Memory warning received - clearing caches\")\n    }\n    \n    private func handleThermalStateChange() {\n        let thermalState = ProcessInfo.processInfo.thermalState\n        \n        switch thermalState {\n        case .nominal:\n            // Normal operation\n            break\n        case .fair:\n            // Reduce cache sizes\n            break\n        case .serious:\n            // Further reduce cache sizes and limit network\n            break\n        case .critical:\n            // Clear caches and stop non-essential operations\n            break\n        @unknown default:\n            break\n        }\n    }\n    \n    deinit {\n        if let memoryObserver = memoryWarningObserver {\n            NotificationCenter.default.removeObserver(memoryObserver)\n        }\n        if let thermalObserver = thermalStateObserver {\n            NotificationCenter.default.removeObserver(thermalObserver)\n        }\n    }\n}\n\n// === SUPPORTING STRUCTURES ===\nstruct ImageLoadOptions {\n    var shouldDownsample: Bool = true\n    var targetSize: CGSize?\n    var shouldProgressiveLoad: Bool = false\n    var cachePolicy: CachePolicy = .default\n    \n    enum CachePolicy {\n        case `default`, reloadIgnoringCache, returnCacheElseLoad\n    }\n}\n\nstruct ImageStoreOptions {\n    var compressionQuality: CGFloat = 0.8\n    var shouldStoreOriginal: Bool = false\n    var expiration: TimeInterval = 7 * 24 * 60 * 60 // 1 week\n}\n\nclass DoubleLinkedList<Key, Value> {\n    class Node {\n        let key: Key\n        var value: Value\n        var next: Node?\n        var prev: Node?\n        \n        init(key: Key, value: Value) {\n            self.key = key\n            self.value = value\n        }\n    }\n    \n    private(set) var head: Node?\n    private(set) var tail: Node?\n    \n    func append(_ key: Key, _ value: Value) -> Node {\n        let newNode = Node(key: key, value: value)\n        \n        if let tailNode = tail {\n            tailNode.next = newNode\n            newNode.prev = tailNode\n            tail = newNode\n        } else {\n            head = newNode\n            tail = newNode\n        }\n        \n        return newNode\n    }\n    \n    func append(_ node: Node) {\n        if let tailNode = tail {\n            tailNode.next = node\n            node.prev = tailNode\n            node.next = nil\n            tail = node\n        } else {\n            head = node\n            tail = node\n        }\n    }\n    \n    func remove(_ node: Node) {\n        let prev = node.prev\n        let next = node.next\n        \n        if let prev = prev {\n            prev.next = next\n        } else {\n            head = next\n        }\n        \n        if let next = next {\n            next.prev = prev\n        } else {\n            tail = prev\n        }\n        \n        node.next = nil\n        node.prev = nil\n    }\n}",
        "hints": [
          "PART 1: Use NSCache for memory cache, implement LRU for custom memory management",
          "PART 2: Use CGImageSource for progressive loading, implement format detection",
          "PART 3: Track cache hit ratios and load times for performance optimization",
          "PART 4: Use OperationQueue for request management, implement priority systems",
          "PART 5: Observe system notifications and adjust behavior accordingly",
          "Use Instruments to measure memory usage and optimize cache sizes",
          "Implement proper background task management for iOS lifecycle",
          "Consider using HEIC format for better compression on supported devices"
        ],
        "testCases": [
          {
            "input": "memoryCache.count <= memoryCache.capacity",
            "expectedOutput": "true",
            "description": "Memory cache should never exceed its capacity"
          },
          {
            "input": "diskCache.totalSize < diskCache.sizeLimit",
            "expectedOutput": "true",
            "description": "Disk cache should stay within size limits"
          },
          {
            "input": "progressiveLoader.isLoadingComplete == false || progressiveLoader.hasPartialData == true",
            "expectedOutput": "true",
            "description": "Progressive loader should handle partial data correctly"
          }
        ]
      }
    },
    {
      "id": "performance_audit",
      "title": "Project: Performance Audit",
      "description": "Master advanced performance optimization techniques by conducting comprehensive audits on existing iOS applications",
      "difficulty": "advanced",
      "theory": "# Performance Audit - Advanced iOS Optimization\n\n## 1. Performance Audit Methodology (90 min)\n\n### The Performance Audit Process:\nPerformance auditing is a systematic approach to identifying and resolving performance bottlenecks in iOS applications.\n\n**Audit Framework:**\n```swift\nstruct PerformanceAudit {\n    let metrics: [PerformanceMetric]\n    let tools: [ProfilingTool]\n    let benchmarks: [Benchmark]\n    let optimizationStrategies: [OptimizationStrategy]\n}\n\nenum PerformanceMetric {\n    case startupTime\n    case memoryUsage\n    case cpuUtilization\n    case energyImpact\n    case frameRate\n    case networkEfficiency\n    case diskIOLatency\n}\n```\n\n### Performance Baselines:\nEstablish performance benchmarks before optimization:\n- **Cold Start Time**: < 400ms\n- **Warm Start Time**: < 200ms\n- **Memory Usage**: < 100MB baseline\n- **Frame Rate**: Consistent 60/120 FPS\n- **Energy Impact**: Low/Medium in Energy Debugger\n\n## 2. Advanced Instrumentation & Profiling (120 min)\n\n### Instruments Deep Dive:\n\n#### Time Profiler - Advanced Configuration:\n```swift\n// Symbolication for accurate profiling\nclass PerformanceInstrumentation {\n    private let signpost = OSLog(\n        subsystem: \"com.yourapp.performance\",\n        category: .pointsOfInterest\n    )\n    \n    func trackPerformance<T>(_ operation: String, _ block: () -> T) -> T {\n        let startTime = CACurrentMediaTime()\n        os_signpost(.begin, log: signpost, name: \"Performance\", \"%s\", operation)\n        defer {\n            let duration = CACurrentMediaTime() - startTime\n            os_signpost(.end, log: signpost, name: \"Performance\", \"%s - %.3f\", operation, duration)\n            \n            if duration > 0.016 { // 60 FPS threshold\n                PerformanceMonitor.recordSlowOperation(operation, duration)\n            }\n        }\n        return block()\n    }\n}\n```\n\n#### Memory Graph Debugger:\n```swift\nclass MemoryAuditor {\n    static func analyzeMemoryGraph() {\n        // Check for common memory issues\n        checkForRetainCycles()\n        analyzeUnnecessaryRetention()\n        identifyLargeAllocations()\n        monitorMemoryGrowth()\n    }\n    \n    private static func checkForRetainCycles() {\n        // Use Memory Graph Debugger to identify cycles\n        // Common culpits: closures capturing self, delegate patterns\n    }\n    \n    private static func identifyLargeAllocations() {\n        // Look for:\n        // - Large image allocations\n        // - Unreleased caches\n        // - Background operations holding memory\n    }\n}\n```\n\n### Custom Performance Metrics:\n```swift\nclass AdvancedPerformanceMonitor {\n    private var metrics: [String: PerformanceMetric] = [:]\n    private let samplingQueue = DispatchQueue(\n        label: \"performance.monitor\",\n        qos: .userInitiated\n    )\n    \n    func startTracking(_ metric: String) {\n        samplingQueue.async { [weak self] in\n            self?.metrics[metric] = PerformanceMetric()\n        }\n    }\n    \n    func measure<T>(_ operation: String, _ work: () -> T) -> T {\n        let startTime = mach_absolute_time()\n        let startMemory = getMemoryUsage()\n        \n        defer {\n            let endTime = mach_absolute_time()\n            let endMemory = getMemoryUsage()\n            let duration = nanosecondsToSeconds(endTime - startTime)\n            let memoryDelta = endMemory - startMemory\n            \n            recordMetric(operation, duration: duration, memoryDelta: memoryDelta)\n        }\n        \n        return work()\n    }\n    \n    private func getMemoryUsage() -> Int {\n        var info = task_vm_info_data_t()\n        var count = mach_msg_type_number_t(MemoryLayout<task_vm_info>.size) / 4\n        \n        let result = withUnsafeMutablePointer(to: &info) {\n            $0.withMemoryRebound(to: integer_t.self, capacity: 1) {\n                task_info(mach_task_self_, task_flavor_t(TASK_VM_INFO), $0, &count)\n            }\n        }\n        \n        return result == KERN_SUCCESS ? Int(info.phys_footprint) : 0\n    }\n}\n```\n\n## 3. Memory Optimization Strategies (90 min)\n\n### Advanced Memory Management:\n\n#### Lazy Loading Patterns:\n```swift\nclass OptimizedImageCache {\n    private let cache = NSCache<NSString, UIImage>()\n    private let loadingQueue = DispatchQueue(\n        label: \"image.loading\",\n        qos: .userInitiated,\n        attributes: .concurrent\n    )\n    \n    func loadImageAsync(\n        for key: String,\n        size: CGSize,\n        completion: @escaping (UIImage?) -> Void\n    ) {\n        // Check cache first\n        if let cached = cache.object(forKey: key as NSString) {\n            completion(cached)\n            return\n        }\n        \n        loadingQueue.async { [weak self] in\n            // Downsample large images\n            guard let image = self?.loadAndDownsampleImage(key: key, targetSize: size) else {\n                DispatchQueue.main.async { completion(nil) }\n                return\n            }\n            \n            // Cache the downsample image\n            self?.cache.setObject(image, forKey: key as NSString)\n            \n            DispatchQueue.main.async {\n                completion(image)\n            }\n        }\n    }\n    \n    private func loadAndDownsampleImage(key: String, targetSize: CGSize) -> UIImage? {\n        // Implement image downsampling to reduce memory footprint\n        // Use Image I/O for efficient decoding\n        return nil\n    }\n}\n```\n\n#### Memory-Mapped Files:\n```swift\nclass MemoryMappedDataStore {\n    private var fileHandle: FileHandle?\n    private var fileSize: Int = 0\n    \n    func openFile(at path: String) throws {\n        fileHandle = try FileHandle(forReadingFrom: URL(fileURLWithPath: path))\n        \n        // Get file size for mapping\n        if let attributes = try? FileManager.default.attributesOfItem(atPath: path) {\n            fileSize = attributes[.size] as? Int ?? 0\n        }\n    }\n    \n    func readData(offset: Int, length: Int) -> Data? {\n        guard let handle = fileHandle,\n              offset + length <= fileSize else {\n            return nil\n        }\n        \n        try? handle.seek(toOffset: UInt64(offset))\n        return try? handle.read(upToCount: length)\n    }\n}\n```\n\n### ARC Optimization:\n```swift\nclass ARCPerformanceAnalyzer {\n    static func optimizeReferenceCounting() {\n        // Strategies to reduce ARC overhead:\n        // 1. Use value types where appropriate\n        // 2. Avoid unnecessary object creation in loops\n        // 3. Use unowned/weak references carefully\n        // 4. Batch object operations\n    }\n}\n\nstruct EfficientDataModel {\n    // Value types avoid reference counting\n    let id: UUID\n    let timestamp: Date\n    let values: [Double]\n    \n    // Copy-on-write for efficient large value types\n    private class Storage {\n        var values: [Double]\n        init(values: [Double]) { self.values = values }\n    }\n    \n    private var storage: Storage\n    \n    init(values: [Double]) {\n        self.storage = Storage(values: values)\n        self.id = UUID()\n        self.timestamp = Date()\n    }\n    \n    mutating func updateValue(at index: Int, with value: Double) {\n        if !isKnownUniquelyReferenced(&storage) {\n            storage = Storage(values: storage.values)\n        }\n        storage.values[index] = value\n    }\n}\n```\n\n## 4. CPU & GPU Optimization (90 min)\n\n### Advanced CPU Optimization:\n\n#### Algorithm Optimization:\n```swift\nclass AlgorithmOptimizer {\n    // Replace O(nÂ²) with O(n log n) or O(n)\n    static func findDuplicatesOptimized(_ array: [Int]) -> [Int] {\n        var seen = Set<Int>()\n        var duplicates = Set<Int>()\n        \n        for element in array {\n            if seen.contains(element) {\n                duplicates.insert(element)\n            } else {\n                seen.insert(element)\n            }\n        }\n        \n        return Array(duplicates)\n    }\n    \n    // Efficient sorting for specific data patterns\n    static func optimizedSort<T: Comparable>(_ array: [T]) -> [T] {\n        // Choose algorithm based on data characteristics\n        if array.count < 20 {\n            return insertionSort(array)\n        } else if array.count > 1000 {\n            return mergeSort(array)\n        } else {\n            return array.sorted()\n        }\n    }\n}\n```\n\n#### Concurrent Processing:\n```swift\nclass ConcurrentDataProcessor {\n    private let queue = DispatchQueue(\n        label: \"data.processor\",\n        qos: .userInitiated,\n        attributes: .concurrent\n    )\n    \n    func processLargeDataset<T>(_ data: [T], batchSize: Int = 100) -> [T] {\n        let group = DispatchGroup()\n        let results = SynchronizedArray<T>()\n        \n        let batches = data.chunked(into: batchSize)\n        \n        for batch in batches {\n            group.enter()\n            queue.async {\n                let processed = self.processBatch(batch)\n                results.append(contentsOf: processed)\n                group.leave()\n            }\n        }\n        \n        group.wait()\n        return results.all\n    }\n    \n    private func processBatch<T>(_ batch: [T]) -> [T] {\n        // Batch processing logic\n        return batch\n    }\n}\n\nfinal class SynchronizedArray<T> {\n    private var array: [T] = []\n    private let queue = DispatchQueue(label: \"synchronized.array\", attributes: .concurrent)\n    \n    func append(_ element: T) {\n        queue.async(flags: .barrier) {\n            self.array.append(element)\n        }\n    }\n    \n    func append(contentsOf elements: [T]) {\n        queue.async(flags: .barrier) {\n            self.array.append(contentsOf: elements)\n        }\n    }\n    \n    var all: [T] {\n        return queue.sync { array }\n    }\n}\n```\n\n### GPU Optimization:\n\n#### Efficient Core Animation:\n```swift\nclass GPUOptimizedUI {\n    static func optimizeLayerProperties(_ layer: CALayer) {\n        // Enable GPU optimizations\n        layer.shouldRasterize = true\n        layer.rasterizationScale = UIScreen.main.scale\n        \n        // Avoid expensive operations\n        layer.shadowPath = UIBezierPath(rect: layer.bounds).cgPath\n        layer.masksToBounds = true\n        \n        // Use cornerRadius carefully\n        if #available(iOS 13.0, *) {\n            layer.cornerCurve = .continuous\n        }\n    }\n    \n    static func createEfficientGradient() -> CAGradientLayer {\n        let gradient = CAGradientLayer()\n        \n        // Prefer simple gradients\n        gradient.colors = [\n            UIColor.systemBlue.cgColor,\n            UIColor.systemTeal.cgColor\n        ]\n        \n        // Avoid complex gradient configurations\n        gradient.startPoint = CGPoint(x: 0, y: 0)\n        gradient.endPoint = CGPoint(x: 1, y: 1)\n        \n        return gradient\n    }\n}\n```\n\n## 5. Network & I/O Optimization (60 min)\n\n### Advanced Network Optimization:\n\n#### Efficient API Design:\n```swift\nclass OptimizedAPIClient {\n    private let session: URLSession\n    private let cache = URLCache.shared\n    \n    init() {\n        let config = URLSessionConfiguration.default\n        config.requestCachePolicy = .returnCacheDataElseLoad\n        config.urlCache = cache\n        config.timeoutIntervalForRequest = 30\n        config.timeoutIntervalForResource = 60\n        \n        self.session = URLSession(configuration: config)\n    }\n    \n    func fetchDataWithOptimizations(\n        url: URL,\n        completion: @escaping (Result<Data, Error>) -> Void\n    ) {\n        var request = URLRequest(url: url)\n        \n        // Request optimization\n        request.httpShouldUsePipelining = true\n        request.cachePolicy = .returnCacheDataElseLoad\n        \n        // Add conditional requests\n        if let cachedResponse = cache.cachedResponse(for: request),\n           let etag = (cachedResponse.response as? HTTPURLResponse)?.allHeaderFields[\"ETag\"] as? String {\n            request.setValue(etag, forHTTPHeaderField: \"If-None-Match\")\n        }\n        \n        let task = session.dataTask(with: request) { data, response, error in\n            // Handle response efficiently\n            self.processResponse(\n                data: data,\n                response: response,\n                error: error,\n                completion: completion\n            )\n        }\n        \n        task.resume()\n    }\n}\n```\n\n#### Batch Network Requests:\n```swift\nclass BatchNetworkManager {\n    func executeBatchRequests<T>(_ requests: [URLRequest]) -> AnyPublisher<[T], Error> {\n        return Publishers.MergeMany(requests.map { request in\n            URLSession.shared.dataTaskPublisher(for: request)\n                .map(\\.data)\n                .decode(type: T.self, decoder: JSONDecoder())\n        })\n        .collect()\n        .eraseToAnyPublisher()\n    }\n}\n```\n\n## 6. Energy Efficiency & Thermal Management (60 min)\n\n### Advanced Energy Optimization:\n\n#### Location Services Optimization:\n```swift\nclass EnergyEfficientLocationManager {\n    private let locationManager = CLLocationManager()\n    private var backgroundTask: UIBackgroundTaskIdentifier = .invalid\n    \n    func startEfficientTracking() {\n        // Use significant location changes when possible\n        locationManager.startMonitoringSignificantLocationChanges()\n        \n        // Configure for energy efficiency\n        locationManager.desiredAccuracy = kCLLocationAccuracyHundredMeters\n        locationManager.distanceFilter = 100.0 // 100 meters\n        locationManager.pausesLocationUpdatesAutomatically = true\n        locationManager.activityType = .otherNavigation\n    }\n    \n    func stopTracking() {\n        locationManager.stopMonitoringSignificantLocationChanges()\n        \n        if backgroundTask != .invalid {\n            UIApplication.shared.endBackgroundTask(backgroundTask)\n            backgroundTask = .invalid\n        }\n    }\n}\n```\n\n#### Background Task Optimization:\n```swift\nclass OptimizedBackgroundProcessor {\n    func scheduleBackgroundWork() {\n        let backgroundTask = BackgroundTask()\n        \n        backgroundTask.expirationHandler = {\n            // Clean up if task is about to be terminated\n            self.cleanup()\n        }\n        \n        // Perform work in chunks with breaks\n        processInChunks { [weak self] in\n            self?.cleanup()\n            backgroundTask.end()\n        }\n    }\n    \n    private func processInChunks(completion: @escaping () -> Void) {\n        let chunkSize = 10\n        var currentIndex = 0\n        \n        func processNextChunk() {\n            guard currentIndex < totalItems else {\n                completion()\n                return\n            }\n            \n            let endIndex = min(currentIndex + chunkSize, totalItems)\n            processItems(from: currentIndex, to: endIndex)\n            \n            currentIndex = endIndex\n            \n            // Allow system to breathe between chunks\n            DispatchQueue.main.asyncAfter(deadline: .now() + 0.1) {\n                processNextChunk()\n            }\n        }\n        \n        processNextChunk()\n    }\n}\n```\n\n## 7. Continuous Performance Monitoring (30 min)\n\n### Production Performance Monitoring:\n\n#### Analytics Integration:\n```swift\nclass ProductionPerformanceMonitor {\n    static func trackPerformanceMetrics() {\n        // Track key performance indicators\n        trackStartupTime()\n        trackScreenRenderTimes()\n        trackNetworkLatency()\n        trackMemoryUsage()\n        trackEnergyImpact()\n    }\n    \n    private static func trackStartupTime() {\n        let startupTime = Date().timeIntervalSince(AppLaunchTracker.launchTime)\n        \n        Analytics.logEvent(\"app_startup_time\", parameters: [\n            \"duration\": startupTime,\n            \"device_model\": UIDevice.current.model,\n            \"os_version\": UIDevice.current.systemVersion\n        ])\n        \n        if startupTime > 2.0 {\n            // Alert for slow startup\n            logPerformanceIssue(\"Slow startup detected: \" + String(startupTime))\n        }\n    }\n}\n```\n\n#### Automated Performance Regression Testing:\n```swift\nclass PerformanceRegressionTests: XCTestCase {\n    func testStartupPerformance() {\n        measureMetrics([.wallClockTime], automaticallyStartMeasuring: false) {\n            // Setup\n            let app = XCUIApplication()\n            \n            // Start measuring\n            startMeasuring()\n            app.launch()\n            \n            // Stop when app is ready\n            let readyPredicate = NSPredicate(format: \"exists == true\")\n            let readyElement = app.staticTexts[\"AppReady\"]\n            expectation(for: readyPredicate, evaluatedWith: readyElement, handler: nil)\n            waitForExpectations(timeout: 10, handler: { _ in\n                self.stopMeasuring()\n            })\n        }\n    }\n    \n    func testScrollPerformance() {\n        let app = XCUIApplication()\n        app.launch()\n        \n        measure {\n            // Scroll through a large list\n            let collectionView = app.collectionViews.firstMatch\n            collectionView.swipeUp()\n            collectionView.swipeUp()\n            collectionView.swipeDown()\n            collectionView.swipeDown()\n        }\n    }\n}\n```",
      "codeExample": "import UIKit\nimport Combine\nimport CoreLocation\nimport os.signpost\n\n// === PERFORMANCE MONITORING INFRASTRUCTURE ===\nclass PerformanceMonitor {\n    static let shared = PerformanceMonitor()\n    \n    private let log = OSLog(\n        subsystem: \"com.yourapp.performance\",\n        category: \"Performance\"\n    )\n    \n    private var metrics: [String: PerformanceMetric] = [:]\n    private let queue = DispatchQueue(label: \"performance.monitor\", attributes: .concurrent)\n    \n    func track<T>(_ operation: String, _ work: () -> T) -> T {\n        let signpostID = OSSignpostID(log: log)\n        os_signpost(.begin, log: log, name: \"Operation\", signpostID: signpostID, \"%s\", operation)\n        \n        let startTime = CACurrentMediaTime()\n        let startMemory = report_memory()\n        \n        defer {\n            let duration = CACurrentMediaTime() - startTime\n            let memoryUsed = report_memory() - startMemory\n            \n            os_signpost(.end, log: log, name: \"Operation\", signpostID: signpostID, \"%s - %.3fs\", operation, duration)\n            \n            recordMetric(operation, duration: duration, memoryDelta: memoryUsed)\n        }\n        \n        return work()\n    }\n    \n    private func recordMetric(_ operation: String, duration: TimeInterval, memoryDelta: Int) {\n        queue.async(flags: .barrier) {\n            if self.metrics[operation] == nil {\n                self.metrics[operation] = PerformanceMetric()\n            }\n            self.metrics[operation]?.addSample(duration: duration, memoryDelta: memoryDelta)\n        }\n    }\n    \n    func generateReport() -> PerformanceReport {\n        return queue.sync {\n            PerformanceReport(metrics: metrics)\n        }\n    }\n}\n\nstruct PerformanceMetric {\n    private(set) var samples: [TimeInterval] = []\n    private(set) var memoryDeltas: [Int] = []\n    \n    mutating func addSample(duration: TimeInterval, memoryDelta: Int) {\n        samples.append(duration)\n        memoryDeltas.append(memoryDelta)\n    }\n    \n    var averageDuration: TimeInterval {\n        samples.reduce(0, +) / TimeInterval(max(samples.count, 1))\n    }\n    \n    var peakMemoryDelta: Int {\n        memoryDeltas.max() ?? 0\n    }\n}\n\nstruct PerformanceReport {\n    let metrics: [String: PerformanceMetric]\n    let generatedAt = Date()\n    \n    func printSummary() {\n        print(\"=== PERFORMANCE REPORT ===\")\n        print(\"Generated at: \" + generatedAt.description)\n        \n        for (operation, metric) in metrics {\n            print(\"\\nOperation: \" + operation)\n            print(\"  Average Duration: \" + String(format: \"%.3f\", metric.averageDuration) + \"s\")\n            print(\"  Sample Count: \" + String(metric.samples.count))\n            print(\"  Peak Memory Delta: \" + String(metric.peakMemoryDelta / 1024 / 1024) + \"MB\")\n        }\n    }\n}\n\n// === MEMORY OPTIMIZATION ===\nclass OptimizedImageManager {\n    static let shared = OptimizedImageManager()\n    \n    private let cache = NSCache<NSString, UIImage>()\n    private let loadingQueue = DispatchQueue(\n        label: \"image.loading\",\n        qos: .userInitiated,\n        attributes: .concurrent\n    )\n    \n    func loadImage(\n        from url: URL,\n        targetSize: CGSize,\n        completion: @escaping (UIImage?) -> Void\n    ) {\n        let cacheKey = url.absoluteString as NSString\n        \n        // Check memory cache first\n        if let cached = cache.object(forKey: cacheKey) {\n            completion(cached)\n            return\n        }\n        \n        loadingQueue.async { [weak self] in\n            guard let self = self else { return }\n            \n            // Downsample image to target size\n            guard let image = self.downsampleImage(at: url, to: targetSize) else {\n                DispatchQueue.main.async { completion(nil) }\n                return\n            }\n            \n            // Cache the optimized image\n            self.cache.setObject(image, forKey: cacheKey)\n            \n            DispatchQueue.main.async {\n                completion(image)\n            }\n        }\n    }\n    \n    private func downsampleImage(at url: URL, to size: CGSize) -> UIImage? {\n        let imageSourceOptions = [kCGImageSourceShouldCache: false] as CFDictionary\n        guard let imageSource = CGImageSourceCreateWithURL(url as CFURL, imageSourceOptions) else {\n            return nil\n        }\n        \n        let maxDimension = max(size.width, size.height) * UIScreen.main.scale\n        let downsampleOptions = [\n            kCGImageSourceCreateThumbnailFromImageAlways: true,\n            kCGImageSourceShouldCacheImmediately: true,\n            kCGImageSourceCreateThumbnailWithTransform: true,\n            kCGImageSourceThumbnailMaxPixelSize: maxDimension\n        ] as CFDictionary\n        \n        guard let downsampledImage = CGImageSourceCreateThumbnailAtIndex(imageSource, 0, downsampleOptions) else {\n            return nil\n        }\n        \n        return UIImage(cgImage: downsampledImage)\n    }\n}\n\n// === CPU OPTIMIZATION ===\nclass EfficientDataProcessor {\n    private let processingQueue = DispatchQueue(\n        label: \"data.processor\",\n        qos: .userInitiated,\n        attributes: .concurrent\n    )\n    \n    func processLargeDatasetConcurrently<T, U>(\n        _ data: [T],\n        transform: @escaping (T) -> U,\n        completion: @escaping ([U]) -> Void\n    ) {\n        let group = DispatchGroup()\n        let results = SynchronizedArray<U>()\n        \n        // Process in concurrent batches\n        let batchSize = max(1, data.count / ProcessInfo.processInfo.activeProcessorCount)\n        let batches = data.chunked(into: batchSize)\n        \n        for batch in batches {\n            group.enter()\n            processingQueue.async {\n                let processedBatch = batch.map(transform)\n                results.append(contentsOf: processedBatch)\n                group.leave()\n            }\n        }\n        \n        group.notify(queue: .main) {\n            completion(results.all)\n        }\n    }\n    \n    // Optimized algorithm implementations\n    func findIntersectionOptimized<T: Hashable>(_ arrays: [[T]]) -> Set<T> {\n        guard !arrays.isEmpty else { return [] }\n        \n        // Start with smallest array for efficiency\n        let sortedArrays = arrays.sorted { $0.count < $1.count }\n        var intersection = Set(sortedArrays.first!)\n        \n        for array in sortedArrays.dropFirst() {\n            intersection.formIntersection(array)\n            if intersection.isEmpty { break }\n        }\n        \n        return intersection\n    }\n}\n\n// === NETWORK OPTIMIZATION ===\nclass OptimizedNetworkManager {\n    private let session: URLSession\n    private let cache = URLCache.shared\n    \n    init() {\n        let config = URLSessionConfiguration.default\n        config.requestCachePolicy = .returnCacheDataElseLoad\n        config.urlCache = cache\n        config.httpMaximumConnectionsPerHost = 6\n        config.timeoutIntervalForRequest = 30\n        \n        self.session = URLSession(configuration: config)\n    }\n    \n    func fetchDataWithOptimizations(\n        from url: URL,\n        completion: @escaping (Result<Data, Error>) -> Void\n    ) {\n        PerformanceMonitor.shared.track(\"Network Request: \" + url.absoluteString) {\n            var request = URLRequest(url: url)\n            request.httpShouldUsePipelining = true\n            request.cachePolicy = .returnCacheDataElseLoad\n            \n            let task = session.dataTask(with: request) { data, response, error in\n                if let error = error {\n                    completion(.failure(error))\n                    return\n                }\n                \n                guard let data = data, let response = response else {\n                    completion(.failure(NetworkError.noData))\n                    return\n                }\n                \n                // Cache the response\n                if let httpResponse = response as? HTTPURLResponse,\n                   httpResponse.statusCode == 200 {\n                    let cachedResponse = CachedURLResponse(response: httpResponse, data: data)\n                    self.cache.storeCachedResponse(cachedResponse, for: request)\n                }\n                \n                completion(.success(data))\n            }\n            \n            task.resume()\n        }\n    }\n}\n\n// === UTILITIES ===\nfinal class SynchronizedArray<T> {\n    private var array: [T] = []\n    private let queue = DispatchQueue(label: \"synchronized.array\", attributes: .concurrent)\n    \n    func append(_ element: T) {\n        queue.async(flags: .barrier) {\n            self.array.append(element)\n        }\n    }\n    \n    func append(contentsOf elements: [T]) {\n        queue.async(flags: .barrier) {\n            self.array.append(contentsOf: elements)\n        }\n    }\n    \n    var all: [T] {\n        return queue.sync { array }\n    }\n}\n\nextension Array {\n    func chunked(into size: Int) -> [[Element]] {\n        return stride(from: 0, to: count, by: size).map {\n            Array(self[$0..<Swift.min($0 + size, count)])\n        }\n    }\n}\n\nfunc report_memory() -> Int {\n    var info = mach_task_basic_info()\n    var count = mach_msg_type_number_t(MemoryLayout<mach_task_basic_info>.size) / 4\n    \n    let kerr = withUnsafeMutablePointer(to: &info) {\n        $0.withMemoryRebound(to: integer_t.self, capacity: 1) {\n            task_info(mach_task_self_, task_flavor_t(MACH_TASK_BASIC_INFO), $0, &count)\n        }\n    }\n    \n    guard kerr == KERN_SUCCESS else { return 0 }\n    return Int(info.resident_size)\n}\n\nenum NetworkError: Error {\n    case noData\n    case invalidResponse\n}",
      "category": "Performance & Optimization",
      "estimatedTime": 360,
      "dependencies": ["memory_management", "networking", "swift_concurrency"],
      "challenge": {
        "instructions": "Conduct a comprehensive performance audit on an existing iOS application:\n\nPART 1: Performance Baseline & Instrumentation (90 min)\n1. Set up performance monitoring infrastructure with custom metrics\n2. Establish performance baselines for startup time, memory usage, and CPU\n3. Implement automated performance regression detection\n4. Create performance dashboards for key metrics\n\nPART 2: Memory Optimization Deep Dive (90 min)\n5. Analyze and fix memory leaks using Memory Graph Debugger\n6. Implement efficient image loading with downsampling\n7. Optimize data structures for memory efficiency\n8. Reduce ARC overhead through value types and copy-on-write\n\nPART 3: CPU & Algorithm Optimization (90 min)\n9. Profile and optimize expensive algorithms\n10. Implement concurrent processing for CPU-intensive tasks\n11. Optimize Core Animation and rendering performance\n12. Reduce main thread blocking operations\n\nPART 4: Network & I/O Optimization (60 min)\n13. Optimize network requests with caching and batching\n14. Implement efficient data persistence strategies\n15. Reduce disk I/O through memory mapping\n16. Optimize API response parsing\n\nPART 5: Energy Efficiency & Production Monitoring (30 min)\n17. Implement energy-efficient background processing\n18. Set up production performance monitoring\n19. Create performance alerting system\n20. Document optimization strategies and results\n\nPART 6: Performance Regression Prevention (60 min)\n21. Create automated performance tests\n22. Set up CI/CD performance gates\n23. Implement performance budget tracking\n24. Create performance optimization playbook",
        "starterCode": "import UIKit\nimport Combine\nimport os.signpost\n\n// === PERFORMANCE AUDIT STARTER CODE ===\n\n// 1. Performance Monitoring Setup\nclass PerformanceAuditor {\n    // TODO: Implement performance monitoring infrastructure\n}\n\n// 2. Memory Optimization\nclass MemoryOptimizer {\n    // TODO: Implement memory optimization strategies\n}\n\n// 3. CPU Optimization\nclass CPUOptimizer {\n    // TODO: Implement CPU optimization techniques\n}\n\n// 4. Network Optimization\nclass NetworkOptimizer {\n    // TODO: Implement network optimization\n}\n\n// 5. Energy Efficiency\nclass EnergyOptimizer {\n    // TODO: Implement energy-efficient patterns\n}\n\n// 6. Performance Testing\nclass PerformanceTests {\n    // TODO: Implement performance regression tests\n}",
        "solution": "import UIKit\nimport Combine\nimport os.signpost\n\n// === COMPREHENSIVE PERFORMANCE AUDIT SOLUTION ===\n\n// PART 1: Performance Monitoring Infrastructure\nclass AdvancedPerformanceAuditor {\n    static let shared = AdvancedPerformanceAuditor()\n    \n    private let log = OSLog(subsystem: \"com.audit.performance\", category: \"Audit\")\n    private var metrics: [String: PerformanceMetric] = [:]\n    private let queue = DispatchQueue(label: \"performance.auditor\", attributes: .concurrent)\n    \n    private var startupTime: TimeInterval = 0\n    private var peakMemory: Int = 0\n    \n    func applicationDidFinishLaunching() {\n        startupTime = CACurrentMediaTime()\n        startContinuousMonitoring()\n    }\n    \n    func trackPerformance<T>(_ operation: String, _ work: () -> T) -> T {\n        let signpostID = OSSignpostID(log: log)\n        os_signpost(.begin, log: log, name: \"AuditOperation\", signpostID: signpostID, \"%s\", operation)\n        \n        let startTime = CACurrentMediaTime()\n        let startMemory = report_memory()\n        \n        defer {\n            let duration = CACurrentMediaTime() - startTime\n            let memoryUsed = report_memory() - startMemory\n            \n            os_signpost(.end, log: log, name: \"AuditOperation\", signpostID: signpostID, \n                       \"%s - %.3fs - %dKB\", operation, duration, memoryUsed / 1024)\n            \n            recordMetric(operation, duration: duration, memoryDelta: memoryUsed)\n            updatePeakMemory()\n        }\n        \n        return work()\n    }\n    \n    private func startContinuousMonitoring() {\n        // Monitor memory usage continuously\n        Timer.scheduledTimer(withTimeInterval: 1.0, repeats: true) { [weak self] _ in\n            self?.updatePeakMemory()\n        }\n    }\n    \n    private func updatePeakMemory() {\n        let currentMemory = report_memory()\n        peakMemory = max(peakMemory, currentMemory)\n    }\n    \n    private func recordMetric(_ operation: String, duration: TimeInterval, memoryDelta: Int) {\n        queue.async(flags: .barrier) {\n            if self.metrics[operation] == nil {\n                self.metrics[operation] = PerformanceMetric()\n            }\n            self.metrics[operation]?.addSample(duration: duration, memoryDelta: memoryDelta)\n        }\n    }\n    \n    func generateAuditReport() -> AuditReport {\n        let appRunTime = CACurrentMediaTime() - startupTime\n        \n        return queue.sync {\n            AuditReport(\n                metrics: metrics,\n                startupTime: startupTime,\n                peakMemory: peakMemory,\n                appRunTime: appRunTime\n            )\n        }\n    }\n}\n\nstruct AuditReport {\n    let metrics: [String: PerformanceMetric]\n    let startupTime: TimeInterval\n    let peakMemory: Int\n    let appRunTime: TimeInterval\n    let generatedAt = Date()\n    \n    func printComprehensiveReport() {\n        print(\"\\n\" + \"=\"*50)\n        print(\"COMPREHENSIVE PERFORMANCE AUDIT REPORT\")\n        print(\"=\"*50)\n        print(\"Generated: \" + generatedAt.description)\n        print(\"App Run Time: \" + String(format: \"%.1f\", appRunTime) + \"s\")\n        print(\"Peak Memory: \" + String(peakMemory / 1024 / 1024) + \"MB\")\n        \n        print(\"\\n--- PERFORMANCE METRICS ---\")\n        for (operation, metric) in metrics.sorted(by: { $0.value.averageDuration > $1.value.averageDuration }) {\n            print(\"\\n\" + operation + \":\")\n            print(\"  Average: \" + String(format: \"%.3f\", metric.averageDuration) + \"s\")\n            print(\"  Samples: \" + String(metric.samples.count))\n            print(\"  Peak Memory: \" + String(metric.peakMemoryDelta / 1024) + \"KB\")\n            \n            if metric.averageDuration > 0.016 {\n                print(\"  âš ï¸  Above 60FPS threshold\")\n            }\n        }\n        \n        print(\"\\n--- RECOMMENDATIONS ---\")\n        generateRecommendations()\n    }\n    \n    private func generateRecommendations() {\n        let slowOperations = metrics.filter { $0.value.averageDuration > 0.016 }\n        \n        if !slowOperations.isEmpty {\n            print(\"Optimize these slow operations:\")\n            for (operation, _) in slowOperations {\n                print(\"  â€¢ \" + operation)\n            }\n        }\n        \n        if peakMemory > 100 * 1024 * 1024 { // 100MB\n            print(\"\\nHigh memory usage detected. Consider:\")\n            print(\"  â€¢ Implementing image downsampling\")\n            print(\"  â€¢ Using NSCache for frequently accessed data\")\n            print(\"  â€¢ Reviewing retain cycles with Memory Graph Debugger\")\n        }\n    }\n}\n\n// PART 2: Memory Optimization\nclass ComprehensiveMemoryOptimizer {\n    \n    // Efficient image handling with multiple optimization strategies\n    func optimizedImageLoadingStrategy() {\n        // Strategy 1: Downsampling\n        // Strategy 2: Lazy loading\n        // Strategy 3: Memory-mapped files for large assets\n        // Strategy 4: Progressive loading\n    }\n    \n    // Advanced data structure optimization\n    struct OptimizedDataModel {\n        private class Storage {\n            var data: [String: Any]\n            init(data: [String: Any]) { self.data = data }\n        }\n        \n        private var storage: Storage\n        \n        init(data: [String: Any]) {\n            self.storage = Storage(data: data)\n        }\n        \n        mutating func updateValue(_ value: Any, forKey key: String) {\n            if !isKnownUniquelyReferenced(&storage) {\n                storage = Storage(data: storage.data)\n            }\n            storage.data[key] = value\n        }\n    }\n    \n    // Memory leak detection and prevention\n    func detectCommonMemoryIssues() {\n        // 1. Retain cycles in closures\n        // 2. Strong reference cycles in delegates\n        // 3. Unreleased observers\n        // 4. Cached data without limits\n    }\n}\n\n// PART 3: CPU Optimization\nclass AdvancedCPUOptimizer {\n    \n    // Algorithm optimization examples\n    func optimizedSearchAlgorithms() {\n        // Replace O(n) with O(log n) where possible\n        // Use sets for membership testing\n        // Implement efficient sorting strategies\n    }\n    \n    // Concurrent processing with proper resource management\n    func optimizedConcurrentProcessing<T>(_ items: [T], processor: @escaping (T) -> Void) {\n        let concurrentQueue = DispatchQueue(\n            label: \"concurrent.processor\",\n            qos: .userInitiated,\n            attributes: .concurrent\n        )\n        \n        let semaphore = DispatchSemaphore(value: ProcessInfo.processInfo.activeProcessorCount)\n        let group = DispatchGroup()\n        \n        for item in items {\n            group.enter()\n            semaphore.wait()\n            \n            concurrentQueue.async {\n                processor(item)\n                semaphore.signal()\n                group.leave()\n            }\n        }\n        \n        group.wait()\n    }\n    \n    // Main thread optimization\n    func ensureMainThreadOptimization() {\n        // Use RunLoop modes appropriately\n        // Batch UI updates\n        // Use CADisplayLink for frame-accurate updates\n    }\n}\n\n// PART 4: Network & I/O Optimization\nclass ProductionNetworkOptimizer {\n    \n    private let session: URLSession\n    private let cache: URLCache\n    \n    init() {\n        // Configure for production performance\n        let config = URLSessionConfiguration.ephemeral\n        config.requestCachePolicy = .returnCacheDataElseLoad\n        config.urlCache = URLCache(memoryCapacity: 50 * 1024 * 1024, \n                                 diskCapacity: 200 * 1024 * 1024)\n        config.httpMaximumConnectionsPerHost = 4\n        config.timeoutIntervalForRequest = 15\n        \n        self.session = URLSession(configuration: config)\n        self.cache = config.urlCache!\n    }\n    \n    func optimizedDataTask(with request: URLRequest) -> URLSessionDataTask {\n        // Add performance tracking\n        return session.dataTask(with: request)\n    }\n    \n    // Batch network requests\n    func executeBatchRequests(_ requests: [URLRequest]) -> AnyPublisher<[Data], Error> {\n        return Publishers.MergeMany(requests.map { request in\n            session.dataTaskPublisher(for: request)\n                .map(\\.data)\n                .catch { _ in Empty() }\n        })\n        .collect()\n        .eraseToAnyPublisher()\n    }\n}\n\n// PART 5: Energy Efficiency\nclass EnergyEfficiencyManager {\n    \n    private var backgroundTask: UIBackgroundTaskIdentifier = .invalid\n    \n    func startEnergyEfficientOperation() {\n        // Request background task\n        backgroundTask = UIApplication.shared.beginBackgroundTask {\n            self.cleanup()\n            self.endBackgroundTask()\n        }\n        \n        // Perform work in energy-efficient manner\n        performEnergyEfficientWork()\n    }\n    \n    private func performEnergyEfficientWork() {\n        // Use appropriate QoS\n        // Batch operations\n        // Avoid unnecessary timers\n        // Use significant location changes when possible\n    }\n    \n    private func endBackgroundTask() {\n        UIApplication.shared.endBackgroundTask(backgroundTask)\n        backgroundTask = .invalid\n    }\n    \n    private func cleanup() {\n        // Clean up resources\n    }\n}\n\n// PART 6: Performance Regression Prevention\nclass PerformanceRegressionDetector {\n    \n    private let baselineMetrics: [String: TimeInterval]\n    private let tolerance: TimeInterval = 0.1 // 10% tolerance\n    \n    init(baselineMetrics: [String: TimeInterval]) {\n        self.baselineMetrics = baselineMetrics\n    }\n    \n    func checkForRegression(_ currentMetrics: [String: TimeInterval]) -> [String] {\n        var regressions: [String] = []\n        \n        for (operation, baseline) in baselineMetrics {\n            if let current = currentMetrics[operation],\n               current > baseline * (1.0 + tolerance) {\n                regressions.append(operation)\n            }\n        }\n        \n        return regressions\n    }\n    \n    func generatePerformanceGate() -> Bool {\n        let currentReport = AdvancedPerformanceAuditor.shared.generateAuditReport()\n        var currentMetrics: [String: TimeInterval] = [:]\n        \n        for (operation, metric) in currentReport.metrics {\n            currentMetrics[operation] = metric.averageDuration\n        }\n        \n        let regressions = checkForRegression(currentMetrics)\n        \n        if !regressions.isEmpty {\n            print(\"Performance regression detected in: \" + regressions.joined(separator: \", \"))\n            return false\n        }\n        \n        return true\n    }\n}\n\n// Utility function for string multiplication (used in report formatting)\nfunc *(lhs: String, rhs: Int) -> String {\n    return String(repeating: lhs, count: rhs)\n}",
        "hints": [
          "PART 1: Use os_signpost for precise performance measurement and create baseline metrics",
          "PART 2: Focus on memory graph analysis and implement copy-on-write for large data structures",
          "PART 3: Profile with Time Profiler and optimize algorithms based on data size and patterns",
          "PART 4: Implement strategic caching and batch network requests to reduce overhead",
          "PART 5: Use appropriate QoS levels and minimize background task duration",
          "PART 6: Set up automated performance gates in CI/CD to catch regressions early",
          "Use Instruments' System Trace to understand thread usage and blocking operations",
          "Implement memory warning handlers to gracefully reduce cache sizes",
          "Use XCTest performance metrics for automated regression testing",
          "Monitor thermal state and adjust processing intensity accordingly"
        ],
        "testCases": [
          {
            "input": "startupTime < 2.0",
            "expectedOutput": "true",
            "description": "App should start in under 2 seconds"
          },
          {
            "input": "peakMemory < 150 * 1024 * 1024",
            "expectedOutput": "true",
            "description": "Peak memory usage should stay under 150MB"
          },
          {
            "input": "slowOperations.isEmpty",
            "expectedOutput": "true",
            "description": "No operations should exceed 16ms threshold"
          },
          {
            "input": "regressions.isEmpty",
            "expectedOutput": "true",
            "description": "No performance regressions compared to baseline"
          }
        ]
      }
    },
    {
      "id": "app_store_preparation",
      "title": "App Store Preparation & Submission",
      "description": "Master the complete App Store submission process, from metadata optimization to App Store Connect configuration",
      "difficulty": "advanced",
      "theory": "# App Store Preparation & Submission\n\n## 1. App Store Connect Setup & Configuration (90 min)\n\n### Account Configuration\n\n**Team Roles & Permissions:**\n```swift\n// Understanding App Store Connect roles:\n- Admin: Full access, manage users, financial reports\n- App Manager: Can manage apps but not financial data\n- Developer: Submit builds, view analytics\n- Marketing: Access to marketing materials and analytics\n- Sales: View sales and trends data\n- Customer Support: Respond to reviews, access support data\n```\n\n**Multiple Account Management:**\n```bash\n# Fastlane configuration for multiple accounts\nfastlane spaceauth -u email@company.com\nfastlane match --readonly -u email@company.com\n\n# Xcode account management\n# Preferences â†’ Accounts â†’ Add Apple ID\n# Manage certificates, identifiers, and profiles\n```\n\n### Bundle ID Strategy\n\n**Naming Conventions:**\n```\nReverse DNS notation best practices:\n- com.companyname.appname (Production)\n- com.companyname.appname.staging (Staging)\n- com.companyname.appname.dev (Development)\n- com.companyname.appname.demo (Demo)\n```\n\n**Capabilities Configuration:**\n```swift\n// Common capabilities requiring configuration:\n- Push Notifications\n- In-App Purchase\n- Game Center\n- Apple Pay\n- Sign in with Apple\n- CloudKit\n- Background Modes\n- Associated Domains\n- NFC Tag Reading\n```\n\n## 2. App Metadata Optimization (120 min)\n\n### App Store Listing Components\n\n**Primary Metadata:**\n```yaml\nApp Name: 30 characters max\nSubtitle: 30 characters max\nPrivacy Policy URL: Required for all apps\nSupport URL: Direct customer support\nMarketing URL: Optional promotional site\n```\n\n**Localization Strategy:**\n```swift\n// Supported languages priority:\n1. English (Primary)\n2. Chinese (Simplified & Traditional)\n3. Spanish\n4. Japanese\n5. French\n6. German\n7. Korean\n8. Italian\n9. Portuguese (Brazil)\n10. Russian\n```\n\n### Screenshot Strategy\n\n**Device Requirements:**\n```bash\n# Required screenshot sizes (2024):\niPhone 6.7\" Display: 1290x2796 pixels\niPhone 5.5\" Display: 1242x2208 pixels\niPhone 6.5\" Display: 1242x2688 pixels\niPad Pro 3rd Gen: 2048x2732 pixels\niPad Pro 2nd Gen: 2048x2732 pixels\nApple Watch: 384x480 pixels\n```\n\n**Screenshot Content Guidelines:**\n```swift\n// Best practices:\n- Show actual app content, not templates\n- Include device frames (optional)\n- Demonstrate key features\n- Show diverse content across screenshots\n- Include text overlays for feature explanation\n- Maintain consistent visual style\n- Avoid placeholder text\n- Show real user interfaces\n```\n\n### App Preview Videos\n\n**Technical Specifications:**\n```yaml\nDuration: 15-30 seconds\nFormat: MOV or MP4\nResolution: Match device requirements\nFrame Rate: 30 fps\nFile Size: 500MB max\nContent: Must show actual app usage\nAudio: Optional, but recommended\n```\n\n**Content Strategy:**\n```swift\n// Effective app preview structure:\n0-3s: Hook with compelling feature\n3-10s: Demonstrate core functionality\n10-20s: Show advanced features\n20-30s: Call to action and value proposition\n```\n\n## 3. Build Configuration & Upload (90 min)\n\n### Build Settings Optimization\n\n**App Store Build Configuration:**\n```swift\n// Build Settings for Release:\nDEVELOPMENT_TEAM = \"YourTeamID\"\nPRODUCT_BUNDLE_IDENTIFIER = \"com.company.app\"\nIPHONEOS_DEPLOYMENT_TARGET = \"16.0\"\nASSETCATALOG_COMPILER_OPTIMIZATION = \"time\"\nSWIFT_OPTIMIZATION_LEVEL = \"-O\"\nGCC_OPTIMIZATION_LEVEL = \"3\"\nENABLE_BITCODE = \"NO\"\n```\n\n**Info.plist Configuration:**\n```xml\n<key>CFBundleDisplayName</key>\n<string>Your App Name</string>\n<key>CFBundleShortVersionString</key>\n<string>1.0.0</string>\n<key>CFBundleVersion</key>\n<string>1</string>\n<key>LSApplicationQueriesSchemes</key>\n<array>\n    <string>whatsapp</string>\n    <string>instagram</string>\n</array>\n<key>NSAppTransportSecurity</key>\n<dict>\n    <key>NSAllowsArbitraryLoads</key>\n    <false/>\n</dict>\n```\n\n### Upload Process\n\n**Manual Upload via Xcode:**\n```bash\n# Archive process:\n1. Select Generic iOS Device\n2. Product â†’ Archive\n3. Validate App\n4. Distribute App\n5. App Store Connect\n6. Upload\n7. Wait for processing\n```\n\n**Automated Upload with Fastlane:**\n```ruby\n# Fastfile configuration:\nlane :release do\n  increment_build_number\n  build_app(\n    scheme: \"YourApp\",\n    export_method: \"app-store\",\n    export_options: {\n      method: \"app-store\",\n      teamID: \"YOUR_TEAM_ID\"\n    }\n  )\n  upload_to_app_store(\n    skip_metadata: true,\n    skip_screenshots: true\n  )\nend\n```\n\n## 4. App Store Review Guidelines (60 min)\n\n### Common Rejection Reasons\n\n**Technical Issues:**\n```swift\n// Avoid these common technical rejections:\n- Crashing on launch\n- Broken functionality\n- Placeholder content\n- Incomplete information\n- Broken links\n- Unsupported device features\n- Performance issues\n- Memory leaks\n- Battery drain\n```\n\n**Content Issues:**\n```swift\n// Content guideline violations:\n- Inaccurate metadata\n- Misleading functionality\n- Inappropriate content\n- Copyright violations\n- Privacy violations\n- Incomplete sign-in\n- Unclear business model\n- Hidden features\n```\n\n### Guideline Compliance\n\n**Design Guidelines:**\n```swift\n// Apple's Human Interface Guidelines:\n- Respect safe areas\n- Support all screen sizes\n- Provide launch screen\n- Use system fonts appropriately\n- Maintain touch target sizes (44x44 points)\n- Support Dark Mode\n- Provide app icons in all sizes\n- Use adaptive layout\n```\n\n**Legal Requirements:**\n```swift\n// Must-have legal components:\n- Privacy Policy (required)\n- Terms of Service (recommended)\n- End User License Agreement\n- Data processing disclosures\n- Age rating accuracy\n- Copyright compliance\n- Trademark clearance\n```\n\n## 5. Pre-Release Testing & Validation (60 min)\n\n### TestFlight Management\n\n**Internal Testing:**\n```swift\n// Internal testers (max 100):\n- Development team members\n- Immediate stakeholders\n- Quick iteration cycles\n- No App Review required\n- Builds expire in 30 days\n```\n\n**External Testing:**\n```swift\n// External testers (max 10,000):\n- Public beta testers\n- Requires App Review\n- Builds expire in 90 days\n- Feedback collection enabled\n- Crash report analysis\n```\n\n### Validation Checklist\n\n**Pre-Submission Testing:**\n```bash\n# Comprehensive testing checklist:\nâœ“ Test on all supported devices\nâœ“ Verify all screen sizes\nâœ“ Test network conditions\nâœ“ Validate in-app purchases\nâœ“ Check memory usage\nâœ“ Verify battery impact\nâœ“ Test accessibility features\nâœ“ Validate localization\nâœ“ Check orientation support\nâœ“ Verify push notifications\nâœ“ Test background operations\nâœ“ Validate data persistence\n```\n\n## 6. Submission & Release Management (60 min)\n\n### App Store Submission\n\n**Version Release Options:**\n```swift\n// Release timing strategies:\n- Manual Release: Control exact launch time\n- Automatic Release: Launch after approval\n- Time-Delayed Release: Schedule specific date\n- Phased Release: Roll out to percentage of users\n```\n\n**Phased Rollout Strategy:**\n```swift\n// Benefits of phased release:\n- Monitor crash reports\n- Gather user feedback\n- Identify issues early\n- Control server load\n- A/B test features\n- Gradual user adoption\n```\n\n### Post-Submission Process\n\n**Review Timeline Management:**\n```swift\n// Typical review timelines:\n- Expedited Review: 24-48 hours (for critical bugs)\n- Standard Review: 1-3 business days\n- Extended Review: 3-7 business days (complex apps)\n- Rejection Resolution: 1-2 days for resubmission\n```\n\n**Review Status Monitoring:**\n```swift\n// App Store Connect statuses:\n- Prepare for Submission\n- Waiting for Review\n- In Review\n- Pending Developer Release\n- Ready for Sale\n- Rejected\n- Metadata Rejected\n- Developer Rejected\n- Removed from Sale\n```\n\n## 7. Advanced App Store Features (90 min)\n\n### App Store Optimization (ASO)\n\n**Keyword Optimization:**\n```swift\n// ASO best practices:\n- Primary keyword in app name\n- Secondary keywords in subtitle\n- Relevant keywords in keyword field\n- Localized keywords for each region\n- Monitor keyword performance\n- Competitor keyword analysis\n- Seasonal keyword adjustments\n```\n\n**Conversion Rate Optimization:**\n```swift\n// Improve conversion rates:\n- Compelling screenshots\n- Engaging app preview\n- Clear value proposition\n- Social proof (ratings/reviews)\n- Feature highlighting\n- Benefit-oriented descriptions\n- Regular A/B testing\n```\n\n### Advanced Metadata Management\n\n**Custom Product Page:**\n```swift\n// Custom page opportunities:\n- Targeted marketing campaigns\n- Specific user segments\n- Geographic customization\n- Seasonal promotions\n- Feature-specific landing\n- A/B testing variations\n```\n\n**Product Page Optimization:**\n```swift\n// Testing and optimization:\n- Screenshot A/B testing\n- App preview variations\n- Description testing\n- Promotional text updates\n- Seasonal imagery\n- Localized content testing\n```\n\n## 8. Post-Launch Management & Analytics (60 min)\n\n### Performance Monitoring\n\n**App Store Connect Analytics:**\n```swift\n// Key metrics to monitor:\n- Impressions\n- Product Page Views\n- Downloads\n- Conversion Rate\n- Crash Reports\n- Ratings & Reviews\n- Retention Rates\n- Engagement Metrics\n- Revenue Analytics\n```\n\n**Third-Party Analytics Integration:**\n```swift\n// Popular analytics platforms:\n- Firebase Analytics\n- Mixpanel\n- Amplitude\n- Appsflyer\n- Adjust\n- Branch\n- Localytics\n- Countly\n```\n\n### Update Strategy\n\n**Version Update Planning:**\n```swift\n// Update release cadence:\n- Bug Fix Releases: As needed\n- Feature Updates: Monthly/Quarterly\n- Major Updates: Biannually\n- Seasonal Updates: Holiday-specific\n- Compliance Updates: ASAP when required\n```\n\n**Update Metadata Optimization:**\n```swift\n// What's New text strategy:\n- Lead with most exciting feature\n- Use bullet points for readability\n- Focus on user benefits\n- Include bug fixes if significant\n- Localize for all languages\n- Test different messaging\n- Reference user feedback\n```\n\n## Best Practices Summary\n\n### Pro Tips for Success\n\n**Submission Readiness:**\n```swift\n// Final checklist before submission:\nâœ“ All metadata completed and accurate\nâœ“ Screenshots for all device sizes\nâœ“ App preview videos uploaded\nâœ“ Privacy policy URL valid\nâœ“ Support information provided\nâœ“ Build validated and tested\nâœ“ In-app purchases configured\nâœ“ Age rating accurate\nâœ“ Export compliance completed\nâœ“ Copyright information provided\n```\n\n**Ongoing Maintenance:**\n```swift\n// Post-launch maintenance:\n- Monitor app performance daily\n- Respond to reviews promptly\n- Analyze crash reports\n- Track key metrics\n- Plan regular updates\n- Stay current with iOS versions\n- Monitor competitor activity\n- Gather user feedback\n- Optimize ASO continuously\n```",
      "codeExample": "#!/bin/bash\n\n# === FASTLANE CONFIGURATION ===\n\n# Appfile\napp_identifier \"com.yourcompany.yourapp\"\napple_id \"your@email.com\"\nteam_id \"YOUR_TEAM_ID\"\n\n# Fastfile\nlane :beta do\n  # Increment build number\n  increment_build_number(\n    build_number: latest_testflight_build_number + 1\n  )\n  \n  # Build the app\n  build_app(\n    scheme: \"YourApp\",\n    export_method: \"app-store\",\n    export_options: {\n      provisioningProfiles: {\n        \"com.yourcompany.yourapp\" => \"App Store Provisioning Profile\"\n      }\n    }\n  )\n  \n  # Upload to TestFlight\n  upload_to_testflight(\n    skip_waiting_for_build_processing: false,\n    groups: [\"Internal Testers\", \"External Testers\"]\n  )\nend\n\nlane :release do\n  # Ensure clean git state\n  ensure_git_status_clean\n  \n  # Update version number\n  increment_version_number(\n    version_number: \"1.1.0\"\n  )\n  \n  # Build for App Store\n  build_app(\n    scheme: \"YourApp\",\n    clean: true,\n    export_method: \"app-store\",\n    export_xcargs: \"-allowProvisioningUpdates\"\n  )\n  \n  # Upload to App Store Connect\n  upload_to_app_store(\n    skip_metadata: false,\n    skip_screenshots: false,\n    submit_for_review: true,\n    automatic_release: false\n  )\n  \n  # Add git tag\n  add_git_tag(\n    tag: \"v1.1.0\"\n  )\n  \n  push_to_git_remote\nend\n\n# === XCODE BUILD SETTINGS ===\n\n# Release Configuration\n/* Release Build Settings:\nASSETCATALOG_COMPILER_APPICON_NAME = AppIcon\nASSETCATALOG_COMPILER_GLOBAL_ACCENT_COLOR_NAME = AccentColor\nCLANG_ENABLE_MODULES = YES\nCODE_SIGN_ENTITLEMENTS = YourApp/YourApp.entitlements\nCODE_SIGN_STYLE = Automatic\nCURRENT_PROJECT_VERSION = 1\nDEVELOPMENT_TEAM = YOUR_TEAM_ID\nENABLE_BITCODE = NO\nGCC_OPTIMIZATION_LEVEL = 3\nINFOPLIST_FILE = YourApp/Info.plist\nIPHONEOS_DEPLOYMENT_TARGET = 16.0\nLD_RUNPATH_SEARCH_PATHS = $(inherited) @executable_path/Frameworks\nMARKETING_VERSION = 1.0.0\nPRODUCT_BUNDLE_IDENTIFIER = com.yourcompany.yourapp\nPRODUCT_NAME = YourApp\nSWIFT_OPTIMIZATION_LEVEL = -O\nTARGETED_DEVICE_FAMILY = 1,2\n*/\n\n# === APP STORE CONNECT API CONFIGURATION ===\n\nimport AppStoreConnect_Swift_SDK\n\nclass AppStoreConnectManager {\n    private let configuration: APIConfiguration\n    \n    init() {\n        self.configuration = try! APIConfiguration(\n            issuerID: Environment.issuerID,\n            privateKeyID: Environment.privateKeyID,\n            privateKey: Environment.privateKey\n        )\n    }\n    \n    func fetchAppInfo() async throws {\n        let provider = APIProvider(configuration: configuration)\n        \n        let request = APIEndpoint\n            .v1\n            .apps\n            .get(parameters: .init(\n                filterBundleID: [\"com.yourcompany.yourapp\"]\n            ))\n        \n        let apps = try await provider.request(request).data\n        \n        for app in apps {\n            print(\"App Name: \\(app.attributes?.name ?? \"Unknown\")\")\n            print(\"Bundle ID: \\(app.attributes?.bundleID ?? \"Unknown\")\")\n            print(\"Primary Locale: \\(app.attributes?.primaryLocale ?? \"Unknown\")\")\n        }\n    }\n    \n    func submitForReview(appId: String) async throws {\n        let provider = APIProvider(configuration: configuration)\n        \n        let request = APIEndpoint\n            .v1\n            .appStoreVersionSubmissions\n            .create(.init(\n                data: .init(\n                    type: .appStoreVersionSubmissions,\n                    relationships: .init(appStoreVersion: .init(data: .init(\n                        type: .appStoreVersions,\n                        id: appId\n                    )))\n                )\n            ))\n        \n        try await provider.request(request)\n    }\n}\n\n# === METADATA VALIDATION ===\n\nclass MetadataValidator {\n    \n    func validateAppMetadata(metadata: AppMetadata) -> [ValidationError] {\n        var errors: [ValidationError] = []\n        \n        // App Name validation\n        if metadata.name.count > 30 {\n            errors.append(.appNameTooLong)\n        }\n        \n        if metadata.name.trimmingCharacters(in: .whitespaces).isEmpty {\n            errors.append(.appNameEmpty)\n        }\n        \n        // Subtitle validation\n        if metadata.subtitle.count > 30 {\n            errors.append(.subtitleTooLong)\n        }\n        \n        // Privacy Policy validation\n        guard let privacyURL = URL(string: metadata.privacyPolicyURL),\n              UIApplication.shared.canOpenURL(privacyURL) else {\n            errors.append(.invalidPrivacyPolicyURL)\n        }\n        \n        // Screenshot validation\n        if metadata.screenshots.isEmpty {\n            errors.append(.missingScreenshots)\n        }\n        \n        for screenshot in metadata.screenshots {\n            if !isValidScreenshotSize(screenshot) {\n                errors.append(.invalidScreenshotSize)\n            }\n        }\n        \n        return errors\n    }\n    \n    private func isValidScreenshotSize(_ screenshot: Screenshot) -> Bool {\n        let validSizes: [CGSize] = [\n            CGSize(width: 1290, height: 2796),  // iPhone 6.7\"\n            CGSize(width: 1242, height: 2208),  // iPhone 5.5\"\n            CGSize(width: 1242, height: 2688),  // iPhone 6.5\"\n            CGSize(width: 2048, height: 2732)   // iPad Pro\n        ]\n        \n        return validSizes.contains(screenshot.size)\n    }\n}\n\nenum ValidationError: Error {\n    case appNameTooLong\n    case appNameEmpty\n    case subtitleTooLong\n    case invalidPrivacyPolicyURL\n    case missingScreenshots\n    case invalidScreenshotSize\n    case missingAppPreview\n    case invalidAgeRating\n}\n\n# === AUTOMATED SUBMISSION PIPELINE ===\n\nclass AppStoreSubmissionPipeline {\n    \n    func executeSubmissionPipeline() async throws {\n        // Step 1: Validate metadata\n        let validator = MetadataValidator()\n        let errors = validator.validateAppMetadata(metadata: appMetadata)\n        \n        guard errors.isEmpty else {\n            print(\"Metadata validation failed: \\(errors)\")\n            throw SubmissionError.metadataValidationFailed\n        }\n        \n        // Step 2: Build and archive\n        try await buildAndArchive()\n        \n        // Step 3: Upload to App Store Connect\n        try await uploadToAppStoreConnect()\n        \n        // Step 4: Update metadata\n        try await updateAppStoreMetadata()\n        \n        // Step 5: Submit for review\n        try await submitForReview()\n        \n        print(\"Submission pipeline completed successfully!\")\n    }\n    \n    private func buildAndArchive() async throws {\n        let process = Process()\n        process.executableURL = URL(fileURLWithPath: \"/usr/bin/xcodebuild\")\n        process.arguments = [\n            \"-workspace\", \"YourApp.xcworkspace\",\n            \"-scheme\", \"YourApp\",\n            \"-configuration\", \"Release\",\n            \"-destination\", \"generic/platform=iOS\",\n            \"clean\", \"archive\",\n            \"-archivePath\", \"build/YourApp.xcarchive\"\n        ]\n        \n        try process.run()\n        process.waitUntilExit()\n        \n        guard process.terminationStatus == 0 else {\n            throw SubmissionError.buildFailed\n        }\n    }\n}\n\nenum SubmissionError: Error {\n    case metadataValidationFailed\n    case buildFailed\n    case uploadFailed\n    case submissionFailed\n}",
      "category": "App Store & Distribution",
      "estimatedTime": 300,
      "dependencies": ["ios_fundamentals", "version_control", "ci_cd"],
      "challenge": {
        "instructions": "Complete this comprehensive App Store submission simulation:\n\nPART 1: App Store Connect Setup (60 min)\n1. Configure App Store Connect team with proper roles\n2. Create and manage Bundle IDs for multiple environments\n3. Set up app capabilities and services\n4. Configure in-app purchases and subscriptions\n\nPART 2: Metadata Optimization (90 min)\n5. Create compelling app name and subtitle within character limits\n6. Write engaging description with proper keyword optimization\n7. Design and prepare screenshots for all required device sizes\n8. Produce and optimize app preview videos\n9. Localize metadata for key international markets\n\nPART 3: Build Configuration & Validation (60 min)\n10. Configure Xcode build settings for App Store distribution\n11. Set up proper code signing and provisioning profiles\n12. Create and validate archive build\n13. Configure Info.plist with all required entries\n\nPART 4: Submission Process (60 min)\n14. Upload build to App Store Connect using multiple methods\n15. Complete all metadata in App Store Connect\n16. Configure pricing and availability\n17. Set up age rating and privacy questionnaire\n\nPART 5: Advanced Scenarios (90 min)\n18. Handle App Store rejection and resubmission\n19. Implement phased release strategy\n20. Set up custom product pages for different user segments\n21. Configure App Store Connect API for automation\n22. Create pre-release testing strategy with TestFlight",
        "starterCode": "#!/bin/bash\n\n# === STARTER TEMPLATE ===\n\n# AppStorePreparation.sh\n# Complete the implementation for automated App Store submission\n\n# Configuration\nAPP_NAME=\"YourApp\"\nBUNDLE_ID=\"com.yourcompany.yourapp\"\nTEAM_ID=\"YOUR_TEAM_ID\"\nAPP_STORE_CONNECT_ISSUER_ID=\"YOUR_ISSUER_ID\"\n\n# TODO: Implement the following functions\n\nfunction setup_app_store_connect() {\n    echo \"Setting up App Store Connect...\"\n    # Implement App Store Connect configuration\n}\n\nfunction optimize_metadata() {\n    echo \"Optimizing app metadata...\"\n    # Implement metadata optimization\n}\n\nfunction validate_build() {\n    echo \"Validating build...\"\n    # Implement build validation\n}\n\nfunction upload_to_app_store() {\n    echo \"Uploading to App Store...\"\n    # Implement upload process\n}\n\nfunction handle_submission() {\n    echo \"Handling submission...\"\n    # Implement submission logic\n}\n\n# Main execution flow\nmain() {\n    setup_app_store_connect\n    optimize_metadata\n    validate_build\n    upload_to_app_store\n    handle_submission\n}\n\nmain \"$@\"",
        "solution": "#!/bin/bash\n\n# === COMPLETE APP STORE SUBMISSION SOLUTION ===\n\n# Configuration\nAPP_NAME=\"YourApp\"\nBUNDLE_ID=\"com.yourcompany.yourapp\"\nTEAM_ID=\"YOUR_TEAM_ID\"\nAPP_STORE_CONNECT_ISSUER_ID=\"YOUR_ISSUER_ID\"\nVERSION=\"1.0.0\"\nBUILD_NUMBER=\"1\"\n\nfunction setup_app_store_connect() {\n    echo \"=== SETTING UP APP STORE CONNECT ===\"\n    \n    # Create App ID if it doesn't exist\n    if ! app_id_exists; then\n        echo \"Creating App ID...\"\n        create_app_id\n    fi\n    \n    # Configure capabilities\n    configure_app_capabilities\n    \n    # Set up in-app purchases\n    setup_in_app_purchases\n    \n    # Configure TestFlight groups\n    setup_testflight_groups\n    \n    echo \"App Store Connect setup completed\"\n}\n\nfunction app_id_exists() {\n    # Check if App ID exists in developer portal\n    xcrun altool --list-providers -u \"$APP_STORE_USERNAME\" -p \"$APP_STORE_PASSWORD\" | grep -q \"$BUNDLE_ID\"\n    return $?\n}\n\nfunction create_app_id() {\n    # Create App ID using Apple Developer Portal API\n    curl -X POST \"https://developer.apple.com/services/account/appid/create\" \\\n        -H \"Content-Type: application/json\" \\\n        -H \"Authorization: Bearer $DEVELOPER_TOKEN\" \\\n        -d '{\n            \"name\": \"'\"$APP_NAME\"'\",\n            \"bundleId\": \"'\"$BUNDLE_ID\"'\",\n            \"teamId\": \"'\"$TEAM_ID\"'\"\n        }'\n}\n\nfunction configure_app_capabilities() {\n    echo \"Configuring app capabilities...\"\n    \n    # Enable Push Notifications\n    enable_capability \"push\"\n    \n    # Enable In-App Purchase\n    enable_capability \"in-app-purchase\"\n    \n    # Enable Game Center if needed\n    if [[ \"$APP_TYPE\" == \"game\" ]]; then\n        enable_capability \"game-center\"\n    fi\n    \n    # Enable Sign in with Apple\n    enable_capability \"sign-in-with-apple\"\n}\n\nfunction enable_capability() {\n    local capability=$1\n    echo \"Enabling $capability capability...\"\n    \n    # This would typically use Apple Developer Portal API\n    # or fastlane produce command\n    # fastlane produce enable_services --push-notification\n}\n\nfunction setup_in_app_purchases() {\n    echo \"Setting up in-app purchases...\"\n    \n    # Create consumable IAP\n    create_iap \"premium_coins\" \"100 Premium Coins\" \"0.99\" \"consumable\"\n    \n    # Create subscription\n    create_iap \"premium_subscription\" \"Premium Subscription\" \"4.99\" \"subscription\"\n    \n    # Create non-consumable\n    create_iap \"premium_themes\" \"Premium Themes\" \"2.99\" \"non-consumable\"\n}\n\nfunction create_iap() {\n    local product_id=$1\n    local name=$2\n    local price=$3\n    local type=$4\n    \n    echo \"Creating IAP: $name ($type)\"\n    \n    # Implementation would use App Store Connect API\n    # or fastlane deliver command\n}\n\nfunction optimize_metadata() {\n    echo \"=== OPTIMIZING APP METADATA ===\"\n    \n    # Generate optimized app name and subtitle\n    generate_app_name\n    \n    # Write compelling description\n    write_app_description\n    \n    # Prepare screenshots\n    prepare_screenshots\n    \n    # Create app preview\n    create_app_preview\n    \n    # Localize metadata\n    localize_metadata\n    \n    echo \"Metadata optimization completed\"\n}\n\nfunction generate_app_name() {\n    local primary_keyword=\"Productivity\"\n    local app_name=\"TaskMaster\"\n    local subtitle=\"Smart Task Management\"\n    \n    # Ensure character limits\n    if [[ ${#app_name} -gt 30 ]]; then\n        echo \"Error: App name exceeds 30 characters\"\n        exit 1\n    fi\n    \n    if [[ ${#subtitle} -gt 30 ]]; then\n        echo \"Error: Subtitle exceeds 30 characters\"\n        exit 1\n    fi\n    \n    echo \"App Name: $app_name\"\n    echo \"Subtitle: $subtitle\"\n}\n\nfunction write_app_description() {\n    cat > \"description.txt\" << EOF\nTaskMaster - Revolutionize Your Productivity\n\nðŸŒŸ FEATURES ðŸŒŸ\nâ€¢ Smart task organization with AI-powered suggestions\nâ€¢ Cross-device synchronization\nâ€¢ Collaborative project management\nâ€¢ Time tracking and analytics\nâ€¢ Customizable workflows\n\nðŸ“± WHY TASKMASTER? ðŸ“±\nJoin millions of users who have transformed their productivity. TaskMaster helps you focus on what matters most with intuitive design and powerful features.\n\nðŸ”’ PRIVACY FIRST ðŸ”’\nYour data is always encrypted and under your control. We never sell your personal information.\n\nDownload now and start mastering your tasks!\nEOF\n    \n    echo \"App description written to description.txt\"\n}\n\nfunction prepare_screenshots() {\n    echo \"Preparing screenshots for all device sizes...\"\n    \n    # iPhone 6.7\" screenshots\n    generate_screenshot \"1290\" \"2796\" \"iphone_67\"\n    \n    # iPhone 5.5\" screenshots\n    generate_screenshot \"1242\" \"2208\" \"iphone_55\"\n    \n    # iPad Pro screenshots\n    generate_screenshot \"2048\" \"2732\" \"ipad_pro\"\n    \n    echo \"Screenshots prepared successfully\"\n}\n\nfunction generate_screenshot() {\n    local width=$1\n    local height=$2\n    local device=$3\n    \n    # This would typically use automation tools to generate screenshots\n    # For now, create placeholder\n    echo \"Generating $width x $height screenshot for $device\"\n}\n\nfunction validate_build() {\n    echo \"=== VALIDATING BUILD ===\"\n    \n    # Validate code signing\n    validate_code_signing\n    \n    # Validate entitlements\n    validate_entitlements\n    \n    # Validate Info.plist\n    validate_info_plist\n    \n    # Validate app size\n    validate_app_size\n    \n    # Run static analysis\n    run_static_analysis\n    \n    echo \"Build validation completed\"\n}\n\nfunction validate_code_signing() {\n    echo \"Validating code signing...\"\n    \n    # Check provisioning profiles\n    if ! security find-identity -p codesigning -v | grep -q \"$TEAM_ID\"; then\n        echo \"Error: No valid code signing identity found\"\n        exit 1\n    fi\n    \n    echo \"Code signing validation passed\"\n}\n\nfunction validate_entitlements() {\n    echo \"Validating entitlements...\"\n    \n    # Check required entitlements\n    local required_entitlements=(\n        \"application-identifier\"\n        \"keychain-access-groups\"\n        \"com.apple.developer.team-identifier\"\n    )\n    \n    for entitlement in \"${required_entitlements[@]}\"; do\n        if ! grep -q \"$entitlement\" \"$APP_NAME.entitlements\"; then\n            echo \"Error: Missing entitlement: $entitlement\"\n            exit 1\n        fi\n    done\n    \n    echo \"Entitlements validation passed\"\n}\n\nfunction upload_to_app_store() {\n    echo \"=== UPLOADING TO APP STORE ===\"\n    \n    # Create archive\n    create_archive\n    \n    # Validate archive\n    validate_archive\n    \n    # Upload to App Store Connect\n    upload_archive\n    \n    # Wait for processing\n    wait_for_processing\n    \n    echo \"Upload completed successfully\"\n}\n\nfunction create_archive() {\n    echo \"Creating archive...\"\n    \n    xcodebuild archive \\\n        -workspace \"$APP_NAME.xcworkspace\" \\\n        -scheme \"$APP_NAME\" \\\n        -configuration Release \\\n        -archivePath \"build/$APP_NAME.xcarchive\" \\\n        -destination generic/platform=iOS \\\n        CODE_SIGN_STYLE=\"Manual\" \\\n        PROVISIONING_PROFILE_SPECIFIER=\"App Store\" \\\n        DEVELOPMENT_TEAM=\"$TEAM_ID\"\n    \n    if [[ $? -ne 0 ]]; then\n        echo \"Error: Archive creation failed\"\n        exit 1\n    fi\n}\n\nfunction handle_submission() {\n    echo \"=== HANDLING SUBMISSION ===\"\n    \n    # Update metadata in App Store Connect\n    update_app_store_metadata\n    \n    # Submit for review\n    submit_for_review\n    \n    # Monitor review status\n    monitor_review_status\n    \n    # Handle potential rejection\n    setup_rejection_handling\n    \n    echo \"Submission process completed\"\n}\n\nfunction update_app_store_metadata() {\n    echo \"Updating App Store metadata...\"\n    \n    # Use fastlane deliver or App Store Connect API\n    # to update metadata\n    \n    fastlane deliver \\\n        --username \"$APP_STORE_USERNAME\" \\\n        --app_identifier \"$BUNDLE_ID\" \\\n        --app_version \"$VERSION\" \\\n        --metadata_path \"./metadata\" \\\n        --screenshots_path \"./screenshots\" \\\n        --skip_binary_upload true \\\n        --submit_for_review false \\\n        --automatic_release false\n}\n\nfunction submit_for_review() {\n    echo \"Submitting for App Store review...\"\n    \n    fastlane deliver \\\n        --submit_for_review true \\\n        --automatic_release false \\\n        --force true\n    \n    echo \"App submitted for review successfully\"\n}\n\n# Main execution flow\nmain() {\n    set -e  # Exit on any error\n    \n    echo \"Starting App Store submission process...\"\n    \n    setup_app_store_connect\n    optimize_metadata\n    validate_build\n    upload_to_app_store\n    handle_submission\n    \n    echo \"=== APP STORE SUBMISSION COMPLETED ===\"\n    echo \"App successfully submitted to App Store!\"\n    echo \"Version: $VERSION\"\n    echo \"Build: $BUILD_NUMBER\"\n    echo \"Bundle ID: $BUNDLE_ID\"\n}\n\nmain \"$@\"",
        "hints": [
          "Use fastlane match for automated code signing management",
          "Always validate builds on multiple device types before submission",
          "Keep app names under 30 characters and subtitles under 30 characters",
          "Use keyword-rich descriptions for better App Store Optimization",
          "Test all in-app purchases thoroughly in Sandbox environment",
          "Monitor App Store Connect for processing status updates",
          "Have a rejection response plan ready before submission",
          "Use phased release for major updates to monitor stability",
          "Keep screenshots updated with each major version release",
          "Respond to App Store reviews promptly to improve ratings"
        ],
        "testCases": [
          {
            "input": "validate_app_name \"My Super Long App Name That Definitely Exceeds Character Limits\"",
            "expectedOutput": "false",
            "description": "App name validation should fail for names over 30 characters"
          },
          {
            "input": "validate_bundle_id \"com.company.app\"",
            "expectedOutput": "true",
            "description": "Bundle ID should follow reverse DNS notation"
          },
          {
            "input": "check_screenshot_sizes \"./screenshots\"",
            "expectedOutput": "true",
            "description": "All screenshots should meet Apple's required dimensions"
          },
          {
            "input": "validate_privacy_policy \"https://company.com/privacy\"",
            "expectedOutput": "true",
            "description": "Privacy policy URL should be valid and accessible"
          }
        ]
      }
    },
    {
      "id": "in_app_purchases",
      "title": "In-App Purchases & Subscriptions",
      "description": "Master StoreKit 2 for implementing in-app purchases, subscriptions, and managing digital products in iOS apps",
      "difficulty": "advanced",
      "theory": "# In-App Purchases & Subscriptions with StoreKit 2\n\n## 1. StoreKit 2 Fundamentals (60 min)\n\n### Introduction to StoreKit 2\nStoreKit 2 is Apple's modern framework for handling in-app purchases with Swift-native async/await APIs.\n\n**Key Improvements over StoreKit 1:**\n- Async/await support\n- Swift-native error handling\n- Simplified transaction management\n- Enhanced subscription APIs\n\n### StoreKit Architecture:\n```swift\nimport StoreKit\n\n// Product Types\nenum ProductType {\n    case consumable        // One-time use (coins, gems)\n    case nonConsumable    // Permanent purchase (remove ads)\n    case autoRenewable   // Subscriptions\n    case nonRenewable    // Content access for limited time\n}\n```\n\n### App Store Connect Setup:\n1. **Create App ID** in Apple Developer Portal\n2. **Configure In-App Purchases** in App Store Connect\n3. **Set up Bank and Tax Information**\n4. **Create Sandbox Testers**\n5. **Configure Product Entitlements**\n\n## 2. Product Management (90 min)\n\n### Fetching Products:\n```swift\nimport StoreKit\n\n@MainActor\nclass StoreKitManager: ObservableObject {\n    @Published var products: [Product] = []\n    @Published var purchasedProductIDs: Set<String> = []\n    \n    private var productIDs: Set<String> = [\n        \"com.yourapp.consumable.coins_100\",\n        \"com.yourapp.nonconsumable.remove_ads\",\n        \"com.yourapp.subscription.premium_monthly\",\n        \"com.yourapp.subscription.premium_yearly\"\n    ]\n    \n    func fetchProducts() async {\n        do {\n            let storeProducts = try await Product.products(for: productIDs)\n            await MainActor.run {\n                self.products = storeProducts\n            }\n        } catch {\n            print(\"Failed to fetch products: \\(error)\")\n        }\n    }\n}\n```\n\n### Product Properties:\n```swift\nstruct ProductView: View {\n    let product: Product\n    \n    var body: some View {\n        VStack {\n            Text(product.displayName)\n            Text(product.description)\n            Text(product.displayPrice)\n            \n            if let subscription = product.subscription {\n                Text(\"Subscription Group: \\(subscription.subscriptionGroupID)\")\n                Text(\"Renewal Period: \\(subscription.subscriptionPeriod.unit)\")\n            }\n        }\n    }\n}\n```\n\n### Product Validation:\n```swift\nextension StoreKitManager {\n    func validateProducts() async throws {\n        let products = try await Product.products(for: productIDs)\n        \n        for product in products {\n            switch product.type {\n            case .consumable:\n                print(\"Consumable: \\(product.id)\")\n            case .nonConsumable:\n                print(\"Non-Consumable: \\(product.id)\")\n            case .autoRenewable:\n                print(\"Auto-Renewable Subscription: \\(product.id)\")\n            case .nonRenewable:\n                print(\"Non-Renewable Subscription: \\(product.id)\")\n            @unknown default:\n                print(\"Unknown product type: \\(product.id)\")\n            }\n        }\n    }\n}\n```\n\n## 3. Purchase Flow & Transaction Handling (120 min)\n\n### Making Purchases:\n```swift\nextension StoreKitManager {\n    func purchase(_ product: Product) async throws -> Transaction? {\n        let result = try await product.purchase()\n        \n        switch result {\n        case .success(let verification):\n            let transaction = try checkVerified(verification)\n            await updatePurchasedProducts(transaction)\n            await transaction.finish()\n            return transaction\n            \n        case .pending:\n            print(\"Purchase pending - requires additional action\")\n            return nil\n            \n        case .userCancelled:\n            print(\"User cancelled purchase\")\n            return nil\n            \n        @unknown default:\n            print(\"Unknown purchase result\")\n            return nil\n        }\n    }\n    \n    private func checkVerified<T>(_ result: VerificationResult<T>) throws -> T {\n        switch result {\n        case .unverified(_, let error):\n            throw error\n        case .verified(let safe):\n            return safe\n        }\n    }\n}\n```\n\n### Transaction Listeners:\n```swift\nextension StoreKitManager {\n    func setupTransactionListener() {\n        Task.detached {\n            for await result in Transaction.updates {\n                do {\n                    let transaction = try self.checkVerified(result)\n                    await self.updatePurchasedProducts(transaction)\n                    await transaction.finish()\n                } catch {\n                    print(\"Transaction failed verification: \\(error)\")\n                }\n            }\n        }\n    }\n    \n    @MainActor\n    private func updatePurchasedProducts(_ transaction: Transaction) async {\n        if transaction.revocationDate == nil {\n            purchasedProductIDs.insert(transaction.productID)\n        } else {\n            purchasedProductIDs.remove(transaction.productID)\n        }\n    }\n}\n```\n\n### Restoring Purchases:\n```swift\nextension StoreKitManager {\n    func restorePurchases() async throws {\n        try await AppStore.sync()\n        \n        for await result in Transaction.currentEntitlements {\n            do {\n                let transaction = try checkVerified(result)\n                await updatePurchasedProducts(transaction)\n            } catch {\n                print(\"Restore failed for transaction: \\(error)\")\n            }\n        }\n    }\n}\n```\n\n## 4. Subscription Management (90 min)\n\n### Subscription Status:\n```swift\nextension StoreKitManager {\n    func checkSubscriptionStatus() async -> [String: Product.SubscriptionInfo.Status] {\n        var statuses: [String: Product.SubscriptionInfo.Status] = [:]\n        \n        for await result in Transaction.currentEntitlements {\n            guard case .verified(let transaction) = result,\n                  let subscription = transaction.subscription else {\n                continue\n            }\n            \n            let status = await subscription.status\n            statuses[transaction.productID] = status.first\n        }\n        \n        return statuses\n    }\n}\n```\n\n### Subscription Groups:\n```swift\nclass SubscriptionManager: ObservableObject {\n    @Published var subscriptionGroups: [String: [Product]] = [:]\n    \n    func organizeProductsByGroup(_ products: [Product]) {\n        var groups: [String: [Product]] = [:]\n        \n        for product in products where product.type == .autoRenewable {\n            if let subscription = product.subscription {\n                let groupID = subscription.subscriptionGroupID\n                groups[groupID, default: []].append(product)\n            }\n        }\n        \n        subscriptionGroups = groups\n    }\n}\n```\n\n### Subscription Renewal Information:\n```swift\nstruct SubscriptionStatusView: View {\n    let status: Product.SubscriptionInfo.Status\n    \n    var body: some View {\n        VStack(alignment: .leading) {\n            Text(\"State: \\(status.state.description)\")\n            \n            if let renewalInfo = status.renewalInfo {\n                Text(\"Renews: \\(renewalInfo.currentProductID)\")\n                \n                if let expiration = status.expirationDate {\n                    Text(\"Expires: \\(expiration, style: .date)\")\n                }\n            }\n        }\n    }\n}\n```\n\n## 5. Advanced Subscription Features (120 min)\n\n### Introductory Offers:\n```swift\nextension StoreKitManager {\n    func checkIntroductoryOffers() async {\n        for product in products {\n            guard let subscription = product.subscription,\n                  let introductoryOffer = subscription.introductoryOffer else {\n                continue\n            }\n            \n            switch introductoryOffer {\n            case .freeTrial(let period, let unit, _):\n                print(\"Free trial: \\(period) \\(unit)\")\n            case .payAsYouGo(let price, let period, let unit, _):\n                print(\"Pay as you go: \\(price) for \\(period) \\(unit)\")\n            case .payUpFront(let price, let period, let unit, _):\n                print(\"Pay up front: \\(price) for \\(period) \\(unit)\")\n            @unknown default:\n                break\n            }\n        }\n    }\n}\n```\n\n### Promotional Offers:\n```swift\nextension StoreKitManager {\n    func checkEligibilityForPromotionalOffer() async -> Bool {\n        guard let product = products.first(where: { $0.type == .autoRenewable }) else {\n            return false\n        }\n        \n        let eligibility = await product.subscription?.isEligibleForIntroOffer\n        return eligibility ?? false\n    }\n    \n    func generatePromotionalSignature() async throws -> (String, String, String) {\n        let offer = try await Product.PromotionalOffer.Signature(\n            productID: \"com.yourapp.subscription.premium\",\n            applicationUsername: \"user123\"\n        )\n        \n        return (offer.signature, offer.keyIdentifier, offer.nonce)\n    }\n}\n```\n\n### Family Sharing:\n```swift\nextension StoreKitManager {\n    func checkFamilySharingStatus() async -> Bool {\n        let groupID = \"your_group_id\"\n        return await Product.SubscriptionGroup.status(for: groupID) == .inGroup\n    }\n    \n    func manageFamilySharing() async {\n        do {\n            try await AppStore.showManageSubscriptions(in: <#UIWindowScene#>)\n        } catch {\n            print(\"Failed to show subscription management: \\(error)\")\n        }\n    }\n}\n```\n\n## 6. Testing & Debugging (60 min)\n\n### Sandbox Testing:\n```swift\nclass StoreKitTestingManager {\n    func setupTestEnvironment() {\n        // Configure StoreKit Testing\n        let configuration = Configuration.storeKit\n        \n        // Create test transactions\n        Task {\n            try await StoreKit.Transaction.generate(\n                productID: \"com.yourapp.consumable.coins_100\",\n                with: .buy\n            )\n        }\n    }\n    \n    func simulateSubscriptionRenewal() async throws {\n        try await StoreKit.Transaction.generate(\n            productID: \"com.yourapp.subscription.premium_monthly\",\n            with: .renew\n        )\n    }\n    \n    func simulateSubscriptionExpiration() async throws {\n        try await StoreKit.Transaction.generate(\n            productID: \"com.yourapp.subscription.premium_monthly\",\n            with: .expire\n        )\n    }\n}\n```\n\n### Error Handling:\n```swift\nextension StoreKitManager {\n    func handlePurchaseError(_ error: Error) -> String {\n        if let storeError = error as? StoreKitError {\n            switch storeError {\n            case .userCancelled:\n                return \"Purchase was cancelled\"\n            case .networkError(let underlyingError):\n                return \"Network error: \\(underlyingError.localizedDescription)\"\n            case .systemError(let code):\n                return \"System error: \\(code)\"\n            case .notAvailableInStorefront:\n                return \"Product not available in your region\"\n            @unknown default:\n                return \"Unknown StoreKit error\"\n            }\n        }\n        return error.localizedDescription\n    }\n}\n```\n\n## 7. Advanced Patterns & Best Practices (90 min)\n\n### Purchase Coordinator Pattern:\n```swift\n@MainActor\nclass PurchaseCoordinator: ObservableObject {\n    @Published var purchaseState: PurchaseState = .idle\n    \n    enum PurchaseState {\n        case idle\n        case purchasing\n        case success(Product)\n        case failure(Error)\n        case pending\n    }\n    \n    private let storeManager: StoreKitManager\n    \n    init(storeManager: StoreKitManager) {\n        self.storeManager = storeManager\n    }\n    \n    func purchaseProduct(_ product: Product) async {\n        purchaseState = .purchasing\n        \n        do {\n            if let transaction = try await storeManager.purchase(product) {\n                purchaseState = .success(product)\n                // Handle successful purchase\n                await handleSuccessfulPurchase(transaction)\n            } else {\n                purchaseState = .pending\n            }\n        } catch {\n            purchaseState = .failure(error)\n        }\n    }\n}\n```\n\n### Entitlement Manager:\n```swift\nclass EntitlementManager: ObservableObject {\n    @Published var userEntitlements: Set<UserEntitlement> = []\n    \n    struct UserEntitlement: Hashable {\n        let productID: String\n        let type: Product.ProductType\n        let expirationDate: Date?\n        let isActive: Bool\n    }\n    \n    func updateEntitlements(from transactions: [Transaction]) {\n        var newEntitlements: Set<UserEntitlement> = []\n        \n        for transaction in transactions {\n            let entitlement = UserEntitlement(\n                productID: transaction.productID,\n                type: transaction.productType,\n                expirationDate: transaction.expirationDate,\n                isActive: transaction.isActive\n            )\n            newEntitlements.insert(entitlement)\n        }\n        \n        userEntitlements = newEntitlements\n    }\n    \n    func hasEntitlement(_ productID: String) -> Bool {\n        return userEntitlements.contains { $0.productID == productID && $0.isActive }\n    }\n}\n```\n\n### Analytics & Tracking:\n```swift\nclass PurchaseAnalytics {\n    func trackPurchaseEvent(_ transaction: Transaction, product: Product) {\n        let event: [String: Any] = [\n            \"product_id\": transaction.productID,\n            \"transaction_id\": transaction.id,\n            \"purchase_date\": transaction.purchaseDate,\n            \"revenue\": product.price,\n            \"currency\": product.priceFormatStyle.currencyCode ?? \"USD\"\n        ]\n        \n        // Send to analytics service\n        AnalyticsService.track(event: \"purchase_completed\", parameters: event)\n    }\n    \n    func trackSubscriptionRenewal(_ transaction: Transaction) {\n        let event: [String: Any] = [\n            \"product_id\": transaction.productID,\n            \"renewal_date\": transaction.purchaseDate,\n            \"original_transaction_id\": transaction.originalID\n        ]\n        \n        AnalyticsService.track(event: \"subscription_renewed\", parameters: event)\n    }\n}\n```\n\n## 8. Security & Compliance (30 min)\n\n### Receipt Validation:\n```swift\nclass ReceiptValidator {\n    func validateReceipt() async throws -> Bool {\n        guard let appStoreReceiptURL = Bundle.main.appStoreReceiptURL,\n              FileManager.default.fileExists(atPath: appStoreReceiptURL.path) else {\n            throw ReceiptError.receiptNotFound\n        }\n        \n        let receiptData = try Data(contentsOf: appStoreReceiptURL)\n        return try await verifyReceiptWithApple(receiptData)\n    }\n    \n    private func verifyReceiptWithApple(_ receiptData: Data) async throws -> Bool {\n        // Implement server-side receipt validation\n        return true\n    }\n}\n\nenum ReceiptError: Error {\n    case receiptNotFound\n    case validationFailed\n    case networkError\n}\n```\n\n### Privacy Compliance:\n```swift\nclass PrivacyManager {\n    func shouldShowPrivacyConsent() -> Bool {\n        return !UserDefaults.standard.bool(forKey: \"hasShownPrivacyConsent\")\n    }\n    \n    func recordPrivacyConsent() {\n        UserDefaults.standard.set(true, forKey: \"hasShownPrivacyConsent\")\n        UserDefaults.standard.set(Date(), forKey: \"privacyConsentDate\")\n    }\n}\n```",
      "codeExample": "import StoreKit\nimport SwiftUI\n\n// === COMPLETE STOREKIT 2 IMPLEMENTATION ===\n\n@MainActor\nclass StoreManager: ObservableObject {\n    @Published var products: [Product] = []\n    @Published var purchasedProductIDs: Set<String> = []\n    @Published var subscriptionStatus: [String: Product.SubscriptionInfo.Status] = [:]\n    \n    private let productIDs: Set<String> = [\n        \"com.gamedev.consumable.coins_100\",\n        \"com.gamedev.consumable.coins_500\",\n        \"com.gamedev.nonconsumable.remove_ads\",\n        \"com.gamedev.subscription.premium_monthly\",\n        \"com.gamedev.subscription.premium_yearly\",\n        \"com.gamedev.subscription.pro_weekly\"\n    ]\n    \n    private var updates: Task<Void, Never>? = nil\n    \n    init() {\n        updates = Task {\n            await listenForTransactions()\n        }\n    }\n    \n    deinit {\n        updates?.cancel()\n    }\n    \n    // MARK: - Product Management\n    func fetchProducts() async {\n        do {\n            let storeProducts = try await Product.products(for: productIDs)\n            await MainActor.run {\n                self.products = storeProducts.sorted { $0.price < $1.price }\n            }\n        } catch {\n            print(\"Failed to fetch products: \\(error)\")\n        }\n    }\n    \n    // MARK: - Purchase Flow\n    func purchase(_ product: Product) async throws -> Transaction? {\n        let result = try await product.purchase()\n        \n        switch result {\n        case .success(let verification):\n            let transaction = try checkVerified(verification)\n            await updatePurchasedProducts(transaction)\n            await transaction.finish()\n            return transaction\n            \n        case .pending:\n            print(\"Purchase pending - requires additional action\")\n            return nil\n            \n        case .userCancelled:\n            print(\"User cancelled purchase\")\n            return nil\n            \n        @unknown default:\n            return nil\n        }\n    }\n    \n    // MARK: - Transaction Handling\n    private func listenForTransactions() async {\n        for await result in Transaction.updates {\n            do {\n                let transaction = try checkVerified(result)\n                await updatePurchasedProducts(transaction)\n                await transaction.finish()\n            } catch {\n                print(\"Transaction failed verification: \\(error)\")\n            }\n        }\n    }\n    \n    private func checkVerified<T>(_ result: VerificationResult<T>) throws -> T {\n        switch result {\n        case .unverified(_, let error):\n            throw error\n        case .verified(let safe):\n            return safe\n        }\n    }\n    \n    @MainActor\n    private func updatePurchasedProducts(_ transaction: Transaction) async {\n        if transaction.revocationDate == nil {\n            purchasedProductIDs.insert(transaction.productID)\n        } else {\n            purchasedProductIDs.remove(transaction.productID)\n        }\n        \n        // Update subscription status\n        await updateSubscriptionStatus()\n    }\n    \n    // MARK: - Subscription Management\n    func updateSubscriptionStatus() async {\n        var statuses: [String: Product.SubscriptionInfo.Status] = [:]\n        \n        for await result in Transaction.currentEntitlements {\n            guard case .verified(let transaction) = result,\n                  transaction.productType == .autoRenewable,\n                  let subscription = transaction.subscription else {\n                continue\n            }\n            \n            let status = await subscription.status\n            if let firstStatus = status.first {\n                statuses[transaction.productID] = firstStatus\n            }\n        }\n        \n        await MainActor.run {\n            self.subscriptionStatus = statuses\n        }\n    }\n    \n    func isProductPurchased(_ productID: String) -> Bool {\n        return purchasedProductIDs.contains(productID)\n    }\n    \n    func hasActiveSubscription() -> Bool {\n        return subscriptionStatus.values.contains { status in\n            status.state == .subscribed || status.state == .inGracePeriod\n        }\n    }\n    \n    // MARK: - Restore Purchases\n    func restorePurchases() async throws {\n        try await AppStore.sync()\n        \n        for await result in Transaction.currentEntitlements {\n            do {\n                let transaction = try checkVerified(result)\n                await updatePurchasedProducts(transaction)\n            } catch {\n                print(\"Restore failed: \\(error)\")\n            }\n        }\n    }\n}\n\n// === UI COMPONENTS ===\n\nstruct ProductListView: View {\n    @EnvironmentObject var storeManager: StoreManager\n    @State private var isLoading = false\n    @State private var errorMessage: String?\n    \n    var body: some View {\n        List {\n            if isLoading {\n                ProgressView(\"Loading products...\")\n            } else if let error = errorMessage {\n                Text(\"Error: \\(error)\")\n                    .foregroundColor(.red)\n            } else {\n                ForEach(storeManager.products, id: \\.id) { product in\n                    ProductRow(product: product)\n                }\n            }\n        }\n        .navigationTitle(\"Store\")\n        .task {\n            await loadProducts()\n        }\n        .refreshable {\n            await loadProducts()\n        }\n    }\n    \n    private func loadProducts() async {\n        isLoading = true\n        errorMessage = nil\n        \n        await storeManager.fetchProducts()\n        \n        isLoading = false\n        if storeManager.products.isEmpty {\n            errorMessage = \"No products available\"\n        }\n    }\n}\n\nstruct ProductRow: View {\n    @EnvironmentObject var storeManager: StoreManager\n    let product: Product\n    @State private var isPurchasing = false\n    @State private var showAlert = false\n    @State private var alertMessage = \"\"\n    \n    var body: some View {\n        VStack(alignment: .leading, spacing: 8) {\n            HStack {\n                VStack(alignment: .leading) {\n                    Text(product.displayName)\n                        .font(.headline)\n                    Text(product.description)\n                        .font(.caption)\n                        .foregroundColor(.secondary)\n                    \n                    if product.type == .autoRenewable, let subscription = product.subscription {\n                        SubscriptionInfoView(subscription: subscription)\n                    }\n                }\n                \n                Spacer()\n                \n                VStack(alignment: .trailing) {\n                    Text(product.displayPrice)\n                        .font(.title3)\n                        .bold()\n                    \n                    if storeManager.isProductPurchased(product.id) {\n                        Text(\"Purchased\")\n                            .font(.caption)\n                            .foregroundColor(.green)\n                    } else {\n                        PurchaseButton(\n                            product: product,\n                            isPurchasing: $isPurchasing,\n                            showAlert: $showAlert,\n                            alertMessage: $alertMessage\n                        )\n                    }\n                }\n            }\n        }\n        .padding(.vertical, 4)\n        .alert(\"Purchase\", isPresented: $showAlert) {\n            Button(\"OK\") { }\n        } message: {\n            Text(alertMessage)\n        }\n    }\n}\n\nstruct PurchaseButton: View {\n    @EnvironmentObject var storeManager: StoreManager\n    let product: Product\n    @Binding var isPurchasing: Bool\n    @Binding var showAlert: Bool\n    @Binding var alertMessage: String\n    \n    var body: some View {\n        Button(action: purchaseProduct) {\n            if isPurchasing {\n                ProgressView()\n                    .scaleEffect(0.8)\n            } else {\n                Text(\"Buy\")\n            }\n        }\n        .disabled(isPurchasing)\n        .buttonStyle(.borderedProminent)\n    }\n    \n    private func purchaseProduct() {\n        Task {\n            isPurchasing = true\n            \n            do {\n                if let transaction = try await storeManager.purchase(product) {\n                    alertMessage = \"Successfully purchased \\(product.displayName)\"\n                } else {\n                    alertMessage = \"Purchase is pending\"\n                }\n            } catch {\n                alertMessage = \"Purchase failed: \\(error.localizedDescription)\"\n            }\n            \n            isPurchasing = false\n            showAlert = true\n        }\n    }\n}\n\nstruct SubscriptionInfoView: View {\n    let subscription: Product.SubscriptionInfo\n    \n    var body: some View {\n        VStack(alignment: .leading) {\n            Text(\"Renews every \\(subscription.subscriptionPeriod.value) \\(subscription.subscriptionPeriod.unit)\")\n                .font(.caption2)\n                .foregroundColor(.blue)\n            \n            if let introductoryOffer = subscription.introductoryOffer {\n                Text(\"Introductory offer available\")\n                    .font(.caption2)\n                    .foregroundColor(.green)\n            }\n        }\n    }\n}\n\n// === SUBSCRIPTION STATUS VIEW ===\n\nstruct SubscriptionStatusView: View {\n    @EnvironmentObject var storeManager: StoreManager\n    \n    var body: some View {\n        VStack(alignment: .leading) {\n            Text(\"Subscription Status\")\n                .font(.title2)\n                .bold()\n            \n            if storeManager.hasActiveSubscription() {\n                ForEach(Array(storeManager.subscriptionStatus.keys), id: \\.self) { productID in\n                    if let status = storeManager.subscriptionStatus[productID],\n                       let product = storeManager.products.first(where: { $0.id == productID }) {\n                        SubscriptionStatusRow(product: product, status: status)\n                    }\n                }\n            } else {\n                Text(\"No active subscription\")\n                    .foregroundColor(.secondary)\n            }\n        }\n        .padding()\n        .background(Color.gray.opacity(0.1))\n        .cornerRadius(10)\n    }\n}\n\nstruct SubscriptionStatusRow: View {\n    let product: Product\n    let status: Product.SubscriptionInfo.Status\n    \n    var body: some View {\n        HStack {\n            VStack(alignment: .leading) {\n                Text(product.displayName)\n                    .font(.headline)\n                Text(status.state.description)\n                    .font(.caption)\n                    .foregroundColor(status.state == .subscribed ? .green : .orange)\n                \n                if let expiration = status.expirationDate {\n                    Text(\"Expires: \\(expiration, style: .date)\")\n                        .font(.caption2)\n                        .foregroundColor(.secondary)\n                }\n            }\n            \n            Spacer()\n        }\n        .padding()\n        .background(Color.white)\n        .cornerRadius(8)\n    }\n}\n\n// === ENTRY POINT ===\n\n@main\nstruct MyApp: App {\n    @StateObject private var storeManager = StoreManager()\n    \n    var body: some Scene {\n        WindowGroup {\n            ContentView()\n                .environmentObject(storeManager)\n        }\n    }\n}\n\nstruct ContentView: View {\n    @EnvironmentObject var storeManager: StoreManager\n    \n    var body: some View {\n        TabView {\n            ProductListView()\n                .tabItem {\n                    Label(\"Store\", systemImage: \"cart\")\n                }\n            \n            SubscriptionStatusView()\n                .tabItem {\n                    Label(\"Subscriptions\", systemImage: \"star\")\n                }\n        }\n        .task {\n            await storeManager.fetchProducts()\n            await storeManager.updateSubscriptionStatus()\n        }\n    }\n}",
      "category": "Monetization",
      "estimatedTime": 240,
      "dependencies": ["swift_concurrency", "swiftui_fundamentals"],
      "challenge": {
        "instructions": "Build a complete subscription-based app with StoreKit 2:\n\nPART 1: Store Setup & Product Management (60 min)\n1. Create a StoreManager class with async/await product fetching\n2. Implement product caching and error handling\n3. Create UI components for displaying products with subscription info\n4. Handle different product types (consumable, non-consumable, subscriptions)\n\nPART 2: Purchase Flow & Transaction Handling (90 min)\n5. Implement purchase flow with proper state management\n6. Set up transaction listeners for real-time updates\n7. Handle purchase verification and JWT validation\n8. Implement restore purchases functionality\n\nPART 3: Subscription Management & Status (90 min)\n9. Create subscription status monitoring system\n10. Implement family sharing checks and group management\n11. Handle subscription renewals, expirations, and grace periods\n12. Create UI for subscription status and renewal information\n\nPART 4: Advanced Subscription Features (120 min)\n13. Implement introductory offers and promotional pricing\n14. Create subscription upgrade/downgrade logic\n15. Handle subscription sharing and group management\n16. Implement server-side receipt validation\n\nPART 5: Testing & Analytics (60 min)\n17. Set up StoreKit Testing configuration\n18. Create unit tests for purchase flows\n19. Implement analytics tracking for revenue and conversion\n20. Add error reporting and crash monitoring",
        "starterCode": "import StoreKit\nimport SwiftUI\n\n// TODO: Implement StoreManager class\nclass StoreManager: ObservableObject {\n    // Add required properties and methods\n}\n\n// TODO: Create product display UI\nstruct ProductView: View {\n    var body: some View {\n        Text(\"Implement product display\")\n    }\n}\n\n// TODO: Implement purchase flow\nstruct PurchaseFlow: View {\n    var body: some View {\n        Text(\"Implement purchase flow\")\n    }\n}\n\n// TODO: Create subscription status monitor\nclass SubscriptionMonitor {\n    // Implement subscription status tracking\n}\n\n// TODO: Add StoreKit testing configuration\nstruct StoreKitTesting {\n    // Implement test environment setup\n}",
        "solution": "import StoreKit\nimport SwiftUI\n\n// === COMPLETE STORE MANAGER ===\n\n@MainActor\nclass StoreManager: ObservableObject {\n    @Published var products: [Product] = []\n    @Published var purchasedProductIDs: Set<String> = []\n    @Published var subscriptionStatus: [String: Product.SubscriptionInfo.Status] = [:]\n    @Published var purchaseState: PurchaseState = .idle\n    \n    enum PurchaseState {\n        case idle, purchasing, success, failed(Error), pending\n    }\n    \n    private let productIDs: Set<String> = [\n        \"com.yourapp.consumable.coins_100\",\n        \"com.yourapp.nonconsumable.premium_features\",\n        \"com.yourapp.subscription.pro_monthly\",\n        \"com.yourapp.subscription.pro_yearly\"\n    ]\n    \n    private var updates: Task<Void, Never>? = nil\n    \n    init() {\n        setupTransactionListener()\n    }\n    \n    deinit {\n        updates?.cancel()\n    }\n    \n    // MARK: - Product Management\n    func fetchProducts() async {\n        do {\n            let storeProducts = try await Product.products(for: productIDs)\n            await MainActor.run {\n                self.products = storeProducts\n            }\n        } catch {\n            print(\"Failed to fetch products: \\(error)\")\n        }\n    }\n    \n    // MARK: - Purchase Flow\n    func purchase(_ product: Product) async throws {\n        await MainActor.run { purchaseState = .purchasing }\n        \n        let result = try await product.purchase()\n        \n        switch result {\n        case .success(let verification):\n            let transaction = try checkVerified(verification)\n            await updatePurchasedProducts(transaction)\n            await transaction.finish()\n            await MainActor.run { purchaseState = .success }\n            \n        case .pending:\n            await MainActor.run { purchaseState = .pending }\n            \n        case .userCancelled:\n            await MainActor.run { purchaseState = .idle }\n            \n        @unknown default:\n            await MainActor.run { purchaseState = .idle }\n        }\n    }\n    \n    // MARK: - Transaction Handling\n    private func setupTransactionListener() {\n        updates = Task {\n            for await result in Transaction.updates {\n                await handleTransaction(result)\n            }\n        }\n    }\n    \n    private func handleTransaction(_ result: VerificationResult<Transaction>) async {\n        do {\n            let transaction = try checkVerified(result)\n            await updatePurchasedProducts(transaction)\n            await updateSubscriptionStatus()\n            await transaction.finish()\n        } catch {\n            print(\"Transaction verification failed: \\(error)\")\n        }\n    }\n    \n    private func checkVerified<T>(_ result: VerificationResult<T>) throws -> T {\n        switch result {\n        case .unverified(_, let error):\n            throw error\n        case .verified(let safe):\n            return safe\n        }\n    }\n    \n    @MainActor\n    private func updatePurchasedProducts(_ transaction: Transaction) async {\n        if transaction.revocationDate == nil {\n            purchasedProductIDs.insert(transaction.productID)\n        } else {\n            purchasedProductIDs.remove(transaction.productID)\n        }\n    }\n    \n    // MARK: - Subscription Management\n    func updateSubscriptionStatus() async {\n        var statuses: [String: Product.SubscriptionInfo.Status] = [:]\n        \n        for await result in Transaction.currentEntitlements {\n            guard case .verified(let transaction) = result,\n                  transaction.productType == .autoRenewable,\n                  let subscription = transaction.subscription else {\n                continue\n            }\n            \n            let status = await subscription.status\n            if let firstStatus = status.first {\n                statuses[transaction.productID] = firstStatus\n            }\n        }\n        \n        await MainActor.run {\n            self.subscriptionStatus = statuses\n        }\n    }\n    \n    func hasActiveSubscription() -> Bool {\n        return subscriptionStatus.values.contains { status in\n            status.state == .subscribed || status.state == .inGracePeriod\n        }\n    }\n    \n    // MARK: - Restore Purchases\n    func restorePurchases() async throws {\n        try await AppStore.sync()\n        await updateSubscriptionStatus()\n    }\n}\n\n// === COMPLETE UI IMPLEMENTATION ===\n\nstruct StoreView: View {\n    @StateObject private var storeManager = StoreManager()\n    \n    var body: some View {\n        NavigationView {\n            List {\n                Section(\"Subscriptions\") {\n                    ForEach(storeManager.products.filter { $0.type == .autoRenewable }, id: \\.id) { product in\n                        SubscriptionProductRow(product: product)\n                    }\n                }\n                \n                Section(\"One-time Purchases\") {\n                    ForEach(storeManager.products.filter { $0.type != .autoRenewable }, id: \\.id) { product in\n                        ProductRow(product: product)\n                    }\n                }\n                \n                Section(\"Subscription Status\") {\n                    SubscriptionStatusView()\n                }\n            }\n            .navigationTitle(\"Store\")\n            .toolbar {\n                ToolbarItem(placement: .navigationBarTrailing) {\n                    Button(\"Restore\") {\n                        Task {\n                            try? await storeManager.restorePurchases()\n                        }\n                    }\n                }\n            }\n        }\n        .environmentObject(storeManager)\n        .task {\n            await storeManager.fetchProducts()\n            await storeManager.updateSubscriptionStatus()\n        }\n    }\n}\n\nstruct SubscriptionProductRow: View {\n    @EnvironmentObject var storeManager: StoreManager\n    let product: Product\n    @State private var isPurchasing = false\n    \n    var body: some View {\n        VStack(alignment: .leading, spacing: 8) {\n            HStack {\n                VStack(alignment: .leading, spacing: 4) {\n                    Text(product.displayName)\n                        .font(.headline)\n                    Text(product.description)\n                        .font(.caption)\n                        .foregroundColor(.secondary)\n                    \n                    if let subscription = product.subscription {\n                        Text(\"Every \\(subscription.subscriptionPeriod.value) \\(subscription.subscriptionPeriod.unit)\")\n                            .font(.caption2)\n                            .foregroundColor(.blue)\n                    }\n                }\n                \n                Spacer()\n                \n                VStack(alignment: .trailing) {\n                    Text(product.displayPrice)\n                        .font(.title3)\n                        .bold()\n                    \n                    if isPurchasing {\n                        ProgressView()\n                    } else {\n                        Button(\"Subscribe\") {\n                            Task {\n                                isPurchasing = true\n                                try? await storeManager.purchase(product)\n                                isPurchasing = false\n                            }\n                        }\n                        .buttonStyle(.borderedProminent)\n                    }\n                }\n            }\n        }\n        .padding(.vertical, 8)\n    }\n}\n\nstruct SubscriptionStatusView: View {\n    @EnvironmentObject var storeManager: StoreManager\n    \n    var body: some View {\n        VStack(alignment: .leading, spacing: 8) {\n            if storeManager.hasActiveSubscription() {\n                Text(\"Active Subscription\")\n                    .foregroundColor(.green)\n                    .bold()\n                \n                ForEach(Array(storeManager.subscriptionStatus.keys), id: \\.self) { productID in\n                    if let status = storeManager.subscriptionStatus[productID],\n                       let product = storeManager.products.first(where: { $0.id == productID }) {\n                        HStack {\n                            Text(product.displayName)\n                            Spacer()\n                            Text(status.state.description)\n                                .foregroundColor(status.state == .subscribed ? .green : .orange)\n                        }\n                        .font(.caption)\n                    }\n                }\n            } else {\n                Text(\"No Active Subscription\")\n                    .foregroundColor(.secondary)\n            }\n        }\n    }\n}",
        "hints": [
          "Use @MainActor for StoreManager to ensure UI updates on main thread",
          "Implement Transaction.updates listener for real-time purchase updates",
          "Use VerificationResult to handle JWT verification properly",
          "StoreKit Testing requires Xcode 13+ and special configuration",
          "Handle all purchase states: success, pending, userCancelled",
          "Use Product.products(for:) with async/await for clean product fetching",
          "Implement proper error handling for network issues and invalid products",
          "Use Transaction.currentEntitlements for restore purchases functionality",
          "Test subscription status with different renewal scenarios",
          "Consider implementing server-side receipt validation for production"
        ],
        "testCases": [
          {
            "input": "storeManager.products.count > 0",
            "expectedOutput": "true",
            "description": "Should successfully fetch products from App Store"
          },
          {
            "input": "storeManager.hasActiveSubscription()",
            "expectedOutput": "false",
            "description": "Initial state should have no active subscriptions"
          },
          {
            "input": "Transaction.updates iterator active",
            "expectedOutput": "true",
            "description": "Transaction listener should be actively monitoring"
          }
        ]
      }
    },
    {
      "id": "analytics_crash_reporting",
      "title": "Analytics & Crash Reporting",
      "description": "Master advanced analytics implementation, crash reporting, and performance monitoring using Firebase and Crashlytics",
      "difficulty": "advanced",
      "theory": "# Advanced Analytics & Crash Reporting with Firebase\n\n## 1. Advanced Firebase Analytics Implementation (90 min)\n\n### Custom Event Tracking Architecture\n```swift\n// Analytics Event Protocol\nprotocol AnalyticsEvent {\n    var name: String { get }\n    var parameters: [String: Any]? { get }\n}\n\n// Event Builder Pattern\nstruct AnalyticsEventBuilder {\n    private var name: String\n    private var parameters: [String: Any] = [:]\n    \n    init(_ name: String) {\n        self.name = name\n    }\n    \n    func addParameter(_ key: String, value: Any) -> AnalyticsEventBuilder {\n        var builder = self\n        builder.parameters[key] = value\n        return builder\n    }\n    \n    func build() -> AnalyticsEvent {\n        return ConcreteAnalyticsEvent(name: name, parameters: parameters)\n    }\n}\n```\n\n### User Journey Tracking\n```swift\nclass UserJourneyTracker {\n    private var currentJourney: UserJourney?\n    private let analytics: AnalyticsService\n    \n    func startJourney(_ type: JourneyType, source: String) {\n        currentJourney = UserJourney(type: type, startTime: Date(), source: source)\n        \n        analytics.logEvent(\"journey_started\", parameters: [\n            \"journey_type\": type.rawValue,\n            \"source\": source,\n            \"timestamp\": Date().timeIntervalSince1970\n        ])\n    }\n    \n    func completeJourney(outcome: JourneyOutcome) {\n        guard let journey = currentJourney else { return }\n        \n        let duration = Date().timeIntervalSince(journey.startTime)\n        \n        analytics.logEvent(\"journey_completed\", parameters: [\n            \"journey_type\": journey.type.rawValue,\n            \"outcome\": outcome.rawValue,\n            \"duration_seconds\": duration,\n            \"steps_completed\": journey.stepsCompleted\n        ])\n        \n        currentJourney = nil\n    }\n}\n```\n\n## 2. Crashlytics Advanced Configuration (60 min)\n\n### Custom Crash Context\n```swift\nclass AdvancedCrashReporting {\n    private let crashlytics: Crashlytics\n    \n    func configureCustomContext() {\n        // Set user identifier\n        Crashlytics.crashlytics().setUserID(User.current.id)\n        \n        // Set custom keys for crash context\n        Crashlytics.crashlytics().setCustomValue(\n            User.current.subscriptionLevel.rawValue,\n            forKey: \"subscription_level\"\n        )\n        \n        Crashlytics.crashlytics().setCustomValue(\n            UIApplication.shared.applicationState.description,\n            forKey: \"app_state\"\n        )\n        \n        // Track app-specific context\n        updateAppContext()\n    }\n    \n    func logNonFatalError(_ error: Error, context: [String: Any] = [:]) {\n        let nsError = error as NSError\n        var userInfo = nsError.userInfo\n        userInfo[\"custom_context\"] = context\n        \n        let enhancedError = NSError(\n            domain: nsError.domain,\n            code: nsError.code,\n            userInfo: userInfo\n        )\n        \n        Crashlytics.crashlytics().record(error: enhancedError)\n        \n        // Also log custom keys for this specific error\n        for (key, value) in context {\n            Crashlytics.crashlytics().setCustomValue(value, forKey: key)\n        }\n    }\n}\n```\n\n### Performance Monitoring Integration\n```swift\nclass PerformanceTracker {\n    private var traces: [String: Trace] = [:]\n    private var httpMetrics: [URLSessionTask: URLSessionTaskTransactionMetrics] = [:]\n    \n    func startTrace(_ name: String) -> Trace {\n        let trace = Performance.startTrace(name: name)\n        traces[name] = trace\n        return trace\n    }\n    \n    func trackNetworkRequest(_ request: URLRequest) {\n        guard let url = request.url else { return }\n        \n        let trace = startTrace(\"network_\\(url.host ?? \"unknown\")\")\n        \n        // Add custom attributes\n        trace.setValue(request.httpMethod ?? \"GET\", forAttribute: \"http_method\")\n        trace.setValue(url.path, forAttribute: \"path\")\n    }\n}\n```\n\n## 3. Advanced Event Architecture (90 min)\n\n### Event Taxonomy and Schema Management\n```swift\n// Event Schema Registry\nclass AnalyticsEventRegistry {\n    static let shared = AnalyticsEventRegistry()\n    \n    private var schemas: [String: EventSchema] = [:]\n    \n    func registerSchema(_ schema: EventSchema) {\n        schemas[schema.eventName] = schema\n    }\n    \n    func validateEvent(_ event: AnalyticsEvent) -> ValidationResult {\n        guard let schema = schemas[event.name] else {\n            return .invalid(\"Unknown event type\")\n        }\n        \n        return schema.validate(event.parameters)\n    }\n}\n\n// Schema Definition\nstruct EventSchema {\n    let eventName: String\n    let requiredParameters: [String: ParameterType]\n    let optionalParameters: [String: ParameterType]\n    let maxParameters: Int\n}\n```\n\n### Batch Event Processing\n```swift\nclass BatchEventProcessor {\n    private let batchSize: Int\n    private var currentBatch: [AnalyticsEvent] = []\n    private let flushInterval: TimeInterval\n    private var flushTimer: Timer?\n    \n    init(batchSize: Int = 25, flushInterval: TimeInterval = 30) {\n        self.batchSize = batchSize\n        self.flushInterval = flushInterval\n        setupFlushTimer()\n    }\n    \n    func logEvent(_ event: AnalyticsEvent) {\n        currentBatch.append(event)\n        \n        if currentBatch.count >= batchSize {\n            flushBatch()\n        }\n    }\n    \n    private func flushBatch() {\n        guard !currentBatch.isEmpty else { return }\n        \n        let batchToFlush = currentBatch\n        currentBatch.removeAll()\n        \n        // Process batch asynchronously\n        DispatchQueue.global(qos: .utility).async {\n            self.processBatch(batchToFlush)\n        }\n    }\n}\n```\n\n## 4. Real-time Analytics and Dashboards (60 min)\n\n### Custom Analytics Dashboard\n```swift\nclass AnalyticsDashboard {\n    private let realTimeDatabase: DatabaseReference\n    private var listeners: [DatabaseHandle] = []\n    \n    func setupRealTimeListeners() {\n        // Active users count\n        let activeUsersRef = realTimeDatabase.child(\"analytics/active_users\")\n        let activeUsersHandle = activeUsersRef.observe(.value) { snapshot in\n            if let activeUsers = snapshot.value as? Int {\n                self.updateActiveUsersDisplay(activeUsers)\n            }\n        }\n        listeners.append(activeUsersHandle)\n        \n        // Error rate monitoring\n        let errorRateRef = realTimeDatabase.child(\"analytics/error_rate\")\n        let errorRateHandle = errorRateRef.observe(.value) { snapshot in\n            if let errorRate = snapshot.value as? Double {\n                self.updateErrorRateDisplay(errorRate)\n            }\n        }\n        listeners.append(errorRateHandle)\n    }\n    \n    func trackCustomConversion(_ conversion: ConversionEvent) {\n        let conversionData: [String: Any] = [\n            \"name\": conversion.name,\n            \"value\": conversion.value,\n            \"timestamp\": ServerValue.timestamp(),\n            \"user_id\": User.current.id,\n            \"platform\": \"ios\"\n        ]\n        \n        realTimeDatabase.child(\"conversions\").childByAutoId().setValue(conversionData)\n    }\n}\n```\n\n## 5. Advanced Crash Analysis and Debugging (60 min)\n\n### Symbolicated Crash Reporting\n```swift\nclass SymbolicatedCrashReporter {\n    private let crashlytics: Crashlytics\n    private let debugSymbolsManager: DebugSymbolsManager\n    \n    func uploadDebugSymbols() {\n        guard let dsymPath = debugSymbolsManager.dsymPath else {\n            print(\"No dSYM found for current build\")\n            return\n        }\n        \n        // Upload dSYM to Crashlytics for symbolication\n        crashlytics.uploadSymbols(filePath: dsymPath)\n    }\n    \n    func enhanceCrashReportsWithLogs() {\n        // Integrate with logging system to include recent logs in crash reports\n        let recentLogs = LogManager.shared.getRecentLogs()\n        \n        for logEntry in recentLogs {\n            Crashlytics.crashlytics().log(\"\\(logEntry.timestamp): \\(logEntry.message)\")\n        }\n    }\n}\n```\n\n### Automated Crash Analysis\n```swift\nclass CrashAnalysisEngine {\n    private let crashlytics: Crashlytics\n    \n    func analyzeCrashTrends() -> CrashTrendReport {\n        // Implement trend analysis for recurring crashes\n        let recentCrashes = fetchRecentCrashes()\n        \n        var trendReport = CrashTrendReport()\n        \n        // Group crashes by type and stack trace\n        let groupedCrashes = Dictionary(grouping: recentCrashes) { $0.stackTraceHash }\n        \n        for (stackTraceHash, crashes) in groupedCrashes {\n            if crashes.count >= 3 {\n                // This is a recurring crash\n                trendReport.recurringCrashes.append(\n                    RecurringCrash(\n                        stackTraceHash: stackTraceHash,\n                        occurrenceCount: crashes.count,\n                        firstOccurrence: crashes.first?.timestamp,\n                        lastOccurrence: crashes.last?.timestamp\n                    )\n                )\n            }\n        }\n        \n        return trendReport\n    }\n}\n```\n\n## 6. Performance and Optimization (60 min)\n\n### Analytics Performance Optimization\n```swift\nclass OptimizedAnalyticsService {\n    private let operationQueue: OperationQueue\n    private let backgroundQueue = DispatchQueue(label: \"analytics.background\", qos: .utility)\n    \n    init() {\n        operationQueue = OperationQueue()\n        operationQueue.maxConcurrentOperationCount = 1\n        operationQueue.qualityOfService = .utility\n    }\n    \n    func logEvent(_ event: AnalyticsEvent) {\n        // Use operation queue for serial processing\n        let operation = AnalyticsOperation(event: event)\n        operationQueue.addOperation(operation)\n    }\n    \n    func flushEvents() {\n        operationQueue.waitUntilAllOperationsAreFinished()\n    }\n}\n\nprivate class AnalyticsOperation: Operation {\n    let event: AnalyticsEvent\n    \n    init(event: AnalyticsEvent) {\n        self.event = event\n    }\n    \n    override func main() {\n        guard !isCancelled else { return }\n        \n        // Process event on background thread\n        Analytics.logEvent(event.name, parameters: event.parameters)\n    }\n}\n```\n\n### Memory-Efficient Event Tracking\n```swift\nclass MemoryEfficientEventTracker {\n    private var eventBuffer: [AnalyticsEvent] = []\n    private let bufferSizeLimit = 100\n    private let persistenceManager: EventPersistenceManager\n    \n    func trackEvent(_ event: AnalyticsEvent) {\n        eventBuffer.append(event)\n        \n        if eventBuffer.count >= bufferSizeLimit {\n            persistBuffer()\n        }\n    }\n    \n    private func persistBuffer() {\n        let eventsToPersist = eventBuffer\n        eventBuffer.removeAll()\n        \n        persistenceManager.persistEvents(eventsToPersist)\n    }\n    \n    func flushToService() {\n        persistBuffer()\n        persistenceManager.flushToAnalyticsService()\n    }\n}\n```\n\n## Best Practices Summary\n- Implement proper event schema validation\n- Use batching for network efficiency\n- Include relevant context in crash reports\n- Monitor analytics performance impact\n- Implement proper error handling for analytics failures\n- Use background queues for non-critical analytics\n- Regularly review and clean up unused events",
      "codeExample": "import FirebaseAnalytics\nimport FirebaseCrashlytics\nimport FirebasePerformance\n\n// === ADVANCED ANALYTICS ARCHITECTURE ===\n\n// 1. Event Protocol and Implementation\nprotocol AnalyticsEvent {\n    var name: String { get }\n    var parameters: [String: Any]? { get }\n}\n\nstruct ScreenViewEvent: AnalyticsEvent {\n    let screenName: String\n    let screenClass: String\n    let previousScreen: String?\n    \n    var name: String { \"screen_view\" }\n    \n    var parameters: [String: Any]? {\n        var params: [String: Any] = [\n            \"screen_name\": screenName,\n            \"screen_class\": screenClass\n        ]\n        \n        if let previousScreen = previousScreen {\n            params[\"previous_screen\"] = previousScreen\n        }\n        \n        return params\n    }\n}\n\nstruct UserActionEvent: AnalyticsEvent {\n    let action: String\n    let category: String\n    let label: String?\n    let value: Int?\n    \n    var name: String { \"user_action\" }\n    \n    var parameters: [String: Any]? {\n        var params: [String: Any] = [\n            \"action\": action,\n            \"category\": category\n        ]\n        \n        if let label = label {\n            params[\"label\"] = label\n        }\n        \n        if let value = value {\n            params[\"value\"] = value\n        }\n        \n        return params\n    }\n}\n\n// 2. Advanced Analytics Service\nclass AdvancedAnalyticsService {\n    private let validationEnabled: Bool\n    private let batchProcessor: BatchEventProcessor\n    \n    init(validationEnabled: Bool = true) {\n        self.validationEnabled = validationEnabled\n        self.batchProcessor = BatchEventProcessor()\n        setupEventSchemas()\n    }\n    \n    private func setupEventSchemas() {\n        let screenViewSchema = EventSchema(\n            eventName: \"screen_view\",\n            requiredParameters: [\"screen_name\": .string, \"screen_class\": .string],\n            optionalParameters: [\"previous_screen\": .string],\n            maxParameters: 10\n        )\n        \n        AnalyticsEventRegistry.shared.registerSchema(screenViewSchema)\n    }\n    \n    func logEvent(_ event: AnalyticsEvent) {\n        if validationEnabled {\n            let validationResult = AnalyticsEventRegistry.shared.validateEvent(event)\n            \n            switch validationResult {\n            case .valid:\n                break\n            case .invalid(let reason):\n                print(\"Analytics event validation failed: \\(reason)\")\n                return\n            }\n        }\n        \n        // Log to Firebase Analytics\n        Analytics.logEvent(event.name, parameters: event.parameters)\n        \n        // Also add to batch processor for custom backend\n        batchProcessor.logEvent(event)\n    }\n    \n    func setUserProperties(_ properties: [String: String]) {\n        for (key, value) in properties {\n            Analytics.setUserProperty(value, forName: key)\n        }\n    }\n}\n\n// 3. Enhanced Crash Reporting\nclass EnhancedCrashReporter {\n    private let crashlytics: Crashlytics\n    \n    init() {\n        self.crashlytics = Crashlytics.crashlytics()\n        setupCustomKeys()\n    }\n    \n    private func setupCustomKeys() {\n        // Set initial custom keys\n        crashlytics.setCustomValue(Bundle.main.versionNumber, forKey: \"app_version\")\n        crashlytics.setCustomValue(Bundle.main.buildNumber, forKey: \"build_number\")\n        crashlytics.setCustomValue(Locale.current.identifier, forKey: \"locale\")\n        crashlytics.setCustomValue(UIDevice.current.systemVersion, forKey: \"ios_version\")\n    }\n    \n    func setUserIdentifier(_ identifier: String) {\n        crashlytics.setUserID(identifier)\n    }\n    \n    func logEvent(_ message: String) {\n        crashlytics.log(message)\n    }\n    \n    func recordNonFatalError(_ error: Error, additionalInfo: [String: Any]? = nil) {\n        let nsError = error as NSError\n        \n        var userInfo = nsError.userInfo\n        if let additionalInfo = additionalInfo {\n            userInfo.merge(additionalInfo) { (_, new) in new }\n        }\n        \n        let enhancedError = NSError(\n            domain: nsError.domain,\n            code: nsError.code,\n            userInfo: userInfo\n        )\n        \n        crashlytics.record(error: enhancedError)\n    }\n    \n    func setCustomValue(_ value: Any, forKey key: String) {\n        crashlytics.setCustomValue(value, forKey: key)\n    }\n}\n\n// 4. Performance Monitoring\nclass PerformanceMonitor {\n    private var activeTraces: [String: Trace] = [:]\n    \n    func startTrace(name: String) -> Trace {\n        let trace = Performance.startTrace(name: name)\n        activeTraces[name] = trace\n        return trace\n    }\n    \n    func stopTrace(name: String) {\n        activeTraces[name]?.stop()\n        activeTraces.removeValue(forKey: name)\n    }\n    \n    func measureOperation<T>(_ name: String, operation: () throws -> T) rethrows -> T {\n        let trace = startTrace(name: name)\n        defer { stopTrace(name: name) }\n        \n        return try operation()\n    }\n    \n    func trackNetworkRequest(_ request: URLRequest, response: URLResponse?, data: Data?, error: Error?) {\n        guard let url = request.url else { return }\n        \n        let traceName = \"network_\\(url.host ?? \"unknown\")\"\n        let trace = startTrace(name: traceName)\n        \n        // Set request attributes\n        trace.setValue(request.httpMethod ?? \"GET\", forAttribute: \"http_method\")\n        trace.setValue(url.path, forAttribute: \"path\")\n        \n        if let response = response as? HTTPURLResponse {\n            trace.setValue(response.statusCode, forAttribute: \"status_code\")\n        }\n        \n        if let error = error {\n            trace.setValue(error.localizedDescription, forAttribute: \"error\")\n        }\n        \n        stopTrace(name: traceName)\n    }\n}\n\n// 5. Batch Event Processing\nclass BatchEventProcessor {\n    private var eventBuffer: [AnalyticsEvent] = []\n    private let bufferSize = 25\n    private let flushInterval: TimeInterval = 30\n    private var flushTimer: Timer?\n    \n    init() {\n        setupFlushTimer()\n    }\n    \n    private func setupFlushTimer() {\n        flushTimer = Timer.scheduledTimer(withTimeInterval: flushInterval, repeats: true) { [weak self] _ in\n            self?.flushBuffer()\n        }\n    }\n    \n    func logEvent(_ event: AnalyticsEvent) {\n        eventBuffer.append(event)\n        \n        if eventBuffer.count >= bufferSize {\n            flushBuffer()\n        }\n    }\n    \n    private func flushBuffer() {\n        guard !eventBuffer.isEmpty else { return }\n        \n        let eventsToFlush = eventBuffer\n        eventBuffer.removeAll()\n        \n        // Send to custom analytics backend\n        sendToBackend(eventsToFlush)\n    }\n    \n    private func sendToBackend(_ events: [AnalyticsEvent]) {\n        // Convert events to dictionary for JSON serialization\n        let eventDicts = events.map { event in\n            return [\n                \"name\": event.name,\n                \"parameters\": event.parameters ?? [:],\n                \"timestamp\": Date().timeIntervalSince1970\n            ]\n        }\n        \n        // In a real implementation, you would send this to your backend\n        print(\"Sending \\(events.count) events to backend\")\n    }\n    \n    deinit {\n        flushTimer?.invalidate()\n        // Flush any remaining events\n        flushBuffer()\n    }\n}\n\n// 6. Analytics Manager (Main Interface)\nclass AnalyticsManager {\n    static let shared = AnalyticsManager()\n    \n    let analytics: AdvancedAnalyticsService\n    let crashReporter: EnhancedCrashReporter\n    let performanceMonitor: PerformanceMonitor\n    \n    private init() {\n        self.analytics = AdvancedAnalyticsService()\n        self.crashReporter = EnhancedCrashReporter()\n        self.performanceMonitor = PerformanceMonitor()\n    }\n    \n    func trackScreenView(screenName: String, screenClass: String, previousScreen: String? = nil) {\n        let event = ScreenViewEvent(\n            screenName: screenName,\n            screenClass: screenClass,\n            previousScreen: previousScreen\n        )\n        analytics.logEvent(event)\n    }\n    \n    func trackUserAction(action: String, category: String, label: String? = nil, value: Int? = nil) {\n        let event = UserActionEvent(\n            action: action,\n            category: category,\n            label: label,\n            value: value\n        )\n        analytics.logEvent(event)\n    }\n    \n    func setUserID(_ userID: String) {\n        Analytics.setUserID(userID)\n        crashReporter.setUserIdentifier(userID)\n    }\n    \n    func setUserProperties(_ properties: [String: String]) {\n        analytics.setUserProperties(properties)\n    }\n}\n\n// === SUPPORTING TYPES ===\n\nenum ParameterType {\n    case string, int, double, bool\n}\n\nstruct EventSchema {\n    let eventName: String\n    let requiredParameters: [String: ParameterType]\n    let optionalParameters: [String: ParameterType]\n    let maxParameters: Int\n    \n    func validate(_ parameters: [String: Any]?) -> ValidationResult {\n        guard let parameters = parameters else {\n            return requiredParameters.isEmpty ? .valid : .invalid(\"Missing required parameters\")\n        }\n        \n        // Check required parameters\n        for (key, type) in requiredParameters {\n            guard let value = parameters[key] else {\n                return .invalid(\"Missing required parameter: \\(key)\")\n            }\n            \n            if !validateType(value, matches: type) {\n                return .invalid(\"Parameter \\(key) has incorrect type\")\n            }\n        }\n        \n        // Check parameter count\n        if parameters.count > maxParameters {\n            return .invalid(\"Too many parameters: \\(parameters.count) > \\(maxParameters)\")\n        }\n        \n        return .valid\n    }\n    \n    private func validateType(_ value: Any, matches type: ParameterType) -> Bool {\n        switch type {\n        case .string: return value is String\n        case .int: return value is Int\n        case .double: return value is Double\n        case .bool: return value is Bool\n        }\n    }\n}\n\nenum ValidationResult {\n    case valid\n    case invalid(String)\n}\n\nclass AnalyticsEventRegistry {\n    static let shared = AnalyticsEventRegistry()\n    private var schemas: [String: EventSchema] = [:]\n    \n    func registerSchema(_ schema: EventSchema) {\n        schemas[schema.eventName] = schema\n    }\n    \n    func validateEvent(_ event: AnalyticsEvent) -> ValidationResult {\n        guard let schema = schemas[event.name] else {\n            return .invalid(\"Unknown event type: \\(event.name)\")\n        }\n        \n        return schema.validate(event.parameters)\n    }\n}\n\n// Bundle extension for version info\nextension Bundle {\n    var versionNumber: String {\n        return infoDictionary?[\"CFBundleShortVersionString\"] as? String ?? \"Unknown\"\n    }\n    \n    var buildNumber: String {\n        return infoDictionary?[\"CFBundleVersion\"] as? String ?? \"Unknown\"\n    }\n}\n\n// === USAGE EXAMPLE ===\nclass ExampleViewController: UIViewController {\n    private let analytics = AnalyticsManager.shared\n    \n    override func viewDidLoad() {\n        super.viewDidLoad()\n        \n        // Track screen view\n        analytics.trackScreenView(\n            screenName: \"Example Screen\",\n            screenClass: \"ExampleViewController\",\n            previousScreen: \"HomeScreen\"\n        )\n    }\n    \n    @IBAction func buttonTapped(_ sender: UIButton) {\n        // Track user action\n        analytics.trackUserAction(\n            action: \"button_tap\",\n            category: \"ui_interaction\",\n            label: \"example_button\",\n            value: 1\n        )\n        \n        // Simulate an error for crash reporting\n        do {\n            try simulateNetworkRequest()\n        } catch {\n            analytics.crashReporter.recordNonFatalError(error, additionalInfo: [\n                \"button_name\": \"example_button\",\n                \"user_id\": \"12345\"\n            ])\n        }\n    }\n    \n    private func simulateNetworkRequest() throws {\n        // Simulate network request with performance monitoring\n        let data = try analytics.performanceMonitor.measureOperation(\"network_request\") {\n            // Simulate network work\n            Thread.sleep(forTimeInterval: 0.1)\n            return Data()\n        }\n        \n        print(\"Received data: \\(data.count) bytes\")\n    }\n}",
      "category": "iOS Development",
      "estimatedTime": 240,
      "dependencies": ["networking", "error_handling", "swift_concurrency"],
      "challenge": {
        "instructions": "Build a comprehensive analytics and crash reporting system for a production iOS app:\n\nPART 1: Advanced Analytics Infrastructure (90 min)\n1. Implement a type-safe analytics event system with protocol-oriented design\n2. Create event schema validation with required/optional parameter enforcement\n3. Build a batch event processor with automatic flushing and network optimization\n4. Implement user property management and user journey tracking\n\nPART 2: Enhanced Crash Reporting (60 min)\n5. Create custom crash context with app-specific debugging information\n6. Implement non-fatal error tracking with enhanced error context\n7. Build automated crash trend analysis and reporting\n8. Create symbolicated crash report enhancement\n\nPART 3: Performance Monitoring Integration (45 min)\n9. Implement performance tracing for network requests and operations\n10. Create custom performance metrics for critical user journeys\n11. Build performance alerting system for degradation detection\n12. Implement memory-efficient event tracking\n\nPART 4: Real-time Analytics Dashboard (45 min)\n13. Create real-time analytics data streaming to Firebase\n14. Build custom conversion tracking and goal monitoring\n15. Implement A/B testing event tracking and analysis\n16. Create analytics data export functionality\n\nPART 5: Production Optimization & Testing (60 min)\n17. Implement analytics performance optimization and background processing\n18. Create comprehensive unit tests for analytics events and crash reporting\n19. Build analytics data validation and sanitization\n20. Implement analytics feature flags and remote configuration",
        "starterCode": "import FirebaseAnalytics\nimport FirebaseCrashlytics\nimport FirebasePerformance\n\n// === PART 1: Advanced Analytics Infrastructure ===\n// Implement your analytics event system here\n\n\n// === PART 2: Enhanced Crash Reporting ===\n// Build enhanced crash reporting with custom context\n\n\n// === PART 3: Performance Monitoring Integration ===\n// Implement performance tracing and monitoring\n\n\n// === PART 4: Real-time Analytics Dashboard ===\n// Create real-time analytics streaming\n\n\n// === PART 5: Production Optimization & Testing ===\n// Implement optimization and testing features\n\n",
        "solution": "import FirebaseAnalytics\nimport FirebaseCrashlytics\nimport FirebasePerformance\nimport Combine\n\n// === PART 1: Advanced Analytics Infrastructure ===\nprotocol AnalyticsEvent {\n    var name: String { get }\n    var parameters: [String: Any]? { get }\n}\n\nclass EventSchemaValidator {\n    private var schemas: [String: EventSchema] = [:]\n    \n    func registerSchema(_ schema: EventSchema) {\n        schemas[schema.name] = schema\n    }\n    \n    func validate(_ event: AnalyticsEvent) -> ValidationResult {\n        guard let schema = schemas[event.name] else {\n            return .failure(\"Unknown event type: \\(event.name)\")\n        }\n        return schema.validate(event.parameters)\n    }\n}\n\nclass BatchEventProcessor {\n    private var buffer: [AnalyticsEvent] = []\n    private let bufferSize: Int\n    private let flushInterval: TimeInterval\n    private var timer: Timer?\n    \n    init(bufferSize: Int = 20, flushInterval: TimeInterval = 30) {\n        self.bufferSize = bufferSize\n        self.flushInterval = flushInterval\n        startFlushTimer()\n    }\n    \n    func addEvent(_ event: AnalyticsEvent) {\n        buffer.append(event)\n        if buffer.count >= bufferSize {\n            flush()\n        }\n    }\n    \n    private func flush() {\n        guard !buffer.isEmpty else { return }\n        \n        let eventsToFlush = buffer\n        buffer.removeAll()\n        \n        // Send to analytics service\n        sendToAnalyticsService(eventsToFlush)\n    }\n    \n    private func startFlushTimer() {\n        timer = Timer.scheduledTimer(withTimeInterval: flushInterval, repeats: true) { [weak self] _ in\n            self?.flush()\n        }\n    }\n    \n    deinit {\n        timer?.invalidate()\n        flush() // Flush remaining events\n    }\n}\n\n// === PART 2: Enhanced Crash Reporting ===\nclass EnhancedCrashReporter {\n    private let crashlytics: Crashlytics\n    \n    init() {\n        self.crashlytics = Crashlytics.crashlytics()\n        setupDefaultContext()\n    }\n    \n    private func setupDefaultContext() {\n        crashlytics.setCustomValue(UIDevice.current.model, forKey: \"device_model\")\n        crashlytics.setCustomValue(ProcessInfo.processInfo.operatingSystemVersionString, forKey: \"os_version\")\n        crashlytics.setCustomValue(Locale.preferredLanguages.first ?? \"unknown\", forKey: \"user_language\")\n    }\n    \n    func setUserContext(userId: String, properties: [String: Any]) {\n        crashlytics.setUserID(userId)\n        for (key, value) in properties {\n            crashlytics.setCustomValue(value, forKey: key)\n        }\n    }\n    \n    func recordNonFatalError(_ error: Error, context: [String: Any] = [:]) {\n        let nsError = error as NSError\n        var userInfo = nsError.userInfo\n        userInfo[\"crashlytics_context\"] = context\n        \n        let enhancedError = NSError(\n            domain: nsError.domain,\n            code: nsError.code,\n            userInfo: userInfo\n        )\n        \n        crashlytics.record(error: enhancedError)\n    }\n    \n    func logEvent(_ message: String) {\n        crashlytics.log(message)\n    }\n}\n\nclass CrashTrendAnalyzer {\n    func analyzeRecentCrashes() -> CrashTrendReport {\n        // Implementation would fetch and analyze recent crashes\n        // Group by stack trace, calculate frequency, identify patterns\n        return CrashTrendReport()\n    }\n}\n\n// === PART 3: Performance Monitoring Integration ===\nclass PerformanceMonitor {\n    private var activeTraces: [String: Trace] = [:]\n    \n    func startTrace(name: String) -> Trace {\n        let trace = Performance.startTrace(name: name)\n        activeTraces[name] = trace\n        return trace\n    }\n    \n    func measure<T>(_ operationName: String, work: () throws -> T) rethrows -> T {\n        let trace = startTrace(name: operationName)\n        defer { \n            trace.stop()\n            activeTraces.removeValue(forKey: operationName)\n        }\n        \n        return try work()\n    }\n    \n    func trackNetworkRequest(_ request: URLRequest, response: URLResponse?, data: Data?, error: Error?) {\n        guard let url = request.url else { return }\n        \n        let traceName = \"network_\\(url.host ?? \"unknown\")\"\n        let trace = startTrace(name: traceName)\n        \n        trace.setValue(request.httpMethod ?? \"GET\", forAttribute: \"http_method\")\n        trace.setValue(url.path, forAttribute: \"path\")\n        \n        if let response = response as? HTTPURLResponse {\n            trace.setValue(response.statusCode, forAttribute: \"status_code\")\n        }\n        \n        if let error = error {\n            trace.setValue(error.localizedDescription, forAttribute: \"error\")\n        }\n        \n        trace.stop()\n        activeTraces.removeValue(forKey: traceName)\n    }\n}\n\n// === PART 4: Real-time Analytics Dashboard ===\nclass RealTimeAnalytics {\n    private let databaseReference: DatabaseReference?\n    \n    func trackLiveEvent(_ event: AnalyticsEvent) {\n        // Send to Firebase Realtime Database for live dashboard\n        let eventData: [String: Any] = [\n            \"name\": event.name,\n            \"parameters\": event.parameters ?? [:],\n            \"timestamp\": ServerValue.timestamp()\n        ]\n        \n        databaseReference?.child(\"live_events\").childByAutoId().setValue(eventData)\n    }\n    \n    func updateActiveUserCount() {\n        // Update active users count in real-time\n        let userCountRef = databaseReference?.child(\"active_users\")\n        userCountRef?.runTransactionBlock { currentData in\n            if let value = currentData.value as? Int {\n                currentData.value = value + 1\n            } else {\n                currentData.value = 1\n            }\n            return TransactionResult.success(withValue: currentData)\n        }\n    }\n}\n\n// === PART 5: Production Optimization & Testing ===\nclass OptimizedAnalyticsService {\n    private let backgroundQueue = DispatchQueue(label: \"analytics.processing\", qos: .utility)\n    private let eventValidator: EventSchemaValidator\n    private let batchProcessor: BatchEventProcessor\n    \n    init() {\n        self.eventValidator = EventSchemaValidator()\n        self.batchProcessor = BatchEventProcessor()\n        setupDefaultSchemas()\n    }\n    \n    private func setupDefaultSchemas() {\n        let screenViewSchema = EventSchema(\n            name: \"screen_view\",\n            requiredParams: [\"screen_name\": .string, \"screen_class\": .string],\n            optionalParams: [\"previous_screen\": .string]\n        )\n        eventValidator.registerSchema(screenViewSchema)\n    }\n    \n    func logEvent(_ event: AnalyticsEvent) {\n        backgroundQueue.async { [weak self] in\n            guard let self = self else { return }\n            \n            // Validate event\n            let validationResult = self.eventValidator.validate(event)\n            guard case .success = validationResult else {\n                print(\"Event validation failed\")\n                return\n            }\n            \n            // Log to Firebase\n            Analytics.logEvent(event.name, parameters: event.parameters)\n            \n            // Add to batch processor\n            self.batchProcessor.addEvent(event)\n        }\n    }\n}\n\n// Supporting Types\nstruct EventSchema {\n    let name: String\n    let requiredParams: [String: ParameterType]\n    let optionalParams: [String: ParameterType]\n    \n    func validate(_ params: [String: Any]?) -> ValidationResult {\n        // Implementation details\n        return .success\n    }\n}\n\nenum ParameterType {\n    case string, int, double, bool\n}\n\nenum ValidationResult {\n    case success\n    case failure(String)\n}\n\nstruct CrashTrendReport {\n    let recurringIssues: [String]\n    let frequencyAnalysis: [String: Int]\n    let recommendations: [String]\n}\n\n// Test Implementation\nclass AnalyticsTests {\n    func testEventValidation() {\n        let validator = EventSchemaValidator()\n        // Add test cases for event validation\n    }\n    \n    func testCrashReporting() {\n        let crashReporter = EnhancedCrashReporter()\n        // Test crash context and non-fatal error reporting\n    }\n    \n    func testPerformanceMonitoring() {\n        let monitor = PerformanceMonitor()\n        // Test performance tracing and measurement\n    }\n}",
        "hints": [
          "Use protocol-oriented design for analytics events for type safety",
          "Implement schema validation to catch event parameter issues early",
          "Use background queues for analytics processing to avoid blocking UI",
          "Include rich context in crash reports for easier debugging",
          "Batch network requests to reduce battery and data usage",
          "Validate all event parameters before sending to analytics services",
          "Use performance traces to identify bottlenecks in user journeys",
          "Implement feature flags for analytics to enable/disable in production"
        ],
        "testCases": [
          {
            "input": "eventValidator.validate(screenViewEvent)",
            "expectedOutput": "ValidationResult.success",
            "description": "Valid screen view event should pass validation"
          },
          {
            "input": "batchProcessor.buffer.count",
            "expectedOutput": "0",
            "description": "Buffer should be empty after flush"
          },
          {
            "input": "performanceMonitor.activeTraces.count",
            "expectedOutput": "0",
            "description": "No traces should be active after operations complete"
          }
        ]
      }
    },
    {
      "id": "continuous_integration",
      "title": "Continuous Integration for iOS",
      "description": "Master professional CI/CD pipelines for iOS apps using GitHub Actions and Fastlane",
      "difficulty": "advanced",
      "theory": "# Continuous Integration for iOS Apps\n\n## 1. Introduction to CI/CD for iOS (45 min)\n\n### What is Continuous Integration?\nCI/CD is the practice of automatically building, testing, and deploying code changes.\n\n**Benefits for iOS Development:**\n- Catch bugs early with automated testing\n- Ensure app builds successfully on every change\n- Automate App Store deployment process\n- Maintain consistent build environments\n- Enable rapid iteration and feedback\n\n### CI/CD Pipeline Components:\n- **Source Control**: Git with GitHub/GitLab/Bitbucket\n- **Build Automation**: Fastlane, Xcodebuild\n- **Testing**: Unit tests, UI tests, Snapshot tests\n- **Distribution**: TestFlight, App Store, Enterprise\n- **Monitoring**: Crash reporting, analytics\n\n## 2. GitHub Actions Fundamentals (90 min)\n\n### Workflow Structure:\n```yaml\nname: iOS CI\n\non:\n  push:\n    branches: [ main, develop ]\n  pull_request:\n    branches: [ main ]\n\njobs:\n  build-and-test:\n    runs-on: macOS-latest\n    steps:\n    - uses: actions/checkout@v3\n    - name: Select Xcode\n      run: sudo xcode-select -switch /Applications/Xcode_15.2.app\n    - name: Build and Test\n      run: |\n        xcodebuild build-for-testing \\\n          -project MyApp.xcodeproj \\\n          -scheme MyApp \\\n          -destination 'platform=iOS Simulator,name=iPhone 15,OS=latest'\n```\n\n### Key GitHub Actions Concepts:\n\n#### Workflow Triggers:\n```yaml\non:\n  # Push to specific branches\n  push:\n    branches: [ main, develop, release/* ]\n  \n  # Pull request events\n  pull_request:\n    branches: [ main ]\n    types: [ opened, synchronize, reopened ]\n  \n  # Scheduled builds\n  schedule:\n    - cron: '0 2 * * 1-5'  # 2 AM every weekday\n  \n  # Manual triggers\n  workflow_dispatch:\n    inputs:\n      environment:\n        description: 'Deploy environment'\n        required: true\n        default: 'staging'\n```\n\n#### Matrix Builds:\n```yaml\njobs:\n  test:\n    runs-on: macOS-latest\n    strategy:\n      matrix:\n        xcode: ['15.2', '15.1']\n        device: ['iPhone 15', 'iPhone 14', 'iPad Pro (12.9-inch)']\n        ios: ['17.2', '17.1']\n    steps:\n    - name: Select Xcode ${{ matrix.xcode }}\n      run: sudo xcode-select -switch /Applications/Xcode_${{ matrix.xcode }}.app\n    - name: Run tests on ${{ matrix.device }} iOS ${{ matrix.ios }}\n      run: |\n        xcodebuild test \\\n          -project MyApp.xcodeproj \\\n          -scheme MyApp \\\n          -destination 'platform=iOS Simulator,name=${{ matrix.device }},OS=${{ matrix.ios }}'\n```\n\n#### Caching for Performance:\n```yaml\n- name: Cache CocoaPods\n  uses: actions/cache@v3\n  with:\n    path: Pods\n    key: ${{ runner.os }}-pods-${{ hashFiles('**/Podfile.lock') }}\n    restore-keys: |\n      ${{ runner.os }}-pods-\n\n- name: Cache DerivedData\n  uses: actions/cache@v3\n  with:\n    path: ~/Library/Developer/Xcode/DerivedData\n    key: ${{ runner.os }}-deriveddata-${{ hashFiles('**/*.xcodeproj/**') }}\n```\n\n## 3. Fastlane Deep Dive (120 min)\n\n### Fastlane Setup & Configuration:\n\n#### Fastfile Structure:\n```ruby\n# Fastfile\ndefault_platform(:ios)\n\nplatform :ios do\n  desc \"Run tests\"\n  lane :tests do\n    run_tests(\n      scheme: \"MyApp\",\n      devices: [\"iPhone 15\"],\n      derived_data_path: \"derivedData\"\n    )\n  end\n\n  desc \"Build the app\"\n  lane :build do\n    gym(\n      scheme: \"MyApp\",\n      export_method: \"app-store\",\n      output_directory: \"./build\"\n    )\n  end\n\n  desc \"Submit to TestFlight\"\n  lane :beta do\n    build_app\n    upload_to_testflight\n  end\n\n  desc \"Deploy to App Store\"\n  lane :release do\n    build_app\n    upload_to_app_store\n  end\nend\n```\n\n#### Appfile Configuration:\n```ruby\n# Appfile\napp_identifier \"com.yourcompany.yourapp\"\napple_id \"your@email.com\"\n\n# App Store Connect team\nteam_id \"123456789\"\n\n# Developer Portal team\nteam_name \"Your Team Name\"\n\n# For multiple targets\nfor_platform :ios do\n  app_identifier \"com.yourcompany.yourapp\"\n  apple_id \"your@email.com\"\n  itc_team_id \"123456789\"\n  team_id \"ABCD123456\"\nend\n```\n\n### Advanced Fastlane Actions:\n\n#### Code Signing Management:\n```ruby\nlane :setup_signing do\n  # Automatic code signing\n  enable_automatic_code_signing(\n    path: \"MyApp.xcodeproj\",\n    team_id: \"ABCD123456\"\n  )\n  \n  # Or manual signing\n  import_certificate(\n    certificate_path: \"certificates/distribution.p12\",\n    certificate_password: ENV[\"CERTIFICATE_PASSWORD\"],\n    keychain_name: \"temp.keychain\",\n    keychain_password: \"temp\"\n  )\nend\n```\n\n#### Version Management:\n```ruby\nlane :bump_version do\n  # Increment build number\n  increment_build_number(\n    build_number: latest_testflight_build_number + 1\n  )\n  \n  # Update marketing version\n  increment_version_number(\n    version_number: \"1.2.0\",\n    xcodeproj: \"MyApp.xcodeproj\"\n  )\nend\n```\n\n#### Advanced Testing:\n```ruby\nlane :run_comprehensive_tests do\n  # Run unit tests\n  run_tests(\n    scheme: \"MyApp\",\n    devices: [\"iPhone 15\", \"iPad Pro (12.9-inch)\"],\n    derived_data_path: \"derivedData\",\n    code_coverage: true,\n    output_directory: \"./test_results\"\n  )\n  \n  # Run UI tests\n  run_tests(\n    scheme: \"MyAppUITests\",\n    devices: [\"iPhone 15\"],\n    only_testing: [\"MyAppUITests\"]\n  )\n  \n  # Generate code coverage report\n  slather(\n    cobertura_xml: true,\n    output_directory: \"coverage_report\"\n  )\nend\n```\n\n## 4. Advanced CI/CD Patterns (90 min)\n\n### Multi-environment Setup:\n\n#### Environment-specific Configurations:\n```ruby\n# Fastfile\nprivate_lane :configure_environment do |options|\n  environment = options[:environment] || \"development\"\n  \n  case environment\n  when \"development\"\n    configure_development\n  when \"staging\"\n    configure_staging\n  when \"production\"\n    configure_production\n  end\nend\n\nlane :build_development do\n  configure_environment(environment: \"development\")\n  build_app\nend\n\nlane :build_staging do\n  configure_environment(environment: \"staging\")\n  build_app\nend\n\nlane :build_production do\n  configure_environment(environment: \"production\")\n  build_app\nend\n```\n\n#### Conditional Workflows:\n```yaml\n# .github/workflows/ci.yml\njobs:\n  determine-environment:\n    runs-on: ubuntu-latest\n    outputs:\n      environment: ${{ steps.env.outputs.environment }}\n    steps:\n    - id: env\n      run: |\n        if [[ ${{ github.ref }} == 'refs/heads/main' ]]; then\n          echo \"environment=production\" >> $GITHUB_OUTPUT\n        elif [[ ${{ github.ref }} == 'refs/heads/develop' ]]; then\n          echo \"environment=staging\" >> $GITHUB_OUTPUT\n        else\n          echo \"environment=development\" >> $GITHUB_OUTPUT\n        fi\n\n  build:\n    needs: determine-environment\n    runs-on: macOS-latest\n    steps:\n    - name: Build for ${{ needs.determine-environment.outputs.environment }}\n      run: bundle exec fastlane build_${{ needs.determine-environment.outputs.environment }}\n```\n\n### Advanced GitHub Actions Patterns:\n\n#### Dependent Jobs & Workflows:\n```yaml\njobs:\n  unit-tests:\n    runs-on: macOS-latest\n    steps: [...]\n    \n  ui-tests:\n    runs-on: macOS-latest\n    steps: [...]\n    \n  build:\n    runs-on: macOS-latest\n    needs: [unit-tests, ui-tests]  # Only run after tests pass\n    steps: [...]\n    \n  deploy-staging:\n    runs-on: macOS-latest\n    needs: build  # Only deploy if build succeeds\n    if: github.ref == 'refs/heads/develop'\n    steps: [...]\n    \n  deploy-production:\n    runs-on: macOS-latest\n    needs: build\n    if: github.ref == 'refs/heads/main'\n    steps: [...]\n```\n\n#### Secrets Management:\n```yaml\nenv:\n  MATCH_PASSWORD: ${{ secrets.MATCH_PASSWORD }}\n  APP_STORE_CONNECT_API_KEY: ${{ secrets.APP_STORE_CONNECT_API_KEY }}\n  SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}\n\nsteps:\n- name: Setup Fastlane\n  run: |\n    bundle exec fastlane setup_ci \\\n      --env MATCH_PASSWORD=\"$MATCH_PASSWORD\" \\\n      --env APP_STORE_CONNECT_API_KEY=\"$APP_STORE_CONNECT_API_KEY\"\n```\n\n## 5. Performance Optimization & Monitoring (45 min)\n\n### Build Performance:\n\n#### Parallel Testing:\n```ruby\nlane :parallel_tests do\n  run_tests(\n    scheme: \"MyApp\",\n    devices: [\"iPhone 15\", \"iPhone 14\", \"iPad Pro\"],\n    parallelize_testing: true,\n    concurrent_workers: 3,\n    derived_data_path: \"derivedData\"\n  )\nend\n```\n\n#### Build Caching Strategies:\n```yaml\n- name: Cache Carthage\n  uses: actions/cache@v3\n  with:\n    path: Carthage\n    key: ${{ runner.os }}-carthage-${{ hashFiles('**/Cartfile.resolved') }}\n\n- name: Cache SPM\n  uses: actions/cache@v3\n  with:\n    path: .build\n    key: ${{ runner.os }}-spm-${{ hashFiles('**/Package.resolved') }}\n```\n\n### Monitoring & Notifications:\n\n#### Slack Notifications:\n```ruby\nlane :notify_slack do |options|\n  slack(\n    message: \"Build completed successfully!\",\n    success: true,\n    payload: {\n      \"Build Number\" => get_build_number,\n      \"Version\" => get_version_number,\n      \"Commit\" => last_git_commit_message\n    },\n    default_payloads: [:git_branch, :git_author]\n  )\nend\n```\n\n#### Custom Metrics:\n```ruby\nlane :track_build_metrics do\n  # Track build time\n  start_time = Time.now\n  \n  build_app\n  \n  build_time = Time.now - start_time\n  \n  # Send to analytics\n  puts \"Build completed in #{build_time.round(2)} seconds\"\n  \n  # Fail if build takes too long\n  if build_time > 600  # 10 minutes\n    UI.important(\"Build is taking too long: #{build_time.round(2)}s\")\n  end\nend\n```\n\n## 6. Security & Best Practices (30 min)\n\n### Security Considerations:\n\n#### Secure Secret Management:\n```ruby\n# Never hardcode secrets\nlane :secure_deploy do\n  # Use environment variables\n  api_key = ENV[\"APP_STORE_CONNECT_API_KEY\"]\n  match_password = ENV[\"MATCH_PASSWORD\"]\n  \n  # Use keychain for certificates\n  import_certificate(\n    certificate_path: \"cert.p12\",\n    certificate_password: ENV[\"CERT_PASSWORD\"],\n    keychain_name: \"temp.keychain\",\n    keychain_password: ENV[\"KEYCHAIN_PASSWORD\"]\n  )\nend\n```\n\n#### Code Signing Security:\n```ruby\nlane :secure_signing do\n  # Use match for reproducible signing\n  match(\n    type: \"appstore\",\n    app_identifier: [\"com.yourapp.main\", \"com.yourapp.widget\"],\n    readonly: is_ci?  # Read-only on CI to prevent changes\n  )\nend\n```\n\n### Best Practices Checklist:\n- âœ… Use Match for code signing\n- âœ… Store secrets in GitHub Secrets\n- âœ… Implement branch protection rules\n- âœ… Use required status checks\n- âœ… Monitor build times and optimize\n- âœ… Implement rollback strategies\n- âœ… Regular dependency updates\n- âœ… Security scanning in pipeline\n\n## Practice Exercises\n\nComplete all exercises to master professional CI/CD for iOS!",
      "codeExample": "#!/usr/bin/env bash\n\n# === COMPLETE CI/CD SETUP EXAMPLE ===\n\n# Fastfile\nruby\n# Fastfile\ndefault_platform(:ios)\n\nplatform :ios do\n  desc \"Run all tests\"\n  lane :test do\n    run_tests(\n      scheme: \"MyApp\",\n      devices: [\"iPhone 15\", \"iPad Pro (12.9-inch)\"],\n      derived_data_path: \"derivedData\",\n      code_coverage: true,\n      output_directory: \"./test_output\"\n    )\n  end\n\n  desc \"Build the application\"\n  lane :build do\n    gym(\n      scheme: \"MyApp\",\n      clean: true,\n      output_directory: \"./build\",\n      export_method: \"app-store\",\n      export_options: {\n        method: \"app-store\",\n        provisioningProfiles: {\n          \"com.yourapp\" => \"App Store Profile\"\n        }\n      }\n    )\n  end\n\n  desc \"Deploy to TestFlight\"\n  lane :beta do\n    # Ensure tests pass first\n    test\n    \n    # Increment build number\n    increment_build_number(\n      build_number: latest_testflight_build_number + 1\n    )\n    \n    # Build app\n    build\n    \n    # Upload to TestFlight\n    upload_to_testflight(\n      skip_waiting_for_build_processing: false,\n      apple_id: \"your@email.com\",\n      app_identifier: \"com.yourapp\"\n    )\n    \n    # Notify team\n    slack(\n      message: \"New beta build available on TestFlight!\",\n      success: true,\n      payload: {\n        \"Version\" => get_version_number,\n        \"Build\" => get_build_number\n      }\n    )\n  end\n\n  desc \"Deploy to App Store\"\n  lane :release do\n    # Run comprehensive tests\n    test\n    \n    # Bump version if needed\n    if is_ci?\n      increment_version_number(\n        version_number: ENV[\"NEW_VERSION\"]\n      )\n    end\n    \n    # Build for App Store\n    build\n    \n    # Upload to App Store Connect\n    upload_to_app_store(\n      skip_metadata: true,\n      skip_screenshots: true,\n      submit_for_review: false,\n      force: true\n    )\n    \n    # Notify stakeholders\n    slack(\n      message: \"New version submitted to App Store!\",\n      success: true,\n      payload: {\n        \"Version\" => get_version_number,\n        \"Build\" => get_build_number\n      }\n    )\n  end\n\n  desc \"Setup CI environment\"\n  lane :setup_ci do\n    # Install dependencies\n    cocoapods\n    carthage(\n      use_ssh: false,\n      platform: \"iOS\"\n    )\n    \n    # Setup code signing\n    match(\n      type: \"appstore\",\n      readonly: true,\n      app_identifier: \"com.yourapp\"\n    )\n  end\nend\n\n# GitHub Actions Workflow\nyaml\n# .github/workflows/ci-cd.yml\nname: iOS CI/CD Pipeline\n\non:\n  push:\n    branches: [ develop, main, release/* ]\n  pull_request:\n    branches: [ main ]\n  workflow_dispatch:\n    inputs:\n      environment:\n        description: 'Deployment environment'\n        required: true\n        default: 'staging'\n\nenv:\n  LC_ALL: en_US.UTF-8\n  LANG: en_US.UTF-8\n\njobs:\n  test:\n    name: Run Tests\n    runs-on: macOS-latest\n    strategy:\n      matrix:\n        xcode: ['15.2']\n        device: ['iPhone 15', 'iPad Pro (12.9-inch)']\n    \n    steps:\n    - name: Checkout code\n      uses: actions/checkout@v3\n      \n    - name: Select Xcode ${{ matrix.xcode }}\n      run: sudo xcode-select -switch /Applications/Xcode_${{ matrix.xcode }}.app\n      \n    - name: Cache dependencies\n      uses: actions/cache@v3\n      with:\n        path: Pods\n        key: ${{ runner.os }}-pods-${{ hashFiles('**/Podfile.lock') }}\n        \n    - name: Install Ruby dependencies\n      run: |\n        gem install bundler\n        bundle install\n        \n    - name: Install CocoaPods dependencies\n      run: bundle exec pod install\n      \n    - name: Run tests on ${{ matrix.device }}\n      run: |\n        bundle exec fastlane test\n        \n    - name: Upload test results\n      uses: actions/upload-artifact@v3\n      if: always()\n      with:\n        name: test-results-${{ matrix.device }}\n        path: test_output/\n        \n  build:\n    name: Build App\n    runs-on: macOS-latest\n    needs: test\n    if: github.event_name == 'push' && (github.ref == 'refs/heads/develop' || github.ref == 'refs/heads/main')\n    \n    steps:\n    - name: Checkout code\n      uses: actions/checkout@v3\n      \n    - name: Select Xcode\n      run: sudo xcode-select -switch /Applications/Xcode_15.2.app\n      \n    - name: Setup Fastlane\n      env:\n        MATCH_PASSWORD: ${{ secrets.MATCH_PASSWORD }}\n        APP_STORE_CONNECT_API_KEY: ${{ secrets.APP_STORE_CONNECT_API_KEY }}\n      run: |\n        bundle exec fastlane setup_ci\n        \n    - name: Build application\n      run: |\n        bundle exec fastlane build\n        \n    - name: Upload build artifacts\n      uses: actions/upload-artifact@v3\n      with:\n        name: app-build\n        path: build/\n        \n  deploy-staging:\n    name: Deploy to Staging\n    runs-on: macOS-latest\n    needs: build\n    if: github.ref == 'refs/heads/develop'\n    environment: staging\n    \n    steps:\n    - name: Checkout code\n      uses: actions/checkout@v3\n      \n    - name: Download build artifacts\n      uses: actions/download-artifact@v3\n      with:\n        name: app-build\n        \n    - name: Deploy to TestFlight\n      env:\n        MATCH_PASSWORD: ${{ secrets.MATCH_PASSWORD }}\n        APP_STORE_CONNECT_API_KEY: ${{ secrets.APP_STORE_CONNECT_API_KEY }}\n        SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}\n      run: |\n        bundle exec fastlane beta\n        \n  deploy-production:\n    name: Deploy to Production\n    runs-on: macOS-latest\n    needs: build\n    if: github.ref == 'refs/heads/main'\n    environment: production\n    \n    steps:\n    - name: Checkout code\n      uses: actions/checkout@v3\n      \n    - name: Download build artifacts\n      uses: actions/download-artifact@v3\n      with:\n        name: app-build\n        \n    - name: Deploy to App Store\n      env:\n        MATCH_PASSWORD: ${{ secrets.MATCH_PASSWORD }}\n        APP_STORE_CONNECT_API_KEY: ${{ secrets.APP_STORE_CONNECT_API_KEY }}\n        SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}\n      run: |\n        bundle exec fastlane release\n\n# Matchfile for code signing\nruby\n# Matchfile\ngit_url \"https://github.com/your-company/certificates-repo\"\ntype \"appstore\"\napp_identifier \"com.yourapp\"\nusername \"your@email.com\"\nteam_id \"YOUR_TEAM_ID\"\n\n# Appfile for project configuration\nruby\n# Appfile\napp_identifier \"com.yourapp\"\napple_id \"your@email.com\"\nteam_id \"YOUR_TEAM_ID\"\n\n# Pluginfile for Fastlane plugins\nruby\n# Pluginfile\n# Autogenerated by fastlane\n\n# Gemfile for dependency management\nruby\n# Gemfile\nsource \"https://rubygems.org\"\n\ngem \"fastlane\"\ngem \"cocoapods\"\n\n# Advanced: Multi-scheme configuration\nruby\n# Fastfile extension for multiple schemes\nprivate_lane :build_scheme do |options|\n  scheme = options[:scheme]\n  configuration = options[:configuration] || \"Release\"\n  \n  gym(\n    scheme: scheme,\n    configuration: configuration,\n    export_method: \"app-store\",\n    output_directory: \"./build/#{scheme}\"\n  )\nend\n\nlane :build_all_schemes do\n  schemes = [\"MyApp\", \"MyApp-Staging\", \"MyApp-Development\"]\n  \n  schemes.each do |scheme|\n    build_scheme(scheme: scheme)\n  end\nend",
      "category": "DevOps & Tooling",
      "estimatedTime": 240,
      "dependencies": ["xcode_basics", "swift_package_manager", "git_workflow"],
      "challenge": {
        "instructions": "Build a complete enterprise-grade CI/CD pipeline for an iOS application:\n\nPART 1: GitHub Actions Foundation (60 min)\n1. Create a multi-job workflow with test, build, and deploy stages\n2. Implement matrix builds for multiple Xcode versions and devices\n3. Set up efficient caching for dependencies and derived data\n4. Configure branch protection and required status checks\n\nPART 2: Fastlane Automation (90 min)\n5. Create a comprehensive Fastfile with lanes for testing, building, and deployment\n6. Implement Match for secure code signing management\n7. Set up automatic version and build number management\n8. Create environment-specific configurations (dev, staging, prod)\n\nPART 3: Advanced Pipeline Patterns (90 min)\n9. Implement parallel test execution across multiple simulators\n10. Create conditional deployment based on branch and commit messages\n11. Set up automated App Store Connect API key management\n12. Implement rollback procedures and emergency lanes\n\nPART 4: Security & Monitoring (60 min)\n13. Configure secret management with GitHub Secrets\n14. Implement security scanning in the pipeline\n15. Set up comprehensive notifications (Slack, email)\n16. Create build metrics tracking and performance monitoring\n\nPART 5: Enterprise Features (60 min)\n17. Implement multi-target/multi-scheme support\n18. Create custom Fastlane plugins for company-specific tasks\n19. Set up distributed caching for large teams\n20. Implement automated dependency vulnerability scanning",
        "starterCode": "#!/bin/bash\n\n# === PART 1: GitHub Actions Foundation ===\n# Create .github/workflows/ci-cd.yml\n\n\n# === PART 2: Fastlane Automation ===\n# Create Fastfile, Appfile, Matchfile\n\n\n# === PART 3: Advanced Pipeline Patterns ===\n# Implement advanced Fastlane lanes and workflows\n\n\n# === PART 4: Security & Monitoring ===\n# Configure secrets, notifications, and monitoring\n\n\n# === PART 5: Enterprise Features ===\n# Add multi-scheme support and custom plugins\n\n",
        "solution": "#!/bin/bash\n\n# === COMPLETE CI/CD PIPELINE SOLUTION ===\n\n# .github/workflows/ci-cd.yml\ncat > .github/workflows/ci-cd.yml << 'EOF'\nname: Enterprise iOS CI/CD\n\non:\n  push:\n    branches: [ main, develop, release/*, feature/ci-* ]\n  pull_request:\n    branches: [ main, develop ]\n  schedule:\n    - cron: '0 6 * * 1-5'  # 6 AM weekdays\n  workflow_dispatch:\n    inputs:\n      deploy_environment:\n        description: 'Deployment environment'\n        required: true\n        default: 'staging'\n        type: choice\n        options:\n        - development\n        - staging\n        - production\n\nenv:\n  PROJECT_NAME: \"YourApp\"\n  BUNDLE_ID: \"com.company.yourapp\"\n  XCODE_VERSION: \"15.2\"\n\njobs:\n  environment-check:\n    name: Determine Environment\n    runs-on: ubuntu-latest\n    outputs:\n      environment: ${{ steps.env.outputs.environment }}\n      should_deploy: ${{ steps.env.outputs.should_deploy }}\n    steps:\n    - name: Determine environment and deployment\n      id: env\n      run: |\n        if [[ \"${{ github.ref }}\" == \"refs/heads/main\" ]]; then\n          echo \"environment=production\" >> $GITHUB_OUTPUT\n          echo \"should_deploy=true\" >> $GITHUB_OUTPUT\n        elif [[ \"${{ github.ref }}\" == \"refs/heads/develop\" ]]; then\n          echo \"environment=staging\" >> $GITHUB_OUTPUT\n          echo \"should_deploy=true\" >> $GITHUB_OUTPUT\n        elif [[ \"${{ github.event_name }}\" == \"workflow_dispatch\" ]]; then\n          echo \"environment=${{ github.event.inputs.deploy_environment }}\" >> $GITHUB_OUTPUT\n          echo \"should_deploy=true\" >> $GITHUB_OUTPUT\n        else\n          echo \"environment=development\" >> $GITHUB_OUTPUT\n          echo \"should_deploy=false\" >> $GITHUB_OUTPUT\n        fi\n\n  dependencies:\n    name: Install Dependencies\n    runs-on: macOS-latest\n    steps:\n    - name: Checkout code\n      uses: actions/checkout@v4\n\n    - name: Select Xcode ${{ env.XCODE_VERSION }}\n      run: sudo xcode-select -switch /Applications/Xcode_${{ env.XCODE_VERSION }}.app\n\n    - name: Cache Ruby Gems\n      uses: actions/cache@v3\n      with:\n        path: vendor/bundle\n        key: ${{ runner.os }}-gems-${{ hashFiles('**/Gemfile.lock') }}\n        restore-keys: |\n          ${{ runner.os }}-gems-\n\n    - name: Cache CocoaPods\n      uses: actions/cache@v3\n      with:\n        path: Pods\n        key: ${{ runner.os }}-pods-${{ hashFiles('**/Podfile.lock') }}\n        restore-keys: |\n          ${{ runner.os }}-pods-\n\n    - name: Cache DerivedData\n      uses: actions/cache@v3\n      with:\n        path: ~/Library/Developer/Xcode/DerivedData\n        key: ${{ runner.os }}-derived-${{ hashFiles('**/*.xcodeproj/**', '**/*.xcworkspace/**') }}\n\n    - name: Install Ruby dependencies\n      run: |\n        bundle config path vendor/bundle\n        bundle install --jobs 4 --retry 3\n\n    - name: Install CocoaPods dependencies\n      run: bundle exec pod install\n\n  unit-tests:\n    name: Unit Tests\n    runs-on: macOS-latest\n    needs: [environment-check, dependencies]\n    strategy:\n      matrix:\n        device: ['iPhone 15', 'iPhone 14', 'iPad Pro (12.9-inch)']\n    steps:\n    - name: Checkout code\n      uses: actions/checkout@v4\n\n    - name: Restore caches\n      uses: actions/cache@v3\n      with:\n        path: |\n          vendor/bundle\n          Pods\n          ~/Library/Developer/Xcode/DerivedData\n        key: ${{ runner.os }}-deps-${{ hashFiles('**/Gemfile.lock', '**/Podfile.lock') }}\n\n    - name: Run unit tests on ${{ matrix.device }}\n      run: |\n        bundle exec fastlane run_tests device:\"${{ matrix.device }}\" test_type:\"unit\"\n\n    - name: Upload test results\n      uses: actions/upload-artifact@v3\n      if: always()\n      with:\n        name: unit-test-results-${{ matrix.device }}\n        path: test_output/\n\n  ui-tests:\n    name: UI Tests\n    runs-on: macOS-latest\n    needs: [environment-check, dependencies]\n    strategy:\n      matrix:\n        device: ['iPhone 15', 'iPad Pro (12.9-inch)']\n    steps:\n    - name: Checkout code\n      uses: actions/checkout@v4\n\n    - name: Restore caches\n      uses: actions/cache@v3\n      with:\n        path: |\n          vendor/bundle\n          Pods\n          ~/Library/Developer/Xcode/DerivedData\n        key: ${{ runner.os }}-deps-${{ hashFiles('**/Gemfile.lock', '**/Podfile.lock') }}\n\n    - name: Run UI tests on ${{ matrix.device }}\n      run: |\n        bundle exec fastlane run_tests device:\"${{ matrix.device }}\" test_type:\"ui\"\n\n    - name: Upload UI test results\n      uses: actions/upload-artifact@v3\n      if: always()\n      with:\n        name: ui-test-results-${{ matrix.device }}\n        path: test_output/\n\n  build:\n    name: Build Application\n    runs-on: macOS-latest\n    needs: [unit-tests, ui-tests]\n    if: needs.environment-check.outputs.should_deploy == 'true'\n    steps:\n    - name: Checkout code\n      uses: actions/checkout@v4\n\n    - name: Restore caches\n      uses: actions/cache@v3\n      with:\n        path: |\n          vendor/bundle\n          Pods\n          ~/Library/Developer/Xcode/DerivedData\n        key: ${{ runner.os }}-deps-${{ hashFiles('**/Gemfile.lock', '**/Podfile.lock') }}\n\n    - name: Setup code signing\n      env:\n        MATCH_PASSWORD: ${{ secrets.MATCH_PASSWORD }}\n        APP_STORE_CONNECT_API_KEY: ${{ secrets.APP_STORE_CONNECT_API_KEY }}\n      run: |\n        bundle exec fastlane match_${{ needs.environment-check.outputs.environment }}\n\n    - name: Build application\n      env:\n        ENVIRONMENT: ${{ needs.environment-check.outputs.environment }}\n      run: |\n        bundle exec fastlane build_${{ needs.environment-check.outputs.environment }}\n\n    - name: Upload build artifacts\n      uses: actions/upload-artifact@v3\n      with:\n        name: app-build-${{ needs.environment-check.outputs.environment }}\n        path: build/\n\n  deploy:\n    name: Deploy to ${{ needs.environment-check.outputs.environment }}\n    runs-on: macOS-latest\n    needs: [environment-check, build]\n    environment: ${{ needs.environment-check.outputs.environment }}\n    steps:\n    - name: Checkout code\n      uses: actions/checkout@v4\n\n    - name: Download build artifacts\n      uses: actions/download-artifact@v3\n      with:\n        name: app-build-${{ needs.environment-check.outputs.environment }}\n\n    - name: Deploy application\n      env:\n        MATCH_PASSWORD: ${{ secrets.MATCH_PASSWORD }}\n        APP_STORE_CONNECT_API_KEY: ${{ secrets.APP_STORE_CONNECT_API_KEY }}\n        SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}\n        FIREBASE_APP_DISTRIBUTE_TOKEN: ${{ secrets.FIREBASE_APP_DISTRIBUTE_TOKEN }}\n      run: |\n        bundle exec fastlane deploy_${{ needs.environment-check.outputs.environment }}\n\n  security-scan:\n    name: Security Scan\n    runs-on: macOS-latest\n    needs: [build]\n    if: always()\n    steps:\n    - name: Run security scan\n      run: |\n        bundle exec fastlane security_scan\n\n    - name: Upload security report\n      uses: actions/upload-artifact@v3\n      if: always()\n      with:\n        name: security-scan-report\n        path: security_reports/\nEOF\n\n# Fastfile\ncat > fastlane/Fastfile << 'EOF'\ndefault_platform(:ios)\n\nplatform :ios do\n  desc \"Run tests\"\n  lane :run_tests do |options|\n    device = options[:device] || \"iPhone 15\"\n    test_type = options[:test_type] || \"unit\"\n    \n    scheme = test_type == \"ui\" ? \"#{ENV['PROJECT_NAME']}UITests\" : ENV['PROJECT_NAME']\n    \n    run_tests(\n      scheme: scheme,\n      devices: [device],\n      derived_data_path: \"derivedData\",\n      code_coverage: true,\n      output_directory: \"./test_output\",\n      output_types: \"html,junit\",\n      output_files: \"tests.html,results.xml\",\n      parallelize_testing: true,\n      concurrent_workers: 3\n    )\n  end\n\n  desc \"Match development\"\n  lane :match_development do\n    match(\n      type: \"development\",\n      readonly: is_ci?,\n      app_identifier: ENV['BUNDLE_ID'],\n      team_id: ENV['TEAM_ID']\n    )\n  end\n\n  desc \"Match staging\"\n  lane :match_staging do\n    match(\n      type: \"appstore\",\n      readonly: is_ci?,\n      app_identifier: ENV['BUNDLE_ID'],\n      team_id: ENV['TEAM_ID']\n    )\n  end\n\n  desc \"Match production\"\n  lane :match_production do\n    match(\n      type: \"appstore\",\n      readonly: is_ci?,\n      app_identifier: ENV['BUNDLE_ID'],\n      team_id: ENV['TEAM_ID']\n    )\n  end\n\n  desc \"Build for development\"\n  lane :build_development do\n    gym(\n      scheme: \"#{ENV['PROJECT_NAME']}-Development\",\n      export_method: \"development\",\n      output_directory: \"./build\",\n      build_path: \"./build\",\n      derived_data_path: \"derivedData\",\n      clean: true\n    )\n  end\n\n  desc \"Build for staging\"\n  lane :build_staging do\n    gym(\n      scheme: \"#{ENV['PROJECT_NAME']}-Staging\",\n      export_method: \"app-store\",\n      output_directory: \"./build\",\n      build_path: \"./build\",\n      derived_data_path: \"derivedData\",\n      clean: true\n    )\n  end\n\n  desc \"Build for production\"\n  lane :build_production do\n    increment_build_number(\n      build_number: latest_testflight_build_number + 1\n    )\n    \n    gym(\n      scheme: ENV['PROJECT_NAME'],\n      export_method: \"app-store\",\n      output_directory: \"./build\",\n      build_path: \"./build\",\n      derived_data_path: \"derivedData\",\n      clean: true\n    )\n  end\n\n  desc \"Deploy to development\"\n  lane :deploy_development do\n    firebase_app_distribution(\n      app: ENV['FIREBASE_APP_ID'],\n      groups: \"developers,testers\",\n      release_notes: \"Development build from CI\",\n      firebase_cli_token: ENV['FIREBASE_APP_DISTRIBUTE_TOKEN']\n    )\n    \n    notify_slack(\n      message: \"New development build available!\",\n      channel: \"#app-deployments\"\n    )\n  end\n\n  desc \"Deploy to staging\"\n  lane :deploy_staging do\n    upload_to_testflight(\n      skip_waiting_for_build_processing: true,\n      apple_id: ENV['APPLE_ID'],\n      app_identifier: ENV['BUNDLE_ID']\n    )\n    \n    notify_slack(\n      message: \"New staging build uploaded to TestFlight!\",\n      channel: \"#app-deployments\",\n      payload: {\n        \"Version\" => get_version_number,\n        \"Build\" => get_build_number\n      }\n    )\n  end\n\n  desc \"Deploy to production\"\n  lane :deploy_production do\n    upload_to_testflight(\n      skip_waiting_for_build_processing: false,\n      apple_id: ENV['APPLE_ID'],\n      app_identifier: ENV['BUNDLE_ID']\n    )\n    \n    # Optional: Auto-submit for review\n    # upload_to_app_store(\n    #   skip_metadata: true,\n    #   skip_screenshots: true,\n    #   submit_for_review: true\n    # )\n    \n    notify_slack(\n      message: \"ðŸš€ New production build submitted to App Store!\",\n      channel: \"#app-deployments\",\n      payload: {\n        \"Version\" => get_version_number,\n        \"Build\" => get_build_number,\n        \"What's New\" => ENV['RELEASE_NOTES']\n      }\n    )\n  end\n\n  desc \"Run security scan\"\n  lane :security_scan do\n    # SwiftLint for code quality\n    swiftlint(\n      mode: :lint,\n      output_file: \"security_reports/swiftlint.html\",\n      reporter: \"html\"\n    )\n    \n    # OWASP dependency check\n    # (Assuming you have a script for this)\n    sh \"./scripts/check_dependencies.sh\"\n    \n    # Binary security analysis\n    # (Add your security tools here)\n  end\n\n  desc \"Emergency rollback\"\n  lane :rollback do |options|\n    version = options[:version]\n    build_number = options[:build_number]\n    \n    UI.important(\"Initiating rollback to version #{version} (#{build_number})\")\n    \n    # Reset git to previous version\n    reset_git_repo(\n      force: true,\n      files: [\"#{ENV['PROJECT_NAME']}.xcodeproj/project.pbxproj\"]\n    )\n    \n    # Build and deploy previous version\n    build_production\n    deploy_production\n    \n    notify_slack(\n      message: \"ðŸš¨ Emergency rollback executed to version #{version} (#{build_number})\",\n      channel: \"#app-emergency\",\n      success: false\n    )\n  end\n\n  # Helper lane for multi-scheme projects\n  private_lane :build_scheme do |options|\n    scheme = options[:scheme]\n    export_method = options[:export_method] || \"app-store\"\n    \n    gym(\n      scheme: scheme,\n      export_method: export_method,\n      output_directory: \"./build/#{scheme}\",\n      clean: true\n    )\n  end\n\n  desc \"Build all schemes\"\n  lane :build_all_schemes do\n    schemes = [\n      {scheme: \"#{ENV['PROJECT_NAME']}-Development\", export_method: \"development\"},\n      {scheme: \"#{ENV['PROJECT_NAME']}-Staging\", export_method: \"app-store\"},\n      {scheme: ENV['PROJECT_NAME'], export_method: \"app-store\"}\n    ]\n    \n    schemes.each do |config|\n      build_scheme(config)\n    end\n  end\nend\nEOF\n\n# Appfile\ncat > fastlane/Appfile << 'EOF'\napp_identifier \"#{ENV['BUNDLE_ID']}\"\napple_id \"#{ENV['APPLE_ID']}\"\n\n# Team information\nteam_id \"#{ENV['TEAM_ID']}\"\n\n# Optional: Multiple targets\nfor_platform :ios do\n  app_identifier \"#{ENV['BUNDLE_ID']}\"\n  apple_id \"#{ENV['APPLE_ID']}\"\nend\n\n# App Store Connect team ID\nitc_team_id \"#{ENV['ITC_TEAM_ID']}\"\nEOF\n\n# Matchfile\ncat > fastlane/Matchfile << 'EOF'\ngit_url \"#{ENV['MATCH_GIT_URL']}\"\n\ntype \"appstore\"\napp_identifier \"#{ENV['BUNDLE_ID']}\"\nusername \"#{ENV['APPLE_ID']}\"\n\nteam_id \"#{ENV['TEAM_ID']}\"\nteam_name \"#{ENV['TEAM_NAME']}\"\n\n# Security\nreadonly false\nverbose true\n\n# Generate the cert and profs on CI\nforce_for_new_devices true\n\n# Storage\nstorage_mode \"git\"\n\n# Additional options\ngit_branch \"master\"\nclone_branch_directly false\n\n# For development\ndevelopment false\nEOF\n\n# Pluginfile\ncat > fastlane/Pluginfile << 'EOF'\n# Autogenerated by fastlane\n# Make sure to update this when you add new plugins!\n\ngem 'fastlane-plugin-firebase_app_distribution'\ngem 'fastlane-plugin-slack_bot'\ngem 'fastlane-plugin-versioning'\n\n# Uncomment and add your own plugins here\n# gem 'fastlane-plugin-your_plugin'\nEOF\n\n# Environment setup script\ncat > scripts/setup_ci.sh << 'EOF'\n#!/bin/bash\nset -e\n\necho \"Setting up CI environment...\"\n\n# Install Homebrew if not present\nif ! command -v brew &> /dev/null; then\n    echo \"Installing Homebrew...\"\n    /bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\"\nfi\n\n# Install Ruby if needed\nif ! command -v ruby &> /dev/null; then\n    echo \"Installing Ruby...\"\n    brew install ruby\nfi\n\n# Install Bundler\necho \"Installing Bundler...\"\ngem install bundler\n\n# Install project dependencies\necho \"Installing project dependencies...\"\nbundle install\n\n# Install CocoaPods if needed\nif ! command -v pod &> /dev/null; then\n    echo \"Installing CocoaPods...\"\n    gem install cocoapods\nfi\n\n# Install SwiftLint for code quality\nif ! command -v swiftlint &> /dev/null; then\n    echo \"Installing SwiftLint...\"\n    brew install swiftlint\nfi\n\necho \"CI environment setup complete!\"\nEOF\n\nchmod +x scripts/setup_ci.sh\n\necho \"Enterprise CI/CD pipeline setup complete!\"\necho \"Next steps:\"\necho \"1. Configure GitHub Secrets in your repository\"\necho \"2. Set up your certificate repository for Match\"\necho \"3. Configure your App Store Connect API key\"\necho \"4. Set up Slack webhook for notifications\"\necho \"5. Test the pipeline with a sample push\"\nEOF\n",
        "hints": [
          "PART 1: Use matrix strategy for parallel testing across devices and Xcode versions",
          "PART 2: Implement Match for secure, reproducible code signing across team",
          "PART 3: Use environment-specific lanes and conditional deployment logic",
          "PART 4: Store all secrets in GitHub Secrets, never in code",
          "PART 5: Create custom lanes for company-specific build requirements",
          "Use efficient caching to dramatically reduce build times",
          "Implement proper error handling and rollback procedures",
          "Set up comprehensive monitoring and alerting",
          "Use Fastlane plugins to extend functionality",
          "Regularly update dependencies and security scans"
        ],
        "testCases": [
          {
            "input": "workflow_dispatch with environment=staging",
            "expectedOutput": "Deploy to staging environment",
            "description": "Manual deployment should trigger staging deployment"
          },
          {
            "input": "push to main branch",
            "expectedOutput": "Production deployment pipeline",
            "description": "Main branch pushes should trigger production pipeline"
          },
          {
            "input": "pull request to develop",
            "expectedOutput": "Run tests without deployment",
            "description": "PRs should run tests but not deploy"
          },
          {
            "input": "build time > 30 minutes",
            "expectedOutput": "Performance alert",
            "description": "Long build times should trigger alerts"
          }
        ]
      }
    },
    {
      "id": "app_security",
      "title": "App Security - Keychain & Data Protection",
      "description": "Master iOS security fundamentals including Keychain Services, Data Protection API, encryption, and secure coding practices",
      "difficulty": "advanced",
      "theory": "# App Security - Keychain & Data Protection\n\n## 1. iOS Security Architecture (60 min)\n\n### Security Enclave & Secure Boot\n\n**Secure Boot Chain:**\n- Boot ROM â†’ LLB â†’ iBoot â†’ Kernel â†’ iOS\n- Each stage cryptographically verified\n- Prevents jailbreaking and unauthorized modifications\n\n**App Sandboxing:**\n```swift\n// Each app runs in its own sandbox\n// Limited access to:\n// - File system outside app container\n// - Hardware resources\n// - Other app's data\n// - System services\n```\n\n**Entitlements & Capabilities:**\n```swift\n// Required entitlements for security-sensitive operations\n<key>keychain-access-groups</key>\n<array>\n    <string>$(AppIdentifierPrefix)com.yourapp</string>\n</array>\n\n<key>com.apple.developer.associated-domains</key>\n<array>\n    <string>applinks:yourapp.com</string>\n</array>\n```\n\n## 2. Keychain Services Deep Dive (90 min)\n\n### Keychain Architecture\n\n**Keychain Items Structure:**\n- **kSecClassGenericPassword**: Generic passwords\n- **kSecClassInternetPassword**: Internet passwords\n- **kSecClassCertificate**: Certificates\n- **kSecClassKey**: Cryptographic keys\n- **kSecClassIdentity**: Identity (certificate + private key)\n\n**Access Control & ACLs:**\n```swift\nlet accessControl = SecAccessControlCreateWithFlags(\n    kCFAllocatorDefault,\n    kSecAttrAccessibleWhenUnlockedThisDeviceOnly,\n    [.userPresence, .privateKeyUsage],\n    nil\n)\n```\n\n### Advanced Keychain Operations\n\n**Biometric-Protected Items:**\n```swift\nfunc saveBiometricProtectedData(_ data: Data, for key: String) -> OSStatus {\n    let query: [String: Any] = [\n        kSecClass as String: kSecClassGenericPassword,\n        kSecAttrAccount as String: key,\n        kSecValueData as String: data,\n        kSecAttrAccessControl as String: accessControl,\n        kSecUseAuthenticationContext as String: LAContext(),\n        kSecAttrAccessible as String: kSecAttrAccessibleWhenUnlockedThisDeviceOnly\n    ]\n    \n    SecItemDelete(query as CFDictionary)\n    return SecItemAdd(query as CFDictionary, nil)\n}\n```\n\n**Keychain Sharing Between Apps:**\n```swift\n// App Groups keychain sharing\nlet keychainQuery: [String: Any] = [\n    kSecClass as String: kSecClassGenericPassword,\n    kSecAttrAccount as String: \"sharedToken\",\n    kSecAttrAccessGroup as String: \"group.com.yourapp.suite\",\n    kSecAttrAccessible as String: kSecAttrAccessibleWhenUnlocked,\n    kSecValueData as String: tokenData\n]\n```\n\n**Secure Key Generation & Storage:**\n```swift\nfunc generateSecureKey() throws -> SecKey {\n    let attributes: [String: Any] = [\n        kSecAttrKeyType as String: kSecAttrKeyTypeRSA,\n        kSecAttrKeySizeInBits as String: 2048,\n        kSecPrivateKeyAttrs as String: [\n            kSecAttrIsPermanent as String: true,\n            kSecAttrApplicationTag as String: \"com.yourapp.privatekey\".data(using: .utf8)!,\n            kSecAttrAccessControl as String: accessControl\n        ]\n    ]\n    \n    var error: Unmanaged<CFError>?\n    guard let privateKey = SecKeyCreateRandomKey(attributes as CFDictionary, &error) else {\n        throw error!.takeRetainedValue() as Error\n    }\n    \n    return privateKey\n}\n```\n\n## 3. Data Protection API (75 min)\n\n### File Protection Levels\n\n**Protection Classes:**\n- **complete**: Accessible only when device unlocked\n- **completeUnlessOpen**: File can be opened, then accessible until closed\n- **completeUntilFirstUserAuthentication**: Accessible after first unlock until reboot\n- **none**: No encryption (not recommended)\n\n**Implementing File Protection:**\n```swift\nclass SecureFileManager {\n    \n    func writeProtectedData(_ data: Data, to url: URL) throws {\n        let attributes: [FileAttributeKey: Any] = [\n            .protectionKey: FileProtectionType.complete\n        ]\n        \n        try data.write(to: url, options: [.atomic, .completeFileProtection])\n        try FileManager.default.setAttributes(attributes, ofItemAtPath: url.path)\n    }\n    \n    func createProtectedDirectory(at url: URL) throws {\n        try FileManager.default.createDirectory(\n            at: url,\n            withIntermediateDirectories: true,\n            attributes: [.protectionKey: FileProtectionType.complete]\n        )\n    }\n}\n```\n\n**Database Encryption with SQLCipher:**\n```swift\nimport SQLCipher\n\nclass EncryptedDatabase {\n    private var database: OpaquePointer?\n    \n    func openEncryptedDatabase(at path: String, key: String) throws {\n        guard sqlite3_open(path, &database) == SQLITE_OK else {\n            throw DatabaseError.openFailed\n        }\n        \n        // Set encryption key\n        let keyQuery = \"PRAGMA key = '\\(key)';\"\n        guard sqlite3_exec(database, keyQuery, nil, nil, nil) == SQLITE_OK else {\n            throw DatabaseError.encryptionFailed\n        }\n        \n        // Verify encryption\n        guard sqlite3_exec(database, \"SELECT count(*) FROM sqlite_master;\", nil, nil, nil) == SQLITE_OK else {\n            throw DatabaseError.invalidKey\n        }\n    }\n}\n```\n\n## 4. Cryptographic Operations (90 min)\n\n### Common Crypto Framework\n\n**Secure Hashing:**\n```swift\nimport CommonCrypto\n\nclass CryptoHelper {\n    \n    func sha256(data: Data) -> Data {\n        var hash = [UInt8](repeating: 0, count: Int(CC_SHA256_DIGEST_LENGTH))\n        data.withUnsafeBytes { buffer in\n            _ = CC_SHA256(buffer.baseAddress, CC_LONG(data.count), &hash)\n        }\n        return Data(hash)\n    }\n    \n    func hmac(key: Data, data: Data) -> Data {\n        var hmac = [UInt8](repeating: 0, count: Int(CC_SHA256_DIGEST_LENGTH))\n        key.withUnsafeBytes { keyBuffer in\n            data.withUnsafeBytes { dataBuffer in\n                CCHmac(\n                    CCHmacAlgorithm(kCCHmacAlgSHA256),\n                    keyBuffer.baseAddress, keyBuffer.count,\n                    dataBuffer.baseAddress, dataBuffer.count,\n                    &hmac\n                )\n            }\n        }\n        return Data(hmac)\n    }\n}\n```\n\n**Secure Random Number Generation:**\n```swift\nfunc generateCryptographicallySecureRandom(length: Int) throws -> Data {\n    var bytes = [UInt8](repeating: 0, count: length)\n    let status = SecRandomCopyBytes(kSecRandomDefault, length, &bytes)\n    \n    guard status == errSecSuccess else {\n        throw SecurityError.randomGenerationFailed\n    }\n    \n    return Data(bytes)\n}\n```\n\n**Asymmetric Encryption:**\n```swift\nclass AsymmetricCrypto {\n    \n    func encrypt(data: Data, publicKey: SecKey) throws -> Data {\n        var error: Unmanaged<CFError>?\n        guard let encryptedData = SecKeyCreateEncryptedData(\n            publicKey,\n            .rsaEncryptionOAEPSHA256,\n            data as CFData,\n            &error\n        ) else {\n            throw error!.takeRetainedValue() as Error\n        }\n        \n        return encryptedData as Data\n    }\n    \n    func decrypt(data: Data, privateKey: SecKey) throws -> Data {\n        var error: Unmanaged<CFError>?\n        guard let decryptedData = SecKeyCreateDecryptedData(\n            privateKey,\n            .rsaEncryptionOAEPSHA256,\n            data as CFData,\n            &error\n        ) else {\n            throw error!.takeRetainedValue() as Error\n        }\n        \n        return decryptedData as Data\n    }\n}\n```\n\n## 5. Network Security (60 min)\n\n### Certificate Pinning\n\n**SSL Pinning Implementation:**\n```swift\nclass PinningURLSessionDelegate: NSObject, URLSessionDelegate {\n    \n    private let pinnedCertificates: [Data]\n    \n    init(certificateNames: [String]) {\n        self.pinnedCertificates = certificateNames.compactMap { name in\n            guard let certPath = Bundle.main.path(forResource: name, ofType: \"cer\"),\n                  let certificateData = try? Data(contentsOf: URL(fileURLWithPath: certPath)) else {\n                return nil\n            }\n            return certificateData\n        }\n    }\n    \n    func urlSession(_ session: URLSession, \n                   didReceive challenge: URLAuthenticationChallenge,\n                   completionHandler: @escaping (URLSession.AuthChallengeDisposition, URLCredential?) -> Void) {\n        \n        guard challenge.protectionSpace.authenticationMethod == NSURLAuthenticationMethodServerTrust,\n              let serverTrust = challenge.protectionSpace.serverTrust else {\n            completionHandler(.cancelAuthenticationChallenge, nil)\n            return\n        }\n        \n        // Validate server certificate\n        var secResult = SecTrustResultType.invalid\n        let status = SecTrustEvaluate(serverTrust, &secResult)\n        \n        guard status == errSecSuccess,\n              secResult == .proceed || secResult == .unspecified else {\n            completionHandler(.cancelAuthenticationChallenge, nil)\n            return\n        }\n        \n        // Certificate pinning\n        let serverCertificates = (0..<SecTrustGetCertificateCount(serverTrust))\n            .compactMap { SecTrustGetCertificateAtIndex(serverTrust, $0) }\n            .compactMap { SecCertificateCopyData($0) as Data? }\n        \n        let isPinned = serverCertificates.contains { serverCert in\n            pinnedCertificates.contains { pinnedCert in\n                serverCert == pinnedCert\n            }\n        }\n        \n        if isPinned {\n            completionHandler(.useCredential, URLCredential(trust: serverTrust))\n        } else {\n            completionHandler(.cancelAuthenticationChallenge, nil)\n        }\n    }\n}\n```\n\n**App Transport Security Configuration:**\n```xml\n<key>NSAppTransportSecurity</key>\n<dict>\n    <key>NSAllowsArbitraryLoads</key>\n    <false/>\n    <key>NSExceptionDomains</key>\n    <dict>\n        <key>yourapp.com</key>\n        <dict>\n            <key>NSIncludesSubdomains</key>\n            <true/>\n            <key>NSTemporaryExceptionMinimumTLSVersion</key>\n            <string>TLSv1.2</string>\n        </dict>\n    </dict>\n</dict>\n```\n\n## 6. Advanced Security Patterns (75 min)\n\n### Secure Enclave Operations\n\n**Secure Enclave Key Generation:**\n```swift\nfunc generateSecureEnclaveKey() throws -> SecKey {\n    let accessControl = SecAccessControlCreateWithFlags(\n        kCFAllocatorDefault,\n        kSecAttrAccessibleWhenUnlockedThisDeviceOnly,\n        [.privateKeyUsage, .biometryAny],\n        nil\n    )!\n    \n    let attributes: [String: Any] = [\n        kSecAttrKeyType as String: kSecAttrKeyTypeECSECPrimeRandom,\n        kSecAttrKeySizeInBits as String: 256,\n        kSecAttrTokenID as String: kSecAttrTokenIDSecureEnclave,\n        kSecPrivateKeyAttrs as String: [\n            kSecAttrIsPermanent as String: true,\n            kSecAttrApplicationTag as String: \"com.yourapp.secureenclave.key\".data(using: .utf8)!,\n            kSecAttrAccessControl as String: accessControl\n        ]\n    ]\n    \n    var error: Unmanaged<CFError>?\n    guard let privateKey = SecKeyCreateRandomKey(attributes as CFDictionary, &error) else {\n        throw error!.takeRetainedValue() as Error\n    }\n    \n    return privateKey\n}\n```\n\n**Touch ID/Face ID Authentication:**\n```swift\nclass BiometricAuth {\n    \n    private let context = LAContext()\n    \n    func authenticateUser(reason: String) async throws -> Bool {\n        var error: NSError?\n        \n        guard context.canEvaluatePolicy(.deviceOwnerAuthenticationWithBiometrics, error: &error) else {\n            throw AuthError.biometryNotAvailable\n        }\n        \n        return try await withCheckedThrowingContinuation { continuation in\n            context.evaluatePolicy(.deviceOwnerAuthenticationWithBiometrics, \n                                localizedReason: reason) { success, error in\n                if let error = error {\n                    continuation.resume(throwing: error)\n                } else {\n                    continuation.resume(returning: success)\n                }\n            }\n        }\n    }\n    \n    func secureOperationWithBiometrics() async throws -> Data {\n        try await authenticateUser(reason: \"Access secure data\")\n        \n        // Perform secure operation after successful authentication\n        return try retrieveProtectedData()\n    }\n}\n```\n\n### Jailbreak Detection\n\n**Advanced Jailbreak Detection:**\n```swift\nclass JailbreakDetector {\n    \n    func isJailbroken() -> Bool {\n        return checkSuspiciousFiles() || \n               checkSuspiciousProcesses() ||\n               checkSandboxViolation() ||\n               checkDYLD()\n    }\n    \n    private func checkSuspiciousFiles() -> Bool {\n        let suspiciousPaths = [\n            \"/Applications/Cydia.app\",\n            \"/usr/sbin/sshd\",\n            \"/bin/bash\",\n            \"/etc/apt\",\n            \"/Library/MobileSubstrate/MobileSubstrate.dylib\"\n        ]\n        \n        return suspiciousPaths.contains { path in\n            FileManager.default.fileExists(atPath: path)\n        }\n    }\n    \n    private func checkSandboxViolation() -> Bool {\n        do {\n            try \"jailbreak_test\".write(toFile: \"/private/jailbreak_test\", \n                                    atomically: true, encoding: .utf8)\n            try FileManager.default.removeItem(atPath: \"/private/jailbreak_test\")\n            return true\n        } catch {\n            return false\n        }\n    }\n    \n    private func checkDYLD() -> Bool {\n        let suspiciousLibraries = [\n            \"Library/MobileSubstrate/MobileSubstrate.dylib\",\n            \"usr/lib/libcycript.dylib\",\n            \"usr/lib/libcript.dylib\"\n        ]\n        \n        for libraryIndex in 1..<_dyld_image_count() {\n            guard let imageName = _dyld_get_image_name(libraryIndex) else { continue }\n            let libraryName = String(cString: imageName)\n            \n            if suspiciousLibraries.contains(where: { libraryName.contains($0) }) {\n                return true\n            }\n        }\n        \n        return false\n    }\n}\n```\n\n## 7. Security Testing & Auditing (60 min)\n\n### Static Analysis\n\n**MobSF (Mobile Security Framework):**\n- Automated security analysis\n- Binary analysis\n- Vulnerability detection\n- Code quality assessment\n\n**OWASP Mobile Security Testing Guide:**\n- MASVS (Mobile Application Security Verification Standard)\n- MSTG (Mobile Security Testing Guide)\n- Comprehensive testing methodology\n\n### Dynamic Analysis\n\n**Runtime Protection:**\n```swift\nclass RuntimeSecurity {\n    \n    func detectDebugger() -> Bool {\n        var name: [Int32] = [CTL_KERN, KERN_PROC, KERN_PROC_PID, getpid()]\n        var info = kinfo_proc()\n        var size = MemoryLayout<kinfo_proc>.size\n        \n        let success = name.withUnsafeMutableBytes { pointer in\n            sysctl(pointer.baseAddress?.assumingMemoryBound(to: Int32.self), 4, &info, &size, nil, 0) == 0\n        }\n        \n        return success && (info.kp_proc.p_flag & P_TRACED) != 0\n    }\n    \n    func enableAntiTampering() {\n        // Check bundle integrity\n        guard let bundlePath = Bundle.main.executablePath,\n              let bundleData = try? Data(contentsOf: URL(fileURLWithPath: bundlePath)) else {\n            fatalError(\"Bundle integrity check failed\")\n        }\n        \n        let bundleHash = CryptoHelper().sha256(data: bundleData)\n        let expectedHash = \"expected_bundle_hash\".data(using: .utf8)!\n        \n        if bundleHash != expectedHash {\n            fatalError(\"Application has been modified\")\n        }\n    }\n}\n```\n\n## Best Practices Summary\n\n1. **Always use Keychain for sensitive data**\n2. **Implement proper file protection levels**\n3. **Use certificate pinning for critical connections**\n4. **Validate all inputs and sanitize data**\n5. **Implement proper error handling without leaking information**\n6. **Regular security audits and penetration testing**\n7. **Keep dependencies updated and monitor for vulnerabilities**",
      "codeExample": "import Security\nimport LocalAuthentication\nimport CommonCrypto\n\n// === KEYCHAIN MANAGER ===\nclass SecureKeychainManager {\n    \n    private let service: String\n    \n    init(service: String) {\n        self.service = service\n    }\n    \n    // Save data with biometric protection\n    func saveWithBiometry(_ data: Data, for key: String) throws {\n        let accessControl = SecAccessControlCreateWithFlags(\n            kCFAllocatorDefault,\n            kSecAttrAccessibleWhenUnlockedThisDeviceOnly,\n            [.biometryCurrentSet],\n            nil\n        )!\n        \n        let context = LAContext()\n        context.touchIDAuthenticationAllowableReuseDuration = 10\n        \n        let query: [String: Any] = [\n            kSecClass as String: kSecClassGenericPassword,\n            kSecAttrService as String: service,\n            kSecAttrAccount as String: key,\n            kSecValueData as String: data,\n            kSecAttrAccessControl as String: accessControl,\n            kSecUseAuthenticationContext as String: context,\n            kSecAttrAccessible as String: kSecAttrAccessibleWhenUnlockedThisDeviceOnly\n        ]\n        \n        // Delete existing item\n        SecItemDelete(query as CFDictionary)\n        \n        // Add new item\n        let status = SecItemAdd(query as CFDictionary, nil)\n        guard status == errSecSuccess else {\n            throw KeychainError.saveFailed(status: status)\n        }\n    }\n    \n    // Retrieve data with biometric authentication\n    func retrieveWithBiometry(for key: String) throws -> Data {\n        let context = LAContext()\n        \n        let query: [String: Any] = [\n            kSecClass as String: kSecClassGenericPassword,\n            kSecAttrService as String: service,\n            kSecAttrAccount as String: key,\n            kSecReturnData as String: true,\n            kSecUseAuthenticationContext as String: context,\n            kSecMatchLimit as String: kSecMatchLimitOne\n        ]\n        \n        var item: CFTypeRef?\n        let status = SecItemCopyMatching(query as CFDictionary, &item)\n        \n        guard status == errSecSuccess, let data = item as? Data else {\n            throw KeychainError.loadFailed(status: status)\n        }\n        \n        return data\n    }\n    \n    // Generate and store cryptographic key\n    func generateAndStoreKey() throws -> SecKey {\n        let accessControl = SecAccessControlCreateWithFlags(\n            kCFAllocatorDefault,\n            kSecAttrAccessibleWhenUnlockedThisDeviceOnly,\n            [.privateKeyUsage],\n            nil\n        )!\n        \n        let attributes: [String: Any] = [\n            kSecAttrKeyType as String: kSecAttrKeyTypeRSA,\n            kSecAttrKeySizeInBits as String: 2048,\n            kSecPrivateKeyAttrs as String: [\n                kSecAttrIsPermanent as String: true,\n                kSecAttrApplicationTag as String: (service + \".privatekey\").data(using: .utf8)!,\n                kSecAttrAccessControl as String: accessControl\n            ]\n        ]\n        \n        var error: Unmanaged<CFError>?\n        guard let privateKey = SecKeyCreateRandomKey(attributes as CFDictionary, &error) else {\n            throw error!.takeRetainedValue() as Error\n        }\n        \n        return privateKey\n    }\n}\n\n// === SECURE FILE MANAGER ===\nclass SecureFileManager {\n    \n    private let fileManager = FileManager.default\n    \n    func createSecureDirectory(at url: URL) throws {\n        try fileManager.createDirectory(\n            at: url,\n            withIntermediateDirectories: true,\n            attributes: [\n                .protectionKey: FileProtectionType.completeUntilFirstUserAuthentication\n            ]\n        )\n    }\n    \n    func writeSecureData(_ data: Data, to url: URL) throws {\n        try data.write(to: url, options: [.atomic, .completeFileProtection])\n    }\n    \n    func readSecureData(from url: URL) throws -> Data {\n        return try Data(contentsOf: url, options: .mappedIfSafe)\n    }\n    \n    // Secure deletion with multiple overwrites\n    func secureDeleteFile(at url: URL) throws {\n        guard fileManager.fileExists(atPath: url.path) else { return }\n        \n        // Overwrite file content before deletion\n        if let fileHandle = try? FileHandle(forWritingTo: url) {\n            let fileSize = try fileManager.attributesOfItem(atPath: url.path)[.size] as? Int ?? 0\n            let randomData = try generateCryptographicallySecureRandom(length: fileSize)\n            fileHandle.write(randomData)\n            fileHandle.closeFile()\n        }\n        \n        try fileManager.removeItem(at: url)\n    }\n}\n\n// === CRYPTOGRAPHIC OPERATIONS ===\nclass AdvancedCrypto {\n    \n    // AES-GCM encryption\n    func encryptAESGCM(plainText: Data, key: Data) throws -> (cipherText: Data, nonce: Data, tag: Data) {\n        let nonce = try generateCryptographicallySecureRandom(length: 12)\n        \n        var cipherText = Data(count: plainText.count)\n        var tag = Data(count: 16)\n        \n        let status = key.withUnsafeBytes { keyBytes in\n            nonce.withUnsafeBytes { nonceBytes in\n                plainText.withUnsafeBytes { plainTextBytes in\n                    cipherText.withUnsafeMutableBytes { cipherTextBytes in\n                        tag.withUnsafeMutableBytes { tagBytes in\n                            CCCrypt(\n                                CCOperation(kCCEncrypt),\n                                CCAlgorithm(kCCAlgorithmAES),\n                                CCOptions(kCCModeGCM),\n                                keyBytes.baseAddress, keyBytes.count,\n                                nonceBytes.baseAddress, nonceBytes.count,\n                                plainTextBytes.baseAddress, plainTextBytes.count,\n                                cipherTextBytes.baseAddress, cipherTextBytes.count,\n                                nil\n                            )\n                        }\n                    }\n                }\n            }\n        }\n        \n        guard status == kCCSuccess else {\n            throw CryptoError.encryptionFailed\n        }\n        \n        return (cipherText, nonce, tag)\n    }\n    \n    // Password-based key derivation\n    func deriveKey(from password: String, salt: Data) throws -> Data {\n        var derivedKey = Data(count: 32)\n        \n        let status = derivedKey.withUnsafeMutableBytes { derivedKeyBytes in\n            salt.withUnsafeBytes { saltBytes in\n                CCKeyDerivationPBKDF(\n                    CCPBKDFAlgorithm(kCCPBKDF2),\n                    password, password.lengthOfBytes(using: .utf8),\n                    saltBytes.baseAddress, saltBytes.count,\n                    CCPseudoRandomAlgorithm(kCCPRFHmacAlgSHA256),\n                    100000, // iterations\n                    derivedKeyBytes.baseAddress, derivedKeyBytes.count\n                )\n            }\n        }\n        \n        guard status == kCCSuccess else {\n            throw CryptoError.keyDerivationFailed\n        }\n        \n        return derivedKey\n    }\n}\n\n// === NETWORK SECURITY ===\nclass SecureNetworkManager {\n    \n    private let pinnedCertificates: [Data]\n    private let session: URLSession\n    \n    init(certificateNames: [String]) {\n        self.pinnedCertificates = certificateNames.compactMap { name in\n            guard let path = Bundle.main.path(forResource: name, ofType: \"cer\") else { return nil }\n            return try? Data(contentsOf: URL(fileURLWithPath: path))\n        }\n        \n        let configuration = URLSessionConfiguration.ephemeral\n        configuration.tlsMinimumSupportedProtocolVersion = .TLSv12\n        \n        self.session = URLSession(\n            configuration: configuration,\n            delegate: PinningDelegate(pinnedCertificates: pinnedCertificates),\n            delegateQueue: nil\n        )\n    }\n    \n    func makeSecureRequest(_ request: URLRequest) async throws -> Data {\n        let (data, response) = try await session.data(for: request)\n        \n        guard let httpResponse = response as? HTTPURLResponse,\n              (200...299).contains(httpResponse.statusCode) else {\n            throw NetworkError.invalidResponse\n        }\n        \n        return data\n    }\n}\n\n// === SECURE ENCLAVE OPERATIONS ===\nclass SecureEnclaveManager {\n    \n    func createSecureEnclaveKey() throws -> SecKey {\n        let accessControl = SecAccessControlCreateWithFlags(\n            kCFAllocatorDefault,\n            kSecAttrAccessibleWhenUnlockedThisDeviceOnly,\n            [.privateKeyUsage, .biometryCurrentSet],\n            nil\n        )!\n        \n        let attributes: [String: Any] = [\n            kSecAttrKeyType as String: kSecAttrKeyTypeECSECPrimeRandom,\n            kSecAttrKeySizeInBits as String: 256,\n            kSecAttrTokenID as String: kSecAttrTokenIDSecureEnclave,\n            kSecPrivateKeyAttrs as String: [\n                kSecAttrIsPermanent as String: true,\n                kSecAttrApplicationTag as String: \"secure.enclave.key\".data(using: .utf8)!,\n                kSecAttrAccessControl as String: accessControl\n            ]\n        ]\n        \n        var error: Unmanaged<CFError>?\n        guard let privateKey = SecKeyCreateRandomKey(attributes as CFDictionary, &error) else {\n            throw error!.takeRetainedValue() as Error\n        }\n        \n        return privateKey\n    }\n    \n    func signWithSecureEnclave(_ data: Data, privateKey: SecKey) throws -> Data {\n        var error: Unmanaged<CFError>?\n        \n        guard let signature = SecKeyCreateSignature(\n            privateKey,\n            .ecdsaSignatureMessageX962SHA256,\n            data as CFData,\n            &error\n        ) else {\n            throw error!.takeRetainedValue() as Error\n        }\n        \n        return signature as Data\n    }\n}\n\n// === ERROR DEFINITIONS ===\nenum KeychainError: Error {\n    case saveFailed(status: OSStatus)\n    case loadFailed(status: OSStatus)\n    case deleteFailed(status: OSStatus)\n}\n\nenum CryptoError: Error {\n    case encryptionFailed\n    case decryptionFailed\n    case keyDerivationFailed\n    case randomGenerationFailed\n}\n\nenum NetworkError: Error {\n    case invalidResponse\n    case pinningFailed\n    case certificateNotFound\n}\n\n// === PINNING DELEGATE ===\nclass PinningDelegate: NSObject, URLSessionDelegate {\n    private let pinnedCertificates: [Data]\n    \n    init(pinnedCertificates: [Data]) {\n        self.pinnedCertificates = pinnedCertificates\n    }\n    \n    func urlSession(_ session: URLSession, \n                   didReceive challenge: URLAuthenticationChallenge,\n                   completionHandler: @escaping (URLSession.AuthChallengeDisposition, URLCredential?) -> Void) {\n        \n        guard challenge.protectionSpace.authenticationMethod == NSURLAuthenticationMethodServerTrust,\n              let serverTrust = challenge.protectionSpace.serverTrust else {\n            completionHandler(.cancelAuthenticationChallenge, nil)\n            return\n        }\n        \n        // Perform certificate pinning\n        let isPinned = verifyCertificatePinning(serverTrust: serverTrust)\n        \n        if isPinned {\n            completionHandler(.useCredential, URLCredential(trust: serverTrust))\n        } else {\n            completionHandler(.cancelAuthenticationChallenge, nil)\n        }\n    }\n    \n    private func verifyCertificatePinning(serverTrust: SecTrust) -> Bool {\n        // Implementation of certificate pinning verification\n        return true // Simplified for example\n    }\n}",
      "category": "App Security",
      "estimatedTime": 240,
      "dependencies": ["ios_fundamentals", "networking"],
      "challenge": {
        "instructions": "Build a comprehensive security framework for a banking application:\n\nPART 1: Secure Keychain Implementation (90 min)\n1. Create a SecureKeychainManager with biometric protection\n2. Implement secure storage for sensitive data (tokens, keys, passwords)\n3. Add keychain sharing between related apps\n4. Implement secure key generation and storage\n\nPART 2: Data Protection & Encryption (90 min)\n5. Create encrypted file storage with proper protection levels\n6. Implement SQLCipher for database encryption\n7. Add secure data deletion with multiple overwrites\n8. Create secure backup/restore functionality\n\nPART 3: Cryptographic Operations (90 min)\n9. Implement AES-GCM encryption for sensitive data\n10. Add RSA encryption for key exchange\n11. Create secure password-based key derivation\n12. Implement digital signatures with Secure Enclave\n\nPART 4: Network Security & Certificate Pinning (60 min)\n13. Implement certificate pinning with fallback strategies\n14. Create secure network manager with TLS 1.3\n15. Add request/response encryption\n16. Implement secure WebSocket connections\n\nPART 5: Advanced Security Features (90 min)\n17. Create jailbreak detection system\n18. Implement runtime integrity checks\n19. Add debugger detection and anti-tampering\n20. Create secure logging system\n\nPART 6: Security Testing & Auditing (60 min)\n21. Write unit tests for security components\n22. Perform penetration testing scenarios\n23. Implement security monitoring\n24. Create security audit reports",
        "starterCode": "import Security\nimport LocalAuthentication\nimport CommonCrypto\n\n// === PART 1: Secure Keychain Implementation ===\n// Implement biometric-protected keychain storage\n\n\n// === PART 2: Data Protection & Encryption ===\n// Create encrypted file and database storage\n\n\n// === PART 3: Cryptographic Operations ===\n// Implement various encryption algorithms\n\n\n// === PART 4: Network Security ===\n// Add certificate pinning and secure communication\n\n\n// === PART 5: Advanced Security Features ===\n// Implement runtime protection mechanisms\n\n\n// === PART 6: Security Testing ===\n// Add security tests and monitoring\n\n",
        "solution": "import Security\nimport LocalAuthentication\nimport CommonCrypto\nimport Foundation\n\n// === PART 1: Secure Keychain Implementation ===\nclass BankingKeychainManager {\n    private let service: String\n    private let accessGroup: String?\n    \n    init(service: String, accessGroup: String? = nil) {\n        self.service = service\n        self.accessGroup = accessGroup\n    }\n    \n    func saveBankingToken(_ token: String, for user: String) throws {\n        let accessControl = SecAccessControlCreateWithFlags(\n            kCFAllocatorDefault,\n            kSecAttrAccessibleWhenUnlockedThisDeviceOnly,\n            [.biometryCurrentSet, .and, .devicePasscode],\n            nil\n        )!\n        \n        let context = LAContext()\n        \n        var query: [String: Any] = [\n            kSecClass as String: kSecClassGenericPassword,\n            kSecAttrService as String: service,\n            kSecAttrAccount as String: user,\n            kSecValueData as String: token.data(using: .utf8)!,\n            kSecAttrAccessControl as String: accessControl,\n            kSecUseAuthenticationContext as String: context,\n            kSecAttrAccessible as String: kSecAttrAccessibleWhenUnlockedThisDeviceOnly\n        ]\n        \n        if let accessGroup = accessGroup {\n            query[kSecAttrAccessGroup as String] = accessGroup\n        }\n        \n        SecItemDelete(query as CFDictionary)\n        \n        let status = SecItemAdd(query as CFDictionary, nil)\n        guard status == errSecSuccess else {\n            throw BankingSecurityError.keychainSaveFailed\n        }\n    }\n    \n    func generateAndStoreAsymmetricKeyPair() throws -> (publicKey: SecKey, privateKey: SecKey) {\n        let privateKeyAccessControl = SecAccessControlCreateWithFlags(\n            kCFAllocatorDefault,\n            kSecAttrAccessibleWhenUnlockedThisDeviceOnly,\n            [.privateKeyUsage, .biometryCurrentSet],\n            nil\n        )!\n        \n        let attributes: [String: Any] = [\n            kSecAttrKeyType as String: kSecAttrKeyTypeRSA,\n            kSecAttrKeySizeInBits as String: 2048,\n            kSecPrivateKeyAttrs as String: [\n                kSecAttrIsPermanent as String: true,\n                kSecAttrApplicationTag as String: \"com.bank.privatekey\".data(using: .utf8)!,\n                kSecAttrAccessControl as String: privateKeyAccessControl\n            ]\n        ]\n        \n        var error: Unmanaged<CFError>?\n        guard let privateKey = SecKeyCreateRandomKey(attributes as CFDictionary, &error) else {\n            throw error!.takeRetainedValue() as Error\n        }\n        \n        guard let publicKey = SecKeyCopyPublicKey(privateKey) else {\n            throw BankingSecurityError.keyGenerationFailed\n        }\n        \n        return (publicKey, privateKey)\n    }\n}\n\n// === PART 2: Data Protection & Encryption ===\nclass BankingFileSecurity {\n    \n    func createSecureUserDirectory(for userId: String) throws -> URL {\n        guard let documentsURL = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask).first else {\n            throw BankingSecurityError.fileSystemError\n        }\n        \n        let userDirectory = documentsURL.appendingPathComponent(\"users/\\(userId)\")\n        \n        try FileManager.default.createDirectory(\n            at: userDirectory,\n            withIntermediateDirectories: true,\n            attributes: [\n                .protectionKey: FileProtectionType.completeUntilFirstUserAuthentication\n            ]\n        )\n        \n        return userDirectory\n    }\n    \n    func encryptAndSaveTransaction(_ transaction: BankingTransaction, \n                                 to url: URL, \n                                 encryptionKey: Data) throws {\n        let encoder = JSONEncoder()\n        let transactionData = try encoder.encode(transaction)\n        \n        let crypto = BankingCrypto()\n        let encryptedData = try crypto.encryptAESGCM(plainText: transactionData, key: encryptionKey)\n        \n        try encryptedData.cipherText.write(to: url, options: [.atomic, .completeFileProtection])\n        \n        // Save nonce and tag separately with different protection\n        let metadata = EncryptionMetadata(nonce: encryptedData.nonce, tag: encryptedData.tag)\n        let metadataURL = url.appendingPathExtension(\"meta\")\n        let metadataData = try encoder.encode(metadata)\n        try metadataData.write(to: metadataURL, options: [.atomic, .completeFileProtection])\n    }\n}\n\n// === PART 3: Cryptographic Operations ===\nclass BankingCrypto {\n    \n    func encryptAESGCM(plainText: Data, key: Data) throws -> (cipherText: Data, nonce: Data, tag: Data) {\n        let nonce = try generateSecureRandom(length: 12)\n        \n        var cipherText = Data(count: plainText.count)\n        var tag = Data(count: 16)\n        \n        let status = key.withUnsafeBytes { keyBytes in\n            nonce.withUnsafeBytes { nonceBytes in\n                plainText.withUnsafeBytes { plainTextBytes in\n                    cipherText.withUnsafeMutableBytes { cipherTextBytes in\n                        tag.withUnsafeMutableBytes { tagBytes in\n                            CCCrypt(\n                                CCOperation(kCCEncrypt),\n                                CCAlgorithm(kCCAlgorithmAES),\n                                CCOptions(kCCModeGCM),\n                                keyBytes.baseAddress, keyBytes.count,\n                                nonceBytes.baseAddress, nonceBytes.count,\n                                plainTextBytes.baseAddress, plainTextBytes.count,\n                                cipherTextBytes.baseAddress, cipherTextBytes.count,\n                                tagBytes.baseAddress, tagBytes.count\n                            )\n                        }\n                    }\n                }\n            }\n        }\n        \n        guard status == kCCSuccess else {\n            throw BankingSecurityError.encryptionFailed\n        }\n        \n        return (cipherText, nonce, tag)\n    }\n    \n    func deriveKeyFromPassword(_ password: String, salt: Data) throws -> Data {\n        var derivedKey = Data(count: 32)\n        \n        let status = password.withCString { passwordBytes in\n            salt.withUnsafeBytes { saltBytes in\n                derivedKey.withUnsafeMutableBytes { derivedKeyBytes in\n                    CCKeyDerivationPBKDF(\n                        CCPBKDFAlgorithm(kCCPBKDF2),\n                        passwordBytes, password.utf8.count,\n                        saltBytes.baseAddress, saltBytes.count,\n                        CCPseudoRandomAlgorithm(kCCPRFHmacAlgSHA256),\n                        100000,\n                        derivedKeyBytes.baseAddress, derivedKeyBytes.count\n                    )\n                }\n            }\n        }\n        \n        guard status == kCCSuccess else {\n            throw BankingSecurityError.keyDerivationFailed\n        }\n        \n        return derivedKey\n    }\n    \n    private func generateSecureRandom(length: Int) throws -> Data {\n        var bytes = [UInt8](repeating: 0, count: length)\n        let status = SecRandomCopyBytes(kSecRandomDefault, length, &bytes)\n        \n        guard status == errSecSuccess else {\n            throw BankingSecurityError.randomGenerationFailed\n        }\n        \n        return Data(bytes)\n    }\n}\n\n// === PART 4: Network Security ===\nclass BankingNetworkManager {\n    private let session: URLSession\n    private let certificatePinner: CertificatePinner\n    \n    init() {\n        self.certificatePinner = CertificatePinner(pinnedCertificates: [\"bank-root-ca\", \"bank-intermediate-ca\"])\n        \n        let configuration = URLSessionConfiguration.ephemeral\n        configuration.tlsMinimumSupportedProtocolVersion = .TLSv13\n        configuration.httpShouldSetCookies = false\n        configuration.httpCookieAcceptPolicy = .never\n        \n        self.session = URLSession(\n            configuration: configuration,\n            delegate: certificatePinner,\n            delegateQueue: nil\n        )\n    }\n    \n    func makeSecureAPIRequest(_ request: URLRequest) async throws -> Data {\n        // Add security headers\n        var securedRequest = request\n        securedRequest.addValue(\"Bearer \\(getAuthToken())\", forHTTPHeaderField: \"Authorization\")\n        securedRequest.addValue(\"application/json\", forHTTPHeaderField: \"Content-Type\")\n        \n        let (data, response) = try await session.data(for: securedRequest)\n        \n        guard let httpResponse = response as? HTTPURLResponse else {\n            throw BankingSecurityError.networkError\n        }\n        \n        switch httpResponse.statusCode {\n        case 200...299:\n            return data\n        case 401:\n            throw BankingSecurityError.authenticationFailed\n        case 403:\n            throw BankingSecurityError.accessDenied\n        default:\n            throw BankingSecurityError.serverError\n        }\n    }\n    \n    private func getAuthToken() -> String {\n        // Retrieve from secure storage\n        return \"secure-auth-token\"\n    }\n}\n\n// === PART 5: Advanced Security Features ===\nclass BankingSecurityMonitor {\n    \n    func performSecurityChecks() -> SecurityStatus {\n        let jailbreakDetected = checkJailbreak()\n        let debuggerDetected = checkDebugger()\n        let integrityCompromised = checkBinaryIntegrity()\n        \n        if jailbreakDetected || debuggerDetected || integrityCompromised {\n            return .compromised\n        }\n        \n        return .secure\n    }\n    \n    private func checkJailbreak() -> Bool {\n        // Comprehensive jailbreak detection\n        return JailbreakDetector().isJailbroken()\n    }\n    \n    private func checkDebugger() -> Bool {\n        var name: [Int32] = [CTL_KERN, KERN_PROC, KERN_PROC_PID, getpid()]\n        var info = kinfo_proc()\n        var size = MemoryLayout<kinfo_proc>.size\n        \n        return sysctl(&name, 4, &info, &size, nil, 0) == 0 && \n               (info.kp_proc.p_flag & P_TRACED) != 0\n    }\n    \n    private func checkBinaryIntegrity() -> Bool {\n        // Check code signature and bundle integrity\n        return true // Implementation details\n    }\n}\n\n// === SUPPORTING TYPES ===\nstruct BankingTransaction: Codable {\n    let id: String\n    let amount: Double\n    let timestamp: Date\n    let description: String\n}\n\nstruct EncryptionMetadata: Codable {\n    let nonce: Data\n    let tag: Data\n}\n\nenum SecurityStatus {\n    case secure, compromised, unknown\n}\n\nenum BankingSecurityError: Error {\n    case keychainSaveFailed\n    case keyGenerationFailed\n    case fileSystemError\n    case encryptionFailed\n    case keyDerivationFailed\n    case randomGenerationFailed\n    case networkError\n    case authenticationFailed\n    case accessDenied\n    case serverError\n}\n\n// === CERTIFICATE PINNER ===\nclass CertificatePinner: NSObject, URLSessionDelegate {\n    private let pinnedCertificates: [Data]\n    \n    init(pinnedCertificates: [String]) {\n        self.pinnedCertificates = pinnedCertificates.compactMap { name in\n            guard let path = Bundle.main.path(forResource: name, ofType: \"cer\") else { return nil }\n            return try? Data(contentsOf: URL(fileURLWithPath: path))\n        }\n        super.init()\n    }\n    \n    func urlSession(_ session: URLSession, \n                   didReceive challenge: URLAuthenticationChallenge,\n                   completionHandler: @escaping (URLSession.AuthChallengeDisposition, URLCredential?) -> Void) {\n        \n        guard challenge.protectionSpace.authenticationMethod == NSURLAuthenticationMethodServerTrust,\n              let serverTrust = challenge.protectionSpace.serverTrust else {\n            completionHandler(.cancelAuthenticationChallenge, nil)\n            return\n        }\n        \n        // Certificate pinning implementation\n        completionHandler(.performDefaultHandling, nil)\n    }\n}\n\n// === JAILBREAK DETECTOR ===\nclass JailbreakDetector {\n    func isJailbroken() -> Bool {\n        return checkSuspiciousFiles() || checkSandboxIntegrity()\n    }\n    \n    private func checkSuspiciousFiles() -> Bool {\n        let paths = [\n            \"/Applications/Cydia.app\",\n            \"/usr/sbin/sshd\",\n            \"/bin/bash\",\n            \"/etc/apt\"\n        ]\n        return paths.contains { FileManager.default.fileExists(atPath: $0) }\n    }\n    \n    private func checkSandboxIntegrity() -> Bool {\n        return !FileManager.default.isWritableFile(atPath: \"/\")\n    }\n}",
        "hints": [
          "PART 1: Use kSecAttrAccessibleWhenUnlockedThisDeviceOnly for maximum security",
          "PART 2: Combine FileProtectionType with custom encryption for layered security",
          "PART 3: Always use authenticated encryption like AES-GCM for sensitive data",
          "PART 4: Implement certificate pinning with proper fallback strategies",
          "PART 5: Combine multiple detection methods for robust security monitoring",
          "Use Secure Enclave for cryptographic keys when possible",
          "Implement proper error handling without leaking sensitive information",
          "Test security features on actual devices, not just simulators"
        ],
        "testCases": [
          {
            "input": "keychainManager.saveBankingToken(\"test-token\", for: \"test-user\")",
            "expectedOutput": "success",
            "description": "Should save token to keychain with biometric protection"
          },
          {
            "input": "crypto.encryptAESGCM(plainText: testData, key: testKey)",
            "expectedOutput": "encryptedData",
            "description": "Should encrypt data with AES-GCM and return ciphertext with auth tag"
          },
          {
            "input": "securityMonitor.performSecurityChecks()",
            "expectedOutput": "secure",
            "description": "Should return secure status on non-jailbroken device"
          }
        ]
      }
    }
]
